[{"id":0,"href":"/docs/Textbook/C-Primer-Plus/","title":"C Primer Plus - Stephen Prata","section":"资料","content":" PEARSON # CPrimer Plus（第 6 版）中文版\n[美]Stephen Prata　著\n姜佑　译\n人民邮电出版社 # 北京 # 图书在版编目（ CIP ）数据 # C Primer Plus（第 6 版）中文版/（美）普拉达（Prata,S.）著；姜佑译.\u0026ndash;\n北京：人民邮电出版社，2016.\nISBN 978-7-115-39059-\nI.①C\u0026hellip;　II.①普\u0026hellip;②姜\u0026hellip;　III.①C语言—程序设计　IV.①TP\n中国版本图书馆CIP数据核字（ 2015 ）第 084602 号\n版权声明\nAuthorized translation from the English language edition,entitled C Primer Plus(sixth edition),9780321928429 by Stephen Prata,published by Pearson Education,Inc.,publishing as Addison-Wesley，Copyright©2014 Pearson Education,Inc.\nAll rights reserved.No part of this book may be reproduced or transmitted in any form or by any means,electronic or mechanical,including photocopying,recording or by any information storage retrieval system,without permission from Pearson Education Inc.CHINESE SIMPLIFIED language edition published by PEARSON EDUCATION ASIA LTD.,and POSTS ＆ TELECOMMUNICATIONS PRESS Copyright©2015.\n本书封面贴有 Pearson Education （培生教育出版集团）激光防伪标签。无标签者不得销售。\n◆著　[美]Stephen Prata\n译　姜佑\n责任编辑　傅道坤\n责任印制　张佳莹　焦志炜\n◆人民邮电出版社出版发行　北京市丰台区成寿寺路 11 号\n邮编　100164 电子邮件　315@ptpress.com.cn\n网址　http://www.ptpress.com.cn\n北京圣夫亚美印刷有限公司印刷\n◆开本：787×1092 1/16\n印张： 47\n字数： 1412 千字　2016 年 4 月第 1 版\n印数：1-8000册　2016 年 4 月北京第 1 次印刷\n著作权合同登记号　图字：01-2014-5617号\n定价：89.00元\n读者服务热线： (010)81055410 印装质量热线： (010)81055316\n反盗版热线： (010)81055315\n内容提要 # 本书详细讲解了C语言的基本概念和编程技巧。\n全书共 17 章。第 1 章、第 2 章介绍了C语言编程的预备知识。第 3 章～第15 章详细讲解了C语言的相关知识，包括数据类型、格式化输入/输出、运算符、表达式、语句、循环、字符输入和输出、函数、数组和指针、字符和字符串函数、内存管理、文件输入输出、结构、位操作等。第 16 章、第 17 章介绍C预处理器、C库和高级数据表示。本书以完整的程序为例，讲解C语言的知识要点和注意事项。每章末尾设计了大量复习题和编程练习，帮助读者巩固所学知识和提高实际编程能力。附录给出了各章复习题的参考答案和丰富的参考资料。\n本书可作为C语言的教材，适用于需要系统学习C语言的初学者，也适用于巩固C语言知识或希望进一步提高编程技术的程序员。\n作者简介 # Stephen Prata曾在加利福尼亚的马林学院（肯特菲尔德）教授天文学、物理学和程序设计课程，现已退休。他在加州理工学院获得学士学位，在加州大学伯克利分校获得博士学位。他最早接触程序设计，是为了利用计算机给星团建模。Stephen撰写和与他人合著了十几本图书，其中包括C++ Primer Plus和UNIX Primer Plus。\n献辞\n谨将本书献给我的父亲William Prata。\n致谢\n感谢Pearson的Mark Taber一直都非常关注本书。感谢Danny Kalev在技术上提供的帮助和建议。\n前言 # 1984 年C Primer Plus第 1 版刚问世时，使用C语言编程的人并不多。C语 言从那时开始流行，许多人在本书的帮助下掌握了C语言。实际上，C Primer Plus各个版本累计销售量已超过 55 万册。\nC语言从早期的非正式的K\u0026amp;R标准，发展到1990 ISO/ANSI标准，进而 发展到2011 ISO/IEC标准。本书也随着逐渐成熟，发展到现在的第 6 版。在 所有这些版本中，我的目标是致力于编写一本指导性强、条理清晰而且有用 的C语言教程。\n本书的用法和目标\n我希望撰写一本友好、方便使用、便于自学的指南。为此，本书采用以下写作策略。\n在介绍C语言细节的同时，讲解编程概念。本书假定读者为非专业的程序员。\n每次尽量用短小简单的示例演示一两个概念，学以致用是最有效的学习方式之一。\n当概念用文字较难解释时，则用图表演示以帮助读者理解。\nC语言的主要特性总结在方框中，便于查找和复习。\n每章末尾设有复习题和编程练习，帮助读者测试和加深对C语言的理解。\n为了获得最佳的学习效果，学习本书时，读者应尽量扮演一个积极的角 色。不仅要仔细阅读程序示例，还要亲自动手录入程序并运行。C 是一种可 移植性很高的语言，但有时在你的系统中运行的结果和在我们的系统中运行 的结果不同。经常改动程序的某些部分，运行后看看有什么效果。偶尔出现 警告也不必理会，主要是看一下执行错误操作会出现什么状况。在学习的过 程中应该多提出问题和多练习。用得越多，学的知识就越牢固。\n希望本书能帮助读者轻松愉快地学习C语言。\n第 1 章 初识 C 语言 # 本章介绍以下内容： # C的历史和特性 # 编写程序的步骤 # 编译器和链接器的一些知识 # C标准 # 欢迎来到C语言的世界。C是一门功能强大的专业化编程语言，深受业 # 余编程爱好者和专业程序员的喜爱。本章为读者学习这一强大而流行的语言 # 打好基础，并介绍几种开发C程序最可能使用的环境。 # 我们先来了解C语言的起源和一些特性，包括它的优缺点。然后，介绍 # 编程的起源并探讨一些编程的基本原则。最后，讨论如何在一些常见系统中 # 运行C程序。 # 1.1 C 语言的起源 # 1972 年，贝尔实验室的丹尼斯·里奇（Dennis Ritch）和肯·汤普逊（Ken Thompson）在开发UNIX操作系统时设计了C语言。然而，C语言不完全是里 奇突发奇想而来，他是在B语言（汤普逊发明）的基础上进行设计。至于 B 语言的起源，那是另一个故事。C 语言设计的初衷是将其作为程序员使用的 一种编程工具，因此，其主要目标是成为有用的语言。 虽然绝大多数语言都以实用为目标，但是通常也会考虑其他方面。例 如，Pascal 的主要目标是为更好地学习编程原理提供扎实的基础；而BASIC 的主要目标是开发出类似英文的语言，让不熟悉计算机的学生轻松学习编 程。这些目标固然很重要，但是随着计算机的迅猛发展，它们已经不是主流 语言。然而，最初为程序员设计开发的C语言，现在已成为首选的编程语言 之一。\n1.2 选择 C 语言的理由 # 在过去 40 多年里，C语言已成为最重要、最流行的编程语言之一。它的 # 成长归功于使用过的人都对它很满意。过去 20 多年里，虽然许多人都从C语 # 言转而使用其他编程语言（如，C++、Objective C、Java等），但是C语言仍 凭借自身实力在众多语言中脱颖而出。在学习C语言的过程中，会发现它的 许多优点（见图1.1）。下面，我们来看看其中较为突出的几点。\n1.2.1 设计特性 # C是一门流行的语言，融合了计算机科学理论和实践的控制特性。C语 # 言的设计理念让用户能轻松地完成自顶向下的规划、结构化编程和模块化设 # 计。因此，用C语言编写的程序更易懂、更可靠。 # 1.2.2 高效性 # C是高效的语言。在设计上，它充分利用了当前计算机的优势，因此 C # 程序相对更紧凑，而且运行速度很快。实际上，C 语言具有通常是汇编语言 # 才具有的微调控制能力（汇编语言是为特殊的中央处理单元设计的一系列内 # 部指令，使用助记符来表示；不同的 CPU 系列使用不同的汇编语言），可 # 以根据具体情况微调程序以获得最大运行速度或最有效地使用内存。 # 图1.1 C语言的优点 1.2.3 可移植性 # C是可移植的语言。这意味着，在一种系统中编写的 C程序稍作修改或 # 不修改就能在其他系统运行。如需修改，也只需简单更改主程序头文件中的 # 少许项即可。大部分语言都希望成为可移植语言，但是，如果经历过把IBM # PC BASIC程序转换成苹果BASIC（两者是近亲），或者在UNIX系统中运行 # IBM大型机的FORTRAN程序的人都知道，移植是最麻烦的事。C语言是可移 # 植方面的佼佼者。从 8 位微处理器到克雷超级计算机，许多计算机体系结构 # 都可以使用C编译器（C编译器是把C代码转换成计算机内部指令的程序）。 # 但是要注意，程序中针对特殊硬件设备（如，显示监视器）或操作系统特殊 # 功能（如，Windows 8或OS X）编写的部分，通常是不可移植的。 由于C语言与UNIX关系密切，UNIX系统通常会将C编译器作为软件包的 一部分。安装Linux时，通常也会安装C编译器。供个人计算机使用的C编译 器很多，运行各种版本的Windows和Macintosh（即， Mac）的PC都能找到 合适的C编译器。因此，无论是使用家庭计算机、专业工作站，还是大型 机，都能找到针对特定系统的C编译器。\n1.2.4 强大而灵活 # C语言功能强大且灵活（计算机领域经常使用这两个词）。例如，功能 # 强大且灵活的UNIX操作系统，大部分是用C语言写的；其他语言（如， # FORTRAN、Perl、Python、Pascal、LISP、Logo、BASIC）的许多编译器和 解释器都是用C语言编写的。因此，在UNIX机上使用FORTRAN时，最终是 由C程序生成最后的可执行程序。C程序可以用于解决物理学和工程学的问 题，甚至可用于制作电影的动画特效。\n1.2.5 面向程序员 # C 语言是为了满足程序员的需求而设计的，程序员利用 C 可以访问硬 # 件、操控内存中的位。C 语言有丰富的运算符，能让程序员简洁地表达自己 # 的意图。C没有Pascal严谨，但是却比C++的限制多。这样的灵活性既是优点 也是缺点。优点是，许多任务用C来处理都非常简洁（如，转换数据的格 式）；缺点是，你可能会犯一些莫名其妙的错误，这些错误不可能在其他语 言中出现。C 语言在提供更多自由的同时，也让使用者承担了更大的责任。 另外，大多数C实现都有一个大型的库，包含众多有用的C函数。这些 函数用于处理程序员经常需要解决的问题。\n1.2.6 缺点 # 人无完人，金无足赤。C语言也有一些缺点。例如，前面提到的，要享 # 受用C语言自由编程的乐趣，就必须承担更多的责任。特别是，C语言使用 # 指针，而涉及指针的编程错误往往难以察觉。有句话说的好：想拥有自由就 # 必须时刻保持警惕。 # C 语言紧凑简洁，结合了大量的运算符。正因如此，我们也可以编写出 # 让人极其费解的代码。虽然没必要强迫自己编写晦涩的代码，但是有兴趣写 # 写也无妨。试问，除 C语言外还为哪种语言举办过年度混乱代码大赛[1]？ # 瑕不掩瑜，C语言的优点比缺点多很多。我们不想在这里多费笔墨，还 # 是来聊聊C语言的其他话题。 # 1.3 C 语言的应用范围 # 早在 20 世纪 80 年代，C语言就已经成为小型计算机（UNIX系统）使用的 # 主流语言。从那以后，C语言的应用范围扩展到微型机（个人计算机）和大 # 型机（庞然大物）。如图1.2所示，许多软件公司都用C语言来开发文字处理 # 程序、电子表格、编译器和其他产品，因为用 C语言编写的程序紧凑而高 # 效。更重要的是，C程序很方便修改，而且移植到新型号的计算机中也没什 # 么问题。 # 无论是软件公司、经验丰富的C程序员，还是其他用户，都能从C语言 # 中受益。越来越多的计算机用户已转而求助C语言解决一些安全问题。不一 # 定非得是计算机专家也能使用C语言。 # 20 世纪 90 年代，许多软件公司开始改用C++来开发大型的编程项目。 # C++在C语言的基础上嫁接了面向对象编程工具（面向对象编程是一门哲 # 学，它通过对语言建模来适应问题，而不是对问题建模以适应语言）。 # C++几乎是C的超集，这意味着任何C程序差不多就是一个C++程序。学习C # 语言，也相当于学习了许多C++的知识。 # 图1.2 C语言的应用范围 虽然这些年来C++和JAVA非常流行，但是C语言仍是软件业中的核心技 能。在最想具备的技能中，C语言通常位居前十。特别是，C 语言已成为嵌 入式系统编程的流行语言。也就是说，越来越多的汽车、照相机、DVD 播 放机和其他现代化设备的微处理器都用 C 语言进行编程。除此之外，C 语 言还从长期被FORTRAN独占的科学编程领域分得一杯羹。最终，作为开发 操作系统的卓越语言，C在Linux开发中扮演着极其重要的角色。因此，在进 入 21 世纪的第 2 个 10 年中，C语言仍然保持着强劲的势头。 简而言之，C 语言是最重要的编程语言之一，将来也是如此。如果你想\n拿下一份编程的工作，被问到是否会C语言时，最好回答“是”。 # 1.4 计算机能做什么 # 在学习如何用C语言编程之前，最好先了解一下计算机的工作原理。这 # 些知识有助于你理解用C语言编写程序和运行C程序时所发生的事情之间有 # 什么联系。 # 现代的计算机由多种部件构成。中央处理单元（CPU）承担绝大部分的 # 运算工作。随机存取内存（RAM）是存储程序和文件的工作区；而永久内 # 存存储设备（过去一般指机械硬盘，现在还包括固态硬盘）即使在关闭计算 # 机后，也不会丢失之前储存的程序和文件。另外，还有各种外围设备（如， # 键盘、鼠标、触摸屏、监视器）提供人与计算机之间的交互。CPU负责处理 # 程序，接下来我们重点讨论它的工作原理。 # CPU 的工作非常简单，至少从以下简短的描述中看是这样。它从内存 # 中获取并执行一条指令，然后再从内存中获取并执行下一条指令，诸如此类 # （一个吉赫兹的CPU一秒钟能重复这样的操作大约十亿次，因此，CPU 能以 # 惊人的速度从事枯燥的工作）。CPU 有自己的小工作区——由若干个寄存 # 器组成，每个寄存器都可以储存一个数字。一个寄存器储存下一条指令的内 # 存地址，CPU 使用该地址来获取和更新下一条指令。在获取指令后，CPU在 # 另一个寄存器中储存该指令，并更新第 1 个寄存器储存下一条指令的地址。 # CPU能理解的指令有限（这些指令的集合叫作指令集）。而且，这些指令相 # 当具体，其中的许多指令都是用于请求计算机把一个数字从一个位置移动到 # 另一个位置。例如，从内存移动到寄存器。 # 下面介绍两个有趣的知识。其一，储存在计算机中的所有内容都是数 # 字。计算机以数字形式储存数字和字符（如，在文本文档中使用的字母）。 # 每个字符都有一个数字码。计算机载入寄存器的指令也以数字形式储存，指 # 令集中的每条指令都有一个数字码。其二，计算机程序最终必须以数字指令 # 码（即，机器语言）来表示。 # 简而言之，计算机的工作原理是：如果希望计算机做某些事，就必须为 # 其提供特殊的指令列表（程序），确切地告诉计算机要做的事以及如何做。 # 你必须用计算机能直接明白的语言（机器语言）创建程序。这是一项繁琐、 # 乏味、费力的任务。计算机要完成诸如两数相加这样简单的事，就得分成类 # 似以下几个步骤。 # 1.从内存位置 2000 上把一个数字拷贝到寄存器 1 。 # 2.从内存位置 2004 上把另一个数字拷贝到寄存器 2 。 # 3.把寄存器 2 中的内容与寄存器 1 中的内容相加，把结果储存在寄存器 1 # 中。 # 4.把寄存器 1 中的内容拷贝到内存位置 2008 。 # 而你要做的是，必须用数字码来表示以上的每个步骤！ # 如果以这种方式编写程序很合你的意，那不得不说抱歉，因为用机器语 # 言编程的黄金时代已一去不复返。但是，如果你对有趣的事情比较感兴趣， # 不妨试试高级编程语言。 # 1.5 高级计算机语言和编译器 # 高级编程语言（如，C）以多种方式简化了编程工作。首先，不必用数 # 字码表示指令；其次，使用的指令更贴近你如何想这个问题，而不是类似计 # 算机那样繁琐的步骤。使用高级编程语言，可以在更抽象的层面表达你的想 # 法，不用考虑CPU在完成任务时具体需要哪些步骤。例如，对于两数相加， # 可以这样写： # total = mine + yours; 对我们而言，光看这行代码就知道要计算机做什么；而看用机器语言写 成的等价指令（多条以数字码形式表现的指令）则费劲得多。但是，对计算 机而言却恰恰相反。在计算机看来，高级指令就是一堆无法理解的无用数 据。编译器在这里派上了用场。编译器是把高级语言程序翻译成计算机能理 解的机器语言指令集的程序。程序员进行高级思维活动，而编译器则负责处 理冗长乏味的细节工作。 编译器还有一个优势。一般而言，不同CPU制造商使用的指令系统和编 码格式不同。例如，用Intel Core i7 （英特尔酷睿i7）CPU编写的机器语言程 序对于ARM Cortex-A57 CPU而言什么都不是。但是，可以找到与特定类型 CPU匹配的编译器。因此，使用合适的编译器或编译器集，便可把一种高级 语言程序转换成供各种不同类型 CPU 使用的机器语言程序。一旦解决了一 个编程问题，便可让编译器集翻译成不同 CPU 使用的机器语言。 简而言之，高级语言（如C、Java、Pascal）以更抽象的方式描述行 为，不受限于特定CPU或指令集。而且，高级语言简单易学，用高级语言编 程比用机器语言编程容易得多。 1964 年，控制数据公司（Control Data Corporation）研制出了CDC 6600 计算机。这台庞然大物是世界上首台超级计算机，当时的售价是 600 万美 元。它是高能核物理研究的首选。然而，现在的普通智能手机在计算能力和 内存方面都超过它数百倍，而且能看视频，放音乐。\n1964 年，在工程和科学领域的主流编程语言是 FORTRAN。虽然编程语 # 言不如硬件发展那么突飞猛进，但是也发生了很大变化。为了应对越来越大 # 型的编程项目，语言先后为结构化编程和面向对象编程提供了更多的支持。 # 随着时间的推移，不仅新语言层出不穷，而且现有语言也会发生变化。 # 1.6 语言标准 # 目前，有许多C实现可用。在理想情况下，编写C程序时，假设该程序 # 中未使用机器特定的编程技术，那么它的运行情况在任何实现中都应该相 # 同。要在实践中做到这一点，不同的实现要遵循同一个标准。 # C语言发展之初，并没有所谓的C标准。 1987 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）合著的The C Programming Language（《C语言程序设计》）第 1 版是公认的C标准，通常称之为K\u0026amp;R C 或经典C。特别是，该书中的附录中的“C语言参考手册”已成为实现C的指导 标准。例如，编译器都声称提供完整的K\u0026amp;R实现。虽然这本书中的附录定 义了C语言，但却没有定义C库。与大多数语言不同的是，C语言比其他语言 更依赖库，因此需要一个标准库。实际上，由于缺乏官方标准，UNIX实现 提供的库已成为了标准库。\n1.6.1 第 1 个 ANSI/ISO C 标准 # 随着C的不断发展，越来越广泛地应用于更多系统中，C社区意识到需 # 要一个更全面、更新颖、更严格的标准。鉴于此，美国国家标准协会 # （ANSI）于 1983 年组建了一个委员会（X3J11），开发了一套新标准，并 # 于 1989 年正式公布。该标准（ANSI C）定义了C语言和C标准库。国际标准 # 化组织于 1990 年采用了这套C标准（ISO C）。ISO C和ANSI C是完全相同的 # 标准。ANSI/ISO标准的最终版本通常叫作C89（因为ANSI于 1989 年批准该标 # 准）或C90（因为ISO于 1990 年批准该标准）。另外，由于ANSI先公布C标 # 准，因此业界人士通常使用ANSI C。 # 在该委员会制定的指导原则中，最有趣的可能是：保持 C的精神。委员 # 会在表述这一精神时列出了以下几点： # 信任程序员； # 不要妨碍程序员做需要做的事； # 保持语言精练简单； # 只提供一种方法执行一项操作； # 让程序运行更快，即使不能保证其可移植性。 # 在最后一点上，标准委员会的用意是：作为实现，应该针对目标计算机 # 来定义最合适的某特定操作，而不是强加一个抽象、统一的定义。在学习C # 语言过程中，许多方面都反映了这一哲学思想。 # 1.6.2 C99 标准 # 1994 年，ANSI/ISO联合委员会（C9X委员会）开始修订C标准，最终发 # 布了C99标准。该委员会遵循了最初C90标准的原则，包括保持语言的精练 # 简单。委员会的用意不是在C语言中添加新特性，而是为了达到新的目标。 # 第 1 个目标是，支持国际化编程。例如，提供多种方法处理国际字符集。第 2 # 个目标是，“调整现有实践致力于解决明显的缺陷”。因此，在遇到需要将C # 移至 64 位处理器时，委员会根据现实生活中处理问题的经验来添加标准。第 # 3 个目标是，为适应科学和工程项目中的关键数值计算，提高C的适应性， # 让C比FORTRAN更有竞争力。 # 这 3 点（国际化、弥补缺陷和提高计算的实用性）是主要的修订目标。 # 在其他方面的改变则更为保守，例如，尽量与C90、C++兼容，让语言在概 # 念上保持简单。用委员会的话说：“„„委员会很满意让C++成为大型、功能 # 强大的语言”。 # C99的修订保留了C语言的精髓，C仍是一门简洁高效的语言。本书指出 # 了许多C99修改的地方。虽然该标准已发布了很长时间，但并非所有的编译 # 器都完全实现C99的所有改动。因此，你可能发现C99的一些改动在自己的 # 系统中不可用，或者只有改变编译器的设置才可用。 # 1.6.3 C11 标准 # 维护标准任重道远。标准委员会在 2007 年承诺C标准的下一个版本是 # C1X， 2011 年终于发布了C11标准。此次，委员会提出了一些新的指导原 # 则。出于对当前编程安全的担忧，不那么强调“信任程序员”目标了。而且， # 供应商并未像对C90那样很好地接受和支持C99。这使得C99的一些特性成为 # C11的可选项。因为委员会认为，不应要求服务小型机市场的供应商支持其 # 目标环境中用不到的特性。另外需要强调的是，修订标准的原因不是因为原 # 标准不能用，而是需要跟进新的技术。例如，新标准添加了可选项支持当前 # 使用多处理器的计算机。对于C11标准，我们浅尝辄止，深入分析这部分内 # 容已超出本书讨论的范围。 # 注意 # 本书使用术语ANSI C、ISO C或ANSI/ISO C讲解C89/90和较新标准共有 # 的特性，用C99或C11介绍新的特性。有时也使用C90（例如，讨论一个特性 # 被首次加入C语言时）。 # 1.7 使用 C 语言的 7 个步骤 # C是编译型语言。如果之前使用过编译型语言（如，Pascal或 FORTRAN），就会很熟悉组建C程序的几个基本步骤。但是，如果以前使 用的是解释型语言（如，BASIC）或面向图形界面语言（如，Visual Basic），或者甚至没接触过任何编程语言，就有必要学习如何编译。别担 心，这并不复杂。首先，为了让读者对编程有大概的了解，我们把编写C程 序的过程分解成 7 个步骤（见图1.3）。注意，这是理想状态。在实际的使用 过程中，尤其是在较大型的项目中，可能要做一些重复的工作，根据下一个 步骤的情况来调整或改进上一个步骤。\n图1.3 编程的 7 个步骤 1.7.1 第 1 步：定义程序的目标 # 在动手写程序之前，要在脑中有清晰的思路。想要程序去做什么首先自 # 己要明确自己想做什么，思考你的程序需要哪些信息，要进行哪些计算和控 # 制，以及程序应该要报告什么信息。在这一步骤中，不涉及具体的计算机语 # 言，应该用一般术语来描述问题。 # 1.7.2 第 2 步：设计程序 # 对程序应该完成什么任务有概念性的认识后，就应该考虑如何用程序来 # 完成它。例如，用户界面应该是怎样的？如何组织程序？目标用户是谁？准 # 备花多长时间来完成这个程序？ # 除此之外，还要决定在程序（还可能是辅助文件）中如何表示数据，以 # 及用什么方法处理数据。学习C语言之初，遇到的问题都很简单，没什么可 # 选的。但是，随着要处理的情况越来越复杂，需要决策和考虑的方面也越来 # 越多。通常，选择一个合适的方式表示信息可以更容易地设计程序和处理数 # 据。 # 再次强调，应该用一般术语来描述问题，而不是用具体的代码。但是， # 你的某些决策可能取决于语言的特性。例如，在数据表示方面，C的程序员 # 就比Pascal的程序员有更多选择。\n1.7.3 第 3 步：编写代码 # 设计好程序后，就可以编写代码来实现它。也就是说，把你设计的程序 # 翻译成 C语言。这里是真正需要使用C语言的地方。可以把思路写在纸上， # 但是最终还是要把代码输入计算机。这个过程的机制取决于编程环境，我们 # 稍后会详细介绍一些常见的环境。一般而言，使用文本编辑器创建源代码文 # 件。该文件中内容就是你翻译的C语言代码。程序清单1.1是一个C源代码的 # 示例。 # 程序清单 1.1 C 源代码示例 # #include \u0026lt;stdio.h\u0026gt; int main(void) { int dogs; printf(\u0026ldquo;How many dogs do you have?\\n\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;dogs); printf(\u0026ldquo;So you have %d dog(s)!\\n\u0026rdquo;, dogs); return 0; } 在这一步骤中，应该给自己编写的程序添加文字注释。最简单的方式是 使用 C的注释工具在源代码中加入对代码的解释。第 2 章将详细介绍如何在 代码中添加注释。\n1.7.4 第 4 步：编译 # 接下来的这一步是编译源代码。再次提醒读者注意，编译的细节取决于 # 编程的环境，我们稍后马上介绍一些常见的编程环境。现在，先从概念的角 # 度讲解编译发生了什么事情。 # 前面介绍过，编译器是把源代码转换成可执行代码的程序。可执行代码 # 是用计算机的机器语言表示的代码。这种语言由数字码表示的指令组成。如 # 前所述，不同的计算机使用不同的机器语言方案。C 编译器负责把C代码翻 # 译成特定的机器语言。此外，C编译器还将源代码与C库（库中包含大量的 # 标准函数供用户使用，如printf()和scanf()）的代码合并成最终的程序（更精 确地说，应该是由一个被称为链接器的程序来链接库函数，但是在大多数系 统中，编译器运行链接器）。其结果是，生成一个用户可以运行的可执行文 件，其中包含着计算机能理解的代码。\n编译器还会检查C语言程序是否有效。如果C编译器发现错误，就不生 # 成可执行文件并报错。理解特定编译器报告的错误或警告信息是程序员要掌 # 握的另一项技能。 # 1.7.5 第 5 步：运行程序 # 传统上，可执行文件是可运行的程序。在常见环境（包括Windows命令 提示符模式、UNIX终端模式和Linux终端模式）中运行程序要输入可执行文 件的文件名，而其他环境可能要运行命令（如，在VAX中的VMS[2]）或一 些其他机制。例如，在Windows和Macintosh提供的集成开发环境（IDE） 中，用户可以在IDE中通过选择菜单中的选项或按下特殊键来编辑和执行C 程序。最终生成的程序可通过单击或双击文件名或图标直接在操作系统中运 行。\n1.7.6 第 6 步：测试和调试程序 # 程序能运行是个好迹象，但有时也可能会出现运行错误。接下来，应该 # 检查程序是否按照你所设计的思路运行。你会发现你的程序中有一些错误， # 计算机行话叫作bug。查找并修复程序错误的过程叫调试。学习的过程中不 可避免会犯错，学习编程也是如此。因此，当你把所学的知识应用于编程 时，最好为自己会犯错做好心理准备。随着你越来越老练，你所写的程序中 的错误也会越来越不易察觉。 将来犯错的机会很多。你可能会犯基本的设计错误，可能错误地实现了 一个好想法，可能忽视了输入检查导致程序瘫痪，可能会把圆括号放错地 方，可能误用 C语言或打错字，等等。把你将来犯错的地方列出来，这份错 误列表应该会很长。 看到这里你可能会有些绝望，但是情况没那么糟。现在的编译器会捕获 许多错误，而且自己也可以找到编译器未发现的错误。在学习本书的过程 中，我们会给读者提供一些调试的建议。\n1.7.7 第 7 步：维护和修改代码 # 创建完程序后，你发现程序有错，或者想扩展程序的用途，这时就要修 # 改程序。例如，用户输入以Zz开头的姓名时程序出现错误、你想到了一个更 好的解决方案、想添加一个更好的新特性，或者要修改程序使其能在不同的 计算机系统中运行，等等。如果在编写程序时清楚地做了注释并采用了合理 的设计方案，这些事情都很简单。\n1.7.8 说明 # 编程并非像描述那样是一个线性的过程。有时，要在不同的步骤之间往 # 复。例如，在写代码时发现之前的设计不切实际，或者想到了一个更好的解 # 决方案，或者等程序运行后，想改变原来的设计思路。对程序做文字注释为 # 今后的修改提供了方便。 # 许多初学者经常忽略第 1 步和第 2 步（定义程序目标和设计程序），直接 # 跳到第 3 步（编写代码）。刚开始学习时，编写的程序非常简单，完全可以 # 在脑中构思好整个过程。即使写错了，也很容易发现。但是，随着编写的程 # 序越来越庞大、越来越复杂，动脑不动手可不行，而且程序中隐藏的错误也 # 越来越难找。最终，那些跳过前两个步骤的人往往浪费了更多的时间，因为 # 他们写出的程序难看、缺乏条理、让人难以理解。要编写的程序越大越复 # 杂，事先定义和设计程序环节的工作量就越大。 # 磨刀不误砍柴工，应该养成先规划再动手编写代码的好习惯，用纸和笔 # 记录下程序的目标和设计框架。这样在编写代码的过程中会更加得心应手、 # 条理清晰。 # 1.8 编程机制 # 生成程序的具体过程因计算机环境而异。C是可移植性语言，因此可以 # 在许多环境中使用，包括UNIX、Linux、MS-DOS（一些人仍在使用）、 Windows和Macintosh OS。有些产品会随着时间的推移发生演变或被取代， 本书无法涵盖所有环境。 首先，来看看许多C环境（包括上面提到的 5 种环境）共有的一些方 面。虽然不必详细了解计算机内部如何运行C程序，但是，了解一下编程机 制不仅能丰富编程相关的背景知识，还有助于理解为何要经过一些特殊的步 骤才能得到C程序。 用C语言编写程序时，编写的内容被储存在文本文件中，该文件被称为 源代码文件（source code file）。大部分C系统，包括之前提到的，都要求文 件名以.c结尾（如，wordcount.c和budget.c）。在文件名中，点号（.）前面 的部分称为基本名（basename），点号后面的部分称为扩展名 （extension）。因此，budget是基本名，c是扩展名。基本名与扩展名的组合 （budget.c）就是文件名。文件名应该满足特定计算机操作系统的特殊要 求。例如，MS-DOS是IBM PC及其兼容机的操作系统，比较老旧，它要求基 本名不能超过 8 个字符。因此，刚才提到的文件名wordcount.c就是无效的 DOS文件名。有些UNIX系统限制整个文件名（包括扩展名）不超过 14 个字 符，而有些UNIX系统则允许使用更长的文件名，最多 255 个字符。Linux、 Windows和Macintosh OS都允许使用长文件名。 接下来，我们来看一下具体的应用，假设有一个名为concrete.c的源文 件，其中的C源代码如程序清单1.2所示。 程序清单 1.2 c 程序 #include \u0026lt;stdio.h\u0026gt; int main(void)\n{ # printf(\u0026ldquo;Concrete contains gravel and cement.\\n\u0026rdquo;); return 0; } 如果看不懂程序清单1.2中的代码，不用担心，我们将在第 2 章学习相关 知识。\n1.8.1 目标代码文件、可执行文件和库 # C编程的基本策略是，用程序把源代码文件转换为可执行文件（其中包 # 含可直接运行的机器语言代码）。典型的C实现通过编译和链接两个步骤来 # 完成这一过程。编译器把源代码转换成中间代码，链接器把中间代码和其他 # 代码合并，生成可执行文件。C 使用这种分而治之的方法方便对程序进行模 # 块化，可以独立编译单独的模块，稍后再用链接器合并已编译的模块。通过 # 这种方式，如果只更改某个模块，不必因此重新编译其他模块。另外，链接 # 器还将你编写的程序和预编译的库代码合并。 # 中间文件有多种形式。我们在这里描述的是最普遍的一种形式，即把源 # 代码转换为机器语言代码，并把结果放在目标代码文件（或简称目标文件） # 中（这里假设源代码只有一个文件）。虽然目标文件中包含机器语言代码， # 但是并不能直接运行该文件。因为目标文件中储存的是编译器翻译的源代 # 码，这还不是一个完整的程序。 # 目标代码文件缺失启动代码（startup code）。启动代码充当着程序和操 作系统之间的接口。例如，可以在MS Windows或Linux系统下运行IBM PC兼 容机。这两种情况所使用的硬件相同，所以目标代码相同，但是Windows和 Linux所需的启动代码不同，因为这些系统处理程序的方式不同。 目标代码还缺少库函数。几乎所有的C程序都要使用C标准库中的函 数。例如，concrete.c中就使用了 printf()函数。目标代码文件并不包含该函\n数的代码，它只包含了使用 printf()函数的指令。printf()函数真正的代码储存 在另一个被称为库的文件中。库文件中有许多函数的目标代码。 链接器的作用是，把你编写的目标代码、系统的标准启动代码和库代码 这 3 部分合并成一个文件，即可执行文件。对于库代码，链接器只会把程序 中要用到的库函数代码提取出来（见图1.4）。\n图1.4 编译器和链接器 简而言之，目标文件和可执行文件都由机器语言指令组成的。然而，目 标文件中只包含编译器为你编写的代码翻译的机器语言代码，可执行文件中 还包含你编写的程序中使用的库函数和启动代码的机器代码。\n在有些系统中，必须分别运行编译程序和链接程序，而在另一些系统 # 中，编译器会自动启动链接器，用户只需给出编译命令即可。 # 接下来，了解一些具体的系统。 # 1.8.2 UNIX 系统 # 由于C语言因UNIX系统而生，也因此而流行，所以我们从UNIX系统开 # 始（注意：我们提到的UNIX还包含其他系统，如FreeBSD，它是UNIX的一 个分支，但是由于法律原因不使用该名称）。\n1. 在 UNIX 系统上编辑 UNIX C没有自己的编辑器，但是可以使用通用的UNIX编辑器，如 emacs、jove、vi或X Window System文本编辑器。 作为程序员，要负责输入正确的程序和为储存该程序的文件起一个合适 的文件名。如前所述，文件名应该以.c结尾。注意，UNIX区分大小写。因 此，budget.c、BUDGET.c和Budget.c是 3 个不同但都有效的C源文件名。但是 BUDGET.C是无效文件名，因为该名称的扩展名使用了大写C而不是小写c。 假设我们在vi编译器中编写了下面的程序，并将其储存在inform.c文件 中： #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026ldquo;A .c is used to end a C program filename.\\n\u0026rdquo;); return 0; }\n以上文本就是源代码，inform.c是源文件。注意，源文件是整个编译过 程的开始，不是结束。\n2. 在 UNIX 系统上编译 虽然在我们看来，程序完美无缺，但是对计算机而言，这是一堆乱码。 计算机不明白#include 和printf是什么（也许你现在也不明白，但是学到后面 就会明白，而计算机却不会）。如前所述，我们需要编译器将我们编写的代 码（源代码）翻译成计算机能看懂的代码（机器代码）。最后生成的可执行 文件中包含计算机要完成任务所需的所有机器代码。 以前，UNIX C编译器要调用语言定义的cc命令。但是，它没有跟上标 准发展的脚步，已经退出了历史舞台。但是，UNIX系统提供的C编译器通常 来自一些其他源，然后以cc命令作为编译器的别名。因此，虽然在不同的系 统中会调用不同的编译器，但用户仍可以继续使用相同的命令。 编译inform.c，要输入以下命令： cc inform.c 几秒钟后，会返回 UNIX 的提示，告诉用户任务已完成。如果程序编写 错误，你可能会看到警告或错误消息，但我们先假设编写的程序完全正确 （如果编译器报告void的错误，说明你的系统未更新成ANSI C编译器，只需 删除void即可）。如果使用ls命令列出文件，会发现有一个a.out文件（见图 1.5）。该文件是包含已翻译（或已编译）程序的可执行文件。要运行该文 件，只需输入： a.out 输出内容如下： A .c is used to end a C program filename.\n图1.5 用UNIX准备C程序 如果要储存可执行文件（a.out），应该把它重命名。否则，该文件会被 下一次编译程序时生成的新a.out文件替换。 如何处理目标代码？C 编译器会创建一个与源代码基本名相同的目标代 码文件，但是其扩展名是.o。在该例中，目标代码文件是 inform.o。然而， 却找不到这个文件，因为一旦链接器生成了完整的可执行程序，就会将其删 除。如果原始程序有多个源代码文件，则保留目标代码文件。学到后面多文\n件程序时，你会明白到这样做的好处。 # 1.8.3 GNU 编译器集合和 LLVM 项目 # GNU项目始于 1987 年，是一个开发大量免费UNIX软件的集合（GNU的 # 意思是“GNU’s Not UNIX”，即GNU不是UNIX）。GNU编译器集合（也被称 为GCC，其中包含GCC C编译器）是该项目的产品之一。GCC在一个指导委 员会的带领下，持续不断地开发，它的C编译器紧跟C标准的改动。GCC有 各种版本以适应不同的硬件平台和操作系统，包括UNIX、Linux和 Windows。用gcc命令便可调用GCC C编译器。许多使用gcc的系统都用cc作 为gcc的别名。 LLVM项目成为cc的另一个替代品。该项目是与编译器相关的开源软件 集合，始于伊利诺伊大学的 2000 份研究项目。它的 Clang编译器处理 C代 码，可以通过 clang调用。有多种版本供不同的平台使用，包括Linux。 2012 年，Clang成为FreeBSD的默认C编译器。Clang也对最新的C标准支持得很 好。 GNU和LLVM都可以使用-v选项来显示版本信息，因此各系统都使用cc 别名来代替gcc或clang命令。以下组合： cc -v 显示你所使用的编译器及其版本。 gcc和clang命令都可以根据不同的版本选择运行时选项来调用不同C标 准。 gcc -std=c99 inform.c[3] gcc -std=c1x inform.c gcc -std=c11 inform.c\n第 1 行调用C99标准，第 2 行调用GCC接受C11之前的草案标准，第 3 行调 # 用GCC接受的C11标准版本。Clang编译器在这一点上用法与GCC相同。\n1.8.4 Linux 系统 # Linux是一个开源、流行、类似于UNIX的操作系统，可在不同平台（包 括PC和Mac）上运行。在Linux中准备C程序与在UNIX系统中几乎一样，不 同的是要使用GNU提供的GCC公共域C编译器。编译命令类似于： gcc inform.c 注意，在安装Linux时，可选择是否安装GCC。如果之前没有安装 GCC，则必须安装。通常，安装过程会将cc作为gcc的别名，因此可以在命 令行中使用cc来代替gcc。 欲详细了解GCC和最新发布的版本，请访问 http://www.gnu.org/software/gcc/index.html。\n1.8.5 PC 的命令行编译器 # C编译器不是标准Windows软件包的一部分，因此需要从别处获取并安 装C编译器。可以从互联网免费下载Cygwin和MinGW，这样便可在PC上通 过命令行使用GCC编译器。Cygwin在自己的视窗运行，模仿Linux命令行环 境，有一行命令提示。MinGW在Windows的命令提示模式中运行。这和GCC 的最新版本一样，支持C99和C11最新的一些功能。Borland的C++编译器5.5 也可以免费下载，支持C90。 源代码文件应该是文本文件，不是字处理器文件（字处理器文件包含许 多额外的信息，如字体和格式等）。因此，要使用文本编辑器（如， Windows Notepad）来编辑源代码。如果使用字处理器，要以文本模式另存 文件。源代码文件的扩展名应该是.c。一些字处理器会为文本文件自动添 加.txt 扩展名。如果出现这种情况，要更改文件名，把txt替换成c。 通常，C编译器生成的中间目标代码文件的扩展名是.obj（也可能是其\n他扩展名）。与UNIX编译器不同，这些编译器在完成编译后通常不会删除 # 这些中间文件。有些编译器生成带.asm扩展名的汇编语言文件，而有些编译 器则使用自己特有的格式。 一些编译器在编译后会自动运行链接器，另一些要求用户手动运行链接 器。在可执行文件中链接的结果是，在原始的源代码基本名后面加上.exe扩 展名。例如，编译和链接concrete.c源代码文件，生成的是concrete.exe文件。 可以在命令行输入基本名来运行该程序： C\u0026gt;concrete\n1.8.6 集成开发环境（ Windows ） # 许多供应商（包括微软、Embarcadero、Digital Mars）都提供Windows 下的集成开发环境，或称为IDE（目前，大多数IDE都是C和C++结合的编译 器）。可以免费下载的IDE有Microsoft Visual Studio Express和Pelles C。利用 集成开发环境可以快速开发C程序。关键是，这些IDE都内置了用于编写C程 序的编辑器。这类集成开发环境都提供了各种菜单（如，命名、保存源代码 文件、编译程序、运行程序等），用户不用离开IDE就能顺利编写、编译和 运行程序。如果编译器发现错误，会返回编辑器中，标出有错误的行号，并 简单描述情况。 初次接触Windows IDE可能会望而生畏，因为它提供了多种目标 （target），即运行程序的多种环境。例如，IDE提供了 32 位Windows程序、 64 位Windows程序、动态链接库文件（DLL）等。许多目标都涉及Windows 图形界面。要管理这些（及其他）选择，通常要先创建一个项目 （project），以便稍后在其中添加待使用的源代码文件名。不同的产品具体 步骤不同。一般而言，首先使用【文件】菜单或【项目】菜单创建一个项 目。选择正确的项目形式非常重要。本书中的例子都是一般示例，针对在简 单的命令行环境中运行而设计。Windows IDE提供多种选择以满足用户的不 同需求。例如，Microsoft Visual Studio提供【Win32控制台应用程序】选 项。对于其他系统，查找一个诸如【DOS EXE】、【Console】或\n【Character Mode】的可执行选项。选择这些模式后，将在一个类控制台窗 口中运行可执行程序。选择好正确的项目类型后，使用IDE的菜单打开一个 新的源代码文件。对于大多数产品而言，使用【文件】菜单就能完成。你可 能需要其他步骤将源文件添加到项目中。 通常，Windows IDE既可处理C也可处理C++，因此要指定待处理的程序 是C还是C++。有些产品用项目类型来区分两者，有些产品（如，Microsoft Visual C++）用.c文件扩展名来指明使用C而不是C++。当然，大多数C程序 也可以作为C++程序运行。欲了解C和C++的区别，请参阅参考资料IX。 你可能会遇到一个问题：在程序执行完毕后，执行程序的窗口立即消 失。如果不希望出现这种情况，可以让程序暂停，直到按下Enter键，窗口 才消失。要实现这种效果，可以在程序的最后（return这行代码之前）添加 下面一行代码： getchar(); 该行读取一次键的按下，所以程序在用户按下Enter键之前会暂停。有 时根据程序的需要，可能还需要一个击键等待。这种情况下，必须用两次 getchar()： getchar(); getchar(); 例如，程序在最后提示用户输入体重。用户键入体重后，按下Enter键 以输入数据。程序将读取体重，第 1 个getchar()读取Enter键，第 2 个getchar() 会导致程序暂停，直至用户再次按下Enter键。如果你现在不知所云，没关 系，在学完C输出后就会明白。到时，我们会提醒读者使用这种方法。 虽然许多IDE在使用上大体一致，但是细节上有所不同。就一个产品的 系列而言，不同版本也是如此。要经过一段时间的实践，才会熟悉编译器的 工作方式。必要时，还需阅读使用手册或网上教程。\nMicrosoft Visual Studio 和 C 标准 在Windows软件开发中，Microsoft Visual Studio及其免费版本Microsoft Visual Studio Express都久负盛名，它们与C标准的关系也很重要。然而，微 软鼓励程序员从C转向C++和C#。虽然Visual Studio支持C89/90，但是到目前 为止，它只选择性地支持那些在C++新特性中能找到的C标准（如，long long类型）。而且，自 2012 版本起，Visual Studio不再把C作为项目类型的选 项。尽管如此，本书中的绝大多数程序仍可用Visual Studio来编译。在新建 项目时，选择C++选项，然后选择【Win32控制台应用程序】，在应用设置 中选择【空项目】。几乎所有的C程序都能与C++程序兼容。所以，本书中 的绝大多数C程序都可作为C++程序运行。或者，在选择C++选项后，将默 认的源文件扩展名.cpp替换成.c，编译器便会使用C语言的规则代替C++。\n1.8.7 Windows/Linux # 许多Linux发行版都可以安装在Windows系统中，以创建双系统。一些存 储器会为Linux系统预留空间，以便可以启动Windows或Linux。可以在 Windows系统中运行Linux程序，或在Linux系统中运行Windows程序。不能通 过Windows系统访问Linux文件，但是可以通过Linux系统访问Windows文档。\n1.8.8 Macintosh 中的 C # 目前，苹果免费提供Xcode开发系统下载（过去，它有时免费，有时付 费）。它允许用户选择不同的编程语言，包括C语言。 Xcode 凭借可处理多种编程语言的能力，可用于多平台，开发超大型的 项目。但是，首先要学会如何编写简单的C程序。在Xcode 4.6中，通过 【File】菜单选择【New Project】，然后选择【OS X Application Command Line Tool】，接着输入产品名并选择C类型。Xcode使用Clang或GCC C编译 器来编译C代码，它以前默认使用GCC，但是现在默认使用Clang。可以设置 选择使用哪一个编译器和哪一套C标准（因为许可方面的事宜，Xcode中 Clang的版本比GCC的版本要新）。\nUNIX系统内置Mac OS X，终端工具打开的窗口是让用户在UNIX命令行 环境中运行程序。苹果在标准软件包中不提供命令行编译器，但是，如果下 载了 Xcode，还可以下载可选的命令行工具，这样就可以使用clang和gcc命 令在命令行模式中编译。\n1.9 本书的组织结构 # 本书采用多种方式编排内容，其中最直接的方法是介绍A主题的所有内 # 容、介绍B主题的所有内容，等等。这对参考类书籍来说尤为重要，读者可 # 以在同一处找到与主题相关的所有内容。但是，这通常不是学习的最佳顺 # 序。例如，如果在开始学习英语时，先学完所有的名词，那你的表达能力一 # 定很有限。虽然可以指着物品说出名称，但是，如果稍微学习一些名词、动 # 词、形容词等，再学习一些造句规则，那么你的表达能力一定会大幅提高。 # 为了让读者更好地吸收知识，本书采用螺旋式方法，先在前几个章节中 # 介绍一些主题，在后面章节再详细讨论相关内容。例如，对学习C语言而 # 言，理解函数至关重要。因此，我们在前几个章节中安排一些与函数相关的 # 内容，等读者学到第 9 章时，已对函数有所了解，学习使用函数会更加容 # 易。与此类似，前几章还概述了一些字符串和循环的内容。这样，读者在完 # 全弄懂这些内容之前，就可以在自己的程序中使用这些有用的工具。 # 1.10 本书的约定 # 在学习C语言之前，先介绍一下本书的格式。 # 1.10.1 字体 # 本书用类似在屏幕上或打印输出时的字体（一种等宽字体），表示文本 # 程序和计算机输入、输出。前面已经出现了多次，如果读者没有注意到，字 # 体如下所示： # #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026ldquo;Concrete contains gravel and cement.\\n\u0026rdquo;); return 0; } 在涉及与代码相关的术语时，也使用相同的等宽字体，如stdio.h。本书 用等宽斜体表示占位符，可以用具体的项替换这些占位符。例如，下面是一 个声明的模型： type_name variable_name; 这里，可用int替换type_name，用zebra_count替换variable_name。\n1.10.2 程序输出 # 本书用相同的字体表示计算机的输出，粗体表示用户输入。例如，下面 # 是第 14 章中一个程序的输出： # Please enter the book title. Press [enter] at the start of a line to stop. My Life as a Budgie Now enter the author. Mack Zackles 如上所示，以标准计算机字体显示的行表示程序的输出，粗体行表示用 户的输入。 可以通过多种方式与计算机交互。在这里，我们假设读者使用键盘键入 内容，在屏幕上阅读计算机的响应。\n1. 特殊的击键 通常，通过按下标有 Enter、c/r、Return 或一些其他文字的键来发送指 令。本书将这些按键统一称为Enter键。一般情况下，我们默认你在每行输 入的末尾都会按下Enter键。尽管如此，为了标示一些特定的位置，本书使 用[enter]显式标出Enter键。方括号表示按下一次Enter键，而不是输入enter。 除此之外，书中还会提到控制字符（如，Ctrl+D）。这种写法的意思 是，在按下Ctrl键（也可能是Control键）的同时按下D键。 2. 本书使用的系统 C 语言的某些方面（如，储存数字的空间大小）因系统而异。本书在示 例中提到“我们的系统”时，通常是指在iMac上运行OS X 10.8.4，使用Xcode 4.6.2开发系统的Clang 3.2编译器。本书的大部分程序都能使用Windows7系 统的Microsoft Visual Studio Express 2012和Pelles C 7.0，以及Ubuntu13.04 Linux系统的GCC 4.7.3进行编译。 3. 读者的系统\n你需要一个C编译器或访问一个C编译器。C程序可以在多种计算机系统 # 中运行，因此你的选择面很广。确保你使用的C编译器与当前使用的计算机 # 系统匹配。本书中，除了某些示例要求编译器支持C99或C11标准，其余大 # 部分示例都可在C90编译器中运行。如果你使用的编译器是早于ANSI/ISO的 # 老式编译器，在编译时肯定要经常调整，很不方便。与其如此，不如换个新 # 的编译器。 # 大部分编译器供应商都为学生和教学人员提供特惠版本，详情请查看供 # 应商的网站。 # 1.10.3 特殊元素 # 本书包含一些强调特定知识点的特殊元素，提示、注意、警告，将以如 # 下形式出现在本书中： # 边栏 # 边栏提供更深入的讨论或额外的背景，有助于解释当前的主题。 # 提示 # 提示一般都短小精悍，帮助读者理解一些特殊的编程情况。 # 警告 # 用于警告读者注意一些潜在的陷阱。 # 注意 # 提供一些评论，提醒读者不要误入歧途。 # 1.11 本章小结 # C是强大而简洁的编程语言。它之所以流行，在于自身提供大量的实用 # 编程工具，能很好地控制硬件。而且，与大多数其他程序相比，C程序更容 # 易从一个系统移植到另一个系统。 # C是编译型语言。C编译器和链接器是把C语言源代码转换成可执行代码 # 的程序。 # 用C语言编程可能费力、困难，让你感到沮丧，但是它也可以激发你的 # 兴趣，让你兴奋、满意。我们希望你在愉快的学习过程中爱上C。 # 1.12 复习题 # 复习题的参考答案在附录A中。 # 1.对编程而言，可移植性意味着什么？ # 2.解释源代码文件、目标代码文件和可执行文件有什么区别？ # 3.编程的 7 个主要步骤是什么？ # 4.编译器的任务是什么？ # 5.链接器的任务是什么？ # 1.13 编程练习 # 我们尚未要求你编写C代码，该练习侧重于编程过程的早期步骤。 # 1.你刚被MacroMuscle有限公司聘用。该公司准备进入欧洲市场，需要 一个把英寸单位转换为厘米单位（ 1 英寸=2.54 厘米）的程序。该程序要提 示用户输入英寸值。你的任务是定义程序目标和设计程序（编程过程的第 1 步和第 2 步）。\n[1].Contest国际）。这是一项国际编程赛事，从C语言混乱代码大赛（IOCCC， 1984 The International Obfuscated C Code年开始，每年举办一次（ 1997 、\n(^1999) 的C语言代码。、 2002 、 (^2003) ——和译者注 2006 年除外），目的是写出最有创意且最让人难以理解 [2].位小型计算机。VAX（Virtual Address eXtensionVMS（Virtual Memory System）是一种可支持机器语言和虚拟地址的）是旧名，现在叫OpenVMS， 32 是一种用于服务器的操作系统，可在上运行。——译者注 VAX、Alpha或Itanium处理器系列平台 [3].数，GCCfilenames最基本的用法是：是文件名。——gcc [options] [filenames]译者注 ，其中options是所需的参\n第 2 章 C 语言概述 # 本章介绍以下内容： # 运算符：= # 函数：main()、printf() 编写一个简单的C程序 创建整型变量，为其赋值并在屏幕上显示其值 换行字符 如何在程序中写注释，创建包含多个函数的程序，发现程序的错误 什么是关键字 C程序是什么样子的？浏览本书，能看到许多示例。初见 C 程序会觉得 有些古怪，程序中有许多｛、cp-\u0026gt;tort和*ptr++这样的符号。然而，在学习C 的过程中，对这些符号和C语言特有的其他符号会越来越熟悉，甚至会喜欢 上它们。如果熟悉与C相关的其他语言，会对C语言有似曾相识的感觉。本 章，我们从演示一个简单的程序示例开始，解释该程序的功能。同时，强调 一些C语言的基本特性。\n2.1 简单的 C 程序示例 # 我们来看一个简单的C程序，如程序清单2.1所示。该程序演示了用C语 # 言编程的一些基本特性。请先通读程序清单2.1，看看自己是否能明白该程 # 序的用途，再认真阅读后面的解释。 # 程序清单 2.1 first.c 程序 #include \u0026lt;stdio.h\u0026gt; int main(void) /* 一个简单的C程序 / { int num; / 定义一个名为num的变量 / num = 1; / 为num赋一个值 / printf(\u0026ldquo;I am a simple \u0026ldquo;); / 使用printf()函数 */ printf(\u0026ldquo;computer.\\n\u0026rdquo;); printf(\u0026ldquo;My favorite number is %d because it is first.\\n\u0026rdquo;,num); return 0; } 如果你认为该程序会在屏幕上打印一些内容，那就对了！光看程序也许 并不知道打印的具体内容，所以，运行该程序，并查看结果。首先，用你熟 悉的编辑器（或者编译器提供的编辑器）创建一个包含程序清单2.1 中所有 内容的文件。给该文件命名，并以.c作为扩展名，以满足当前系统对文件名 的要求。例如，可以使用first.c。现在，编译并运行该程序（查看第 1 章，复 习该步骤的具体内容）。如果一切运行正常，该程序的输出应该是：\nI am a simple computer. My favorite number is 1 because it is first. 总而言之，结果在意料之中，但是程序中的\\n 和%d 是什么？程序中有 几行代码看起来有点奇怪。接下来，我们逐行解释这个程序。 程序调整 程序的输出是否在屏幕上一闪而过？某些窗口环境会在单独的窗口运行 程序，然后在程序运行结束后自动关闭窗口。如果遇到这种情况，可以在程 序中添加额外的代码，让窗口等待用户按下一个键后才关闭。一种方法是， 在程序的return语句前添加一行代码： getchar()； 这行代码会让程序等待击键，窗口会在用户按下一个键后才关闭。在第 8 章中会详细介绍 getchar()的内容。\n2.2 示例解释 # 我们会把程序清单2.1的程序分析两遍。第 1 遍（快速概要）概述程序中 # 每行代码的作用，帮助读者初步了解程序。第 2 遍（程序细节）详细分析代 # 码的具体含义，帮助读者深入理解程序。 # 图2.1总结了组成C程序的几个部分[1]，图中包含的元素比第 1 个程序 # 多。 # 图2.1 C程序解剖 2.2.1 第 1 遍：快速概要 # 本节简述程序中的每行代码的作用。下一节详细讨论代码的含义。 # #include\u0026lt;stdio.h\u0026gt; ←包含另一个文件 该行告诉编译器把stdio.h中的内容包含在当前程序中。stdio.h是C编译器 软件包的标准部分，它提供键盘输入和屏幕输出的支持。 int main(void) ←函数名 C程序包含一个或多个函数，它们是C程序的基本模块。程序清单2.1的 程序中有一个名为main()的函数。圆括号表明main()是一个函数名。int表明 main()函数返回一个整数，void表明main()不带任何参数。这些内容我们稍后 详述。现在，只需记住int和void是标准ANSI C定义main()的一部分（如果使 用ANSI C之前的编译器，请省略void；考虑到兼容的问题，请尽量使用较新 的C编译器）。 /* 一个简单的C程序 */ ←注释 注释在/和/两个符号之间，这些注释能提高程序的可读性。注意，注 释只是为了帮助读者理解程序，编译器会忽略它们。 { ←函数体开始 左花括号表示函数定义开始，右花括号（}）表示函数定义结束。 int num; ←声明 该声明表明，将使用一个名为num的变量，而且num是int（整数）类 型。 num = 1; ←赋值表达式语句 语句num = 1;把值 1 赋给名为num的变量。\nprintf(\u0026ldquo;I am a simple \u0026ldquo;); ←调用一个函数 该语句使用 printf()函数，在屏幕上显示 I am a simple，光标停在同一 行。printf()是标准的C库函数。在程序中使用函数叫作调用函数。 printf(\u0026ldquo;computer.\\n\u0026rdquo;); ←调用另一个函数 接下来调用的这个printf()函数在上条语句打印出来的内容后面加 上“computer”。代码\\n告诉计算机另起一行，即把光标移至下一行。 printf(\u0026ldquo;My favorite number is %d because it is first.\\n\u0026rdquo;, num); 最后调用的printf()把num的值（ 1 ）内嵌在用双引号括起来的内容中一并 打印。%d告诉计算机以何种形式输出num的值，打印在何处。 return 0; ←return语句 C函数可以给调用方提供（或返回）一个数。目前，可暂时把该行看作 是结束main()函数的要求。 } ←结束 必须以右花括号表示程序结束。\n2.2.2 第 2 遍：程序细节 # 浏览完程序清单2.1后，我们来仔细分析这个程序。再次强调，本节将 # 逐行分析程序中的代码，以每行代码为出发点，深入分析代码背后的细节， # 为更全面地学习C语言编程的特性夯实基础。 # 1.#include 指令和头文件 #include\u0026lt;stdio.h\u0026gt; 这是程序的第 1 行。#include \u0026lt;stdio.h\u0026gt;的作用相当于把stdio.h文件中的所 有内容都输入该行所在的位置。实际上，这是一种“拷贝-粘贴”的操作。\ninclude 文件提供了一种方便的途径共享许多程序共有的信息。 #include这行代码是一条C预处理器指令（preprocessor directive）。通 常，C编译器在编译前会对源代码做一些准备工作，即预处理 （preprocessing）。 所有的C编译器软件包都提供stdio.h文件。该文件中包含了供编译器使 用的输入和输出函数（如， printf()）信息。该文件名的含义是标准输入/输 出头文件。通常，在C程序顶部的信息集合被称为头文件（header）。 在大多数情况下，头文件包含了编译器创建最终可执行程序要用到的信 息。例如，头文件中可以定义一些常量，或者指明函数名以及如何使用它 们。但是，函数的实际代码在一个预编译代码的库文件中。简而言之，头文 件帮助编译器把你的程序正确地组合在一起。 ANSI/ISO C规定了C编译器必须提供哪些头文件。有些程序要包含 stdio.h，而有些不用。特定C实现的文档中应该包含对C库函数的说明。这些 说明确定了使用哪些函数需要包含哪些头文件。例如，要使用printf()函数， 必须包含stdio.h头文件。省略必要的头文件可能不会影响某一特定程序，但 是最好不要这样做。本书每次用到库函数，都会用#include指令包含 ANSI/ISO标准指定的头文件。 注意 为何不内置输入和输出 读者一定很好奇，为何不把输入和输出这些基本功能内置在语言中。原 因之一是，并非所有的程序都会用到I/O（输入/输出）包。轻装上阵表现了 C语言的哲学。正是这种经济使用资源的原则，使得C语言成为流行的嵌入 式编程语言（例如，编写控制汽车自动燃油系统或蓝光播放机芯片的代 码）。#include中的#符号表明，C预处理器在编译器接手之前处理这条指 令。本书后面章节中会介绍更多预处理器指令的示例，第 16 章将更详细地讨 论相关内容。 2.main() 函数\nint main(void); 程序清单2.1中的第 2 行表明该函数名为main。的确，main是一个极其普 通的名称，但是这是唯一的选择。C程序一定从main()函数开始执行（目前 不必考虑例外的情况）。除了main()函数，你可以任意命名其他函数，而且 main()函数必须是开始的函数。圆括号有什么功能？用于识别main()是一个 函数。很快你将学到更多的函数。就目前而言，只需记住函数是C程序的基 本模块。 int是main()函数的返回类型。这表明main()函数返回的值是整数。返回 到哪里？返回给操作系统。我们将在第 6 章中再来探讨这个问题。 通常，函数名后面的圆括号中包含一些传入函数的信息。该例中没有传 递任何信息。因此，圆括号内是单词void（第 11 章将介绍把信息从main()函 数传回操作系统的另一种形式）。 如果浏览旧式的C代码，会发现程序以如下形式开始： main() C90标准勉强接受这种形式，但是C99和C11标准不允许这样写。因此， 即使你使用的编译器允许，也不要这样写。 你还会看到下面这种形式： void main() 一些编译器允许这样写，但是所有的标准都未认可这种写法。因此，编 译器不必接受这种形式，而且许多编译器都不能这样写。需要强调的是，只 要坚持使用标准形式，把程序从一个编译器移至另一个编译器时就不会出什 么问题。\n3. 注释 /一个简单的程序/\n在程序中，被/* */两个符号括起来的部分是程序的注释。写注释能让他 # 人（包括自己）更容易明白你所写的程序。C 语言注释的好处之一是，可将 # 注释放在任意的地方，甚至是与要解释的内容在同一行。较长的注释可单独 # 放一行或多行。在/和/之间的内容都会被编译器忽略。下面列出了一些有 # 效和无效的注释形式： # /* 这是一条C注释。 */ # /* 这也是一条注释， # 被分成两行。*/ # /* # 也可以这样写注释。 # */ # /* 这条注释无效，因为缺少了结束标记。 # C99新增了另一种风格的注释，普遍用于C++和Java。这种新风格使用// 符号创建注释，仅限于单行。 // 这种注释只能写成一行。 int rigue; // 这种注释也可置于此。 因为一行末尾就标志着注释的结束，所以这种风格的注释只需在注释开 始处标明//符号即可。 这种新形式的注释是为了解决旧形式注释存在的潜在问题。假设有下面 的代码： /* 希望能运行。\n*/ # x = 100; y = 200; /* 其他内容已省略。 / 接下来，假设你决定删除第 4 行，但不小心删掉了第 3 行（/）。代码如 下所示： /* 希望能运行。 y = 200; /*其他内容已省略。 */ 现在，编译器把第 1 行的/和第 4 行的/配对，导致 4 行代码全都成了注释 （包括应作为代码的那一行）。而//形式的注释只对单行有效，不会导致这 种“消失代码”的问题。 一些编译器可能不支持这一特性。还有一些编译器需要更改设置，才能 支持C99或C11的特性。 考虑到只用一种注释风格过于死板乏味，本书在示例中采用两种风格的 注释。\n4. 花括号、函数体和块 { \u0026hellip; }\n程序清单2.1中，花括号把main()函数括起来。一般而言，所有的C函数 都使用花括号标记函数体的开始和结束。这是规定，不能省略。只有花括号 （{}）能起这种作用，圆括号（()）和方括号（[]）都不行。 花括号还可用于把函数中的多条语句合并为一个单元或块。如果读者熟 悉Pascal、ADA、Modula-2或者Algol，就会明白花括号在C语言中的作用类 似于这些语言中的begin和end。\n5. 声明 int num; 程序清单2.1中，这行代码叫作声明（declaration）。声明是C语言最重 要的特性之一。在该例中，声明完成了两件事。其一，在函数中有一个名为 num的变量（variable）。其二，int表明num是一个整数（即，没有小数点或 小数部分的数）。int是一种数据类型。编译器使用这些信息为num变量在内 存中分配存储空间。分号在C语言中是大部分语句和声明的一部分，不像在 Pascal中只是语句间的分隔符。 int是C语言的一个关键字（keyword），表示一种基本的C语言数据类 型。关键字是语言定义的单词，不能做其他用途。例如，不能用int作为函数 名和变量名。但是，这些关键字在该语言以外不起作用，所以把一只猫或一 个可爱的小孩叫int是可以的（尽管某些地方的当地习俗或法律可能不允 许）。 示例中的num是一个标识符（identifier），也就一个变量、函数或其他 实体的名称。因此，声明把特定标识符与计算机内存中的特定位置联系起 来，同时也确定了储存在某位置的信息类型或数据类型。 在C语言中，所有变量都必须先声明才能使用。这意味着必须列出程序 中用到的所有变量名及其类型。 以前的C语言，还要求把变量声明在块的顶部，其他语句不能在任何声\n明的前面。也就是说，main()函数体如下所示： int main() //旧规则 { int doors; int dogs; doors = 5; dogs = 3; // 其他语句 } C99和C11遵循C++的惯例，可以把声明放在块中的任何位置。尽管如 此，首次使用变量之前一定要先声明它。因此，如果编译器支持这一新特 性，可以这样编写上面的代码： int main() // 目前的C规则 { // 一些语句 int doors; doors = 5; // 第 1 次使用doors // 其他语句 int dogs; dogs = 3; // 第 1 次使用dogs\n// 其他语句 # } # 为了与旧系统更好地兼容，本书沿用最初的规则（即，把变量声明都写 # 在块的顶部）。 # 现在，读者可能有 3 个问题：什么是数据类型？如何命名？为何要声明 # 变量？请往下看。 # 数据类型 # C 语言可以处理多种类型的数据，如整数、字符和浮点数。把变量声明 # 为整型或字符类型，计算机才能正确地储存、读取和解释数据。下一章将详 # 细介绍C语言中的各种数据类型。 # 命名 # 给变量命名时要使用有意义的变量名或标识符（如，程序中需要一个变 # 量数羊，该变量名应该是sheep_count而不是x3）。如果变量名无法清楚地表 达自身的用途，可在注释中进一步说明。这是一种良好的编程习惯和编程技 巧。 C99和C11允许使用更长的标识符名，但是编译器只识别前 63 个字符。 对于外部标识符（参阅第 12 章），只允许使用 31 个字符。〔以前C90只允许 6 个字符，这是一个很大的进步。旧式编译器通常最多只允许使用 8 个字 符。〕实际上，你可以使用更长的字符，但是编译器会忽略超出的字符。也 就是说，如果有两个标识符名都有 63 个字符，只有一个字符不同，那么编译 器会识别这是两个不同的名称。如果两个标识符都是 64 个字符，只有最后一 个字符不同，那么编译器可能将其视为同一个名称，也可能不会。标准并未 定义在这种情况下会发生什么。 可以用小写字母、大写字母、数字和下划线（_）来命名。而且，名称 的第 1 个字符必须是字符或下划线，不能是数字。表2.1给出了一些示例。\n表2.1 有效和无效的名称 操作系统和C库经常使用以一个或两个下划线字符开始的标识符（如， # _kcab），因此最好避免在自己的程序中使用这种名称。标准标签都以一个 或两个下划线字符开始，如库标识符。这样的标识符都是保留的。这意味 着，虽然使用它们没有语法错误，但是会导致名称冲突。 C语言的名称区分大小写，即把一个字母的大写和小写视为两个不同的 字符。因此，stars和Stars、STARS都不同。 为了让C语言更加国际化，C99和C11根据通用字符名（即UCN）机制添 加了扩展字符集。其中包含了除英文字母以外的部分字符。欲了解详细内 容，请参阅附录B的“参考资料VII：扩展字符支持”。 声明变量的 4 个理由 一些更老的语言（如，FORTRAN 和 BASIC 的最初形式）都允许直接 使用变量，不必先声明。为何 C语言不采用这种简单易行的方法？原因如 下。 把所有的变量放在一处，方便读者查找和理解程序的用途。如果变量名 都是有意义的（如，taxtate而不是 r），这样做效果很好。如果变量名无法 表述清楚，在注释中解释变量的含义。这种方法让程序的可读性更高。 声明变量会促使你在编写程序之前做一些计划。程序在开始时要获得哪 些信息？希望程序如何输出？表示数据最好的方式是什么？ 声明变量有助于发现隐藏在程序中的小错误，如变量名拼写错误。例\n如，假设在某些不需要声明就可以直接使用变量的语言中，编写如下语句： # RADIUS1 = 20.4; # 在后面的程序中，误写成： # CIRCUM = 6.28 * RADIUSl; 你不小心把数字 1 打成小写字母l。这些语言会创建一个新的变量 RADIUSl，并使用该变量中的值（也许是 0 ，也许是垃圾值），导致赋给 CIRCUM的值是错误值。你可能要花很久时间才能查出原因。这样的错误在 C语言中不会发生（除非你很不明智地声明了两个极其相似的变量），因为 编译器在发现未声明的RADIUSl时会报错。 如果事先未声明变量，C程序将无法通过编译。如果前几个理由还不足 以说服你，这个理由总可以让你认真考虑一下了。 如果要声明变量，应该声明在何处？前面提到过，C99之前的标准要求 把声明都置于块的顶部，这样规定的好处是：把声明放在一起更容易理解程 序的用途。C99 允许在需要时才声明变量，这样做的好处是：在给变量赋值 之前声明变量，就不会忘记给变量赋值。但是实际上，许多编译器都还不支 持C99。\n6. 赋值 num = 1; 程序清单中的这行代码是赋值表达式语句[2]。赋值是C语言的基本操作 之一。该行代码的意思是“把值 1 赋给变量num”。在执行int num;声明时，编 译器在计算机内存中为变量num预留了空间，然后在执行这行赋值表达式语 句时，把值储存在之前预留的位置。可以给num赋不同的值，这就是num之 所以被称为变量（variable）的原因。注意，该赋值表达式语句从右侧把值 赋到左侧。另外，该语句以分号结尾，如图2.2所示。\n图2.2 赋值是C语言中的基本操作之一 7.printf() 函数 printf(\u0026ldquo;I am a simple \u0026ldquo;); printf(\u0026ldquo;computer.\\n\u0026rdquo;); printf(\u0026ldquo;My favorite number is %d because it is first.\\n\u0026rdquo;, num); 这 3 行都使用了C语言的一个标准函数：printf()。圆括号表明printf是一 个函数名。圆括号中的内容是从main()函数传递给printf()函数的信息。例 如，上面的第 1 行把I am a simple传递给printf()函数。该信息被称为参数，或 者更确切地说，是函数的实际参数（actual argument），如图2.3所示。〔在 C语言中，实际参数（简称实参）是传递给函数的特定值，形式参数（简称 形参）是函数中用于储存值的变量。第 5 章中将详述相关内容。〕printf()函 数用参数来做什么？该函数会查看双引号中的内容，并将其打印在屏幕上。\n图2.3 带实参的printf()函数 第 1 行printf()演示了在C语言中如何调用函数。只需输入函数名，把所需 的参数填入圆括号即可。当程序运行到这一行时，控制权被转给已命名的函 # 数（该例中是printf()）。函数执行结束后，控制权被返回至主调函数 （calling function），该例中是main()。 第 2 行printf()函数的双引号中的\\n字符并未输出。这是为什么？\\n的意思 是换行。\\n组合（依次输入这两个字符）代表一个换行符（newline character）。对于printf()而言，它的意思是“在下一行的最左边开始新的一 行”。也就是说，打印换行符的效果与在键盘按下Enter键相同。既然如此， 为何不在键入printf()参数时直接使用Enter键？因为编辑器可能认为这是直接 的命令，而不是储存在在源代码中的指令。换句话说，如果直接按下Enter 键，编辑器会退出当前行并开始新的一行。但是，换行符仅会影响程序输出 的显示格式。 换行符是一个转义序列（escape sequence）。转义序列用于代表难以表 示或无法输入的字符。如，\\t代表Tab键，\\b代表Backspace键（退格键）。每 个转义序列都以反斜杠字符（\\）开始。我们在第 3 章中再来探讨相关内容。 这样，就解释了为什么 3 行printf()语句只打印出两行：第 1 个printf()打印 的内容中不含换行符，但是第 2 和第 3 个printf()中都有换行符。 第 3 个printf()还有一些不明之处：参数中的%d在打印时有什么作用？先 来看该函数的输出： My favorite number is 1 because it is first. 对比发现，参数中的%d被数字 1 代替了，而 1 就是变量num的值。%d相 当于是一个占位符，其作用是指明输出num值的位置。该行和下面的BASIC 语句很像： PRINT \u0026ldquo;My favorite number is \u0026ldquo;; num; \u0026quot; because it is first.\u0026rdquo; 实际上，C语言的printf()比BASIC的这条语句做的事情多一些。%提醒 程序，要在该处打印一个变量，d表明把变量作为十进制整数打印。printf()\n函数名中的f提醒用户，这是一种格式化打印函数。printf()函数有多种打印 变量的格式，包括小数和十六进制整数。后面章节在介绍数据类型时，会详 细介绍相关内容。 8.return 语句 return 0; return语句[3]是程序清单2.1的最后一条语句。int main(void)中的int表明 main()函数应返回一个整数。C标准要求main()这样做。有返回值的C函数要 有return语句。该语句以return关键字开始，后面是待返回的值，并以分号结 尾。如果遗漏 main()函数中的 return 语句，程序在运行至最外面的右花括号 （}）时会返回 0 。因此，可以省略main()函数末尾的return语句。但是，不要 在其他有返回值的函数中漏掉它。因此，强烈建议读者养成在 main()函数中 保留 return 语句的好习惯。在这种情况下，可将其看作是统一代码风格。但 对于某些操作系统（包括Linux和UNIX），return语句有实际的用途。第 11 章 再详述这个主题。\n2.3 简单程序的结构 # 在看过一个具体的程序示例后，我们来了解一下C程序的基本结构。程 # 序由一个或多个函数组成，必须有 main()函数。函数由函数头和函数体组 成。函数头包括函数名、传入该函数的信息类型和函数的返回类型。通过函 数名后的圆括号可识别出函数，圆括号里可能为空，可能有参数。函数体被 花括号括起来，由一系列语句、声明组成，如图2.4所示。本章的程序示例 中有一条声明，声明了程序使用的变量名和类型。然后是一条赋值表达式语 句，变量被赋给一个值。接下来是 3 条printf()语句[4]，调用printf()函数 3 次。 最后，main()以return语句结束。\n图2.4 函数包含函数头和函数体 简而言之，一个简单的C程序的格式如下： #include \u0026lt;stdio.h\u0026gt; int main(void) { 语句 return 0; } （大部分语句都以分号结尾。）\n2.4 提高程序可读性的技巧 # 编写可读性高的程序是良好的编程习惯。可读性高的程序更容易理解， # 以后也更容易修改和更正。提高程序的可读性还有助于你理清编程思路。 # 前面介绍过两种提高程序可读性的技巧：选择有意义的函数名和写注 # 释。注意，使用这两种技巧时应相得益彰，避免重复啰嗦。如果变量名是 # width，就不必写注释说明该变量表示宽度，但是如果变量名是 video_routine_4，就要解释一下该变量名的含义。 提高程序可读性的第 3 个技巧是：在函数中用空行分隔概念上的多个部 分。例如，程序清单2.1中用空行把声明部分和程序的其他部分区分开来。C 语言并未规定一定要使用空行，但是多使用空行能提高程序的可读性。 提高程序可读性的第 4 个技巧是：每条语句各占一行。同样，这也不是 C语言的要求。C语言的格式比较自由，可以把多条语句放在一行，也可以 每条语句独占一行。下面的语句都没问题，但是不好看： int main( void ) { int four; four # 4 ; printf( \u0026ldquo;%d\\n\u0026rdquo;, four); return 0;} 分号告诉编译器一条语句在哪里结束、下一条语句在哪里开始。如果按 照本章示例的约定来编写代码（见图2.5），程序的逻辑会更清晰。\n图2.5 提高程序的可读性\n2.5 进一步使用 C # 本章的第 1 个程序相当简单，下面的程序清单2.2也不太难。 # 程序清单 2.2 fathm_ft.c 程序 // fathm_ft.c \u0026ndash; 把 2 音寻转换成英寸 #include \u0026lt;stdio.h\u0026gt; int main(void) { int feet, fathoms; fathoms = 2; feet = 6 * fathoms; printf(\u0026ldquo;There are %d feet in %d fathoms!\\n\u0026rdquo;, feet, fathoms); printf(\u0026ldquo;Yes, I said %d feet!\\n\u0026rdquo;, 6 * fathoms); return 0; } 与程序清单2.1相比，以上代码有什么新内容？这段代码提供了程序描 述，声明了多个变量，进行了乘法运算，并打印了两个变量的值。下面我们 更详细地分析这些内容。\n2.5.1 程序说明 # 程序在开始处有一条注释（使用新的注释风格），给出了文件名和程序 # 的目的。写这种程序说明很简单、不费时，而且在以后浏览或打印程序时很 # 有帮助。 # 2.5.2 多条声明 # 接下来，程序在一条声明中声明了两个变量，而不是一个变量。为此， # 要在声明中用逗号隔开两个变量（feet和fathoms）。也就是说， int feet, fathoms; 和 int feet; int fathoms; 等价。\n2.5.3 乘法 # 然后，程序进行了乘法运算。利用计算机强大的计算能力来计算 6 乘以 # 2 。C 语言和许多其他语言一样，用*表示乘法。因此，语句 # feet = 6 * fathoms; 的意思是“查找变量fathoms的值，用 6 乘以该值，并把计算结果赋给变量 feet”。\n2.5.4 打印多个值 # 最后，程序以新的方式使用printf()函数。如果编译并运行该程序，输出 应该是这样： There are 12　feet in 2　fathoms! Yes, I said 12　feet!\n程序的第 1 个printf()中进行了两次替换。双引号号后面的第 1 个变量 （feet）替换了双引号中的第 1 个%d；双引号号后面的第 2 个变量（fathoms） 替换了双引号中的第 2 个%d。注意，待输出的变量列于双引号的后面。还要 注意，变量之间要用逗号隔开。 第 2 个printf()函数说明待打印的值不一定是变量，只要可求值得出合适 类型值的项即可，如6 *fathoms。 该程序涉及的范围有限，但它是把音寻[5]转换成英寸程序的核心部 分。我们还需要把其他值通过交互的方式赋给feet，其方法将在后面章节中 介绍。\n2.6 多个函数 # 到目前为止，介绍的几个程序都只使用了printf()函数。程序清单2.3演 示了除main()以外，如何把自己的函数加入程序中。 程序清单 2.3 two_func.c 程序 //* two_func.c \u0026ndash; 一个文件中包含两个函数 / #include \u0026lt;stdio.h\u0026gt; void butler(void); / ANSI/ISO C函数原型 / int main(void) { printf(\u0026ldquo;I will summon the butler function.\\n\u0026rdquo;); butler(); printf(\u0026ldquo;Yes. Bring me some tea and writeable DVDs.\\n\u0026rdquo;); return 0; } void butler(void) / 函数定义开始 */ { printf(\u0026ldquo;You rang, sir?\\n\u0026rdquo;); } 该程序的输出如下：\nI will summon the butler function. You rang, sir? Yes.Bring me some tea and writeable DVDs. butler()函数在程序中出现了 3 次。第 1 次是函数原型（prototype），告知 编译器在程序中要使用该函数；第 2 次以函数调用（function call）的形式出 现在 main()中；最后一次出现在函数定义（function definition）中，函数定 义即是函数本身的源代码。下面逐一分析。 C90 标准新增了函数原型，旧式的编译器可能无法识别（稍后我们将介 绍，如果使用这种编译器应该怎么做）。函数原型是一种声明形式，告知编 译器正在使用某函数，因此函数原型也被称为函数声明（function declaration）。函数原型还指明了函数的属性。例如，butler()函数原型中的 第 1 个void表明，butler()函数没有返回值（通常，被调函数会向主调函数返 回一个值，但是 bulter()函数没有）。第 2 个 void （butler(void)中的 void） 的意思是 butler()函数不带参数。因此，当编译器运行至此，会检查butler() 是否使用得当。注意，void在这里的意思是“空的”，而不是“无效”。 早期的C语言支持一种更简单的函数声明，只需指定返回类型，不用描 述参数： void butler(); 早期的C代码中的函数声明就类似上面这样，不是现在的函数原型。 C90、C99 和C11 标准都承认旧版本的形式，但是也表明了会逐渐淘汰这种 过时的写法。如果要使用以前写的 C代码，就需要把旧式声明转换成函数原 型。本书在后面的章节会继续介绍函数原型的相关内容。 接下来我们继续分析程序。在 main()中调用 butler()很简单，写出函数 名和圆括号即可。当butler()执行完毕后，程序会继续执行main()中的下一条 语句。\n程序的最后部分是 butler()函数的定义，其形式和 main()相同，都包含 函数头和用花括号括起来的函数体。函数头重述了函数原型的信息：bulter() 不带任何参数，且没有返回值。如果使用老式编译器，请去掉圆括号中的 void。 这里要注意，何时执行 butler()函数取决于它在 main()中被调用的位 置，而不是 butler()的定义在文件中的位置。例如，把 butler()函数的定义放 在 main()定义之前，不会改变程序的执行顺序， butler()函数仍然在两次 printf()调用之间被调用。记住，无论main()在程序文件处于什么位置，所有 的C程序都从main()开始执行。但是，C的惯例是把main()放在开头，因为它 提供了程序的基本框架。 C标准建议，要为程序中用到的所有函数提供函数原型。标准include文 件（包含文件）为标准库函数提供可函数原型。例如，在C标准中，stdio.h 文件包含了printf()的函数原型。第 6 章最后一个示例演示了如何使用带返回 值的函数，第 9 章将详细全面地介绍函数。\n2.7 调试程序 # 现在，你可以编写一个简单的 C 程序，但是可能会犯一些简单的错 # 误。程序的错误通常叫做 bug，找出并修正错误的过程叫做调试（debug）。 程序清单2.4是一个有错误的程序，看看你能找出几处。 程序清单 2.4 nogood.c 程序 /* nogood.c \u0026ndash; 有错误的程序 / #include \u0026lt;stdio.h\u0026gt; int main(void) ( int n, int n2, int n3; / 该程序有多处错误 n = 5; n2 = n * n; n3 = n2 * n2; printf(\u0026ldquo;n = %d, n squared = %d, n cubed = %d\\n\u0026rdquo;, n, n2, n3) return 0; )\n2.7.1 语法错误 # 程序清单 2.4 中有多处语法错误。如果不遵循 C 语言的规则就会犯语法 # 错误。这类似于英文中的语法错误。例如，看看这个句子：Bugs frustrate be can[6]。该句子中的英文单词都是有效的单词（即，拼写正确），但是并未 按照正确的顺序组织句子，而且用词也不妥。C语言的语法错误指的是，把 有效的C符号放在错误的地方。 nogood.c程序中有哪些错误？其一，main()函数体使用圆括号来代替花 括号。这就是把C符号用错了地方。其二，变量声明应该这样写： int n, n2, n3; 或者，这样写： int n; int n2; int n3; 其三，main()中的注释末尾漏掉了*/（另一种修改方案是，用//替 换/*）。最后，printf()语句末尾漏掉了分号。 如何发现程序的语法错误？首先，在编译之前，浏览源代码看是否能发 现一些明显的错误。接下来，查看编译器是否发现错误，检查程序的语法错 误是它的工作之一。在编译程序时，编译器发现错误会报告错误信息，指出 每一处错误的性质和具体位置。 尽管如此，编译器也有出错的时候。也许某处隐藏的语法错误会导致编 译器误判。例如，由于nogood.c程序未正确声明n2和n3，会导致编译器在使 用这些变量时发现更多问题。实际上，有时不用把编译器报告的所有错误逐 一修正，仅修正第 1 条或前几处错误后，错误信息就会少很多。继续这样 做，直到编译器不再报错。编译器另一个常见的毛病是，报错的位置比真正 的错误位置滞后一行。例如，编译器在编译下一行时才会发现上一行缺少分 号。因此，如果编译器报错某行缺少分号，请检查上一行。\n2.7.2 语义错误 # 语义错误是指意思上的错误。例如，考虑这个句子：Scornful derivatives sing greenly（轻蔑的衍生物不熟练地唱歌）。句中的形容词、名 词、动词和副词都在正确的位置上，所以语法正确。但是，却让人不知所 云。在C语言中，如果遵循了C规则，但是结果不正确，那就是犯了语义错 误。程序示例中有这样的错误： n3 = n2 * n2; 此处，n3原意表示n的 3 次方，但是代码中的n3被设置成n的 4 次方（n2 = n * n）。 编译器无法检测语义错误，因为这类错误并未违反 C语言的规则。编译 器无法了解你的真正意图，所以你只能自己找出这些错误。例如，假设你修 正了程序的语法错误，程序应该如程序清单2.5所示： 程序清单 2.5 stillbad.c 程序 /* stillbad.c \u0026ndash; 修复了语法错误的程序 / #include \u0026lt;stdio.h\u0026gt; int main(void) { int n, n2, n3; / 该程序有一个语义错误 */ n = 5; n2 = n * n; n3 = n2 * n2;\nprintf(\u0026ldquo;n = %d, n squared = %d, n cubed = %d\\n\u0026rdquo;, n, n2, n3); return 0; } 该程序的输出如下： n = 5, n squared = 25, n cubed = 625 如果对简单的立方比较熟悉，就会注意到 625 不对。下一步是跟踪程序 的执行步骤，找出程序如何得出这个答案。对于本例，通过查看代码就会发 现其中的错误，但是，还应该学习更系统的方法。方法之一是，把自己想象 成计算机，跟着程序的步骤一步一步地执行。下面，我们来试试这种方法。 main()函数体一开始就声明了 3 个变量：n、n2、n3。你可以画出 3 个盒子 并把变量名写在盒子上来模拟这种情况（见图2.6）。接下来，程序把 5 赋给 变量n。你可以在标签为n的盒子里写上 5 。接着，程序把n和n相乘，并把乘 积赋给n2。因此，查看标签为n的盒子，其值是 5 ， 5 乘以 5 得 25 ，于是把 25 放 进标签为 n2 的盒子里。为了模拟下一条语句（n3 = n2 * n2），查看 n2 盒 子，发现其值是 25 。 25 乘以 25 得 625 ，把 625 放进标签为n3的盒子。原来如 此！程序中计算的是n2的平方，不是用n2乘以n得到n的 3 次方。 对于上面的程序示例，检查程序的过程可能过于繁琐。但是，用这种方 法一步一步查看程序的执行情况，通常是发现程序问题所在的良方。\n图2.6 跟踪程序的执行步骤 2.7.3 程序状态 # 通过逐步跟踪程序的执行步骤，并记录每个变量，便可监视程序的状 # 态。程序状态（program state）是在程序的执行过程中，某给定点上所有变 量值的集合。它是计算机当前状态的一个快照。 我们刚刚讨论了一种跟踪程序状态的方法：自己模拟计算机逐步执行程 序。但是，如果程序中有 10000 次循环，这种方法恐怕行不通。不过，你可 以跟踪一小部分循环，看看程序是否按照预期的方式执行。另外，还要考虑 一种情况：你很可能按照自己所想去执行程序，而不是根据实际写出来的代 码去执行。因此，要尽量忠实代码来模拟。 定位语义错误的另一种方法是：在程序中的关键点插入额外的 printf() 语句，以监视制定变量值的变化。通过查看值的变化可以了解程序的执行情 况。对程序的执行满意后，便可删除额外的 printf()语句，然后重新编译。 检测程序状态的第 3 种方法是使用调试器。调试器（debugger）是一种 程序，让你一步一步运行另一个程序，并检查该程序变量的值。调试器有不\n同的使用难度和复杂度。较高级的调试器会显示正在执行的源代码行号。这 # 在检查有多条执行路径的程序时很方便，因为很容易知道正在执行哪条路 # 径。如果你的编译器自带调试器，现在可以花点时间学会怎么使用它。例 # 如，试着调试一下程序清单2.4。 # 2.8 关键字和保留标识符 # 关键字是C语言的词汇。它们对C而言比较特殊，不能用它们作为标识 # 符（如，变量名）。许多关键字用于指定不同的类型，如 int。还有一些关 键字（如，if）用于控制程序中语句的执行顺序。在表 2.2 中所列的C语言关 键字中，粗体表示的是C90标准新增的关键字，斜体表示的C99标准新增的 关键字，粗斜体表示的是C11标准新增的关键字。 表2.2 ISO C关键字\n续表 如果使用关键字不当（如，用关键字作为变量名），编译器会将其视为 # 语法错误。还有一些保留标识符（reserved identifier），C语言已经指定了它 们的用途或保留它们的使用权，如果你使用这些标识符来表示其他意思会导 致一些问题。因此，尽管它们也是有效的名称，不会引起语法错误，也不能 随便使用。保留标识符包括那些以下划线字符开头的标识符和标准库函数 名，如printf()。\n2.9 关键概念 # 编程是一件富有挑战性的事情。程序员要具备抽象和逻辑的思维，并谨 # 慎地处理细节问题（编译器会强迫你注意细节问题）。平时和朋友交流时， # 可能用错几个单词，犯一两个语法错误，或者说几句不完整的句子，但是对 # 方能明白你想说什么。而编译器不允许这样，对它而言，几乎正确仍然是错 # 误。 # 编译器不会在下面讲到的概念性问题上帮助你。因此，本书在这一章中 # 介绍一些关键概念帮助读者弥补这部分的内容。 # 在本章中，读者的目标应该是理解什么是C程序。可以把程序看作是你 # 希望计算机如何完成任务的描述。编译器负责处理一些细节工作，例如把你 # 要计算机完成的任务转换成底层的机器语言（如果从量化方面来解释编译器 # 所做的工作，它可以把1KB的源文件创建成60KB的可执行文件；即使是一 # 个很简单的C程序也要用大量的机器语言来表示）。由于编译器不具有真正 # 的智能，所以你必须用编译器能理解的术语表达你的意图，这些术语就是C # 语言标准规定的形式规则（尽管有些约束，但总比直接用机器语言方便得 # 多）。 # 编译器希望接收到特定格式的指令，我们在本章已经介绍过。作为程序 # 员的任务是，在符合 C标准的编译器框架中，表达你希望程序应该如何完成 # 任务的想法。 # 2.10 本章小结 # C程序由一个或多个C函数组成。每个C程序必须包含一个main()函数， 这是C程序要调用的第 1 个函数。简单的函数由函数头和后面的一对花括号 组成，花括号中是由声明、语句组成的函数体。 在C语言中，大部分语句都以分号结尾。声明为变量创建变量名和标识 该变量中储存的数据类型。变量名是一种标识符。赋值表达式语句把值赋给 变量，或者更一般地说，把值赋给存储空间。函数表达式语句用于调用指定 的已命名函数。调用函数执行完毕后，程序会返回到函数调用后面的语句继 续执行。 printf()函数用于输出想要表达的内容和变量的值。 一门语言的语法是一套规则，用于管理语言中各有效语句组合在一起的 方式。语句的语义是语句要表达的意思。编译器可以检测出语法错误，但是 程序里的语义错误只有在编译完之后才能从程序的行为中表现出来。检查程 序是否有语义错误要跟踪程序的状态，即程序每执行一步后所有变量的值。 最后，关键字是C语言的词汇。\n2.11 复习题 # 复习题的参考答案在附录A中。 # 1.C语言的基本模块是什么？ # 2.什么是语法错误？写出一个英语例子和C语言例子。 # 3.什么是语义错误？写出一个英语例子和C语言例子。 # 4.Indiana Sloth编写了下面的程序，并征求你的意见。请帮助他评定。 include studio.h int main{void} /* 该程序打印一年有多少周 /* ( int s s := 56; print(There are s weeks in a year.); return 0; 5.假设下面的 4 个例子都是完整程序中的一部分，它们都输出什么结 果？ a. printf(\u0026ldquo;Baa Baa Black Sheep.\u0026rdquo;); printf(\u0026ldquo;Have you any wool?\\n\u0026rdquo;); b. printf(\u0026ldquo;Begone!\\nO creature of lard!\\n\u0026rdquo;); c.printf(\u0026ldquo;What?\\nNo/nfish?\\n\u0026rdquo;);\nd.int num; num = 2; printf(\u0026quot;%d + %d = %d\u0026rdquo;, num, num, num + num); 6.在main、int、function、char、=中，哪些是C语言的关键字？ 7.如何以下面的格式输出变量words和lines的值（这里， 3020 和 350 代表 两个变量的值）？ There were 3020 words and 350 lines. 8.考虑下面的程序： #include \u0026lt;stdio.h\u0026gt; int main(void) { int a, b; a = 5; b = 2; /* 第 7 行 / b = a; / 第 8 行 / a = b; / 第 9 行 */ printf(\u0026quot;%d %d\\n\u0026rdquo;, b, a); return 0; }\n请问，在执行完第 7 、第 8 、第 9 行后，程序的状态分别是什么？ # 9.考虑下面的程序： # #include \u0026lt;stdio.h\u0026gt; int main(void) { int x, y; x = 10; y = 5; /* 第 7 行 / y = x + y; /第 8 行/ x = xy; /第 9 行/ printf(\u0026quot;%d %d\\n\u0026rdquo;, x, y); return 0; } 请问，在执行完第 7 、第 8 、第 9 行后，程序的状态分别是什么？\n2.12 编程练习 # 纸上得来终觉浅，绝知此事要躬行。读者应该试着编写一两个简单的程 # 序，体会一下编写程序是否和阅读本章介绍的这样轻松。题目中会给出一些 # 建议，但是应该尽量自己思考这些问题。一些编程答案练习的答案可在出版 # 商网站获取。 # 1.编写一个程序，调用一次 printf()函数，把你的姓名打印在一行。再调 用一次 printf()函数，把你的姓名分别打印在两行。然后，再调用两次printf() 函数，把你的姓名打印在一行。输出应如下所示（当然要把示例的内容换成 你的姓名）：\n2.编写一个程序，打印你的姓名和地址。 # 3.编写一个程序把你的年龄转换成天数，并显示这两个值。这里不用考 # 虑闰年的问题。 # 4.编写一个程序，生成以下输出： # For he\u0026#39;s a jolly good fellow! For he\u0026#39;s a jolly good fellow! For he\u0026#39;s a jolly good fellow! Which nobody can deny! 除了 main()函数以外，该程序还要调用两个自定义函数：一个名为 jolly()，用于打印前 3 条消息，调用一次打印一条；另一个函数名为 deny()，打印最后一条消息。 5.编写一个程序，生成以下输出： Brazil, Russia, India, China India, China, Brazil, Russia 除了main()以外，该程序还要调用两个自定义函数：一个名为br()，调 用一次打印一次“Brazil, Russia”；另一个名为ic()，调用一次打印一次“India, China”。其他内容在main()函数中完成。 6.编写一个程序，创建一个整型变量toes，并将toes设置为 10 。程序中还 要计算toes的两倍和toes的平方。该程序应打印 3 个值，并分别描述以示区 分。 7.许多研究表明，微笑益处多多。编写一个程序，生成以下格式的输 出： Smile!Smile!Smile! Smile!Smile! Smile! 该程序要定义一个函数，该函数被调用一次打印一次“Smile!”，根据程 序的需要使用该函数。 8.在C语言中，函数可以调用另一个函数。编写一个程序，调用一个名 为one_three()的函数。该函数在一行打印单词“one”，再调用第 2 个函数 two()，然后在另一行打印单词“three”。two()函数在一行显示单词“two”。 main()函数在调用 one_three()函数前要打印短语“starting now:”，并在调用完\n毕后显示短语“done!”。因此，该程序的输出应如下所示： starting now: one two three done!\n[1].——原书图中叙述有误。根据译者注 C11标准，C语言有 6 种语句，已在图中更正。\n[2].语言并没有所谓的C语言是通过赋值运算符而不是赋值语句完成赋值操作。根据“赋值语句”，本书及一些其他书籍中提到的“赋值语句C标准，”C实 际上是表达式语句（为“赋值表达式语句”，以提醒初学者注意。C语言的 6 种基本语句之一）。本书把——译者注 “赋值语句”均译\n[3].在C语言中，return语句是一种跳转语句。——译者注 [4].历年的市面上许多书籍（包括本书）都把这种语句叫作C标准中从来没有函数调用语句！值得一提的是，函数调用本身是一“函数调用语句”，但是 个表达式，圆括号是运算符，圆括号左边的函数名是运算对象。在中，这样的表达式是一种后缀表达式。在表达式末尾加上分号，就成了表达C11标准 式语句。请初学者注意，这样的错误之处已在翻译过程中更正。“——函数调用语句译者注 ”实质是表达式语句。本书的\n[5].图上测量水深。音寻，也称为寻。航海用的深度单位，——译者注 1 英寻=6英尺=1.8米，通常用在海\n[6].注 要理解该句子存在语法错误，需要具备基本的英文语法知识。——译者\n第 3 章 数据和 C # 本章介绍以下内容： # 关键字：int 、short、long、unsigned、char、float、double、_Bool、 _Complex、_Imaginary 运算符：sizeof() 函数：scanf() 整数类型和浮点数类型的区别 如何书写整型和浮点型常数，如何声明这些类型的变量 如何使用printf()和scanf()函数读写不同类型的值 程序离不开数据。把数字、字母和文字输入计算机，就是希望它利用这 些数据完成某些任务。例如，需要计算一份利息或显示一份葡萄酒商的排序 列表。本章除了介绍如何读取数据外，还将教会读者如何操控数据。 C 语言提供两大系列的多种数据类型。本章详细介绍两大数据类型：整 数类型和浮点数类型，讲解这些数据类型是什么、如何声明它们、如何以及 何时使用它们。除此之外，还将介绍常量和变量的区别。读者很快就能看到 第 1 个交互式程序。\n3.1 示例程序 # 本章仍从一个简单的程序开始。如果发现有不熟悉的内容，别担心，我 # 们稍后会详细解释。该程序的意图比较明了，请试着编译并运行程序清单 # 3.1中的源代码。为了节省时间，在输入源代码时可省略注释。 # 程序清单 3.1 platinum.c 程序 /* platinum.c -- your weight in platinum */ #include \u0026lt;stdio.h\u0026gt; int main(void) { float weight; /* 你的体重　*/ float value; /* 相等重量的白金价值　*/ printf(\u0026#34;Are you worth your weight in platinum?\\n\u0026#34;); printf(\u0026#34;Let\u0026#39;s check it out.\\n\u0026#34;); printf(\u0026#34;Please enter your weight in pounds: \u0026#34;); /* 获取用户的输入　*/ scanf(\u0026#34;%f\u0026#34;, \u0026amp;weight); /* 假设白金的价格是每盎司$1700 */ /* 14.5833用于把英镑常衡盎司转换为金衡盎司[1]*/ value = 1700.0 * weight * 14.5833; printf(\u0026ldquo;Your weight in platinum is worth $%.2f.\\n\u0026rdquo;, value); printf(\u0026ldquo;You are easily worth that! If platinum prices drop,\\n\u0026rdquo;); printf(\u0026ldquo;eat more to maintain your value.\\n\u0026rdquo;); return 0; } 提示 错误与警告 如果输入程序时打错（如，漏了一个分号），编译器会报告语法错误消 息。然而，即使输入正确无误，编译器也可能给出一些警告，如“警告：从 double类型转换成float类型可能会丢失数据”。错误消息表明程序中有错，不 能进行编译。而警告则表明，尽管编写的代码有效，但可能不是程序员想要 的。警告并不终止编译。特殊的警告与C如何处理1700.0这样的值有关。本 例不必理会这个问题，本章稍后会进一步说明。 输入该程序时，可以把1700.0改成贵金属白金当前的市价，但是不要改 动14.5833，该数是 1 英镑的金衡盎司数（金衡盎司用于衡量贵金属，而英镑 常衡盎司用于衡量人的体重）。 注意，“enter your weight”的意思是输入你的体重，然后按下Enter或 Return键（不要键入体重后就一直等着）。按下Enter键是告知计算机，你已 完成输入数据。该程序需要你输入一个数字（如， 155 ），而不是单词 （如，too much）。如果输入字母而不是数字，会导致程序出问题。这个问 题要用if语句来解决（详见第 7 章），因此请先输入数字。下面是程序的输 出示例： Are you worth your weight in platinum? Let\u0026rsquo;s check it out. Please enter your weight in pounds: 156\nYour weight in platinum is worth $3867491.25. You are easily worth that! If platinum prices drop, eat more to maintain your value. 程序调整 即使用第 2 章介绍的方法，在程序中添加下面一行代码： getchar(); 程序的输出是否依旧在屏幕上一闪而过？本例，需要调用两次getchar() 函数： getchar(); getchar(); getchar()函数读取下一个输入字符，因此程序会等待用户输入。在这种 情况下，键入 156 并按下Enter（或Return）键（发送一个换行符），然后 scanf()读取键入的数字，第 1 个getchar()读取换行符，第 2 个getchar()让程序暂 停，等待输入。 3.1.1 程序中的新元素 程序清单3.1中包含C语言的一些新元素。 注意，代码中使用了一种新的变量声明。前面的例子中只使用了整数类 型的变量（int），但是本例使用了浮点数类型（float）的变量，以便处理更 大范围的数据。float 类型可以储存带小数的数字。 程序中演示了常量的几种新写法。现在可以使用带小数点的数了。 为了打印新类型的变量，在printf()中使用%f来处理浮点值。%.2f中的.2 用于精确控制输出，指定输出的浮点数只显示小数点后面两位。\nscanf()函数用于读取键盘的输入。%f说明scanf()要读取用户从键盘输入 的浮点数，\u0026amp;weight告诉 scanf()把输入的值赋给名为 weight 的变量。scanf() 函数使用\u0026amp;符号表明找到 weight变量的地点。下一章将详细讨论\u0026amp;。就目前 而言，请按照这样写。 也许本程序最突出的新特点是它的交互性。计算机向用户询问信息，然 后用户输入数字。与非交互式程序相比，交互式程序用起来更有趣。更重要 的是，交互式使得程序更加灵活。例如，示例程序可以使用任何合理的体 重，而不只是 156 磅。不必重写程序，就可以根据不同体重进行计算。 scanf()和printf()函数用于实现这种交互。scanf()函数读取用户从键盘输入的 数据，并把数据传递给程序；printf()函数读取程序中的数据，并把数据显示 在屏幕上。把两个函数结合起来，就可以建立人机双向通信（见图 3.1）， 这让使用计算机更加饶有趣味。\n图3.1 程序中的scanf()和printf()函数 本章着重解释上述新特性中的前两项：各种数据类型的变量和常量。第 4 章将介绍后 3 项。\n3.2 变量与常量数据 # 在程序的指导下，计算机可以做许多事情，如数值计算、名字排序、执 # 行语言或视频命令、计算彗星轨道、准备邮件列表、拨电话号码、画画、做 # 决策或其他你能想到的事情。要完成这些任务，程序需要使用数据，即承载 # 信息的数字和字符。有些数据类型在程序使用之前已经预先设定好了，在整 # 个程序的运行过程中没有变化，这些称为常量（constant）。其他数据类型 在程序运行期间可能会改变或被赋值，这些称为变量（variable）。在示例 程序中，weight 是一个变量，14.5833 是一个常量。那么，1700.0 是常量还 是变量？在现实生活中，白金的价格不会是常量，但是在程序中，像1700.0 这样的价格被视为常量。\n3.3 数据：数据类型关键字 # 不仅变量和常量不同，不同的数据类型之间也有差异。一些数据类型表 # 示数字，一些数据类型表示字母（更普遍地说是字符）。C通过识别一些基 # 本的数据类型来区分和使用这些不同的数据类型。如果数据是常量，编译器 # 一般通过用户书写的形式来识别类型（如， 42 是整数，42.100是浮点数）。 # 但是，对变量而言，要在声明时指定其类型。稍后会详细介绍如何声明变 # 量。现在，我们先来了解一下 C语言的基本类型关键字。K\u0026amp;C给出了 7 个与 # 类型相关的关键字。C90标准添加了 2 个关键字，C99标准又添加了 3 个关键 # 字（见表3.1）。 # 表3.1 C语言的数据类型关键字 在C语言中，用int关键字来表示基本的整数类型。后 3 个关键字（long、 short和unsigned）和C90新增的signed用于提供基本整数类型的变式，例如 unsigned short int和long long int。char关键字用于指定字母和其他字符（如， #、$、%和*）。另外，char类型也可以表示较小的整数。float、double和 long double表示带小数点的数。_Bool类型表示布尔值（true或false）， _complex和_Imaginary分别表示复数和虚数。 通过这些关键字创建的类型，按计算机的储存方式可分为两大基本类 型：整数类型和浮点数类型。 位、字节和字 位、字节和字是描述计算机数据单元或存储单元的术语。这里主要指存\n储单元。 # 最小的存储单元是位（bit），可以储存 0 或 1 （或者说，位用于设 置“开”或“关”）。虽然 1 位储存的信息有限，但是计算机中位的数量十分庞 大。位是计算机内存的基本构建块。 字节（byte）是常用的计算机存储单位。对于几乎所有的机器， 1 字节 均为 8 位。这是字节的标准定义，至少在衡量存储单位时是这样（但是，C 语言对此有不同的定义，请参阅本章3.4.3节）。既然 1 位可以表示 0 或 1 ，那 么 8 位字节就有 256 （ 2 的 8 次方）种可能的 0 、 1 的组合。通过二进制编码（仅 用 0 和 1 便可表示数字），便可表示 0 ～ 255 的整数或一组字符（第 15 章将详细 讨论二进制编码，如果感兴趣可以现在浏览一下该章的内容）。 字（word）是设计计算机时给定的自然存储单位。对于 8 位的微型计算 机（如，最初的苹果机）， 1 个字长只有 8 位。从那以后，个人计算机字长 增至 16 位、 32 位，直到目前的 64 位。计算机的字长越大，其数据转移越快， 允许的内存访问也更多。\n3.3.1 整数和浮点数 # 整数类型？浮点数类型？如果觉得这些术语非常陌生，别担心，下面先 # 简述它们的含义。如果不熟悉位、字节和字的概念，请阅读上面方框中的内 # 容。刚开始学习时，不必了解所有的细节，就像学习开车之前不必详细了解 # 汽车内部引擎的原理一样。但是，了解一些计算机或汽车引擎内部的原理会 # 对你有所帮助。 # 对我们而言，整数和浮点数的区别是它们的书写方式不同。对计算机而 # 言，它们的区别是储存方式不同。下面详细介绍整数和浮点数。 # 3.3.2 整数 # 和数学的概念一样，在C语言中，整数是没有小数部分的数。例如， # 2 、−23和 2456 都是整数。而3.14、0.22和2.000都不是整数。计算机以二进制 # 数字储存整数，例如，整数 7 以二进制写是 111 。因此，要在 8 位字节中储存 # 该数字，需要把前 5 位都设置成 0 ，后 3 位设置成 1 （如图3.2所示）。 # 图3.2 使用二进制编码储存整数 7 3.3.3 浮点数 # 浮点数与数学中实数的概念差不多。2.75、3.16E7、7.00 和 2e-8 都是浮 点数。注意，在一个值后面加上一个小数点，该值就成为一个浮点值。所 以， 7 是整数，7.00是浮点数。显然，书写浮点数有多种形式。稍后将详细 介绍e记数法，这里先做简要介绍：3.16E7 表示3.16×10^7 （3.16 乘以 10 的 7 次 方）。其中， 107 =10000000， 7 被称为 10 的指数。 这里关键要理解浮点数和整数的储存方案不同。计算机把浮点数分成小 数部分和指数部分来表示，而且分开储存这两部分。因此，虽然7.00和 7 在 数值上相同，但是它们的储存方式不同。在十进制下，可以把7.0写成 0.7E1。这里，0.7是小数部分， 1 是指数部分。图3.3演示了一个储存浮点数 的例子。当然，计算机在内部使用二进制和 2 的幂进行储存，而不是 10 的 幂。第 15 章将详述相关内容。现在，我们着重讲解这两种类型的实际区别。 整数没有小数部分，浮点数有小数部分。 浮点数可以表示的范围比整数大。参见本章末的表3.3。 对于一些算术运算（如，两个很大的数相减），浮点数损失的精度更\n多。 # 图3.3 以浮点格式（十进制）储存π的值 因为在任何区间内（如，1.0 到 2.0 之间）都存在无穷多个实数，所以 计算机的浮点数不能表示区间内所有的值。浮点数通常只是实际值的近似 值。例如，7.0可能被储存为浮点值6.99999。稍后会讨论更多精度方面的内 容。 过去，浮点运算比整数运算慢。不过，现在许多CPU都包含浮点处理 器，缩小了速度上的差距。\n3.4 C 语言基本数据类型 # 本节将详细节介绍C语言的基本数据类型，包括如何声明变量、如何表 # 示字面值常量（如， 5 或2.78），以及典型的用法。一些老式的C语言编译器 # 无法支持这里提到的所有类型，请查阅你使用的编译器文档，了解可以使用 # 哪些类型。 # 3.4.1 int 类型 # C语言提供了许多整数类型，为什么一种类型不够用？因为 C语言让程 # 序员针对不同情况选择不同的类型。特别是，C语言中的整数类型可表示不 # 同的取值范围和正负值。一般情况使用int类型即可，但是为满足特定任务和 机器的要求，还可以选择其他类型。 int类型是有符号整型，即int类型的值必须是整数，可以是正整数、负整 数或零。其取值范围依计算机系统而异。一般而言，储存一个int要占用一个 机器字长。因此，早期的 16 位IBM PC兼容机使用 16 位来储存一个int值，其 取值范围（即int值的取值范围）是-32768～ 32767 。目前的个人计算机一般 是 32 位，因此用 32 位储存一个int值。现在，个人计算机产业正逐步向着 64 位 处理器发展，自然能储存更大的整数。ISO C规定int的取值范围最小 为-32768～ 32767 。一般而言，系统用一个特殊位的值表示有符号整数的正 负号。第 15 章将介绍常用的方法。\n1. 声明 int 变量 第 2 章中已经用int声明过基本整型变量。先写上int，然后写变量名，最 后加上一个分号。要声明多个变量，可以单独声明每个变量，也可在int后面 列出多个变量名，变量名之间用逗号分隔。下面都是有效的声明： int erns; int hogs, cows, goats;\n可以分别在 4 条声明中声明各变量，也可以在一条声明中声明 4 个变量。 # 两种方法的效果相同，都为 4 个int大小的变量赋予名称并分配内存空间。 以上声明创建了变量，但是并没有给它们提供值。变量如何获得值？前 面介绍过在程序中获取值的两种途径。第 1 种途径是赋值： cows = 112; 第 2 种途径是，通过函数（如，scanf()）获得值。接下来，我们着重介 绍第 3 种途径。\n2. 初始化变量 初始化（initialize）变量就是为变量赋一个初始值。在C语言中，初始 化可以直接在声明中完成。只需在变量名后面加上赋值运算符（=）和待赋 给变量的值即可。如下所示： int hogs = 21; int cows = 32, goats = 14; int dogs, cats = 94; /* 有效，但是这种格式很糟糕 */ 以上示例的最后一行，只初始化了cats，并未初始化dogs。这种写法很 容易让人误认为dogs也被初始化为 94 ，所以最好不要把初始化的变量和未初 始化的变量放在同一条声明中。 简而言之，声明为变量创建和标记存储空间，并为其指定初始值（如图 3.4所示）。\n图3.4 定义并初始化变量 3.int 类型常量 上面示例中出现的整数（ 21 、 32 、 14 和 94 ）都是整型常量或整型字面 量。C语言把不含小数点和指数的数作为整数。因此， 22 和-44都是整型常 量，但是22.0和2.2E1则不是。C语言把大多数整型常量视为int类型，但是非 常大的整数除外。详见后面“long常量和long long常量”小节对long int类型的 讨论。\n4. 打印 int 值 可以使用printf()函数打印int类型的值。第 2 章中介绍过，%d指明了在一 行中打印整数的位置。%d称为转换说明，它指定了printf()应使用什么格式 来显示一个值。格式化字符串中的每个%d都与待打印变量列表中相应的int 值匹配。这个值可以是int类型的变量、int类型的常量或其他任何值为int类型 的表达式。作为程序员，要确保转换说明的数量与待打印值的数量相同，编 译器不会捕获这类型的错误。程序清单3.2演示了一个简单的程序，程序中 初始化了一个变量，并打印该变量的值、一个常量值和一个简单表达式的 值。另外，程序还演示了如果粗心犯错会导致什么结果。 程序清单 3.2 print1.c 程序\n/* print1.c - 演示printf()的一些特性 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int ten = 10; int two = 2; printf(\u0026ldquo;Doing it right: \u0026ldquo;); printf(\u0026quot;%d minus %d is %d\\n\u0026rdquo;, ten, 2, ten - two); printf(\u0026ldquo;Doing it wrong: \u0026ldquo;); printf(\u0026quot;%d minus %d is %d\\n\u0026rdquo;, ten); // 遗漏 2 个参数 return 0; } 编译并运行该程序，输出如下： Doing it right: 10 minus 2 is 8 Doing it wrong: 10 minus 16 is 1650287143 在第一行输出中，第 1 个%d对应int类型变量ten；第 2 个%d对应int类型常 量 2 ；第 3 个%d对应int类型表达式ten - two的值。在第二行输出中，第 1 个%d 对应ten的值，但是由于没有给后两个%d提供任何值，所以打印出的值是内 存中的任意值（读者在运行该程序时显示的这两个数值会与输出示例中的数 值不同，因为内存中储存的数据不同，而且编译器管理内存的位置也不 同）。\n你可能会抱怨编译器为何不能捕获这种明显的错误，但实际上问题出在 # printf()不寻常的设计。大部分函数都需要指定数目的参数，编译器会检查参 数的数目是否正确。但是，printf()函数的参数数目不定，可以有 1 个、 2 个、 3 个或更多，编译器也爱莫能助。记住，使用printf()函数时，要确保转换说 明的数量与待打印值的数量相等。\n5. 八进制和十六进制 通常，C语言都假定整型常量是十进制数。然而，许多程序员很喜欢使 用八进制和十六进制数。因为 8 和 16 都是 2 的幂，而 10 却不是。显然，八进制 和十六进制记数系统在表达与计算机相关的值时很方便。例如，十进制数 65536 经常出现在 16 位机中，用十六进制表示正好是 10000 。另外，十六进制 数的每一位的数恰好由 4 位二进制数表示。例如，十六进制数 3 是 0011 ，十六 进制数 5 是 0101 。因此，十六进制数 35 的位组合（bit pattern）是 00110101 ， 十六进制数 53 的位组合是 01010011 。这种对应关系使得十六进制和二进制的 转换非常方便。但是，计算机如何知道 10000 是十进制、十六进制还是二进 制？在C语言中，用特定的前缀表示使用哪种进制。0x或0X前缀表示十六进 制值，所以十进制数 16 表示成十六进制是0x10或0X10。与此类似， 0 前缀表 示八进制。例如，十进制数 16 表示成八进制是 020 。第 15 章将更全面地介绍 进制相关的内容。 要清楚，使用不同的进制数是为了方便，不会影响数被储存的方式。也 就是说，无论把数字写成 16 、 020 或0x10，储存该数的方式都相同，因为计 算机内部都以二进制进行编码。 6. 显示八进制和十六进制 在C程序中，既可以使用和显示不同进制的数。不同的进制要使用不同 的转换说明。以十进制显示数字，使用%d；以八进制显示数字，使用%o； 以十六进制显示数字，使用%x。另外，要显示各进制数的前缀 0 、0x和0X， 必须分别使用%#o、%#x、%#X。程序清单3.3演示了一个小程序。回忆一 下，在某些集成开发环境（IDE）下编写的代码中插入getchar();语句，程序\n在执行完毕后不会立即关闭执行窗口。 # 程序清单 3.3 bases.c 程序 /* bases.c\u0026ndash;以十进制、八进制、十六进制打印十进制数100 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int x = 100; printf(\u0026ldquo;dec = %d; octal = %o; hex = %x\\n\u0026rdquo;, x, x, x); printf(\u0026ldquo;dec = %d; octal = %#o; hex = %#x\\n\u0026rdquo;, x, x, x); return 0; } 编译并运行该程序，输出如下： dec = 100; octal = 144; hex = 64 dec = 100; octal = 0144; hex = 0x64 该程序以 3 种不同记数系统显示同一个值。printf()函数做了相应的转 换。注意，如果要在八进制和十六进制值前显示 0 和0x前缀，要分别在转换 说明中加入#。\n3.4.2 其他整数类型 # 初学C语言时，int类型应该能满足大多数程序的整数类型需求。尽管如 此，还应了解一下整型的其他形式。当然，也可以略过本节跳至3.4.3节阅读\nchar类型的相关内容，以后有需要时再阅读本节。 C语言提供 3 个附属关键字修饰基本整数类型：short、long和unsigned。 应记住以下几点。 short int类型（或者简写为short）占用的存储空间可能比int类型少，常 用于较小数值的场合以节省空间。与int类似，short是有符号类型。 long int或long占用的存储空间可能比int多，适用于较大数值的场合。与 int类似，long是有符号类型。 long long int或long long（C99标准加入）占用的储存空间可能比long多， 适用于更大数值的场合。该类型至少占 64 位。与int类似，long long是有符号 类型。 unsigned int或unsigned只用于非负值的场合。这种类型与有符号类型表 示的范围不同。例如， 16 位unsigned int允许的取值范围是 0 ～ 65535 ，而不 是-32768～ 32767 。用于表示正负号的位现在用于表示另一个二进制位，所 以无符号整型可以表示更大的数。 在C90标准中，添加了unsigned long int或unsigned long和unsigned int或 unsigned short类型。C99标准又添加了unsigned long long int或unsigned long long。 在任何有符号类型前面添加关键字signed，可强调使用有符号类型的意 图。例如，short、short int、signed short、signed short int都表示同一种类型。\n1. 声明其他整数类型 其他整数类型的声明方式与int类型相同，下面列出了一些例子。不是所 有的C编译器都能识别最后 3 条声明，最后一个例子所有的类型是C99标准新 增的。 long int estine;\nlong johns; short int erns; short ribs; unsigned int s_count; unsigned players; unsigned long headcount; unsigned short yesvotes; long long ago; 2. 使用多种整数类型的原因 为什么说short类型“可能”比int类型占用的空间少，long类型“可能”比int 类型占用的空间多？因为C语言只规定了short占用的存储空间不能多于int， long占用的存储空间不能少于int。这样规定是为了适应不同的机器。例如， 过去的一台运行Windows 3的机器上，int类型和short类型都占 16 位，long类 型占 32 位。后来，Windows和苹果系统都使用 16 位储存short类型， 32 位储存 int类型和long类型（使用 32 位可以表示的整数数值超过 20 亿）。现在，计算 机普遍使用 64 位处理器，为了储存 64 位的整数，才引入了long long类型。 现在，个人计算机上最常见的设置是，long long占 64 位，long占 32 位， short占 16 位，int占 16 位或 32 位（依计算机的自然字长而定）。原则上，这 4 种类型代表 4 种不同的大小，但是在实际使用中，有些类型之间通常有重 叠。 C 标准对基本数据类型只规定了允许的最小大小。对于 16 位机，short 和 int 的最小取值范围是[−32767,32767]；对于 32 位机，long的最小取值范围 是[−2147483647,2147483647]。对于unsigned short和unsigned int，最小取值范 围是[0,65535]；对于unsigned long，最小取值范围是[0,4294967295]。long\nlong类型是为了支持 64 位的需求，最小取值范围是 [−9223372036854775807,9223372036854775807]；unsigned long long的最小取 值范围是[0,18446744073709551615]。如果要开支票，这个数是一千八百亿 亿（兆）六千七百四十四万亿零七百三十七亿零九百五十五万一千六百一十 五。但是，谁会去数？ int类型那么多，应该如何选择？首先，考虑unsigned类型。这种类型的 数常用于计数，因为计数不用负数。而且，unsigned类型可以表示更大的正 数。 如果一个数超出了int类型的取值范围，且在long类型的取值范围内时， 使用long类型。然而，对于那些long占用的空间比int大的系统，使用long类 型会减慢运算速度。因此，如非必要，请不要使用long类型。另外要注意一 点：如果在long类型和int类型占用空间相同的机器上编写代码，当确实需要 32 位的整数时，应使用long类型而不是int类型，以便把程序移植到 16 位机后 仍然可以正常工作。类似地，如果确实需要 64 位的整数，应使用long long类 型。 如果在int设置为 32 位的系统中要使用 16 位的值，应使用short类型以节省 存储空间。通常，只有当程序使用相对于系统可用内存较大的整型数组时， 才需要重点考虑节省空间的问题。使用short类型的另一个原因是，计算机中 某些组件使用的硬件寄存器是 16 位。 3.long 常量和 long long 常量 通常，程序代码中使用的数字（如， 2345 ）都被储存为int类型。如果使 用 1000000 这样的大数字，超出了int类型能表示的范围，编译器会将其视为 long int类型（假设这种类型可以表示该数字）。如果数字超出long可表示的 最大值，编译器则将其视为unsigned long类型。如果还不够大，编译器则将 其视为long long或unsigned long long类型（前提是编译器能识别这些类型）。 八进制和十六进制常量被视为int类型。如果值太大，编译器会尝试使用 unsigned int。如果还不够大，编译器会依次使用long、unsigned long、long\nlong和unsigned long long类型。 有些情况下，需要编译器以long类型储存一个小数字。例如，编程时要 显式使用IBM PC上的内存地址时。另外，一些C标准函数也要求使用long类 型的值。要把一个较小的常量作为long类型对待，可以在值的末尾加上l（小 写的L）或L后缀。使用L后缀更好，因为l看上去和数字 1 很像。因此，在int 为 16 位、long为 32 位的系统中，会把 7 作为 16 位储存，把7L作为 32 位储存。l 或L后缀也可用于八进制和十六进制整数，如020L和0x10L。 类似地，在支持long long类型的系统中，也可以使用ll或LL后缀来表示 long long类型的值，如3LL。另外，u或U后缀表示unsigned long long，如 5ull、10LLU、6LLU或9Ull。 整数溢出 如果整数超出了相应类型的取值范围会怎样？下面分别将有符号类型和 无符号类型的整数设置为比最大值略大，看看会发生什么（printf()函数使 用%u说明显示unsigned int类型的值）。 /* toobig.c\u0026ndash; 超出系统允许的最大int值*/ #include \u0026lt;stdio.h\u0026gt; int main(void) { int i = 2147483647; unsigned int j = 4294967295; printf(\u0026quot;%d %d %d\\n\u0026rdquo;, i, i+1, i+2); printf(\u0026quot;%u %u %u\\n\u0026rdquo;, j, j+1, j+2);\nreturn 0; } 在我们的系统下输出的结果是： 2147483647　-2147483648 -2147483647 4294967295　0　1 可以把无符号整数j看作是汽车的里程表。当达到它能表示的最大值 时，会重新从起始点开始。整数 i 也是类似的情况。它们主要的区别是，在 超过最大值时，unsigned int 类型的变量 j 从 0 开始；而int类型的变量i则从 −2147483648开始。注意，当i超出（溢出）其相应类型所能表示的最大值 时，系统并未通知用户。因此，在编程时必须自己注意这类问题。 溢出行为是未定义的行为，C 标准并未定义有符号类型的溢出规则。以 上描述的溢出行为比较有代表性，但是也可能会出现其他情况。\n4. 打印 short 、 long 、 long long 和 unsigned 类型 打印unsigned int类型的值，使用%u转换说明；打印long类型的值，使 用%ld转换说明。如果系统中int和long的大小相同，使用%d就行。但是，这 样的程序被移植到其他系统（int和long类型的大小不同）中会无法正常工 作。在x和o前面可以使用l前缀，%lx表示以十六进制格式打印long类型整 数，%lo表示以八进制格式打印long类型整数。注意，虽然C允许使用大写或 小写的常量后缀，但是在转换说明中只能用小写。 C语言有多种printf()格式。对于short类型，可以使用h前缀。%hd表示以 十进制显示short类型的整数，%ho表示以八进制显示short类型的整数。h和l 前缀都可以和u一起使用，用于表示无符号类型。例如，%lu表示打印 unsigned long类型的值。程序清单3.4演示了一些例子。对于支持long long类 型的系统，%lld和%llu分别表示有符号和无符号类型。第 4 章将详细介绍转 换说明。\n程序清单 3.4 print2.c 程序 /* print2.c\u0026ndash;更多printf()的特性 / #include \u0026lt;stdio.h\u0026gt; int main(void) { unsigned int un = 3000000000; / int为 32 位和short为 16 位的系统 */ short end = 200; long big = 65537; long long verybig = 12345678908642; printf(\u0026ldquo;un = %u and not %d\\n\u0026rdquo;, un, un); printf(\u0026ldquo;end = %hd and %d\\n\u0026rdquo;, end, end); printf(\u0026ldquo;big = %ld and not %hd\\n\u0026rdquo;, big, big); printf(\u0026ldquo;verybig= %lld and not %ld\\n\u0026rdquo;, verybig, verybig); return 0; } 在特定的系统中输出如下（输出的结果可能不同）： un = 3000000000 and not -1294967296 end = 200 and 200 big = 65537 and not 1\nverybig= 12345678908642 and not 1942899938 该例表明，使用错误的转换说明会得到意想不到的结果。第 1 行输出， 对于无符号变量 un，使用%d会生成负值！其原因是，无符号值 3000000000 和有符号值−129496296 在系统内存中的内部表示完全相同（详见第 15 章）。因此，如果告诉printf()该数是无符号数，它打印一个值；如果告诉它 该数是有符号数，它将打印另一个值。在待打印的值大于有符号值的最大值 时，会发生这种情况。对于较小的正数（如 96 ），有符号和无符号类型的存 储、显示都相同。 第 2 行输出，对于short类型的变量end，在printf()中无论指定以short类型 （%hd）还是int类型（%d）打印，打印出来的值都相同。这是因为在给函 数传递参数时，C编译器把short类型的值自动转换成int类型的值。你可能会 提出疑问：为什么要进行转换？h修饰符有什么用？第 1 个问题的答案是， int类型被认为是计算机处理整数类型时最高效的类型。因此，在short和int类 型的大小不同的计算机中，用int类型的参数传递速度更快。第 2 个问题的答 案是，使用h修饰符可以显示较大整数被截断成 short 类型值的情况。第 3 行 输出就演示了这种情况。把 65537 以二进制格式写成一个 32 位数是 00000000000000010000000000000001 。使用%hd，printf()只会查看后 16 位，所以显示的值是 1 。与此类似，输出的最后一行先显示了verybig的完整 值，然后由于使用了%ld，printf()只显示了储存在后 32 位的值。 本章前面介绍过，程序员必须确保转换说明的数量和待打印值的数量相 同。以上内容也提醒读者，程序员还必须根据待打印值的类型使用正确的转 换说明。 提示 匹配 printf() 说明符的类型 在使用 printf()函数时，切记检查每个待打印值都有对应的转换说明， 还要检查转换说明的类型是否与待打印值的类型相匹配。\n3.4.3 使用字符： char 类型 # char类型用于储存字符（如，字母或标点符号），但是从技术层面看， char是整数类型。因为char类型实际上储存的是整数而不是字符。计算机使 用数字编码来处理字符，即用特定的整数表示特定的字符。美国最常用的编 码是ASCII编码，本书也使用此编码。例如，在ASCII码中，整数 65 代表大写 字母A。因此，储存字母A实际上储存的是整数 65 （许多IBM的大型主机使 用另一种编码——EBCDIC，其原理相同。另外，其他国家的计算机系统可 能使用完全不同的编码）。 标准ASCII码的范围是 0 ～ 127 ，只需 7 位二进制数即可表示。通常，char 类型被定义为 8 位的存储单元，因此容纳标准ASCII码绰绰有余。许多其他系 统（如IMB PC和苹果Macs）还提供扩展ASCII码，也在 8 位的表示范围之 内。一般而言，C语言会保证char类型足够大，以储存系统（实现C语言的系 统）的基本字符集。 许多字符集都超过了 127 ，甚至多于 255 。例如，日本汉字（kanji）字符 集。商用的统一码（Unicode）创建了一个能表示世界范围内多种字符集的 系统，目前包含的字符已超过 110000 个。国际标准化组织（ISO）和国际电 工技术委员会（IEC）为字符集开发了ISO/IEC 10646标准。统一码标准也与 ISO/IEC 10646标准兼容。 C语言把 1 字节定义为char类型占用的位（bit）数，因此无论是 16 位还是 32 位系统，都可以使用char类型。\n1. 声明 char 类型变量 char类型变量的声明方式与其他类型变量的声明方式相同。下面是一些 例子： char response; char itable, latan; 以上声明创建了 3 个char类型的变量：response、itable和latan。\n2. 字符常量和初始化 # 如果要把一个字符常量初始化为字母 A，不必背下 ASCII 码，用计算机 # 语言很容易做到。通过以下初始化把字母A赋给grade即可： char grade = \u0026lsquo;A\u0026rsquo;; 在C语言中，用单引号括起来的单个字符被称为字符常量（character constant）。编译器一发现\u0026rsquo;A\u0026rsquo;，就会将其转换成相应的代码值。单引号必不 可少。下面还有一些其他的例子： char broiled; /* 声明一个char类型的变量 / broiled = \u0026lsquo;T\u0026rsquo;; / 为其赋值，正确 / broiled = T; / 错误！此时T是一个变量 / broiled = \u0026ldquo;T\u0026rdquo;; / 错误！此时\u0026quot;T\u0026quot;是一个字符串 / 如上所示，如果省略单引号，编译器认为T是一个变量名；如果把T用 双引号括起来，编译器则认为\u0026quot;T\u0026quot;是一个字符串。字符串的内容将在第 4 章中 介绍。 实际上，字符是以数值形式储存的，所以也可使用数字代码值来赋值： char grade = 65; / 对于ASCII，这样做没问题，但这是一种不好的编程 风格 */ 在本例中，虽然 65 是int类型，但是它在char类型能表示的范围内，所以 将其赋值给grade没问题。由于 65 是字母A对应的ASCII码，因此本例是把A 赋给grade。注意，能这样做的前提是系统使用ASCII码。其实，用\u0026rsquo;A\u0026rsquo;代替 65 才是较为妥当的做法，这样在任何系统中都不会出问题。因此，最好使用字 符常量，而不是数字代码值。 奇怪的是，C语言将字符常量视为int类型而非char类型。例如，在int为\n32 位、char为 8 位的ASCII系统中，有下面的代码： char grade = \u0026lsquo;B\u0026rsquo;; 本来\u0026rsquo;B\u0026rsquo;对应的数值 66 储存在 32 位的存储单元中，现在却可以储存在 8 位 的存储单元中（grade）。利用字符常量的这种特性，可以定义一个字符常 量\u0026rsquo;FATE\u0026rsquo;，即把 4 个独立的 8 位ASCII码储存在一个 32 位存储单元中。如果把 这样的字符常量赋给char类型变量grade，只有最后 8 位有效。因此，grade的 值是\u0026rsquo;E\u0026rsquo;。\n3. 非打印字符 单引号只适用于字符、数字和标点符号，浏览ASCII表会发现，有些 ASCII字符打印不出来。例如，一些代表行为的字符（如，退格、换行、终 端响铃或蜂鸣）。C语言提供了 3 种方法表示这些字符。 第 1 种方法前面介绍过——使用ASCII码。例如，蜂鸣字符的ASCII值是 7 ，因此可以这样写： char beep = 7; 第 2 种方法是，使用特殊的符号序列表示一些特殊的字符。这些符号序 列叫作转义序列（escape sequence）。表3.2列出了转义序列及其含义。 把转义序列赋给字符变量时，必须用单引号把转义序列括起来。例如， 假设有下面一行代码： char nerf = \u0026lsquo;\\n\u0026rsquo;; 稍后打印变量nerf的效果是，在打印机或屏幕上另起一行。 表3.2 转义序列\n现在，我们来仔细分析一下转义序列。使用C90新增的警报字符（\\a） 是否能产生听到或看到的警报，取决于计算机的硬件，蜂鸣是最常见的警报 （在一些系统中，警报字符不起作用）。C标准规定警报字符不得改变活跃 位置。标准中的活跃位置（active position）指的是显示设备（屏幕、电传打 字机、打印机等）中下一个字符将出现的位置。简而言之，平时常说的屏幕 光标位置就是活跃位置。在程序中把警报字符输出在屏幕上的效果是，发出 一声蜂鸣，但不会移动屏幕光标。 接下来的转义字符\\b、\\f、\\n、\\r、\\t和\\v是常用的输出设备控制字符。了 解它们最好的方式是查看它们对活跃位置的影响。换页符（\\f）把活跃位置 移至下一页的开始处；换行符（\\n）把活跃位置移至下一行的开始处；回车 符（\\r）把活跃位置移动到当前行的开始处；水平制表符（\\t）将活跃位置 移至下一个水平制表点（通常是第 1 个、第 9 个、第 17 个、第 25 个等字符位 置）；垂直制表符（\\v）把活跃位置移至下一个垂直制表点。 这些转义序列字符不一定在所有的显示设备上都起作用。例如，换页符 和垂直制表符在PC屏幕上会生成奇怪的符号，光标并不会移动。只有将其 输出到打印机上时才会产生前面描述的效果。 接下来的 3 个转义序列（\\、'、\u0026quot;）用于打印\\、\u0026rsquo;、\u0026ldquo;字符（由于这些字符\n用于定义字符常量，是printf()函数的一部分，若直接使用它们会造成混 乱）。如果打印下面一行内容： Gramps sez, \u0026ldquo;a \\ is a backslash.\u0026rdquo; 应这样编写代码： printf(\u0026ldquo;Gramps sez, \u0026quot;a \\ is a backslash.\u0026quot;\\n\u0026rdquo;); 表3.2中的最后两个转义序列（\\0oo和\\xhh）是ASCII码的特殊表示。如 果要用八进制ASCII码表示一个字符，可以在编码值前面加一个反斜杠（\\） 并用单引号括起来。例如，如果编译器不识别警报字符（\\a），可以使用 ASCII码来代替： beep = \u0026lsquo;\\007\u0026rsquo;; 可以省略前面的 0 ，\u0026rsquo;\\07\u0026rsquo;甚至\u0026rsquo;\\7\u0026rsquo;都可以。即使没有前缀 0 ，编译器在处 理这种写法时，仍会解释为八进制。 从C90开始，不仅可以用十进制、八进制形式表示字符常量，C语言还 提供了第 3 种选择——用十六进制形式表示字符常量，即反斜杠后面跟一个x 或X，再加上 1 ～ 3 位十六进制数字。例如，Ctrl+P字符的ASCII十六进制码是 10 （相当于十进制的 16 ），可表示为\u0026rsquo;\\x10\u0026rsquo;或\u0026rsquo;\\x010\u0026rsquo;。图3.5列出了一些整数类 型的不同进制形式。\n图3.5 int系列类型的常量写法示例 使用ASCII码时，注意数字和数字字符的区别。例如，字符 4 对应的 ASCII码是 52 。\u0026lsquo;4\u0026rsquo;表示字符 4 ，而不是数值 4 。 关于转义序列，读者可能有下面 3 个问题。 上面最后一个例子（printf(\u0026ldquo;Gramps sez, \u0026quot;a \\ is a backslash\u0026quot;\u0026quot;n\u0026rdquo;），为何 没有用单引号把转义序列括起来？无论是普通字符还是转义序列，只要是双 引号括起来的字符集合，就无需用单引号括起来。双引号中的字符集合叫作 字符串（详见第 4 章）。注意，该例中的其他字符（G、r、a、m、p、s等） 都没有用单引号括起来。与此类似，printf(\u0026ldquo;Hello!\\007\\n\u0026rdquo;);将打印Hello!并发 出一声蜂鸣，而 printf(\u0026ldquo;Hello!7\\n\u0026rdquo;);则打印 Hello!7。不是转义序列中的数字 将作为普通字符被打印出来。 何时使用ASCII码？何时使用转义序列？如果要在转义序列（假设使 用\u0026rsquo;\\f\u0026rsquo;）和ASCII码（\u0026rsquo;\\014\u0026rsquo;）之间选择，请选择前者（即\u0026rsquo;\\f\u0026rsquo;）。这样的写法不 仅更好记，而且可移植性更高。\u0026rsquo;\\f\u0026rsquo;在不使用ASCII码的系统中，仍然有效。\n如果要使用ASCII码，为何要写成\u0026rsquo;\\032\u0026rsquo;而不是 032 ？首先，\u0026rsquo;\\032\u0026rsquo;能更清 # 晰地表达程序员使用字符编码的意图。其次，类似\\032这样的转义序列可以 # 嵌入C的字符串中，如printf(\u0026ldquo;Hello!\\007\\n\u0026rdquo;);中就嵌入了\\007。\n4. 打印字符 printf()函数用%c指明待打印的字符。前面介绍过，一个字符变量实际 上被储存为 1 字节的整数值。因此，如果用%d转换说明打印 char类型变量的 值，打印的是一个整数。而%c转换说明告诉printf()打印该整数值对应的字 符。程序清单3.5演示了打印char类型变量的两种方式。 程序清单 3.5 charcode.c 程序 /* charcode.c-显示字符的代码编号 / #include \u0026lt;stdio.h\u0026gt; int main(void) { char ch; printf(\u0026ldquo;Please enter a character.\\n\u0026rdquo;); scanf(\u0026quot;%c\u0026rdquo;, \u0026amp;ch); / 用户输入字符 */ printf(\u0026ldquo;The code for %c is %d.\\n\u0026rdquo;, ch, ch); return 0; } 运行该程序后，输出示例如下： Please enter a character.\nC # The code for C is 67. 运行该程序时，在输入字母后不要忘记按下Enter或Return键。随后， scanf()函数会读取用户输入的字符，\u0026amp;符号表示把输入的字符赋给变量ch。 接着，printf()函数打印ch的值两次，第 1 次打印一个字符（对应代码中 的%c），第 2 次打印一个十进制整数值（对应代码中的%d）。注意，printf() 函数中的转换说明决定了数据的显示方式，而不是数据的储存方式（见图 3.6）。\n图3.6 数据显示和数据存储 5. 有符号还是无符号 有些C编译器把char实现为有符号类型，这意味着char可表示的范围 是-128～ 127 。而有些C编译器把char实现为无符号类型，那么char可表示的 范围是 0 ～ 255 。请查阅相应的编译器手册，确定正在使用的编译器如何实现 char类型。或者，可以查阅limits.h头文件。下一章将详细介绍头文件的内 容。 根据C90标准，C语言允许在关键字char前面使用signed或unsigned。这\n样，无论编译器默认char是什么类型，signed char表示有符号类型，而 unsigned char表示无符号类型。这在用char类型处理小整数时很有用。如果 只用char处理字符，那么char前面无需使用任何修饰符。\n3.4.4 _Bool 类型 # C99标准添加了_Bool类型，用于表示布尔值，即逻辑值true和false。因 为C语言用值 1 表示true，值 0 表示false，所以_Bool类型实际上也是一种整数 类型。但原则上它仅占用 1 位存储空间，因为对 0 和 1 而言， 1 位的存储空间足 够了。 程序通过布尔值可选择执行哪部分代码。我们将在第 6 章和第 7 章中详述 相关内容。\n3.4.5 可移植类型： stdint.h 和 inttypes.h # C 语言提供了许多有用的整数类型。但是，某些类型名在不同系统中的 # 功能不一样。C99 新增了两个头文件stdint.h和inttypes.h，以确保C语言的类 型在各系统中的功能相同。 C语言为现有类型创建了更多类型名。这些新的类型名定义在stdint.h头 文件中。例如，int32_t表示 32 位的有符号整数类型。在使用 32 位int的系统 中，头文件会把int32_t作为int的别名。不同的系统也可以定义相同的类型 名。例如，int为 16 位、long为 32 位的系统会把int32_t作为long的别名。然 后，使用int32_t类型编写程序，并包含stdint.h头文件时，编译器会把int或 long替换成与当前系统匹配的类型。 上面讨论的类型别名是精确宽度整数类型（exact-width integer type）的 示例。int32_t表示整数类型的宽度正好是 32 位。但是，计算机的底层系统可 能不支持。因此，精确宽度整数类型是可选项。 如果系统不支持精确宽度整数类型怎么办？C99和C11提供了第 2 类别名 集合。一些类型名保证所表示的类型一定是至少有指定宽度的最小整数类\n型。这组类型集合被称为最小宽度类型（minimum width type）。例如， int_least8_t是可容纳 8 位有符号整数值的类型中宽度最小的类型的一个别 名。如果某系统的最小整数类型是 16 位，可能不会定义int8_t类型。尽管如 此，该系统仍可使用int_least8_t类型，但可能把该类型实现为 16 位的整数类 型。 当然，一些程序员更关心速度而非空间。为此，C99和C11定义了一组 可使计算达到最快的类型集合。这组类型集合被称为最快最小宽度类型 （fastst minimum width type）。例如，int_fast8_t被定义为系统中对 8 位有符号 值而言运算最快的整数类型的别名。 另外，有些程序员需要系统的最大整数类型。为此，C99定义了最大的 有符号整数类型intmax_t，可储存任何有效的有符号整数值。类似地， unitmax_t表示最大的无符号整数类型。顺带一提，这些类型有可能比long long和unsigned long类型更大，因为C编译器除了实现标准规定的类型以外， 还可利用C语言实现其他类型。例如，一些编译器在标准引入 long long 类型 之前，已提前实现了该类型。 C99 和 C11 不仅提供可移植的类型名，还提供相应的输入和输出。例 如，printf()打印特定类型时要求与相应的转换说明匹配。如果要打印int32_t 类型的值，有些定义使用%d，而有些定义使用%ld，怎么办？C 标准针对这 一情况，提供了一些字符串宏（第 4 章中详细介绍）来显示可移植类型。例 如， inttypes.h头文件中定义了PRId32字符串宏，代表打印 32 位有符号值的合 适转换说明（如d或l）。程序清单3.6演示了一种可移植类型和相应转换说 明的用法。 程序清单 3.6 altnames.c 程序 /* altnames.c \u0026ndash; 可移植整数类型名 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;inttypes.h\u0026gt; // 支持可移植类型\nint main(void) { int32_t me32; // me32是一个 32 位有符号整型变量 me32 = 45933945; printf(\u0026ldquo;First, assume int32_t is int: \u0026ldquo;); printf(\u0026ldquo;me32 = %d\\n\u0026rdquo;, me32); printf(\u0026ldquo;Next, let\u0026rsquo;s not make any assumptions.\\n\u0026rdquo;); printf(\u0026ldquo;Instead, use a \u0026quot;macro\u0026quot; from inttypes.h: \u0026ldquo;); printf(\u0026ldquo;me32 = %\u0026rdquo; PRId32 \u0026ldquo;\\n\u0026rdquo;, me32); return 0; } 该程序最后一个printf()中，参数PRId32被定义在inttypes.h中的\u0026quot;d\u0026quot;替换， 因而这条语句等价于： printf(\u0026ldquo;me16 = %\u0026rdquo; \u0026ldquo;d\u0026rdquo; \u0026ldquo;\\n\u0026rdquo;, me16); 在C语言中，可以把多个连续的字符串组合成一个字符串，所以这条语 句又等价于： printf(\u0026ldquo;me16 = %d\\n\u0026rdquo;, me16); 下面是该程序的输出，注意，程序中使用了\u0026quot;转义序列来显示双引号： First, assume int32_t is int: me32 = 45933945 Next, let\u0026rsquo;s not make any assumptions.\nInstead, use a \u0026ldquo;macro\u0026rdquo; from inttypes.h: me32 = 45933945 篇幅有限，无法介绍扩展的所有整数类型。本节主要是为了让读者知 道，在需要时可进行这种级别的类型控制。附录B中的参考资料VI“扩展的 整数类型”介绍了完整的inttypes.h和stdint.h头文件。 注意 对 C99/C11 的支持 C语言发展至今，虽然ISO已发布了C11标准，但是编译器供应商对C99 的实现程度却各不相同。在本书第 6 版的编写过程中，一些编译器仍未实现 inttypes.h头文件及其相关功能。\n3.4.6 float 、 double 和 long double # 各种整数类型对大多数软件开发项目而言够用了。然而，面向金融和数 # 学的程序经常使用浮点数。C语言中的浮点类型有float、double和long double 类型。它们与FORTRAN和Pascal中的real类型一致。前面提到过，浮点类型 能表示包括小数在内更大范围的数。浮点数的表示类似于科学记数法（即用 小数乘以 10 的幂来表示数字）。该记数系统常用于表示非常大或非常小的 数。表3.3列出了一些示例。 表3.3 记数法示例\n第 1 列是一般记数法；第 2 列是科学记数法；第 3 列是指数记数法（或称 # 为e记数法），这是科学记数法在计算机中的写法，e后面的数字代表 10 的指 数。图3.7演示了更多的浮点数写法。 C标准规定，float类型必须至少能表示 6 位有效数字，且取值范围至少是 10 -37～ 10 +37。前一项规定指float类型必须至少精确表示小数点后的 6 位有效\n数字，如33.333333。后一项规定用于方便地表示诸如太阳质量（2.0e30千 克）、一个质子的电荷量（1.6e-19库仑）或国家债务之类的数字。通常， 系统储存一个浮点数要占用 32 位。其中 8 位用于表示指数的值和符号，剩下 24 位用于表示非指数部分（也叫作尾数或有效数）及其符号。\n图3.7 更多浮点数写法示例 C语言提供的另一种浮点类型是double（意为双精度）。double类型和 float类型的最小取值范围相同，但至少必须能表示 10 位有效数字。一般情况 下，double占用 64 位而不是 32 位。一些系统将多出的 32 位全部用来表示非 指数部分，这不仅增加了有效数字的位数（即提高了精度），而且还减少了 舍入误差。另一些系统把其中的一些位分配给指数部分，以容纳更大的指 数，从而增加了可表示数的范围。无论哪种方法，double类型的值至少有 13 位有效数字，超过了标准的最低位数规定。 C语言的第 3 种浮点类型是long double，以满足比double类型更高的精度 要求。不过，C只保证long double类型至少与double类型的精度相同。\n1. 声明浮点型变量 # 浮点型变量的声明和初始化方式与整型变量相同，下面是一些例子： # float noah, jonah; double trouble; float planck = 6.63e-34; long double gnp; 2. 浮点型常量 在代码中，可以用多种形式书写浮点型常量。浮点型常量的基本形式 是：有符号的数字（包括小数点），后面紧跟e或E，最后是一个有符号数 表示 10 的指数。下面是两个有效的浮点型常量： -1.56E+12 2.87e-3 正号可以省略。可以没有小数点（如，2E5）或指数部分（如， 19.28），但是不能同时省略两者。可以省略小数部分（如，3.E16）或整数 部分（如，.45E-6），但是不能同时省略两者。下面是更多的有效浮点型常 量示例： 3.14159 .2 4e16 .8E-5 100.\n不要在浮点型常量中间加空格：1.56 E+12（错误！） # 默认情况下，编译器假定浮点型常量是double类型的精度。例如，假设 some是float类型的变量，编写下面的语句： some = 4.0 * 2.0; 通常，4.0和2.0被储存为 64 位的double类型，使用双精度进行乘法运 算，然后将乘积截断成float类型的宽度。这样做虽然计算精度更高，但是会 减慢程序的运行速度。 在浮点数后面加上f或F后缀可覆盖默认设置，编译器会将浮点型常量看 作float类型，如2.3f和9.11E9F。使用l或L后缀使得数字成为long double类 型，如54.3l和4.32L。注意，建议使用L后缀，因为字母l和数字 1 很容易混 淆。没有后缀的浮点型常量是double类型。 C99 标准添加了一种新的浮点型常量格式——用十六进制表示浮点型常 量，即在十六进制数前加上十六进制前缀（0x或0X），用p和P分别代替e和 E，用 2 的幂代替 10 的幂（即，p计数法）。如下所示： 0xa.1fp10 十六进制a等于十进制 10 ，.1f是1/16加上15/256（十六进制f等于十进制 15 ），p10是 210 或 1024 。0xa.1fp10表示的值是(10 + 1/16 + 15/256)×1024（即，十进制10364.0）。 注意，并非所有的编译器都支持C99的这一特性。\n3. 打印浮点值 printf()函数使用%f转换说明打印十进制记数法的float和double类型浮点 数，用%e打印指数记数法的浮点数。如果系统支持十六进制格式的浮点 数，可用a和A分别代替e和E。打印long double类型要使用%Lf、%Le或%La 转换说明。给那些未在函数原型中显式说明参数类型的函数（如，printf()）\n传递参数时，C编译器会把float类型的值自动转换成double类型。程序清单 3.7演示了这些特性。 程序清单 3.7 showf_pt.c 程序 /* showf_pt.c \u0026ndash; 以两种方式显示float类型的值 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { float aboat = 32000.0; double abet = 2.14e9; long double dip = 5.32e-5; printf(\u0026quot;%f can be written %e\\n\u0026rdquo;, aboat, aboat); // 下一行要求编译器支持C99或其中的相关特性 printf(\u0026ldquo;And it\u0026rsquo;s %a in hexadecimal, powers of 2　notation\\n\u0026rdquo;, aboat); printf(\u0026quot;%f can be written %e\\n\u0026rdquo;, abet, abet); printf(\u0026quot;%Lf can be written %Le\\n\u0026rdquo;, dip, dip); return 0; } 该程序的输出如下，前提是编译器支持C99/C11： 32000.000000 can be written 3.200000e+04\nAnd it\u0026rsquo;s 0x1.f4p+14 in hexadecimal, powers of 2　notation 2140000000.000000 can be written 2.140000e+09 0.000053 can be written 5.320000e-05 该程序示例演示了默认的输出效果。下一章将介绍如何通过设置字段宽 度和小数位数来控制输出格式。\n4. 浮点值的上溢和下溢 假设系统的最大float类型值是3.4E38，编写如下代码： float toobig = 3.4E38 * 100.0f; printf(\u0026quot;%e\\n\u0026rdquo;, toobig); 会发生什么？这是一个上溢（overflow）的示例。当计算导致数字过 大，超过当前类型能表达的范围时，就会发生上溢。这种行为在过去是未定 义的，不过现在C语言规定，在这种情况下会给toobig赋一个表示无穷大的 特定值，而且printf()显示该值为inf或infinity（或者具有无穷含义的其他内 容）。 当除以一个很小的数时，情况更为复杂。回忆一下，float类型的数以指 数和尾数部分来储存。存在这样一个数，它的指数部分是最小值，即由全部 可用位表示的最小尾数值。该数字是float类型能用全部精度表示的最小数 字。现在把它除以 2 。通常，这个操作会减小指数部分，但是假设的情况 中，指数已经是最小值了。所以计算机只好把尾数部分的位向右移，空出第 1 个二进制位，并丢弃最后一个二进制数。以十进制为例，把一个有 4 位有 效数字的数（如，0.1234E-10）除以 10 ，得到的结果是0.0123E-10。虽然得 到了结果，但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫 作下溢（underflow）。C语言把损失了类型全精度的浮点值称为低于正常的 （subnormal）浮点值。因此，把最小的正浮点数除以 2 将得到一个低于正常 的值。如果除以一个非常大的值，会导致所有的位都为 0 。现在，C库已提\n供了用于检查计算是否会产生低于正常值的函数。 # 还有另一个特殊的浮点值NaN（not a number的缩写）。例如，给asin() 函数传递一个值，该函数将返回一个角度，该角度的正弦就是传入函数的 值。但是正弦值不能大于 1 ，因此，如果传入的参数大于 1 ，该函数的行为是 未定义的。在这种情况下，该函数将返回NaN值，printf()函数可将其显示为 nan、NaN或其他类似的内容。 浮点数舍入错误 给定一个数，加上 1 ，再减去原来给定的数，结果是多少？你一定认为 是 1 。但是，下面的浮点运算给出了不同的答案： /* floaterr.c\u0026ndash;演示舍入错误 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { float a,b; b = 2.0e20 + 1.0; a = b - 2.0e20; printf(\u0026quot;%f \\n\u0026rdquo;, a); return 0; } 该程序的输出如下：\n得出这些奇怪答案的原因是，计算机缺少足够的小数位来完成正确的运 # 算。2.0e20是 2 后面有 20 个 0 。如果把该数加 1 ，那么发生变化的是第 21 位。 要正确运算，程序至少要储存 21 位数字。而float类型的数字通常只能储存按 指数比例缩小或放大的 6 或 7 位有效数字。在这种情况下，计算结果一定是错 误的。另一方面，如果把2.0e20改成2.0e4，计算结果就没问题。因为2.0e4 加 1 只需改变第 5 位上的数字，float类型的精度足够进行这样的计算。 浮点数表示法 上一个方框中列出了由于计算机使用的系统不同，一个程序有不同的输 出。原因是，根据前面介绍的知识，实现浮点数表示法的方法有多种。为了 尽可能地统一实现，电子和电气工程师协会（IEEE）为浮点数计算和表示 法开发了一套标准。现在，许多硬件浮点单元都采用该标准。 2011 年，该标 准被ISO/IEC/IEEE 60559:2011标准收录。该标准作为C99和C11的可选项， 符合硬件要求的平台可开启。floaterr.c程序的第 3 个输出示例即是支持该浮 点标准的系统显示的结果。支持C标准的编译器还包含捕获异常问题的工 具。详见附录B.5，参考资料V。\n3.4.7 复数和虚数类型 # 许多科学和工程计算都要用到复数和虚数。C99 标准支持复数类型和虚 # 数类型，但是有所保留。一些独立实现，如嵌入式处理器的实现，就不需要 # 使用复数和虚数（VCR芯片就不需要复数）。一般而言，虚数类型都是可选 # 项。C11标准把整个复数软件包都作为可选项。 # 简而言之，C语言有 3 种复数类型：float_Complex、double_Complex和 long double _Complex。例如，float _Complex类型的变量应包含两个float类型 的值，分别表示复数的实部和虚部。类似地， C语言的 3 种虚数类型是float _Imaginary、double _Imaginary和long double _Imaginary。\n如果包含complex.h头文件，便可用complex代替_Complex，用imaginary 代替_Imaginary，还可以用I代替-1的平方根。 为何 C 标准不直接用 complex 作为关键字来代替_Complex，而要添加 一个头文件（该头文件中把complex定义为_Complex）？因为标准委员会考 虑到，如果使用新的关键字，会导致以该关键字作为标识符的现有代码全部 失效。例如，之前的 C99，许多程序员已经使用 struct complex 定义一个结 构来表示复数或者心理学程序中的心理状况（关键字struct用于定义能储存 多个值的结构，详见第 14 章）。让complex成为关键字会导致之前的这些代 码出现语法错误。但是，使用struct _Complex的人很少，特别是标准使用首 字母是下划线的标识符作为预留字以后。因此，标准委员会选定_Complex 作为关键字，在不用考虑名称冲突的情况下可选择使用complex。\n3.4.8 其他类型 # 现在已经介绍完C语言的所有基本数据类型。有些人认为这些类型实在 # 太多了，但有些人觉得还不够用。注意，虽然C语言没有字符串类型，但也 # 能很好地处理字符串。第 4 章将详细介绍相关内容。 # C语言还有一些从基本类型衍生的其他类型，包括数组、指针、结构和 # 联合。尽管后面章节中会详细介绍这些类型，但是本章的程序示例中已经用 # 到了指针〔指针（pointer）指向变量或其他数据对象位置〕。例如，在 scanf()函数中用到的前缀\u0026amp;，便创建了一个指针，告诉 scanf()把数据放在何 处。 小结：基本数据类型 关键字： 基本数据类型由 11 个关键字组成：int、long、short、unsigned、char、 float、double、signed、_Bool、_Complex和_Imaginary。 有符号整型：\n有符号整型可用于表示正整数和负整数。 # int ——系统给定的基本整数类型。C语言规定int类型不小于 16 位。 short或short int ——最大的short类型整数小于或等于最大的int类型整 数。C语言规定short类型至少占 16 位。 long或long int ——该类型可表示的整数大于或等于最大的int类型整数。 C语言规定long类型至少占 32 位。 long long或long long int ——该类型可表示的整数大于或等于最大的long 类型整数。Long long类型至少占 64 位。 一般而言，long类型占用的内存比short类型大，int类型的宽度要么和 long类型相同，要么和short类型相同。例如，旧DOS系统的PC提供 16 位的 short和int，以及 32 位的long；Windows 95系统提供 16 位的short以及 32 位的int 和long。 无符号整型： 无符号整型只能用于表示零和正整数，因此无符号整型可表示的正整数 比有符号整型的大。在整型类型前加上关键字unsigned表明该类型是无符号 整型：unsignedint、unsigned long、unsigned short。单独的unsigned相当于 unsignedint。 字符类型： 可打印出来的符号（如A、\u0026amp;和+）都是字符。根据定义，char类型表示 一个字符要占用 1 字节内存。出于历史原因， 1 字节通常是 8 位，但是如果要 表示基本字符集，也可以是 16 位或更大。 char ——字符类型的关键字。有些编译器使用有符号的char，而有些则 使用无符号的char。在需要时，可在char前面加上关键字signed或unsigned来 指明具体使用哪一种类型。\n布尔类型： # 布尔值表示true和false。C语言用 1 表示true， 0 表示false。 _Bool ——布尔类型的关键字。布尔类型是无符号 int类型，所占用的空 间只要能储存 0 或 1 即可。 实浮点类型： 实浮点类型可表示正浮点数和负浮点数。 float ——系统的基本浮点类型，可精确表示至少 6 位有效数字。 double ——储存浮点数的范围（可能）更大，能表示比 float 类型更多 的有效数字（至少 10 位，通常会更多）和更大的指数。 long long ——储存浮点数的范围（可能）比double更大，能表示比 double更多的有效数字和更大的指数。 复数和虚数浮点数： 虚数类型是可选的类型。复数的实部和虚部类型都基于实浮点类型来构 成： float _Complex double _Complex long double _Complex float _Imaginary double _Imaginary long long _Imaginary\n小结：如何声明简单变量 # 1.选择需要的类型。 # 2.使用有效的字符给变量起一个变量名。 # 3.按以下格式进行声明： # 类型说明符 变量名; # 类型说明符由一个或多个关键字组成。下面是一些示例： # int erest; unsigned short cash; 4.可以同时声明相同类型的多个变量，用逗号分隔各变量名，如下所 示： char ch, init, ans; 5.在声明的同时还可以初始化变量： float mass = 6.0E24;\n3.4.9 类型大小 # 如何知道当前系统的指定类型的大小是多少？运行程序清单3.8，会列 # 出当前系统的各类型的大小。 # 程序清单 3.8 typesize.c 程序 //* typesize.c -- 打印类型大小 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { # /* C99为类型大小提供%zd转换说明 */ printf(\u0026ldquo;Type int has a size of %zd bytes.\\n\u0026rdquo;, sizeof(int)); printf(\u0026ldquo;Type char has a size of %zd bytes.\\n\u0026rdquo;, sizeof(char)); printf(\u0026ldquo;Type long has a size of %zd bytes.\\n\u0026rdquo;, sizeof(long)); printf(\u0026ldquo;Type long long has a size of %zd bytes.\\n\u0026rdquo;, sizeof(long long)); printf(\u0026ldquo;Type double has a size of %zd bytes.\\n\u0026rdquo;, sizeof(double)); printf(\u0026ldquo;Type long double has a size of %zd bytes.\\n\u0026rdquo;, sizeof(long double)); return 0; } sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小。C99 和C11提供%zd转换说明匹配sizeof的返回类型[2]。一些不支持C99和C11的 编译器可用%u或%lu代替%zd。 该程序的输出如下： Type int has a size of 4 bytes. Type char has a size of 1 bytes. Type long has a size of 8 bytes.\nType long long has a size of 8 bytes. Type double has a size of 8 bytes. Type long double has a size of 16 bytes. 该程序列出了 6 种类型的大小，你也可以把程序中的类型更换成感兴趣 的其他类型。注意，因为C语言定义了char类型是 1 字节，所以char类型的大 小一定是 1 字节。而在char类型为 16 位、double类型为 64 位的系统中，sizeof 给出的double是 4 字节。在limits.h和float.h头文件中有类型限制的相关信息 （下一章将详细介绍这两个头文件）。 顺带一提，注意该程序最后几行 printf()语句都被分为两行，只要不在 引号内部或一个单词中间断行，就可以这样写。\n3.5 使用数据类型 # 编写程序时，应注意合理选择所需的变量及其类型。通常，用int或float 类型表示数字，char类型表示字符。在使用变量之前必须先声明，并选择有 意义的变量名。初始化变量应使用与变量类型匹配的常数类型。例如： int apples = 3; /* 正确 / int oranges = 3.0; / 不好的形式 / 与Pascal相比，C在检查类型匹配方面不太严格。C编译器甚至允许二次 初始化，但在激活了较高级别警告时，会给出警告。最好不要养成这样的习 惯。 把一个类型的数值初始化给不同类型的变量时，编译器会把值转换成与 变量匹配的类型，这将导致部分数据丢失。例如，下面的初始化： int cost = 12.99; / 用double类型的值初始化int类型的变量 / float pi = 3.1415926536; / 用double类型的值初始化float类型的变量 */ 第 1 个声明，cost的值是 12 。C编译器把浮点数转换成整数时，会直接丢 弃（截断）小数部分，而不进行四舍五入。第 2 个声明会损失一些精度，因 为C只保证了float类型前 6 位的精度。编译器对这样的初始化可能给出警告。 读者在编译程序清单3.1时可能就遇到了这种警告。 许多程序员和公司内部都有系统化的命名约定，在变量名中体现其类 型。例如，用 i_前缀表示 int类型，us_前缀表示 unsigned short 类型。这样， 一眼就能看出来 i_smart 是 int 类型的变量， us_versmart是unsigned short类型 的变量。\n3.6 参数和陷阱 # 有必要再次提醒读者注意 printf()函数的用法。读者应该还记得，传递 给函数的信息被称为参数。例如，printf(\u0026ldquo;Hello, pal.\u0026quot;)函数调用有一个参 数：\u0026ldquo;Hello,pal.\u0026quot;。双引号中的字符序列（如，\u0026ldquo;Hello,pal.\u0026quot;）被称为字符串 （string），第 4 章将详细讲解相关内容。现在，关键是要理解无论双引号中 包含多少个字符和标点符号，一个字符串就是一个参数。 与此类似，scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;weight)函数调用有两个参数：\u0026quot;%d\u0026quot;和 \u0026amp;weight。C语言用逗号分隔函数中的参数。printf()和scanf()函数与一般函数 不同，它们的参数个数是可变的。例如，前面的程序示例中调用过带一个、 两个，甚至三个参数的 printf()函数。程序要知道函数的参数个数才能正常 工作。printf()和scanf()函数用第 1 个参数表明后续有多少个参数，即第 1 个字 符串中的转换说明与后面的参数一一对应。例如，下面的语句有两个%d转 换说明，说明后面还有两个参数： printf(\u0026quot;%d cats ate %d cans of tuna\\n\u0026rdquo;, cats, cans); 后面的确还有两个参数：cats和cans。 程序员要负责确保转换说明的数量、类型与后面参数的数量、类型相匹 配。现在，C 语言通过函数原型机制检查函数调用时参数的个数和类型是否 正确。但是，该机制对printf()和scanf()不起作用，因为这两个函数的参数个 数可变。如果参数在匹配上有问题，会出现什么情况？假设你编写了程序清 单 3.9中的程序。 程序清单 3.9 badcount.c 程序 /* badcount.c \u0026ndash; 参数错误的情况 */ #include \u0026lt;stdio.h\u0026gt; int main(void)\n{ # int n = 4; int m = 5; float f = 7.0f; float g = 8.0f; printf(\u0026quot;%d\\n\u0026rdquo;, n, m); /* 参数太多　/ printf(\u0026quot;%d %d %d\\n\u0026rdquo;, n); / 参数太少　/ printf(\u0026quot;%d %d\\n\u0026rdquo;, f, g); / 值的类型不匹配 */ return 0; } XCode 4.6（OS 10.8）的输出如下： 4 4　1　-706337836 1606414344　1 Microsoft Visual Studio Express 2012（Windows 7）的输出如下： 4 4　0　0 0　1075576832 注意，用%d显示float类型的值，其值不会被转换成int类型。在不同的\n平台下，缺少参数或参数类型不匹配导致的结果不同。 # 所有编译器都能顺利编译并运行该程序，但其中大部分会给出警告。的 # 确，有些编译器会捕获到这类问题，然而C标准对此未作要求。因此，计算 # 机在运行时可能不会捕获这类错误。如果程序正常运行，很难觉察出来。如 # 果程序没有打印出期望值或打印出意想不到的值，你才会检查 printf()函数 中的参数个数和类型是否得当。\n3.7 转义序列示例 # 再来看一个程序示例，该程序使用了一些特殊的转义序列。程序清单 # 3.10 演示了退格（\\b）、水平制表符（\\t）和回车（\\t）的工作方式。这些概 念在计算机使用电传打字机作为输出设备时就有了，但是它们不一定能与现 代的图形接口兼容。例如，程序清单3.10在某些Macintosh的实现中就无法正 常运行。 程序清单 3.10 escape.c 程序 /* escape.c \u0026ndash; 使用转移序列 / #include \u0026lt;stdio.h\u0026gt; int main(void) { float salary; printf(\u0026quot;\\aEnter your desired monthly salary:\u0026rdquo;); / 1 / printf(\u0026quot; $_______\\b\\b\\b\\b\\b\\b\\b\u0026quot;); / 2 / scanf(\u0026quot;%f\u0026quot;, \u0026amp;salary); printf(\u0026quot;\\n\\t$%.2f a month is $%.2f a year.\u0026quot;, salary, salary * 12.0); / 3 / printf(\u0026quot;\\rGee!\\n\u0026quot;); / 4 */ return 0; }\n3.7.1 程序运行情况 # 假设在系统中运行的转义序列行为与本章描述的行为一致（实际行为可 # 能不同。例如，XCode 4.6把\\a、\\b和\\r显示为颠倒的问号），下面我们来分 析这个程序。 第 1 条printf()语句（注释中标为 1 ）发出一声警报（因为使用了\\a），然 后打印下面的内容： Enter your desired monthly salary: 因为printf()中的字符串末尾没有\\n，所以光标停留在冒号后面。 第 2 条printf()语句在光标处接着打印，屏幕上显示的内容是： Enter your desired monthly salary: $_______ 冒号和美元符号之间有一个空格，这是因为第 2 条printf()语句中的字符 串以一个空格开始。 7 个退格字符使得光标左移 7 个位置，即把光标移至 7 个 下划线字符的前面，紧跟在美元符号后面。通常，退格不会擦除退回所经过 的字符，但有些实现是擦除的，这和本例不同。 假设键入的数据是4000.00（并按下Enter键），屏幕显示的内容应该 是： Enter your desired monthly salary: $4000.00 键入的字符替换了下划线字符。按下Enter键后，光标移至下一行的起 始处。 第 3 条printf()语句中的字符串以\\n\\t开始。换行字符使光标移至下一行起 始处。水平制表符使光标移至该行的下一个制表点，一般是第 9 列（但不一 定）。然后打印字符串中的其他内容。执行完该语句后，此时屏幕显示的内 容应该是：\nEnter your desired monthly salary: $4000.00 $4000.00 a month is $48000.00 a year. 因为这条printf()语句中没有使用换行字符，所以光标停留在最后的点号 后面。 第 4 条printf()语句以\\r开始。这使得光标回到当前行的起始处。然后打印 Gee!，接着\\n使光标移至下一行的起始处。屏幕最后显示的内容应该是： Enter your desired monthly salary: $4000.00 Gee! $4000.00 a month is $48000.00 a year.\n3.7.2 刷新输出 # printf()何时把输出发送到屏幕上？最初，printf()语句把输出发送到一个 叫作缓冲区（buffer）的中间存储区域，然后缓冲区中的内容再不断被发送 到屏幕上。C 标准明确规定了何时把缓冲区中的内容发送到屏幕：当缓冲区 满、遇到换行字符或需要输入的时候（从缓冲区把数据发送到屏幕或文件被 称为刷新缓冲区）。例如，前两个 printf()语句既没有填满缓冲区，也没有 换行符，但是下一条 scanf()语句要求用户输入，这迫使printf()的输出被发送 到屏幕上。 旧式编译器遇到scanf()也不会强行刷新缓冲区，程序会停在那里不显示 任何提示内容，等待用户输入数据。在这种情况下，可以使用换行字符刷新 缓冲区。代码应改为： printf(\u0026ldquo;Enter your desired monthly salary:\\n\u0026rdquo;); scanf(\u0026quot;%f\u0026quot;, \u0026amp;salary); 无论接下来的输入是否能刷新缓冲区，代码都会正常运行。这将导致光 标移至下一行起始处，用户无法在提示内容同一行输入数据。还有一种刷新\n缓冲区的方法是使用fflush()函数，详见第 13 章。\n3.8 关键概念 # C语言提供了大量的数值类型，目的是为程序员提供方便。那以整数类 # 型为例，C认为一种整型不够，提供了有符号、无符号，以及大小不同的整 # 型，以满足不同程序的需求。 # 计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大 # 区别。即使两个 32 位存储单元储存的位组合完全相同，但是一个解释为float 类型，另一个解释为long类型，这两个相同的位组合表示的值也完全不同。 例如，在PC中，假设一个位组合表示float类型的数256.0，如果将其解释为 long类型，得到的值是 113246208 。C语言允许编写混合数据类型的表达式， 但是会进行自动类型转换，以便在实际运算时统一使用一种类型。 计算机在内存中用数值编码来表示字符。美国最常用的是ASCII码，除 此之外C也支持其他编码。字符常量是计算机系统使用的数值编码的符号表 示，它表示为单引号括起来的字符，如\u0026rsquo;A\u0026rsquo;。\n3.9 本章小结 # C 有多种的数据类型。基本数据类型分为两大类：整数类型和浮点数类 # 型。通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类 # 型。最小的整数类型是char，因实现不同，可以是有符号的char或无符号的 char，即unsigned char或signed char。但是，通常用char类型表示小整数时才 这样显示说明。其他整数类型有short、int、long和long long类型。C规定，后 面的类型不能小于前面的类型。上述都是有符号类型，但也可以使用 unsigned关键字创建相应的无符号类型：unsigned short、unsigned int、 unsigned long和unsigned long long。或者，在类型名前加上signed修饰符显式 表明该类型是有符号类型。最后，_Bool类型是一种无符号类型，可储存 0 或 1 ，分别代表false和true。 浮点类型有 3 种：float、double和C90新增的long double。后面的类型应 大于或等于前面的类型。有些实现可选择支持复数类型和虚数类型，通过关 键字_Complex和_Imaginary与浮点类型的关键字组合（如，double _Complex 类型和float _Imaginary类型）来表示这些类型。 整数可以表示为十进制、八进制或十六进制。 0 前缀表示八进制数，0x 或0X前缀表示十六进制数。例如， 32 、 040 、0x20分别以十进制、八进制、 十六进制表示同一个值。l或L前缀表明该值是long类型， ll或LL前缀表明该 值是long long类型。 在C语言中，直接表示一个字符常量的方法是：把该字符用单引号括起 来，如\u0026rsquo;Q\u0026rsquo;、\u0026lsquo;8\u0026rsquo;和\u0026rsquo;$\u0026rsquo;。C语言的转义序列（如，\u0026rsquo;\\n\u0026rsquo;）表示某些非打印字符。另 外，还可以在八进制或十六进制数前加上一个反斜杠（如，\u0026rsquo;\\007\u0026rsquo;），表示 ASCII码中的一个字符。 浮点数可写成固定小数点的形式（如，9393.912）或指数形式（如， 7.38E10）。C99和C11提供了第 3 种指数表示法，即用十六进制数和 2 的幂来 表示（如，0xa.1fp10）。\nprintf()函数根据转换说明打印各种类型的值。转换说明最简单的形式由 一个百分号（%）和一个转换字符组成，如%d或%f。\n3.10 复习题 # 复习题的参考答案在附录A中。 # 1.指出下面各种数据使用的合适数据类型（有些可使用多种数据类 # 型）： # a.East Simpleton的人口 b.DVD影碟的价格 c.本章出现次数最多的字母 d.本章出现次数最多的字母次数 2.在什么情况下要用long类型的变量代替int类型的变量？ 3.使用哪些可移植的数据类型可以获得 32 位有符号整数？选择的理由是 什么？ 4.指出下列常量的类型和含义（如果有的话）： a.\u0026rsquo;\\b\u0026rsquo; b.1066 c.99.44 d.0XAA e.2.0e30 5.Dottie Cawm编写了一个程序，请找出程序中的错误。 include \u0026lt;stdio.h\u0026gt;\nmain ( float g; h; float tax, rate; g = e21; tax = rate*g; ) 6.写出下列常量在声明中使用的数据类型和在printf()中对应的转换说 明：\n7.写出下列常量在声明中使用的数据类型和在printf()中对应的转换说明 （假设int为 16 位）：\n8.假设程序的开头有下列声明： # int imate = 2; long shot = 53456; char grade = \u0026lsquo;A\u0026rsquo;; float log = 2.71828; 把下面printf()语句中的转换字符补充完整： printf(\u0026ldquo;The odds against the %__ were %__ to 1.\\n\u0026rdquo;, imate, shot); printf(\u0026ldquo;A score of %__ is not an %__ grade.\\n\u0026rdquo;, log, grade); 9.假设ch是char类型的变量。分别使用转义序列、十进制值、八进制字 符常量和十六进制字符常量把回车字符赋给ch（假设使用ASCII编码值）。 10.修正下面的程序（在C中，/表示除以）。 void main(int) / this program is perfect / { cows, legs integer;\nprintf(\u0026ldquo;How many cow legs did you count?\\n); scanf(\u0026quot;%c\u0026rdquo;, legs); cows = legs / 4; printf(\u0026ldquo;That implies there are %f cows.\\n\u0026rdquo;, cows) } 11.指出下列转义序列的含义： a.\\n b.\\ c.\u0026quot; d.\\t\n3.11 编程练习 # 1.通过试验（即编写带有此类问题的程序）观察系统如何处理整数上 # 溢、浮点数上溢和浮点数下溢的情况。 # 2.编写一个程序，要求提示输入一个ASCII码值（如， 66 ），然后打印 # 输入的字符。 # 3.编写一个程序，发出一声警报，然后打印下面的文本： # Startled by the sudden sound, Sally shouted, \u0026ldquo;By the Great Pumpkin, what was that!\u0026rdquo; 4.编写一个程序，读取一个浮点数，先打印成小数点形式，再打印成指 数形式。然后，如果系统支持，再打印成p记数法（即十六进制记数法）。 按以下格式输出（实际显示的指数位数因系统而异）： Enter a floating-point value: 64.25 fixed-point notation: 64.250000 exponential notation: 6.425000e+01 p notation: 0x1.01p+6 5.一年大约有3.156×10^7 秒。编写一个程序，提示用户输入年龄，然后显 示该年龄对应的秒数。\n6.1个水分子的质量约为3.0×10−23克。 1 夸脱水大约是 950 克。编写一个 程序，提示用户输入水的夸脱数，并显示水分子的数量。 7.1英寸相当于2.54厘米。编写一个程序，提示用户输入身高（/英 寸），然后以厘米为单位显示身高。\n8.在美国的体积测量系统中， 1 品脱等于 2 杯， 1 杯等于 8 盎司， 1 盎司等 # 于 2 大汤勺， 1 大汤勺等于 3 茶勺。编写一个程序，提示用户输入杯数，并以 # 品脱、盎司、汤勺、茶勺为单位显示等价容量。思考对于该程序，为何使用 # 浮点类型比整数类型更合适？ # [1].金市场上使用的黄金交易计量单位是金衡盎司（欧美日常使用的度量衡单位是常衡盎司（avoirdupois ouncetroy ounce）。国际黄金市），而欧美黄 场上的报价，其单位做重量单位时也称为英两。相关换算参考如下：“盎司”都指的是黄金盎司。常衡盎司属英制计量单位， 1 常衡盎司 = 28.350克， 1 金 衡盎司算成金衡盎司，即 = 31.104克，28.350÷31.104×16=14.5833 16 常衡盎司 = 1磅。该程序的单位转换思路是：把磅换。——译者注\n[2].即，size_t类型。——译者注\n第 4 章 字符串和格式化输入 / 输出 # 本章介绍以下内容： # 函数：strlen() 关键字：const 字符串 如何创建、存储字符串 如何使用strlen()函数获取字符串的长度 用C预处理器指令#define和ANSIC的const修饰符创建符号常量 本章重点介绍输入和输出。与程序交互和使用字符串可以编写个性化的 程序，本章将详细介绍C语言的两个输入/输出函数：printf()和scanf()。学会 使用这两个函数，不仅能与用户交互，还可根据个人喜好和任务要求格式化 输出。最后，简要介绍一个重要的工具——C预处理器指令，并学习如何定 义、使用符号常量。\n4.1 前导程序 # 与前两章一样，本章以一个简单的程序开始。程序清单4.1与用户进行 # 简单的交互。为了使程序的形式灵活多样，代码中使用了新的注释风格。 # 程序清单 4.1 talkback.c 程序 // talkback.c -- 演示与用户交互 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; // 提供strlen()函数的原型 #define DENSITY 62.4 // 人体密度（单位：磅/立方英尺） int main() { float weight, volume; int size, letters; char name[40]; // name是一个可容纳 40 个字符的数组 printf(\u0026#34;Hi! What\u0026#39;s your first name?\\n\u0026#34;); scanf(\u0026#34;%s\u0026#34;, name); printf(\u0026#34;%s, what\u0026#39;s your weight in pounds?\\n\u0026#34;, name); scanf(\u0026#34;%f\u0026#34;, \u0026amp;weight); size = sizeof name; letters = strlen(name); volume = weight / DENSITY; printf(\u0026ldquo;Well, %s, your volume is %2.2f cubic feet.\\n\u0026rdquo;, name, volume); printf(\u0026ldquo;Also, your first name has %d letters,\\n\u0026rdquo;, letters); printf(\u0026ldquo;and we have %d bytes to store it.\\n\u0026rdquo;, size); return 0; } 运行talkback.c程序，输入结果如下： Hi! What\u0026rsquo;s your first name? Christine Christine, what\u0026rsquo;s your weight in pounds? 154 Well, Christine, your volume is 2.47 cubic feet. Also, your first name has 9 letters, and we have 40 bytes to store it. 该程序包含以下新特性。 用数组（array）储存字符串（character string）。在该程序中，用户输 入的名被储存在数组中，该数组占用内存中 40 个连续的字节，每个字节储存 一个字符值。\n使用%s转换说明来处理字符串的输入和输出。注意，在scanf()中， name没有\u0026amp;前缀，而weight有（稍后解释，\u0026amp;weight和name都是地址）。 用C预处理器把字符常量DENSITY定义为62.4。 用C函数strlen()获取字符串的长度。 对于BASIC的输入/输出而言，C的输入/输出看上去有些复杂。不过， 复杂换来的是程序的高效和方便控制输入/输出。而且，一旦熟悉用法后， 会发现它很简单。\n4.2 字符串简介 # 字符串（character string）是一个或多个字符的序列，如下所示： \u0026ldquo;Zing went the strings of my heart!\u0026rdquo; 双引号不是字符串的一部分。双引号仅告知编译器它括起来的是字符 串，正如单引号用于标识单个字符一样。\n4.2.1 char 类型数组和 null 字符 # C语言没有专门用于储存字符串的变量类型，字符串都被储存在char类 型的数组中。数组由连续的存储单元组成，字符串中的字符被储存在相邻的 存储单元中，每个单元储存一个字符（见图4.1）。\n图4.1 数组中的字符串 注意图4.1中数组末尾位置的字符\\0。这是空字符（null character），C 语言用它标记字符串的结束。空字符不是数字 0 ，它是非打印字符，其ASCII 码值是（或等价于） 0 。C中的字符串一定以空字符结束，这意味着数组的 容量必须至少比待存储字符串中的字符数多 1 。因此，程序清单4.1中有 40 个 存储单元的字符串，只能储存 39 个字符，剩下一个字节留给空字符。 那么，什么是数组？可以把数组看作是一行连续的多个存储单元。用更 正式的说法是，数组是同类型数据元素的有序序列。程序清单4.1通过以下 声明创建了一个包含 40 个存储单元（或元素）的数组，每个单元储存一个 char类型的值： char name[40]; name后面的方括号表明这是一个数组，方括号中的 40 表明该数组中的\n元素数量。char表明每个元素的类型（见图4.2）。\n图4.2 声明一个变量和声明一个数组 字符串看上去比较复杂！必须先创建一个数组，把字符串中的字符逐个 放入数组，还要记得在末尾加上一个\\0。还好，计算机可以自己处理这些细 节。\n4.2.2 使用字符串 # 试着运行程序清单4.2，使用字符串其实很简单。 # 程序清单 4.2 praise1.c 程序 /* praise1.c -- 使用不同类型的字符串 */ #include \u0026lt;stdio.h\u0026gt; #define PRAISE \u0026ldquo;You are an extraordinary being.\u0026rdquo; int main(void) { char name[40]; printf(\u0026ldquo;What\u0026rsquo;s your name? \u0026ldquo;); scanf(\u0026quot;%s\u0026rdquo;, name); printf(\u0026ldquo;Hello, %s.%s\\n\u0026rdquo;, name, PRAISE); return 0; } %s告诉printf()打印一个字符串。%s出现了两次，因为程序要打印两个 字符串：一个储存在name数组中；一个由PRAISE来表示。运行praise1.c， 其输出如下所示： What\u0026rsquo;s your name? Angela Plains Hello, Angela.You are an extraordinary being. 你不用亲自把空字符放入字符串末尾，scanf()在读取输入时就已完成这 项工作。也不用在字符串常量PRAISE末尾添加空字符。稍后我们会解释 #define指令，现在先理解PRAISE后面用双引号括起来的文本是一个字符 串。编译器会在末尾加上空字符。 注意（这很重要），scanf()只读取了Angela Plains中的Angela，它在遇 到第 1 个空白（空格、制表符或换行符）时就不再读取输入。因此，scanf() 在读到Angela和Plains之间的空格时就停止了。一般而言，根据%s转换说 明，scanf()只会读取字符串中的一个单词，而不是一整句。C语言还有其他\n的输入函数（如，fgets()），用于读取一般字符串。后面章节将详细介绍这 些函数。 字符串和字符 字符串常量\u0026quot;x\u0026quot;和字符常量\u0026rsquo;x\u0026rsquo;不同。区别之一在于\u0026rsquo;x\u0026rsquo;是基本类型 （char），而\u0026quot;x\u0026quot;是派生类型（char数组）；区别之二是\u0026quot;x\u0026quot;实际上由两个字符 组成：\u0026lsquo;x\u0026rsquo;和空字符\\0（见图4.3）。\n图4.3 字符\u0026#39;x\u0026#39;和字符串\u0026#34;x\u0026#34; 4.2.3 strlen() 函数 # 上一章提到了 sizeof 运算符，它以字节为单位给出对象的大小。strlen() 函数给出字符串中的字符长度。因为 1 字节储存一个字符，读者可能认为把 两种方法应用于字符串得到的结果相同，但事实并非如此。请根据程序清单 4.3，在程序清单4.2中添加几行代码，看看为什么会这样。 程序清单 4.3 praise2.c 程序 /* praise2.c / // 如果编译器不识别%zd，尝试换成%u或%lu。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; / 提供strlen()函数的原型 */\n#define PRAISE \u0026ldquo;You are an extraordinary being.\u0026rdquo; int main(void) { char name[40]; printf(\u0026ldquo;What\u0026rsquo;s your name? \u0026ldquo;); scanf(\u0026quot;%s\u0026rdquo;, name); printf(\u0026ldquo;Hello, %s.%s\\n\u0026rdquo;, name, PRAISE); printf(\u0026ldquo;Your name of %zd letters occupies %zd memory cells.\\n\u0026rdquo;, strlen(name), sizeof name); printf(\u0026ldquo;The phrase of praise has %zd letters \u0026ldquo;, strlen(PRAISE)); printf(\u0026ldquo;and occupies %zd memory cells.\\n\u0026rdquo;, sizeof PRAISE); return 0; } 如果使用ANSI C之前的编译器，必须移除这一行： #include \u0026lt;string.h\u0026gt; string.h头文件包含多个与字符串相关的函数原型，包括strlen()。第 11 章 将详细介绍该头文件（顺带一提，一些ANSI之前的UNIX系统用strings.h代替 string.h，其中也包含了一些字符串函数的声明）。 一般而言，C 把函数库中相关的函数归为一类，并为每类函数提供一个\n头文件。例如，printf()和scanf()都隶属标准输入和输出函数，使用stdio.h头 文件。string.h头文件中包含了strlen()函数和其他一些与字符串相关的函数 （如拷贝字符串的函数和字符串查找函数）。 注意，程序清单4.3使用了两种方法处理很长的printf()语句。第 1 种方法 是将printf()语句分为两行（可以在参数之间断为两行，但是不要在双引号中 的字符串中间断开）；第 2 种方法是使用两个printf()语句打印一行内容，只 在第 2 条printf()语句中使用换行符（\\n）。运行该程序，其交互输出如下： What\u0026rsquo;s your name? Serendipity Chance Hello, Serendipity.You are an extraordinary being. Your name of 11 letters occupies 40 memory cells. The phrase of praise has 31 letters and occupies 32 memory cells. sizeof运算符报告，name数组有 40 个存储单元。但是，只有前 11 个单元 用来储存Serendipity，所以strlen()得出的结果是 11 。name数组的第 12 个单元 储存空字符，strlen()并未将其计入。图4.4演示了这个概念。\n图4.4 strlen()函数知道在何处停止 对于 PRAISE，用 strlen()得出的也是字符串中的字符数（包括空格和标 点符号）。然而，sizeof运算符给出的数更大，因为它把字符串末尾不可见 的空字符也计算在内。该程序并未明确告诉计算机要给字符串预留多少空 间，所以它必须计算双引号内的字符数。\n第 3 章提到过，C99 和 C11 标准专门为 sizeof 运算符的返回类型添加 了%zd 转换说明，这对于strlen()同样适用。对于早期的C，还要知道sizeof和 strlen()返回的实际类型（通常是unsigned或unsigned long）。 另外，还要注意一点：上一章的 sizeof 使用了圆括号，但本例没有。圆 括号的使用时机否取决于运算对象是类型还是特定量？运算对象是类型时， 圆括号必不可少，但是对于特定量，可有可无。也就是说，对于类型，应写 成sizeof(char)或sizeof(float)；对于特定量，可写成sizeof name或sizeof 6.28。 尽管如此，还是建议所有情况下都使用圆括号，如sizeof(6.28)。 程序清单4.3中使用strlen()和sizeof，完全是为了满足读者的好奇心。在 实际应用中，strlen()和 sizeof 是非常重要的编程工具。例如，在各种要处理 字符串的程序中，strlen()很有用。详见第 11 章。 下面我们来学习#define指令。\n4.3 常量和 C 预处理器 # 有时，在程序中要使用常量。例如，可以这样计算圆的周长： # circumference = 3.14159 * diameter; 这里，常量3.14159代表著名的常量pi（π）。在该例中，输入实际值便 可使用这个常量。然而，这种情况使用符号常量（symbolic constant）会更 好。也就是说，使用下面的语句，计算机稍后会用实际值完成替换： circumference = pi * diameter; 为什么使用符号常量更好？首先，常量名比数字表达的信息更多。请比 较以下两条语句： owed = 0.015 * housevalue; owed = taxrate * housevalue; 如果阅读一个很长的程序，第 2 条语句所表达的含义更清楚。 另外，假设程序中的多处使用一个常量，有时需要改变它的值。毕竟， 税率通常是浮动的。如果程序使用符号常量，则只需更改符号常量的定义， 不用在程序中查找使用常量的地方，然后逐一修改。 那么，如何创建符号常量？方法之一是声明一个变量，然后将该变量设 置为所需的常量。可以这样写： float taxrate; taxrate = 0.015; 这样做提供了一个符号名，但是taxrate是一个变量，程序可能会无意间 改变它的值。C语言还提供了一个更好的方案——C预处理器。第 2 章中介 绍了预处理器如何使用#include包含其他文件的信息。预处理器也可用来定\n义常量。只需在程序顶部添加下面一行： # #define TAXRATE 0.015 编译程序时，程序中所有的TAXRATE都会被替换成0.015。这一过程被 称为编译时替换（compile-time substitution）。在运行程序时，程序中所有的 替换均已完成（见图 4.5）。通常，这样定义的常量也称为明示常量 （manifest constant）[1]。 请注意格式，首先是#define，接着是符号常量名（TAXRATE），然后 是符号常量的值（0.015）（注意，其中并没有=符号）。所以，其通用格式 如下： #define NAME value 实际应用时，用选定的符号常量名和合适的值来替换NAME和value。注 意，末尾不用加分号，因为这是一种由预处理器处理的替换机制。为什么 TAXRATE 要用大写？用大写表示符号常量是 C 语言一贯的传统。这样，在 程序中看到全大写的名称就立刻明白这是一个符号常量，而非变量。大写常 量只是为了提高程序的可读性，即使全用小写来表示符号常量，程序也能照 常运行。尽管如此，初学者还是应该养成大写常量的好习惯。 另外，还有一个不常用的命名约定，即在名称前带c_或k_前缀来表示常 量（如，c_level或k_line）。 符号常量的命名规则与变量相同。可以使用大小写字母、数字和下划线 字符，首字符不能为数字。程序清单4.4演示了一个简单的示例。\n图4.5 输入的内容和编译后的内容 程序清单 4.4 pizza.c 程序 /* pizza.c \u0026ndash; 在比萨饼程序中使用已定义的常量 */ #include \u0026lt;stdio.h\u0026gt; #define PI 3.14159 int main(void) { float area, circum, radius; printf(\u0026ldquo;What is the radius of your pizza?\\n\u0026rdquo;); scanf(\u0026quot;%f\u0026rdquo;, \u0026amp;radius); area = PI * radius * radius; circum = 2.0 * PI *radius; printf(\u0026ldquo;Your basic pizza parameters are as follows:\\n\u0026rdquo;); printf(\u0026ldquo;circumference = %1.2f, area = %1.2f\\n\u0026rdquo;, circum,area); return 0; } printf()语句中的%1.2f表明，结果被四舍五入为两位小数输出。下面是 一个输出示例： What is the radius of your pizza?\n6.0 # Your basic pizza parameters are as follows: circumference = 37.70, area = 113.10 #define指令还可定义字符和字符串常量。前者使用单引号，后者使用双 引号。如下所示： #define BEEP \u0026lsquo;\\a\u0026rsquo; #define TEE \u0026lsquo;T\u0026rsquo; #define ESC \u0026lsquo;\\033\u0026rsquo; #define OOPS \u0026ldquo;Now you have done it!\u0026rdquo; 记住，符号常量名后面的内容被用来替换符号常量。不要犯这样的常见 错误： /* 错误的格式 */ #define TOES = 20 如果这样做，替换TOES的是= 20，而不是 20 。这种情况下，下面的语 句： digits = fingers + TOES; 将被转换成错误的语句： digits = fingers + = 20;\n4.3.1 const 限定符 # C90标准新增了const关键字，用于限定一个变量为只读 [2]。其声明如 下： # const int MONTHS = 12; // MONTHS在程序中不可更改，值为 12 这使得MONTHS成为一个只读值。也就是说，可以在计算中使用 MONTHS，可以打印MONTHS，但是不能更改MONTHS的值。const用起来 比#define更灵活，第 12 章将讨论与const相关的内容。\n4.3.2 明示常量 # C头文件limits.h和float.h分别提供了与整数类型和浮点类型大小限制相 关的详细信息。每个头文件都定义了一系列供实现使用的明示常量 [3]。例 如，limits.h头文件包含以下类似的代码： #define INT_MAX +32767 #define INT_MIN -32768 这些明示常量代表int类型可表示的最大值和最小值。如果系统使用 32 位的int，该头文件会为这些明示常量提供不同的值。如果在程序中包含 limits.h头文件，就可编写下面的代码： printf(\u0026ldquo;Maximum int value on this system = %d\\n\u0026rdquo;, INT_MAX); 如果系统使用 4 字节的int，limits.h头文件会提供符合 4 字节int的 INT_MAX和INT_MIN。表4.1列出了limits.h中能找到的一些明示常量。 表4.1 limits.h中的一些明示常量\n类似地，float.h头文件中也定义一些明示常量，如FLT_DIG和 DBL_DIG，分别表示float类型和double类型的有效数字位数。表4.2列出了 float.h中的一些明示常量（可以使用文本编辑器打开并查看系统使用的float.h 头文件）。表中所列都与float类型相关。把明示常量名中的FLT分别替换成 DBL和LDBL，即可分别表示double和long double类型对应的明示常量（表中 假设系统使用 2 的幂来表示浮点数）。 表4.2 float.h中的一些明示常量\n程序清单4.5演示了如何使用float.h和limits.h中的数据（注意，编译器要 完全支持C99标准才能识别LLONG_MIN标识符）。 程序清单 4.5 defines.c 程序 // defines.c \u0026ndash; 使用limit.h和float头文件中定义的明示常量 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;limits.h\u0026gt; // 整型限制 #include \u0026lt;float.h\u0026gt; // 浮点型限制 int main(void) { printf(\u0026ldquo;Some number limits for this system:\\n\u0026rdquo;); printf(\u0026ldquo;Biggest int: %d\\n\u0026rdquo;, INT_MAX); printf(\u0026ldquo;Smallest long long: %lld\\n\u0026rdquo;, LLONG_MIN); printf(\u0026ldquo;One byte = %d bits on this system.\\n\u0026rdquo;, CHAR_BIT); printf(\u0026ldquo;Largest double: %e\\n\u0026rdquo;, DBL_MAX); printf(\u0026ldquo;Smallest normal float: %e\\n\u0026rdquo;, FLT_MIN); printf(\u0026ldquo;float precision = %d digits\\n\u0026rdquo;, FLT_DIG); printf(\u0026ldquo;float epsilon = %e\\n\u0026rdquo;, FLT_EPSILON); return 0; }\n该程序的输出示例如下： # Some number limits for this system: Biggest int: 2147483647 Smallest long long: -9223372036854775808 One byte = 8 bits on this system. Largest double: 1.797693e+308 Smallest normal float: 1.175494e-38 float precision = 6 digits float epsilon = 1.192093e-07 C预处理器是非常有用的工具，要好好利用它。本书的后面章节中会介 绍更多相关应用。\n4.4 printf() 和 scanf() # printf()函数和scanf()函数能让用户可以与程序交流，它们是输入/输出函 数，或简称为I/O函数。它们不仅是C语言中的I/O函数，而且是最多才多艺 的函数。过去，这些函数和C库的一些其他函数一样，并不是C语言定义的 一部分。最初，C把输入/输出的实现留给了编译器的作者，这样可以针对特 殊的机器更好地匹配输入/输出。后来，考虑到兼容性的问题，各编译器都 提供不同版本的printf()和scanf()。尽管如此，各版本之间偶尔有一些差异。 C90 和C99 标准规定了这些函数的标准版本，本书亦遵循这一标准。 虽然printf()是输出函数，scanf()是输入函数，但是它们的工作原理几乎 相同。两个函数都使用格式字符串和参数列表。我们先介绍printf()，再介绍 scanf()。\n4.4.1 printf() 函数 # 请求printf()函数打印数据的指令要与待打印数据的类型相匹配。例如， 打印整数时使用%d，打印字符时使用%c。这些符号被称为转换说明 （conversion specification），它们指定了如何把数据转换成可显示的形式。 我们先列出ANSI C标准为printf()提供的转换说明，然后再示范如何使用一些 较常见的转换说明。表4.3列出了一些转换说明和各自对应的输出类型。 表4.3 转换说明及其打印的输出结果\n4.4.2 使用 printf() # 程序清单4.6的程序中使用了一些转换说明。 # 程序清单 4.6 printout.c 程序 /* printout.c \u0026ndash; 使用转换说明 */ #include \u0026lt;stdio.h\u0026gt; #define PI 3.141593 int main(void) { int number = 7; float pies = 12.75;\nint cost = 7800; printf(\u0026ldquo;The %d contestants ate %f berry pies.\\n\u0026rdquo;, number, pies); printf(\u0026ldquo;The value of pi is %f.\\n\u0026rdquo;, PI); printf(\u0026ldquo;Farewell! thou art too dear for my possessing,\\n\u0026rdquo;); printf(\u0026quot;%c%d\\n\u0026rdquo;, \u0026lsquo;$\u0026rsquo;, 2 * cost); return 0; } 该程序的输出如下： The 7 contestants ate 12.750000 berry pies. The value of pi is 3.141593. Farewell! thou art too dear for my possessing, $15600 这是printf()函数的格式： printf( 格式字符串, 待打印项1, 待打印项2,\u0026hellip;); 待打印项 1 、待打印项 2 等都是要打印的项。它们可以是变量、常量，甚 至是在打印之前先要计算的表达式。第 3 章提到过，格式字符串应包含每个 待打印项对应的转换说明。例如，考虑下面的语句： printf(\u0026ldquo;The %d contestants ate %f berry pies.\\n\u0026rdquo;, number,pies); 格式字符串是双引号括起来的内容。上面语句的格式字符串包含了两个\n待打印项number和poes对应的两个转换说明。图4.6演示了printf()语句的另一 个例子。 下面是程序清单4.6中的另一行： printf(\u0026ldquo;The value of pi is %f.\\n\u0026rdquo;, PI); 该语句中，待打印项列表只有一个项——符号常量PI。 如图4.7所示，格式字符串包含两种形式不同的信息： 实际要打印的字符； 转换说明。\n图4.6 printf()的参数 图4.7 剖析格式字符串 警告 格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基 本要求会导致严重的后果。千万别写成下面这样：\nprintf(\u0026ldquo;The score was Squids %d, Slugs %d.\\n\u0026rdquo;, score1); 这里，第 2 个%d没有对应任何项。系统不同，导致的结果也不同。不 过，出现这种问题最好的状况是得到无意义的值。 如果只打印短语或句子，就不需要使用任何转换说明。如果只打印数 据，也不用加入说明文字。程序清单4.6中的最后两个printf()语句都没问 题： printf(\u0026ldquo;Farewell! thou art too dear for my possessing,\\n\u0026rdquo;); printf(\u0026quot;%c%d\\n\u0026rdquo;, \u0026lsquo;$\u0026rsquo;, 2 * cost); 注意第 2 条语句，待打印列表的第 1 个项是一个字符常量，不是变量；第 2 个项是一个乘法表达式。这说明printf()使用的是值，无论是变量、常量还 是表达式的值。 由于 printf()函数使用%符号来标识转换说明，因此打印%符号就成了个 问题。如果单独使用一个%符号，编译器会认为漏掉了一个转换字符。解决 方法很简单，使用两个%符号就行了： pc = 2*6; printf(\u0026ldquo;Only %d%% of Sally\u0026rsquo;s gribbles were edible.\\n\u0026rdquo;, pc); 下面是输出结果： Only 12% of Sally\u0026rsquo;s gribbles were edible.\n4.4.3 printf() 的转换说明修饰符 # 在%和转换字符之间插入修饰符可修饰基本的转换说明。表4.4和表4.5 # 列出可作为修饰符的合法字符。如果要插入多个字符，其书写顺序应该与表 # 4.4中列出的顺序相同。不是所有的组合都可行。表中有些字符是C99新增 # 的，如果编译器不支持C99，则可能不支持表中的所有项。 # 表4.4 printf()的修饰符\n注意 类型可移植性 # sizeof 运算符以字节为单位返回类型或值的大小。这应该是某种形式的 整数，但是标准只规定了该值是无符号整数。在不同的实现中，它可以是 unsigned int、unsigned long甚至是unsigned long long。因此，如果要用printf() 函数显示sizeof表达式，根据不同系统，可能使用%u、%lu或%llu。这意味 着要查找你当前系统的用法，如果把程序移植到不同的系统还要进行修改。 鉴于此， C提供了可移植性更好的类型。首先，stddef.h头文件（在包含\nstdio.h头文件时已包含其中）把size_t定义成系统使用sizeof返回的类型，这 被称为底层类型（underlying type）。其次，printf()使用z修饰符表示打印相 应的类型。同样，C还定义了ptrdiff_t类型和t修饰符来表示系统使用的两个 地址差值的底层有符号整数类型。 注意 float 参数的转换 对于浮点类型，有用于double和long double类型的转换说明，却没有 float类型的。这是因为在K\u0026amp;R C中，表达式或参数中的float类型值会被自动 转换成double类型。一般而言，ANSI C不会把float自动转换成double。然 而，为保护大量假设float类型的参数被自动转换成double的现有程序， printf()函数中所有float类型的参数（对未使用显式原型的所有C函数都有 效）仍自动转换成double类型。因此，无论是K\u0026amp;R C还是ANSI C，都没有显 示float类型值专用的转换说明。 表 4.5 printf() 中的标记\n1. 使用修饰符和标记的示例 # 接下来，用程序示例演示如何使用这些修饰符和标记。先来看看字段宽 # 度在打印整数时的效果。考虑程序清单4.7中的程序。 # 程序清单 4.7 width.c 程序 /* width.c \u0026ndash; 字段宽度 / #include \u0026lt;stdio.h\u0026gt; #define PAGES 959 int main(void) { printf(\u0026rdquo;%d*\\n\u0026quot;, PAGES); printf(\u0026quot;%2d\\n\u0026quot;, PAGES); printf(\u0026quot;%10d\\n\u0026quot;, PAGES); return 0; printf(\u0026quot;%-10d\\n\u0026quot;, PAGES); } 程序清单4.7通过 4 种不同的转换说明把相同的值打印了 4 次。程序中使 用星号（*）标出每个字段的开始和结束。其输出结果如下所示： 959 959\n959* *959 * 第 1 个转换说明%d不带任何修饰符，其对应的输出结果与带整数字段宽 度的转换说明的输出结果相同。在默认情况下，没有任何修饰符的转换说 明，就是这样的打印结果。第 2 个转换说明是%2d，其对应的输出结果应该 是 2 字段宽度。因为待打印的整数有 3 位数字，所以字段宽度自动扩大以符 # 合整数的长度。第 3 个转换说明是%10d，其对应的输出结果有 10 个空格宽 度，实际上在两个星号之间有 7 个空格和 3 位数字，并且数字位于字段的右 侧。最后一个转换说明是%-10d，其对应的输出结果同样是 10 个空格宽 度，-标记说明打印的数字位于字段的左侧。熟悉它们的用法后，能很好地 控制输出格式。试着改变PAGES的值，看看编译器如何打印不同位数的数 字。 接下来看看浮点型格式。请输入、编译并运行程序清单4.8中的程序。 程序清单 4.8 floats.c 程序 // floats.c \u0026ndash; 一些浮点型修饰符的组合 #include \u0026lt;stdio.h\u0026gt; int main(void) { const double RENT = 3852.99; // const变量 printf(\u0026quot;%f\\n\u0026quot;, RENT); printf(\u0026quot;%e\\n\u0026quot;, RENT); printf(\u0026quot;%4.2f\\n\u0026quot;, RENT); printf(\u0026quot;%3.1f\\n\u0026quot;, RENT); printf(\u0026quot;%10.3f\\n\u0026quot;, RENT); printf(\u0026quot;%10.3E\\n\u0026quot;, RENT); printf(\u0026quot;%+4.2f\\n\u0026quot;, RENT);\nprintf(\u0026quot;%010.2f\\n\u0026quot;, RENT); return 0; } 该程序中使用了const关键字，限定变量为只读。该程序的输出如下： 3852.990000 3.852990e+03 3852.99 3853.0\n3852.990* 3.853E+03* +3852.99 0003852.99 本例的第 1 个转换说明是%f。在这种情况下，字段宽度和小数点后面的 位数均为系统默认设置，即字段宽度是容纳带打印数字所需的位数和小数点 后打印 6 位数字。 第 2 个转换说明是%e。默认情况下，编译器在小数点的左侧打印 1 个数 字，在小数点的右侧打印 6 个数字。这样打印的数字太多！解决方案是指定 小数点右侧显示的位数，程序中接下来的 4 个例子就是这样做的。请注意， 第 4 个和第 6 个例子对输出结果进行了四舍五入。另外，第 6 个例子用E代替 了e。 第 7 个转换说明中包含了+标记，这使得打印的值前面多了一个代数符 号（+）。 0 标记使得打印的值前面以 0 填充以满足字段要求。注意，转换说 明%010.2f的第 1 个 0 是标记，句点（.）之前、标记之后的数字（本例为 10 ） 是指定的字段宽度。尝试修改RENT的值，看看编译器如何打印不同大小的 值。程序清单4.9演示了其他组合。 程序清单 4.9 flags.c 程序 /* flags.c \u0026ndash; 演示一些格式标记 / #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026quot;%x %X %#x\\n\u0026quot;, 31, 31, 31); printf(\u0026quot;%d% d*% d**\\n\u0026quot;, 42, 42, -42); printf(\u0026quot;%5d%5.3d**%05d**%05.3d**\\n\u0026quot;, 6, 6, 6, 6); return 0; } 该程序的输出如下： 1f 1F 0x1f 42 42**-42** ** 6** 00600006 006** 第 1 行输出中，1f是十六进制数，等于十进制数 31 。第 1 行printf()语句 中，根据%x打印出1f，%F打印出1F，%#x打印出0x1f。 第 2 行输出演示了如何在转换说明中用空格在输出的正值前面生成前导\n空格，负值前面不产生前导空格。这样的输出结果比较美观，因为打印出来 # 的正值和负值在相同字段宽度下的有效数字位数相同。 # 第 3 行输出演示了如何在整型格式中使用精度（%5.3d）生成足够的前 导 0 以满足最小位数的要求（本例是 3 ）。然而，使用 0 标记会使得编译器用 前导 0 填充满整个字段宽度。最后，如果 0 标记和精度一起出现， 0 标记会被 忽略。 下面来看看字符串格式的示例。考虑程序清单4.10中的程序。 程序清单 4.10 stringf.c 程序 /* stringf.c \u0026ndash; 字符串格式 */ #include \u0026lt;stdio.h\u0026gt; #define BLURB \u0026ldquo;Authentic imitation!\u0026rdquo; int main(void) { printf(\u0026quot;[%2s]\\n\u0026quot;, BLURB); printf(\u0026quot;[%24s]\\n\u0026quot;, BLURB); printf(\u0026quot;[%24.5s]\\n\u0026quot;, BLURB); printf(\u0026quot;[%-24.5s]\\n\u0026quot;, BLURB); return 0; } 该程序的输出如下：\n[Authentic imitation!] [ Authentic imitation!] [ Authe] [Authe ] 注意，虽然第 1 个转换说明是%2s，但是字段被扩大为可容纳字符串中 的所有字符。还需注意，精度限制了待打印字符的个数。.5告诉printf()只打 印 5 个字符。另外，-标记使得文本左对齐输出。\n2. 学以致用 学习完以上几个示例，试试如何用一个语句打印以下格式的内容： The NAME family just may be $XXX.XX dollars richer! 这里，NAME和XXX.XX代表程序中变量（如name[40]和cash）的值。 可参考以下代码： printf(\u0026ldquo;The %s family just may be $%.2f richer!\\n\u0026rdquo;,name,cash);\n4.4.4 转换说明的意义 # 下面深入探讨一下转换说明的意义。转换说明把以二进制格式储存在计 # 算机中的值转换成一系列字符（字符串）以便于显示。例如，数字 76 在计算 # 机内部的存储格式是二进制数 01001100 。%d转换说明将其转换成字符 7 和 6 ，并显示为 76 ；%x转换说明把相同的值（ 01001100 ）转换成十六进制记数 法4c；%c转换说明把 01001100 转换成字符L。 转换（conversion）可能会误导读者认为原始值被转替换成转换后的 值。实际上，转换说明是翻译说明，%d的意思是“把给定的值翻译成十进制 整数文本并打印出来”。\n1. 转换不匹配 # 前面强调过，转换说明应该与待打印值的类型相匹配。通常都有多种选 # 择。例如，如果要打印一个int类型的值，可以使用%d、%x或%o。这些转换 说明都可用于打印int类型的值，其区别在于它们分别表示一个值的形式不 同。类似地，打印double类型的值时，可使用%f、%e或%g。 转换说明与待打印值的类型不匹配会怎样？上一章中介绍过不匹配导致 的一些问题。匹配非常重要，一定要牢记于心。程序清单4.11演示了一些不 匹配的整型转换示例。 程序清单 4.11 intconv.c 程序 /* intconv.c \u0026ndash; 一些不匹配的整型转换 */ #include \u0026lt;stdio.h\u0026gt; #define PAGES 336 #define WORDS 65618 int main(void) { short num = PAGES; short mnum = -PAGES; printf(\u0026ldquo;num as short and unsigned short: %hd %hu\\n\u0026rdquo;, num,num); printf(\u0026quot;-num as short and unsigned short: %hd %hu\\n\u0026quot;, mnum,mnum); printf(\u0026ldquo;num as int and char: %d %c\\n\u0026rdquo;, num, num); printf(\u0026ldquo;WORDS as int, short, and char: %d %hd %c\\n\u0026rdquo;,WORDS,WORDS,\nWORDS); # return 0; } 在我们的系统中，该程序的输出如下： num as short and unsigned short: 336 336 -num as short and unsigned short: -336 65200 num as int and char: 336 P WORDS as int, short, and char: 65618 82 R 请看输出的第 1 行，num变量对应的转换说明%hd和%hu输出的结果都是 336 。这没有任何问题。然而，第 2 行mnum变量对应的转换说明%u（无符 号）输出的结果却为 65200 ，并非期望的 336 。这是由于有符号short int类型 的值在我们的参考系统中的表示方式所致。首先，short int的大小是 2 字节； 其次，系统使用二进制补码来表示有符号整数。这种方法，数字 0 ～ 32767 代 表它们本身，而数字 32768 ～ 65535 则表示负数。其中， 65535 表示-1， 65534 表示-2，以此类推。因此，-336表示为 65200 （即， 65536-336）。所以被解 释成有符号int时， 65200 代表-336；而被解释成无符号int时， 65200 则代表 65200 。一定要谨慎！一个数字可以被解释成两个不同的值。尽管并非所有 的系统都使用这种方法来表示负整数，但要注意一点：别期望用%u转换说 明能把数字和符号分开。 第 3 行演示了如果把一个大于 255 的值转换成字符会发生什么情况。在我 们的系统中，short int是 2 字节，char是 1 字节。当printf()使用%c打印 336 时， 它只会查看储存 336 的 2 字节中的后 1 字节。这种截断（见图4.8）相当于用一 个整数除以 256 ，只保留其余数。在这种情况下，余数是 80 ，对应的ASCII值 是字符P。用专业术语来说，该数字被解释成“以 256 为模”（modulo 256）， 即该数字除以 256 后取其余数。\n图4.8 把 336 转换成字符 最后，我们在该系统中打印比short int类型最大整数（ 32767 ）更大的整 数（ 65618 ）。这次，计算机也进行了求模运算。在本系统中，应把数字 65618 储存为 4 字节的int类型值。用%hd转换说明打印时， printf()只使用最后 2 个字节。这相当于 65618 除以 65536 的余数。这里，余数是 82 。鉴于负数的 储存方法，如果余数在 32767 ～ 65536 范围内会被打印成负数。对于整数大小 不同的系统，相应的处理行为类似，但是产生的值可能不同。 混淆整型和浮点型，结果更奇怪。考虑程序清单4.12。 程序清单 4.12 floatcnv.c 程序 /* floatcnv.c \u0026ndash; 不匹配的浮点型转换 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { float n1 = 3.0; double n2 = 3.0; long n3 = 2000000000; long n4 = 1234567890; printf(\u0026quot;%.1e %.1e %.1e %.1e\\n\u0026quot;, n1, n2, n3, n4);\nprintf(\u0026quot;%ld %ld\\n\u0026quot;, n3, n4); printf(\u0026quot;%ld %ld %ld %ld\\n\u0026quot;, n1, n2, n3, n4); return 0; } 在我们的系统中，该程序的输出如下： 3.0e+00 3.0e+00 3.1e+46 1.7e+266 2000000000 1234567890 0 1074266112 0 1074266112 第 1 行输出显示，%e转换说明没有把整数转换成浮点数。考虑一下，如 果使用%e转换说明打印n3（long类型）会发生什么情况。首先，%e转换说 明让printf()函数认为待打印的值是double类型（本系统中double为 8 字节）。 当printf()查看n3（本系统中是 4 字节的值）时，除了查看n3的 4 字节外，还会 查看查看n3相邻的 4 字节，共 8 字节单元。接着，它将 8 字节单元中的位组合 解释成浮点数（如，把一部分位组合解释成指数）。因此，即使n3的位数正 确，根据%e转换说明和%ld转换说明解释出来的值也不同。最终得到的结果 是无意义的值。 第 1 行也说明了前面提到的内容：float类型的值作为printf()参数时会被 转换成double类型。在本系统中，float是 4 字节，但是为了printf()能正确地显 示该值，n1被扩成 8 字节。 第 2 行输出显示，只要使用正确的转换说明，printf()就可以打印n3和 n4。 第 3 行输出显示，如果printf()语句有其他不匹配的地方，即使用对了转 换说明也会生成虚假的结果。用%ld转换说明打印浮点数会失败，但是在这 里，用%ld打印long类型的数竟然也失败了！问题出在C如何把信息传递给函\n数。具体情况因编译器实现而异。“参数传递”框中针对一个有代表性的系统 # 进行了讨论。 # 参数传递 # 参数传递机制因实现而异。下面以我们的系统为例，分析参数传递的原 # 理。函数调用如下： # printf(\u0026quot;%ld %ld %ld %ld\\n\u0026quot;, n1, n2, n3, n4); 该调用告诉计算机把变量n1、n2、、n3和n4的值传递给程序。这是一种 常见的参数传递方式。程序把传入的值放入被称为栈（stack）的内存区域。 计算机根据变量类型（不是根据转换说明）把这些值放入栈中。因此，n1被 储存在栈中，占 8 字节（float类型被转换成double类型）。同样，n2也在栈中 占 8 字节，而n3和n4在栈中分别占 4 字节。然后，控制转到printf()函数。该函 数根据转换说明（不是根据变量类型）从栈中读取值。%ld转换说明表明 printf()应该读取 4 字节，所以printf()读取栈中的前 4 字节作为第 1 个值。这是 n1的前半部分，将被解释成一个long类型的整数。根据下一个%ld转换说 明，printf()再读取 4 字节，这是n1的后半部分，将被解释成第 2 个long类型的 整数（见图4.9）。类似地，根据第 3 个和第 4 个%ld，printf()读取n2的前半部 分和后半部分，并解释成两个long类型的整数。因此，对于n3和n4，虽然用 对了转换说明，但printf()还是读错了字节。 float n1; /* 作为double类型传递 */ double n2; long n3, n4; \u0026hellip; printf(\u0026quot;%ld %ld %ld %ld\\n\u0026quot;, n1, n2, n3, n4);\n图4.9 传递参数 2.printf() 的返回值 第 2 章提到过，大部分C函数都有一个返回值，这是函数计算并返回给 主调程序（calling program）的值。例如，C库包含一个sqrt()函数，接受一 个数作为参数，并返回该数的平方根。可以把返回值赋给变量，也可以用于 计算，还可以作为参数传递。总之，可以把返回值像其他值一样使用。 printf()函数也有一个返回值，它返回打印字符的个数。如果有输出错误， printf()则返回一个负值（printf()的旧版本会返回不同的值）。\nprintf()的返回值是其打印输出功能的附带用途，通常很少用到，但在检 查输出错误时可能会用到（如，在写入文件时很常用）。如果一张已满的 CD或DVD拒绝写入时，程序应该采取相应的行动，例如终端蜂鸣 30 秒。不 过，要实现这种情况必须先了解if语句。程序清单4.13演示了如何确定函数 的返回值。 程序清单 4.13 prntval.c 程序 /* prntval.c \u0026ndash; printf()的返回值 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int bph2o = 212; int rv; rv = printf(\u0026quot;%d F is water\u0026rsquo;s boiling point.\\n\u0026quot;, bph2o); printf(\u0026ldquo;The printf() function printed %d characters.\\n\u0026rdquo;, rv); return 0; } 该程序的输出如下： 212 F is water\u0026rsquo;s boiling point. The printf() function printed 32 characters.\n首先，程序用rv = printf(\u0026hellip;);的形式把printf()的返回值赋给rv。因此，该 语句执行了两项任务：打印信息和给变量赋值。其次，注意计算针对所有字 符数，包括空格和不可见的换行符（\\n）。\n3. 打印较长的字符串 有时，printf()语句太长，在屏幕上不方便阅读。如果空白（空格、制表 符、换行符）仅用于分隔不同的部分，C 编译器会忽略它们。因此，一条语 句可以写成多行，只需在不同部分之间输入空白即可。例如，程序清单4.13 中的一条printf()语句： printf(\u0026ldquo;The printf() function printed %d characters.\\n\u0026rdquo;, rv); 该语句在逗号和 rv之间断行。为了让读者知道该行未完，示例缩进了 rv。C编译器会忽略多余的空白。 但是，不能在双引号括起来的字符串中间断行。如果这样写： printf(\u0026ldquo;The printf() function printed %d characters.\\n\u0026rdquo;, rv); C编译器会报错：字符串常量中有非法字符。在字符串中，可以使用\\n 来表示换行字符，但是不能通过按下Enter（或Return）键产生实际的换行 符。 给字符串断行有 3 种方法，如程序清单4.14所示。 程序清单 4.14 longstrg.c 程序 /* longstrg.c ––打印较长的字符串 */ #include \u0026lt;stdio.h\u0026gt;\nint main(void) { printf(\u0026ldquo;Here\u0026rsquo;s one way to print a \u0026ldquo;); printf(\u0026ldquo;long string.\\n\u0026rdquo;); printf(\u0026ldquo;Here\u0026rsquo;s another way to print a long string.\\n\u0026rdquo;); printf(\u0026ldquo;Here\u0026rsquo;s the newest way to print a \u0026quot; \u0026ldquo;long string.\\n\u0026rdquo;); /* ANSI C */ return 0; } 该程序的输出如下： Here\u0026rsquo;s one way to print a long string. Here\u0026rsquo;s another way to print a long string. Here\u0026rsquo;s the newest way to print a long string. 方法 1 ：使用多个printf()语句。因为第 1 个字符串没有以\\n字符结束，所 以第 2 个字符串紧跟第 1 个字符串末尾输出。 方法 2 ：用反斜杠（\\）和Enter（或Return）键组合来断行。这使得光标 移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。 但是，下一行代码必须和程序清单中的代码一样从最左边开始。如果缩进该 行，比如缩进 5 个空格，那么这 5 个空格就会成为字符串的一部分。\n方法 3 ：ANSI C引入的字符串连接。在两个用双引号括起来的字符串之 # 间用空白隔开，C编译器会把多个字符串看作是一个字符串。因此，以下 3 # 种形式是等效的： # printf(\u0026ldquo;Hello, young lovers, wherever you are.\u0026rdquo;); printf(\u0026ldquo;Hello, young \u0026quot; \u0026ldquo;lovers\u0026rdquo; \u0026ldquo;, wherever you are.\u0026rdquo;); printf(\u0026ldquo;Hello, young lovers\u0026rdquo; \u0026ldquo;, wherever you are.\u0026rdquo;); 上述方法中，要记得在字符串中包含所需的空格。 如，\u0026ldquo;young\u0026quot;\u0026ldquo;lovers\u0026quot;会成为\u0026quot;younglovers\u0026rdquo;，而\u0026quot;young \u0026quot; \u0026ldquo;lovers\u0026quot;才是\u0026quot;young lovers\u0026rdquo;。\n4.4.5 使用 scanf() # 刚学完输出，接下来我们转至输入——学习scanf()函数。C库包含了多 个输入函数，scanf()是最通用的一个，因为它可以读取不同格式的数据。当 然，从键盘输入的都是文本，因为键盘只能生成文本字符：字母、数字和标 点符号。如果要输入整数 2014 ，就要键入字符 2 、 0 、 1 、 4 。如果要将其储 存为数值而不是字符串，程序就必须把字符依次转换成数值，这就是scanf() 要做的。scanf()把输入的字符串转换成整数、浮点数、字符或字符串，而 printf()正好与它相反，把整数、浮点数、字符和字符串转换成显示在屏幕上 的文本。 scanf()和 printf()类似，也使用格式字符串和参数列表。scanf()中的格式 字符串表明字符输入流的目标数据类型。两个函数主要的区别在参数列表 中。printf()函数使用变量、常量和表达式，而scanf()函数使用指向变量的指 针。这里，读者不必了解如何使用指针，只需记住以下两条简单的规则： 如果用scanf()读取基本变量类型的值，在变量名前加上一个\u0026amp;；\n如果用scanf()把字符串读入字符数组中，不要使用\u0026amp;。 程序清单4.15中的小程序演示了这两条规则。 程序清单 4.15 input.c 程序 // input.c \u0026ndash; 何时使用\u0026amp; #include \u0026lt;stdio.h\u0026gt; int main(void) { int age; // 变量 float assets; // 变量 char pet[30]; // 字符数组，用于储存字符串 printf(\u0026ldquo;Enter your age, assets, and favorite pet.\\n\u0026rdquo;); scanf(\u0026quot;%d %f\u0026rdquo;, \u0026amp;age, \u0026amp;assets); // 这里要使用\u0026amp; scanf(\u0026quot;%s\u0026rdquo;, pet); // 字符数组不使用\u0026amp; printf(\u0026quot;%d $%.2f %s\\n\u0026rdquo;, age, assets, pet); return 0; } 下面是该程序与用户交互的示例： Enter your age, assets, and favorite pet. 38\n92360.88 llama 38 $92360.88 llama scanf()函数使用空白（换行符、制表符和空格）把输入分成多个字段。 在依次把转换说明和字段匹配时跳过空白。注意，上面示例的输入项（粗体 部分是用户的输入）分成了两行。只要在每个输入项之间输入至少一个换行 符、空格或制表符即可，可以在一行或多行输入： Enter your age, assets, and favorite pet. 42 2121.45 guppy 42 $2121.45 guppy 唯一例外的是%c转换说明。根据%c，scanf()会读取每个字符，包括空 白。我们稍后详述这部分。 scanf()函数所用的转换说明与printf()函数几乎相同。主要的区别是，对 于float类型和double类型，printf()都使用%f、%e、%E、%g和%G转换说 明。而scanf()只把它们用于float类型，对于double类型时要使用l修饰符。表 4.6列出了C99标准中常用的转换说明。 表4.6 ANSI C中scanf()的转换说明\n可以在表4.6所列的转换说明中（百分号和转换字符之间）使用修饰 # 符。如果要使用多个修饰符，必须按表4.7所列的顺序书写。 # 表4.7 scanf()转换说明中的修饰符 续表 如你所见，使用转换说明比较复杂，而且这些表中还省略了一些特性。 # 省略的主要特性是，从高度格式化源中读取选定数据，如穿孔卡或其他数据 # 记录。因为在本书中，scanf()主要作为与程序交互的便利工具，所以我们不 在书中讨论更复杂的特性。\n1. 从 scanf() 角度看输入 接下来，我们更详细地研究scanf()怎样读取输入。假设scanf()根据一 个%d转换说明读取一个整数。scanf()函数每次读取一个字符，跳过所有的 空白字符，直至遇到第 1 个非空白字符才开始读取。因为要读取整数，所以 scanf()希望发现一个数字字符或者一个符号（+或-）。如果找到一个数字或 符号，它便保存该字符，并读取下一个字符。如果下一个字符是数字，它便 保存该数字并读取下一个字符。scanf()不断地读取和保存字符，直至遇到非 数字字符。如果遇到一个非数字字符，它便认为读到了整数的末尾。然后， scanf()把非数字字符放回输入。这意味着程序在下一次读取输入时，首先读 到的是上一次读取丢弃的非数字字符。最后，scanf()计算已读取数字（可能 还有符号）相应的数值，并将计算后的值放入指定的变量中。 如果使用字段宽度，scanf()会在字段结尾或第 1 个空白字符处停止读取 （满足两个条件之一便停止）。 如果第 1 个非空白字符是A而不是数字，会发生什么情况？scanf()将停在\n那里，并把A放回输入中，不会把值赋给指定变量。程序在下一次读取输入 # 时，首先读到的字符是A。如果程序只使用%d转换说明， scanf()就一直无 法越过A读下一个字符。另外，如果使用带多个转换说明的scanf()，C规定 在第 1 个出错处停止读取输入。 用其他数值匹配的转换说明读取输入和用%d 的情况相同。区别在于 scanf()会把更多字符识别成数字的一部分。例如，%x转换说明要求scanf()识 别十六进制数a～f和A～F。浮点转换说明要求scanf()识别小数点、e记数法 （指数记数法）和新增的p记数法（十六进制指数记数法）。 如果使用%s 转换说明，scanf()会读取除空白以外的所有字符。scanf()跳 过空白开始读取第 1 个非空白字符，并保存非空白字符直到再次遇到空白。 这意味着 scanf()根据%s 转换说明读取一个单词，即不包含空白字符的字符 串。如果使用字段宽度，scanf()在字段末尾或第 1 个空白字符处停止读取。 无法利用字段宽度让只有一个%s的scanf()读取多个单词。最后要注意一点： 当scanf()把字符串放进指定数组中时，它会在字符序列的末尾加上\u0026rsquo;\\0\u0026rsquo;，让数 组中的内容成为一个C字符串。 实际上，在C语言中scanf()并不是最常用的输入函数。这里重点介绍它 是因为它能读取不同类型的数据。C 语言还有其他的输入函数，如 getchar() 和 fgets()。这两个函数更适合处理一些特殊情况，如读取单个字符或包含空 格的字符串。我们将在第 7 章、第 11 章、第 13 章中讨论这些函数。目前，无 论程序中需要读取整数、小数、字符还是字符串，都可以使用scanf()函数。\n2. 格式字符串中的普通字符 scanf()函数允许把普通字符放在格式字符串中。除空格字符外的普通字 符必须与输入字符串严格匹配。例如，假设在两个转换说明中添加一个逗 号： scanf(\u0026quot;%d,%d\u0026rdquo;, \u0026amp;n, \u0026amp;m); scanf()函数将其解释成：用户将输入一个数字、一个逗号，然后再输入\n一个数字。也就是说，用户必须像下面这样进行输入两个整数： # 88,121 # 由于格式字符串中，%d后面紧跟逗号，所以必须在输入 88 后再输入一 个逗号。但是，由于scanf()会跳过整数前面的空白，所以下面两种输入方式 都可以： 88, 121 和 88, 121 格式字符串中的空白意味着跳过下一个输入项前面的所有空白。例如， 对于下面的语句： scanf(\u0026quot;%d ,%d\u0026rdquo;, \u0026amp;n, \u0026amp;m); 以下的输入格式都没问题： 88,121 88 ,121 88 , 121 请注意，“所有空白”的概念包括没有空格的特殊情况。 除了%c，其他转换说明都会自动跳过待输入值前面所有的空白。因 此，scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m)与scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;n, \u0026amp;m)的行为相同。对 于%c，在格式字符串中添加一个空格字符会有所不同。例如，如果把%c放 在格式字符串中的空格前面，scanf()便会跳过空格，从第 1 个非空白字符开 始读取。也就是说，scanf(\u0026quot;%c\u0026quot;, \u0026amp;ch)从输入中的第 1 个字符开始读取，而\nscanf(\u0026quot; %c\u0026quot;, \u0026amp;ch)则从第 1 个非空白字符开始读取。 3.scanf() 的返回值 scanf()函数返回成功读取的项数。如果没有读取任何项，且需要读取一 个数字而用户却输入一个非数值字符串，scanf()便返回 0 。当scanf()检测 到“文件结尾”时，会返回EOF（EOF是stdio.h中定义的特殊值，通常用 #define指令把EOF定义为-1）。我们将在第 6 章中讨论文件结尾的相关内容 以及如何利用scanf()的返回值。在读者学会if语句和while语句后，便可使用 scanf()的返回值来检测和处理不匹配的输入。\n4.4.6 printf() 和 scanf() 的 * 修饰符 # printf()和scanf()都可以使用修饰符来修改转换说明的含义。但是，它 们的用法不太一样。首先，我们来看printf()的修饰符。 如果你不想预先指定字段宽度，希望通过程序来指定，那么可以用修 饰符代替字段宽度。但还是要用一个参数告诉函数，字段宽度应该是多少。 也就是说，如果转换说明是%d，那么参数列表中应包含和 d对应的值。这 个技巧也可用于浮点值指定精度和字段宽度。程序清单4.16演示了相关用 法。 程序清单 4.16 varwid.c 程序 / varwid.c \u0026ndash; 使用变宽输出字段 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { unsigned width, precision; int number = 256;\ndouble weight = 242.5; printf(\u0026ldquo;Enter a field width:\\n\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;width); printf(\u0026ldquo;The number is :%d:\\n\u0026rdquo;, width, number); printf(\u0026ldquo;Now enter a width and a precision:\\n\u0026rdquo;); scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;width, \u0026amp;precision); printf(\u0026ldquo;Weight = %.f\\n\u0026rdquo;, width, precision, weight); printf(\u0026ldquo;Done!\\n\u0026rdquo;); return 0; } 变量width提供字段宽度，number是待打印的数字。因为转换说明中在 d的前面，所以在printf()的参数列表中，width在number的前面。同样，width 和precision提供打印weight的格式化信息。下面是一个运行示例： Enter a field width: 6 The number is : 256: Now enter a width and a precision: 8 3 Weight = 242.500 Done!\n这里，用户首先输入 6 ，因此 6 是程序使用的字段宽度。类似地，接下来 # 用户输入 8 和 3 ，说明字段宽度是 8 ，小数点后面显示 3 位数字。一般而言，程 # 序应根据weight的值来决定这些变量的值。 scanf()中的用法与此不同。把放在%和转换字符之间时，会使得 scanf()跳过相应的输出项。程序清单4.17就是一个例子。 程序清单 4.17 skip2.c 程序 /* skiptwo.c \u0026ndash; 跳过输入中的前两个整数 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; printf(\u0026ldquo;Please enter three integers:\\n\u0026rdquo;); scanf(\u0026quot;%*d %*d %d\u0026quot;, \u0026amp;n); printf(\u0026ldquo;The last integer was %d\\n\u0026rdquo;, n); return 0; } 程序清单4.17中的scanf()指示：跳过两个整数，把第 3 个整数拷贝给n。 下面是一个运行示例： Please enter three integers: 2013 2014 2015\nThe last integer was 2015 在程序需要读取文件中特定列的内容时，这项跳过功能很有用。 4.4.7 printf() 的用法提示 # 想把数据打印成列，指定固定字段宽度很有用。因为默认的字段宽度是 # 待打印数字的宽度，如果同一列中打印的数字位数不同，那么下面的语句： # printf(\u0026quot;%d %d %d\\n\u0026quot;, val1, val2, val3); 打印出来的数字可能参差不齐。例如，假设执行 3 次printf()语句，用户 输入不同的变量，其输出可能是这样： 12 234 1222 4 5 23 22334 2322 10001 使用足够大的固定字段宽度可以让输出整齐美观。例如，若使用下面的 语句： printf(\u0026quot;%9d %9d %9d\\n\u0026quot;, val1, val2, val3); 上面的输出将变成： 12　234　1222 4　5　23 22334　2322　10001 在两个转换说明中间插入一个空白字符，可以确保即使一个数字溢出了 自己的字段，下一个数字也不会紧跟该数字一起输出（这样两个数字看起来 像是一个数字）。这是因为格式字符串中的普通字符（包括空格）会被打印\n出来。 # 另一方面，如果要在文字中嵌入一个数字，通常指定一个小于或等于该 # 数字宽度的字段会比较方便。这样，输出数字的宽度正合适，没有不必要的 # 空白。例如，下面的语句： # printf(\u0026ldquo;Count Beppo ran %.2f miles in 3 hours.\\n\u0026rdquo;, distance); 其输出如下： Count Beppo ran 10.22 miles in 3 hours. 如果把转换说明改为%10.2f，则输出如下： Count Beppo ran 10.22 miles in 3 hours. 本地化设置 美国和世界上的许多地区都使用一个点来分隔十进制值的整数部分和小 数部分，如3.14159。然而，许多其他地区用逗号来分隔，如 3,14159。读者 可能注意到了，printf()和 scanf()都没有提供逗号的转换说明。C语言考虑了 这种情况。本书附录B的参考资料V中介绍了C支持的本地化概念，因此C程 序可以选择特定的本地化设置。例如，如果指定了荷兰语言环境，printf()和 scanf()在显示和读取浮点值时会使用本地惯例（在这种情况下，用逗号代替 点分隔浮点值的整数部分和小数部分）。另外，一旦指定了环境，便可在代 码的数字中使用逗号： double pi = 3,14159; // 荷兰本地化设置 C标准有两个本地化设置：\u0026ldquo;C\u0026quot;和\u0026rdquo;\u0026quot;（空字符串）。默认情况下，程序使 用\u0026quot;C\u0026quot;本地化设置，基本上符合美国的用法习惯。而\u0026quot;\u0026ldquo;本地化设置可以替换 当前系统中使用的本地语言环境。原则上，这与\u0026quot;C\u0026quot;本地化设置相同。事实 上，大部分操作系统（如UNIX、Linux和Windows）都提供本地化设置选项 列表，只不过它们提供的列表可能不同。\n4.5 关键概念 # C语言用char类型表示单个字符，用字符串表示字符序列。字符常量是 一种字符串形式，即用双引号把字符括起来：\u0026ldquo;Good luck, my friend\u0026rdquo;。可以 把字符串储存在字符数组（由内存中相邻的字节组成）中。字符串，无论是 表示成字符常量还是储存在字符数组中，都以一个叫做空字符的隐藏字符结 尾。 在程序中，最好用#define 定义数值常量，用 const 关键字声明的变量为 只读变量。在程序中使用符号常量（明示常量），提高了程序的可读性和可 维护性。 C 语言的标准输入函数（scanf()）和标准输出函数（printf()）都使用一 种系统。在该系统中，第 1 个参数中的转换说明必须与后续参数中的值相匹 配。例如，int转换说明%d与一个浮点值匹配会产生奇怪的结果。必须格外 小心，确保转换说明的数量和类型与函数的其余参数相匹配。对于scanf()， 一定要记得在变量名前加上地址运算符（\u0026amp;）。 空白字符（制表符、空格和换行符）在 scanf()处理输入时起着至关重要 的作用。除了%c 模式（读取下一个字符），scanf()在读取输入时会跳过非 空白字符前的所有空白字符，然后一直读取字符，直至遇到空白字符或与正 在读取字符不匹配的字符。考虑一下，如果scanf()根据不同的转换说明读取 相同的输入行，会发生什么情况。假设有如下输入行： -13.45e12# 0 如果其对应的转换说明是%d，scanf()会读取 3 个字符（-13）并停在小数 点处，小数点将被留在输入中作为下一次输入的首字符。如果其对应的转换 说明是%f，scanf()会读取-13.45e12，并停在#符号处，而#将被留在输入中作 为下一次输入的首字符；然后，scanf()把读取的字符序列-13.45e12转换成相 应的浮点值，并储存在float类型的目标变量中。如果其对应的转换说明 是%s，scanf()会读取-13.45e12#，并停在空格处，空格将被留在输入中作为\n下一次输入的首字符；然后，scanf()把这 10 个字符的字符码储存在目标字符 数组中，并在末尾加上一个空字符。如果其对应的转换说明是%c，scanf() 只会读取并储存第 1 个字符，该例中是一个空格 [4]。\n4.6 本章小结 # 字符串是一系列被视为一个处理单元的字符。在C语言中，字符串是以 # 空字符（ASCII码是 0 ）结尾的一系列字符。可以把字符串储存在字符数组 # 中。数组是一系列同类型的项或元素。下面声明了一个名为name、有 30 个 char类型元素的数组： char name[30]; 要确保有足够多的元素来储存整个字符串（包括空字符）。 字符串常量是用双引号括起来的字符序列，如：\u0026ldquo;This is an example of a string\u0026rdquo;。 scanf()函数（声明在string.h头文件中）可用于获得字符串的长度（末尾 的空字符不计算在内）。scanf()函数中的转换说明是%s时，可读取一个单 词。 C预处理器为预处理器指令（以#符号开始）查找源代码程序，并在开 始编译程序之前处理它们。处理器根据#include指令把另一个文件中的内容 添加到该指令所在的位置。#define指令可以创建明示常量（符号常量），即 代表常量的符号。limits.h和float.h头文件用#define定义了一组表示整型和浮 点型不同属性的符号常量。另外，还可以使用const限定符创建定义后就不 能修改的变量。 printf()和scanf()函数对输入和输出提供多种支持。两个函数都使用格式 字符串，其中包含的转换说明表明待读取或待打印数据项的数量和类型。另 外，可以使用转换说明控制输出的外观：字段宽度、小数位和字段内的布 局。\n4.7 复习题 # 复习题的参考答案在附录A中。 # 1.再次运行程序清单 4.1，但是在要求输入名时，请输入名和姓（根据 # 英文书写习惯，名和姓中间有一个空格），看看会发生什么情况？为什么？ # 2.假设下列示例都是完整程序中的一部分，它们打印的结果分别是什 # 么？ # a.printf(\u0026ldquo;He sold the painting for $%2.2f.\\n\u0026rdquo;, 2.345e2); b.printf(\u0026quot;%c%c%c\\n\u0026rdquo;, \u0026lsquo;H\u0026rsquo;, 105, \u0026lsquo;\\41\u0026rsquo;); c.#define Q \u0026ldquo;His Hamlet was funny without being vulgar.\u0026ldquo;printf(\u0026quot;%s\\nhas %d characters.\\n\u0026rdquo;, Q, strlen(Q)); d.printf(\u0026ldquo;Is %2.2e the same as %2.2f?\\n\u0026rdquo;, 1201.0, 1201.0); 3.在第 2 题的c中，要输出包含双引号的字符串Q，应如何修改？ 4.找出下面程序中的错误。 define B booboo define X 10 main(int) { int age; char name; printf(\u0026ldquo;Please enter your first name.\u0026rdquo;);\nscanf(\u0026quot;%s\u0026rdquo;, name); printf(\u0026ldquo;All right, %c, what\u0026rsquo;s your age?\\n\u0026rdquo;, name); scanf(\u0026quot;%f\u0026quot;, age); xp = age + X; printf(\u0026ldquo;That\u0026rsquo;s a %s! You must be at least %d.\\n\u0026rdquo;, B, xp); rerun 0; } 5.假设一个程序的开头是这样： #define BOOK \u0026ldquo;War and Peace\u0026rdquo; int main(void) { float cost =12.99; float percent = 80.0; 请构造一个使用BOOK、cost和percent的printf()语句，打印以下内容： This copy of \u0026ldquo;War and Peace\u0026rdquo; sells for $12.99. That is 80% of list. 6.打印下列各项内容要分别使用什么转换说明？ a.一个字段宽度与位数相同的十进制整数 b.一个形如8A、字段宽度为 4 的十六进制整数\nc.一个形如232.346、字段宽度为 10 的浮点数 d.一个形如2.33e+002、字段宽度为 12 的浮点数 e.一个字段宽度为 30 、左对齐的字符串 7.打印下面各项内容要分别使用什么转换说明？ a.字段宽度为 15 的unsigned long类型的整数 b.一个形如0x8a、字段宽度为 4 的十六进制整数 c.一个形如2.33E+02、字段宽度为 12 、左对齐的浮点数 d.一个形如+232.346、字段宽度为 10 的浮点数 e.一个字段宽度为 8 的字符串的前 8 个字符 8.打印下面各项内容要分别使用什么转换说明？ a.一个字段宽度为 6 、最少有 4 位数字的十进制整数 b.一个在参数列表中给定字段宽度的八进制整数 c.一个字段宽度为 2 的字符 d.一个形如+3.13、字段宽度等于数字中字符数的浮点数 e.一个字段宽度为 7 、左对齐字符串中的前 5 个字符 9.分别写出读取下列各输入行的scanf()语句，并声明语句中用到变量和 数组。 a.101 b.22.32 8.34E−09\nc.linguini d.catch 22 e.catch 22 （但是跳过catch） 10.什么是空白？ 11.下面的语句有什么问题？如何修正？ printf(\u0026ldquo;The double type is %z bytes..\\n\u0026rdquo;, sizeof(double)); 12.假设要在程序中用圆括号代替花括号，以下方法是否可行？ #define ( { #define ) }\n4.8 编程练习 # 1.编写一个程序，提示用户输入名和姓，然后以“名,姓”的格式打印出 # 来。 # 2.编写一个程序，提示用户输入名和姓，并执行一下操作： # a.打印名和姓，包括双引号； b.在宽度为 20 的字段右端打印名和姓，包括双引号； c.在宽度为 20 的字段左端打印名和姓，包括双引号； d.在比姓名宽度宽 3 的字段中打印名和姓。 3.编写一个程序，读取一个浮点数，首先以小数点记数法打印，然后以 指数记数法打印。用下面的格式进行输出（系统不同，指数记数法显示的位 数可能不同）： a.输入21.3或2.1e+001； b.输入+21.290或2.129E+001； 4.编写一个程序，提示用户输入身高（单位：英寸）和姓名，然后以下 面的格式显示用户刚输入的信息： Dabney, you are 6.208 feet tall 使用float类型，并用/作为除号。如果你愿意，可以要求用户以厘米为 单位输入身高，并以米为单位显示出来。 5.编写一个程序，提示用户输入以兆位每秒（Mb/s）为单位的下载速度 和以兆字节（MB）为单位的文件大小。程序中应计算文件的下载时间。注 意，这里 1 字节等于 8 位。使用float类型，并用/作为除号。该程序要以下面 的格式打印 3 个变量的值（下载速度、文件大小和下载时间），显示小数点\n后面两位数字： # At 18.12 megabits per second, a file of 2.20 megabytes downloads in 0.97 seconds. 6.编写一个程序，先提示用户输入名，然后提示用户输入姓。在一行打 印用户输入的名和姓，下一行分别打印名和姓的字母数。字母数要与相应名 和姓的结尾对齐，如下所示： Melissa Honeybee 7　8 接下来，再打印相同的信息，但是字母个数与相应名和姓的开头对齐， 如下所示： Melissa Honeybee 7　8 7.编写一个程序，将一个double类型的变量设置为1.0/3.0，一个float类 型的变量设置为1.0/3.0。分别显示两次计算的结果各 3 次：一次显示小数点 后面 6 位数字；一次显示小数点后面 12 位数字；一次显示小数点后面 16 位数 字。程序中要包含float.h头文件，并显示FLT_DIG和DBL_DIG的值。1.0/3.0 的值与这些值一致吗？ 8.编写一个程序，提示用户输入旅行的里程和消耗的汽油量。然后计算 并显示消耗每加仑汽油行驶的英里数，显示小数点后面一位数字。接下来， 使用 1 加仑大约3.785升， 1 英里大约为1.609千米，把单位是英里/加仑的值转 换为升/100公里（欧洲通用的燃料消耗表示法），并显示结果，显示小数点 后面 1 位数字。注意，美国采用的方案测量消耗单位燃料的行程（值越大越 好），而欧洲则采用单位距离消耗的燃料测量方案（值越低越好）。使用 #define 创建符号常量或使用 const 限定符创建变量来表示两个转换系数。\n[1].是，在历年的其实，符号常量的概念在C标准中（包括最新的K\u0026amp;R合著的《C11），并没有符号常量的概念，只提C语言程序设计》中介绍过。但 # 到过念的理解不同，有些作者把#define最简单的用法是定义一个#define宏定义实现的“明示常量”。市面上各编程书籍对此概“常量”归为“明示常量”；有 些作者（如，本书的作者）则认为注 “明示常量”相当于“符号常量”。——译者\n[2].译者注注意，在C语言中，用const类型限定符声明的是变量，不是常量。——\n[3].在书中混用这两个术语。再次提醒读者注意，本书作者认为——译者注 “明示常量”相当于“符号常量”，经常\n[4].注意，“ -13.45e12# 0”的负号前面有一个空格。——译者注\n第 5 章 运算符、表达式和语句 # 本章介绍以下内容： # 关键字：while、typedef 运算符：=、-、*、/、%、++、\u0026ndash;、(类型名) C语言的各种运算符，包括用于普通数学运算的运算符 运算符优先级以及语句、表达式的含义 while循环 复合语句、自动类型转换和强制类型转换 如何编写带有参数的函数 现在，读者已经熟悉了如何表示数据，接下来我们学习如何处理数据。 C 语言为处理数据提供了大量的操作，可以在程序中进行算术运算、比较值 的大小、修改变量、逻辑地组合关系等。我们先从基本的算术运算（加、 减、乘、除）开始。 组织程序是处理数据的另一个方面，让程序按正确的顺序执行各个步 骤。C 有许多语言特性，帮助你完成组织程序的任务。循环就是其中一个特 性，本章中你将窥其大概。循环能重复执行行为，让程序更有趣、更强大。\n5.1 循环简介 # 程序清单5.1是一个简单的程序示例，该程序进行了简单的运算，计算 # 穿 9 码男鞋的脚长（单位：英寸）。为了让读者体会循环的好处，程序的第 1 # 个版本演示了不使用循环编程的局限性。 # 程序清单 5.1 shoes1.c 程序 /* shoes1.c -- 把鞋码转换成英寸 */ #include \u0026lt;stdio.h\u0026gt; #define ADJUST 7.31 // 字符常量 int main(void) { const double SCALE = 0.333;// const变量 double shoe, foot; shoe = 9.0; foot = SCALE * shoe + ADJUST; printf(\u0026#34;Shoe size (men\u0026#39;s) foot length\\n\u0026#34;); printf(\u0026#34;%10.1f %15.2f inches\\n\u0026#34;, shoe, foot); return 0; } 该程序的输出如下： Shoe size (men\u0026rsquo;s) foot length 9.0 10.31 inches 该程序演示了用#define 指令创建符号常量和用 const 限定符创建在程序 运行过程中不可更改的变量。程序使用了乘法和加法，假定用户穿 9 码的 鞋，以英寸为单位打印用户的脚长。你可能会说：“这太简单了，我用笔算 比敲程序还要快。”说得没错。写出来的程序只使用一次（本例即只根据一 只鞋的尺码计算一次脚长），实在是浪费时间和精力。如果写成交互式程序 会更有用，但是仍无法利用计算机的优势。 应该让计算机做一些重复计算的工作。毕竟，需要重复计算是使用计算 机的主要原因。C 提供多种方法做重复计算，我们在这里简单介绍一种—— while循环。它能让你对运算符做更有趣地探索。程序清单5.2演示了用循环 改进后的程序。 程序清单 5.2 shoes2.c 程序 /* shoes2.c \u0026ndash; 计算多个不同鞋码对应的脚长 */ #include \u0026lt;stdio.h\u0026gt; #define ADJUST 7.31 // 字符常量 int main(void) { const double SCALE = 0.333;// const变量 double shoe, foot; printf(\u0026ldquo;Shoe size (men\u0026rsquo;s) foot length\\n\u0026rdquo;); shoe = 3.0;\nwhile (shoe \u0026lt; 18.5) /* while循环开始 / { / 块开始　/ foot = SCALE * shoe + ADJUST; printf(\u0026quot;%10.1f %15.2f inches\\n\u0026quot;, shoe, foot); shoe = shoe + 1.0; } / 块结束　*/ printf(\u0026ldquo;If the shoe fits, wear it.\\n\u0026rdquo;); return 0; } 下面是shoes2.c程序的输出（\u0026hellip;表示并未显示完整，有删节）： Shoe size (men\u0026rsquo;s) foot length 3.0 8.31 inches 4.0 8.64 inches 5.0 8.97 inches 6.0 9.31 inches \u0026hellip; 16.0 12.64 inches 17.0 12.97 inches 18.0 13.30 inches\nIf the shoe fits, wear it. （如果读者对此颇有研究，应该知道该程序不符合实际情况。程序中假 定了一个统一的鞋码系统。） 下面解释一下while循环的原理。当程序第 1 次到达while循环时，会检查 圆括号中的条件是否为真。该程序中，条件表达式如下： shoe \u0026lt; 18.5 符号\u0026lt;的意思是小于。变量shoe被初始化为3.0，显然小于18.5。因此， 该条件为真，程序进入块中继续执行，把尺码转换成英寸。然后打印计算的 结果。下一条语句把 shoe增加1.0，使shoe的值为4.0： shoe = shoe + 1.0; 此时，程序返回while入口部分检查条件。为何要返回while的入口部 分？因为上面这条语句的下面是右花括号（}），代码使用一对花括号 （{}）来标出while循环的范围。花括号之间的内容就是要被重复执行的内 容。花括号以及被花括号括起来的部分被称为块（block）。现在，回到程 序中。因为 4 小于18.5，所以要重复执行被花括号括起来的所有内容（用计 算机术语来说就是，程序循环这些语句）。该循环过程一直持续到shoe的值 为19.0。此时，由于19.0小于18.5，所以该条件为假： shoe \u0026lt; 18.5 出现这种情况后，控制转到紧跟while循环后面的第 1 条语句。该例中， 是最后的printf()语句。 可以很方便地修改该程序用于其他转换。例如，把SCALE设置成1.8、 ADJUST设置成32.0，该程序便可把摄氏温度转换成华氏温度；把SCALE设 置成0.6214、ADJUST设置成 0 ，该程序便可把公里转换成英里。注意，修改 了设置后，还要更改打印的消息，以免前后表述不一。\n通过while循环能便捷灵活地控制程序。现在，我们来学习程序中会用 到的基本运算符。\n5.2 基本运算符 # C用运算符（operator）表示算术运算。例如，+运算符使在它两侧的值 加在一起。如果你觉得术语“运算符”很奇怪，那么请记住东西总得有个名 称。与其叫“那些东西”或“运算处理符”，还不如叫“运算符”。现在，我们介 绍一下用于基本算术运算的运算符：=、+、-、*和/（C 没有指数运算符。 不过，C 的标准数学库提供了一个pow()函数用于指数运算。例如，pow(3.5, 2.2)返回3.5的2.2次幂）。\n5.2.1 赋值运算符： = # 在C语言中，=并不意味着“相等”，而是一个赋值运算符。下面的赋值 # 表达式语句： # bmw = 2002; 把值 2002 赋给变量bmw。也就是说，=号左侧是一个变量名，右侧是赋 给该变量的值。符号=被称为赋值运算符。另外，上面的语句不读作“bmw等 于2002”，而读作“把值 2002 赋给变量bmw”。赋值行为从右往左进行。 也许变量名和变量值的区别看上去微乎其微，但是，考虑下面这条常用 的语句： i = i + 1; 对数学而言，这完全行不通。如果给一个有限的数加上 1 ，它不可 能“等于”原来的数。但是，在计算机赋值表达式语句中，这很合理。该语句 的意思是：找出变量 i 的值，把该值加 1 ，然后把新值赋值变量i（见图 5.1）。\n图5.1 语句i = i + 1; 在C语言中，类似这样的语句没有意义（实际上是无效的）： 2002 = bmw; 因为在这种情况下， 2002 被称为右值（rvale），只能是字面常量。不 能给常量赋值，常量本身就是它的值。因此，在编写代码时要记住，=号左 侧的项必须是一个变量名。实际上，赋值运算符左侧必须引用一个存储位 置。最简单的方法就是使用变量名。不过，后面章节还会介绍“指针”，可用 于指向一个存储位置。概括地说，C 使用可修改的左值（modifiable lvalue） 标记那些可赋值的实体。也许“可修改的左值”不太好懂，我们再来看一些定 义。 几个术语：数据对象、左值、右值和运算符 赋值表达式语句的目的是把值储存到内存位置上。用于储存值的数据存 储区域统称为数据对象（data object）。C 标准只有在提到这个概念时才会 用到对象这个术语。使用变量名是标识对象的一种方法。除此之外，还有其 他方法，但是要在后面的章节中才学到。例如，可以指定数组的元素、结构 的成员，或者使用指针表达式（指针中储存的是它所指向对象的地址）。左 值（lvalue）是 C 语言的术语，用于标识特定数据对象的名称或表达式。因 此，对象指的是实际的数据存储，而左值是用于标识或定位存储位置的标 签。 对于早期的C语言，提到左值意味着： 1.它指定一个对象，所以引用内存中的地址；\n2.它可用在赋值运算符的左侧，左值（lvalue）中的l源自left。 但是后来，标准中新增了const限定符。用const创建的变量不可修改。 因此，const标识符满足上面的第 1 项，但是不满足第 2 项。一方面C继续把标 识对象的表达式定义为左值，一方面某些左值却不能放在赋值运算符的左 侧。有些左值不能用于赋值运算符的左侧。此时，标准对左值的定义已经不 能满足当前的状况。 为此，C标准新增了一个术语：可修改的左值（modifiable lvalue），用 于标识可修改的对象。所以，赋值运算符的左侧应该是可修改的左值。当前 标准建议，使用术语对象定位值（object locator value）更好。 右值（rvalue）指的是能赋值给可修改左值的量，且本身不是左值。例 如，考虑下面的语句： bmw = 2002; 这里，bmw是可修改的左值， 2002 是右值。读者也许猜到了，右值中的 r源自right。右值可以是常量、变量或其他可求值的表达式（如，函数调 用）。实际上，当前标准在描述这一概念时使用的是表达式的值（value of an expression），而不是右值。 我们看几个简单的示例： int ex; int why; int zee; const int TWO = 2; why = 42; zee = why;\nex = TWO * (why + zee); 这里，ex、why和zee都是可修改的左值（或对象定位值），它们可用于 赋值运算符的左侧和右侧。TWO是不可改变的左值，它只能用于赋值运算 符的右侧（在该例中，TWO被初始化为 2 ，这里的=运算符表示初始化而不 是赋值，因此并未违反规则）。同时， 42 是右值，它不能引用某指定内存 位置。另外，why和 zee 是可修改的左值，表达式(why + zee)是右值，该表 达式不能表示特定内存位置，而且也不能给它赋值。它只是程序计算的一个 临时值，在计算完毕后便会被丢弃。 在学习名称时，被称为“项”（如，赋值运算符左侧的项）的就是运算对 象（operand）。运算对象是运算符操作的对象。例如，可以把吃汉堡描述 为：“吃”运算符操作“汉堡”运算对象。类似地可以说，=运算符的左侧运算 对象应该是可修改的左值。 C的基本赋值运算符有些与众不同，请看程序清单5.3。 程序清单 5.3 golf.c 程序 /* golf.c \u0026ndash; 高尔夫锦标赛记分卡 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int jane, tarzan, cheeta; cheeta = tarzan = jane = 68; printf(\u0026quot; cheeta tarzan jane\\n\u0026quot;); printf(\u0026ldquo;First round score %4d %8d %8d\\n\u0026rdquo;, cheeta, tarzan, jane);\nreturn 0; } 许多其他语言都会回避该程序中的三重赋值，但是C完全没问题。赋值 的顺序是从右往左：首先把 86 赋给jane，然后再赋给tarzan，最后赋给 cheeta。因此，程序的输出如下： cheetah tarzan jane First round score 68　68　68\n5.2.2 加法运算符： + # 加法运算符（addition operator）用于加法运算，使其两侧的值相加。例 如，语句： printf(\u0026quot;%d\u0026quot;, 4 + 20); 打印的是 24 ，而不是表达式 4 + 20 相加的值（运算对象）可以是变量，也可以是常量。因此，执行下面的 语句： income = salary + bribes; 计算机会查看加法运算符右侧的两个变量，把它们相加，然后把和赋给 变量income。 在此提醒读者注意，income、salary和bribes都是可修改的左值。因为每 个变量都标识了一个可被赋值的数据对象。但是，表达式salary + brives是一 个右值。\n5.2.3 减法运算符： - # 减法运算符（subtraction operator）用于减法运算，使其左侧的数减去右 侧的数。例如，下面的语句把200.0赋给takehome： takehome = 224.00 – 24.00; +和-运算符都被称为二元运算符（binary operator），即这些运算符需要 两个运算对象才能完成操作。\n5.2.4 符号运算符： - 和 + # 减号还可用于标明或改变一个值的代数符号。例如，执行下面的语句 # 后，smokey的值为 12 ： rocky = –12; smokey = –rocky;以这种方式使用的负号被称为一元运算符（unary operator）。一元运算符只需要一个运算对象（见图5.2）。 C90标准新增了一元+运算符，它不会改变运算对象的值或符号，只能 这样使用： dozen = +12; 编译器不会报错。但是在以前，这样做是不允许的。\n图5.2 一元和二元运算符 5.2.5 乘法运算符： * # 符号*表示乘法。下面的语句用2.54乘以inch，并将结果赋给cm： cm = 2.54 * inch; C没有平方函数，如果要打印一个平方表，怎么办？如程序清单5.4所 示，可以使用乘法来计算平方。 程序清单 5.4 squares.c 程序\n/* squares.c \u0026ndash; 计算 1 ～ 20 的平方 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int num = 1; while (num \u0026lt; 21) { printf(\u0026quot;%4d %6d\\n\u0026quot;, num, num * num); num = num + 1; } return 0; } 该程序打印数字 1 ～ 20 及其平方。接下来，我们再看一个更有趣的例 子。\n1. 指数增长 读者可能听过这样一个故事，一位强大的统治者想奖励做出突出贡献的 学者。他问这位学者想要什么，学者指着棋盘说，在第 1 个方格里放 1 粒小 麦、第 2 个方格里放 2 粒小麦、第 3 个方格里放 4 粒小麦，第 4 个方格里放 8 粒 小麦，以此类推。这位统治者不熟悉数学，很惊讶学者竟然提出如此谦虚的 要求。因为他原本准备奖励给学者一大笔财产。如果程序清单5.5运行的结 果正确，这显然是跟统治者开了一个玩笑。程序计算出每个方格应放多少小 麦，并计算了总数。可能大多数人对小麦的产量不熟悉，该程序以谷粒数为\n单位，把计算的小麦总数与粗略估计的世界小麦年产量进行了比较。 # 程序清单 5.5 wheat.c 程序 /* wheat.c -- 指数增长 */ #include \u0026lt;stdio.h\u0026gt; #define SQUARES 64 // 棋盘中的方格数 int main(void) { const double CROP = 2E16; // 世界小麦年产谷粒数 double current, total; int count = 1; printf(\u0026#34;square grains total \u0026#34;); printf(\u0026#34;fraction of \\n\u0026#34;); printf(\u0026#34; added grains \u0026#34;); printf(\u0026#34;world total\\n\u0026#34;); total = current = 1.0; /* 从 1 颗谷粒开始　*/ printf(\u0026#34;%4d %13.2e %12.2e %12.2e\\n\u0026#34;, count, current, total, total / CROP); while (count \u0026lt; SQUARES) { count = count + 1; current = 2.0 * current; /* 下一个方格谷粒翻倍 / total = total + current; / 更新总数 */ printf(\u0026quot;%4d %13.2e %12.2e %12.2e\\n\u0026quot;, count, current, total, total / CROP); } printf(\u0026ldquo;That\u0026rsquo;s all.\\n\u0026rdquo;); return 0; } 程序的输出结果如下： square grains total fraction of added grains world total 1　1.00e+00 1.00e+00 5.00e-17 2　2.00e+00 3.00e+00 1.50e-16 3　4.00e+00 7.00e+00 3.50e-16 4　8.00e+00 1.50e+01 7.50e-16 5　1.60e+01 3.10e+01 1.55e-15 6　3.20e+01 6.30e+01 3.15e-15 7　6.40e+01 1.27e+02 6.35e-15\n8　1.28e+02 2.55e+02 1.27e-14 9　2.56e+02 5.11e+02 2.55e-14 10　5.12e+02 1.02e+03 5.12e-14 10 个方格以后，该学者得到的小麦仅超过了 1000 粒。但是，看看 55 个方 格的小麦数是多少： 55　1.80e+16 3.60e+16 1.80e+00 总量已超过了世界年产量！不妨自己动手运行该程序，看看第 64 个方格 有多少小麦。 这个程序示例演示了指数增长的现象。世界人口增长和我们使用的能源 都遵循相同的模式。\n5.2.6 除法运算符： / # C使用符号/来表示除法。/左侧的值是被除数，右侧的值是除数。例 # 如，下面four的值是4.0： four = 12.0/3.0; 整数除法和浮点数除法不同。浮点数除法的结果是浮点数，而整数除法 的结果是整数。整数是没有小数部分的数。这使得 5 除以 3 很让人头痛，因为 实际结果有小数部分。在C语言中，整数除法结果的小数部分被丢弃，这一 过程被称为截断（truncation）。 运行程序清单5.6中的程序，看看截断的情况，体会整数除法和浮点数 除法的区别。 程序清单 5.6 divide.c 程序 /* divide.c \u0026ndash; 演示除法 */\n#include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026ldquo;integer division: 5/4 is %d \\n\u0026rdquo;, 5　/ 4); printf(\u0026ldquo;integer division: 6/3 is %d \\n\u0026rdquo;, 6　/ 3); printf(\u0026ldquo;integer division: 7/4 is %d \\n\u0026rdquo;, 7　/ 4); printf(\u0026ldquo;floating division: 7./4. is %1.2f \\n\u0026rdquo;, 7. / 4.); printf(\u0026ldquo;mixed division: 7./4 is %1.2f \\n\u0026rdquo;, 7. / 4); return 0; } 程序清单5.6中包含一个“混合类型”的示例，即浮点值除以整型值。C相 对其他一些语言而言，在类型管理上比较宽容。尽管如此，一般情况下还是 要避免使用混合类型。该程序的输出如下： integer division: 5/4 is 1 integer division: 6/3 is 2 integer division: 7/4 is 1 floating division: 7./4. is 1.75 mixed division: 7./4 is 1.75 注意，整数除法会截断计算结果的小数部分（丢弃整个小数部分），不 会四舍五入结果。混合整数和浮点数计算的结果是浮点数。实际上，计算机\n不能真正用浮点数除以整数，编译器会把两个运算对象转换成相同的类型。 # 本例中，在进行除法运算前，整数会被转换成浮点数。 # C99标准以前，C语言给语言的实现者留有一些空间，让他们来决定如 # 何进行负数的整数除法。一种方法是，舍入过程采用小于或等于浮点数的最 # 大整数。当然，对于3.8而言，处理后的 3 符合这一描述。但是-3.8 会怎样？ # 该方法建议四舍五入为-4，因为-4 小于-3.8.但是，另一种舍入方法是直接丢 # 弃小数部分。这种方法被称为“趋零截断”，即把-3.8转换成-3。在C99以前， # 不同的实现采用不同的方法。但是C99规定使用趋零截断。所以，应把-3.8 # 转换成-3。 # 5.2.7 运算符优先级 # 考虑下面的代码： # butter = 25.0 + 60.0 * n / SCALE; 这条语句中有加法、乘法和除法运算。先算哪一个？是25.0加上60.0， 然后把计算的和85.0乘以n，再把结果除以SCALE？还是60.0乘以n，然后把 计算的结果加上25.0，最后再把结果除以SCALE？还是其他运算顺序？假设 n是6.0，SCALE是2.0，带入语句中计算会发现，第 1 种顺序得到的结果是 255 ，第 2 种顺序得到的结果是192.5。C程序一定是采用了其他的运算顺序， 因为程序运行该语句后，butter的值是205.0。 显然，执行各种操作的顺序很重要。C 语言对此有明确的规定，通过运 算符优先级来解决操作顺序的问题。每个运算符都有自己的优先级。正如普 通的算术运算那样，乘法和除法的优先级比加法和减法高，所以先执行乘法 和除法。如果两个运算符的优先级相同怎么办？如果它们处理同一个运算对 象，则根据它们在语句中出现的顺序来执行。对大多数运算符而言，这种情 况都是按从左到右的顺序进行（=运算符除外）。因此，语句： butter = 25.0 + 60.0 * n / SCALE;\n的运算顺序是： # 60.0 * n　首先计算表达式中的或/（假设n的值是 6 ，所以 60.0n得360.0） 360.0 / SCALE 然后计算表达式中第 2 个*或/ 25.0 + 180　最后计算表达式里第 1 个+或-，结果为205.0（假设 SCALE的值是2.0） 许多人喜欢用表达式树（expression tree）来表示求值的顺序，如图5.3 所示。该图演示了如何从最初的表达式逐步简化为一个值。\n图5.3 用表达式树演示运算符、运算对象和求值顺序 如何让加法运算在乘法运算之前执行？可以这样做： flour = (25.0 + 60.0 * n) / SCALE; 最先执行圆括号中的部分。圆括号内部按正常的规则执行。该例中，先 执行乘法运算，再执行加法运算。执行完圆括号内的表达式后，用运算结果 除以SCALE。\n表5.1总结了到目前为止学过的运算符优先级。 # 表5.1 运算符优先级（从低至高） 注意正号（加号）和负号（减号）的两种不同用法。结合律栏列出了运 # 算符如何与运算对象结合。例如，一元负号与它右侧的量相结合，在除法中 # 用除号左侧的运算对象除以右侧的运算对象。 # 5.2.8 优先级和求值顺序 # 运算符优先级为表达式中的求值顺序提供重要的依据，但是并没有规定 # 所有的顺序。C 给语言的实现者留出选择的余地。考虑下面的语句： # y = 6 * 12 + 5 * 20; 当运算符共享一个运算对象时，优先级决定了求值顺序。例如上面的语 句中， 12 是和+运算符的运算对象。根据运算符的优先级，乘法的优先级比 加法高，所以先进行乘法运算。类似地，先对 5 进行乘法运算而不是加法运 算。简而言之，先进行两个乘法运算6 * 12和5 * 20，再进行加法运算。但 是，优先级并未规定到底先进行哪一个乘法。C 语言把主动权留给语言的实 现者，根据不同的硬件来决定先计算前者还是后者。可能在一种硬件上采用 某种方案效率更高，而在另一种硬件上采用另一种方案效率更高。无论采用 哪种方案，表达式都会简化为 72 + 100，所以这并不影响最终的结果。但 是，读者可能会根据乘法从左往右的结合律，认为应该先执行+运算符左边 的乘法。结合律只适用于共享同一运算对象运算符。例如，在表达式12 / 3 * 2 中，/和运算符的优先级相同，共享运算对象 3 。因此，从左往右的结合律 在这种情况起作用。表达式简化为4 * 2，即 8 （如果从右往左计算，会得到\n12/6，即 2 ，这种情况下计算的先后顺序会影响最终的计算结果）。在该例 # 中，两个*运算符并没有共享同一个运算对象，因此从左往右的结合律不适 # 用于这种情况。 # 学以致用 # 接下来，我们在更复杂的示例中使用以上规则，请看程序清单5.7。 # 程序清单 5.7 rules.c 程序 /* rules.c \u0026ndash; 优先级测试 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int top, score; top = score = -(2 + 5) * 6 + (4 + 3 * (2 + 3)); printf(\u0026ldquo;top = %d, score = %d\\n\u0026rdquo;, top, score); return 0; } 该程序会打印什么值？先根据代码推测一下，再运行程序或阅读下面的 分析来检查你的答案。 首先，圆括号的优先级最高。先计算-(2 + 5) * 6中的圆括号部分，还是 先计算(4 + 3 * (2 + 3))中的圆括号部分取决于具体的实现。圆括号的最高优 先级意味着，在子表达式-(2 + 5) * 6中，先计算(2 + 5)的值，得 7 。然后，把 一元负号应用在 7 上，得-7。现在，表达式是：\ntop = score = -7 * 6 + (4 + 3 * (2 + 3)) 下一步，计算2 + 3的值。表达式变成： top = score = -7 * 6 + (4 + 3 * 5) 接下来，因为圆括号中的*比+优先级高，所以表达式变成： top = score = -7 * 6 + (4 + 15) 然后，表达式为： top = score = -7 * 6 + 19 -7乘以 6 后，得到下面的表达式： top = score = -42 + 19 然后进行加法运算，得到： top = score = -23 现在，-23被赋值给score，最终top的值也是-23。记住，=运算符的结合 律是从右往左。\n5.3 其他运算符 # C语言有大约 40 个运算符，有些运算符比其他运算符常用得多。前面讨 # 论的是最常用的，本节再介绍 4 个比较有用的运算符。 # 5.3.1 sizeof 运算符和 size_t 类型 # 读者在第 3 章就见过sizeof运算符。回顾一下，sizeof运算符以字节为单 位返回运算对象的大小（在C中， 1 字节定义为char类型占用的空间大小。过 去， 1 字节通常是 8 位，但是一些字符集可能使用更大的字节）。运算对象可 以是具体的数据对象（如，变量名）或类型。如果运算对象是类型（如， float），则必须用圆括号将其括起来。程序清单5.8演示了这两种用法。 程序清单 5.8 sizeof.c 程序 // sizeof.c \u0026ndash; 使用sizeof运算符 // 使用C99新增的%zd转换说明 \u0026ndash; 如果编译器不支持%zd，请将其改 成%u或%lu #include \u0026lt;stdio.h\u0026gt; int main(void) { int n = 0; size_t intsize; intsize = sizeof (int); printf(\u0026ldquo;n = %d, n has %zd bytes; all ints have %zd bytes.\\n\u0026rdquo;,\nn, sizeof n, intsize); return 0; } C 语言规定，sizeof 返回 size_t 类型的值。这是一个无符号整数类型， 但它不是新类型。前面介绍过，size_t是语言定义的标准类型。C有一个 typedef机制（第 14 章再详细介绍），允许程序员为现有类型创建别名。例 如， typedef double real; 这样，real就是double的别名。现在，可以声明一个real类型的变量： real deal; // 使用typedef 编译器查看real时会发现，在typedef声明中real已成为double的别名，于 是把deal创建为double 类型的变量。类似地，C 头文件系统可以使用 typedef 把 size_t 作为 unsigned int 或unsigned long的别名。这样，在使用size_t类型 时，编译器会根据不同的系统替换标准类型。 C99 做了进一步调整，新增了%zd 转换说明用于 printf()显示 size_t 类型 的值。如果系统不支持%zd，可使用%u或%lu代替%zd。\n5.3.2 求模运算符： % # 求模运算符（modulus operator）用于整数运算。求模运算符给出其左侧 整数除以右侧整数的余数（remainder）。例如，13 % 5（读作“13求模5”） 得 3 ，因为 13 比 5 的两倍多 3 ，即 13 除以 5 的余数是 3 。求模运算符只能用于整 数，不能用于浮点数。 乍一看会认为求模运算符像是数学家使用的深奥符号，但是实际上它非 常有用。求模运算符常用于控制程序流。例如，假设你正在设计一个账单预\n算程序，每 3 个月要加进一笔额外的费用。这种情况可以在程序中对月份求 # 模 3 （即，month % 3），并检查结果是否为 0 。如果为 0 ，便加进额外的费 用。等学到第 7 章的if语句后，读者会更明白。 程序清单5.9演示了%运算符的另一种用途。同时，该程序也演示了 while循环的另一种用法。 程序清单 5.9 min_sec.c 程序 // min_sec.c \u0026ndash; 把秒数转换成分和秒 #include \u0026lt;stdio.h\u0026gt; #define SEC_PER_MIN 60 // 1分钟 60 秒 int main(void) { int sec, min, left; printf(\u0026ldquo;Convert seconds to minutes and seconds!\\n\u0026rdquo;); printf(\u0026ldquo;Enter the number of seconds (\u0026lt;=0 to quit):\\n\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;sec); // 读取秒数 while (sec \u0026gt; 0) { min = sec / SEC_PER_MIN; // 截断分钟数 left = sec % SEC_PER_MIN; // 剩下的秒数 printf(\u0026quot;%d seconds is %d minutes, %d seconds.\\n\u0026quot;, sec,\nmin, left); printf(\u0026#34;Enter next value (\u0026lt;=0 to quit):\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;sec); } printf(\u0026#34;Done!\\n\u0026#34;); return 0; } 该程序的输出如下： 程序清单5.2使用一个计数器来控制while循环。当计数器超出给定的大 小时，循环终止。而程序清单5.9则通过scanf()为变量sec获取一个新值。只 要该值为正，循环就继续。当用户输入一个 0 或负值时，循环退出。这两种 情况设计的要点是，每次循环都会修改被测试的变量值。 负数求模如何进行？C99规定“趋零截断”之前，该问题的处理方法很 多。但自从有了这条规则之后，如果第 1 个运算对象是负数，那么求模的结 果为负数；如果第 1 个运算对象是正数，那么求模的结果也是正数：\n11 / 5得 2 ，11 % 5得 1 # 11 / -5得-2，11 % -2得 1 # -11 / -5得 2 ，-11 % -5得-1 # -11 / 5得-2，-11 % 5得-1 # 如果当前系统不支持C99标准，会显示不同的结果。实际上，标准规 # 定：无论何种情况，只要a和b都是整数值，便可通过a - (a/b)*b来计算a%b。 例如，可以这样计算-11%5： -11 - (-11/5) * 5 = -11 -(-2)*5 = -11 -(-10) = -1\n5.3.3 递增运算符： ++ # 递增运算符（increment operator）执行简单的任务，将其运算对象递增 1 。该运算符以两种方式出现。第 1 种方式，++出现在其作用的变量前面， 这是前缀模式；第 2 种方式，++出现在其作用的变量后面，这是后缀模式。 两种模式的区别在于递增行为发生的时间不同。我们先解释它们的相似之 处，再分析它们不同之处。程序清单5.10中的程序示例演示了递增运算符是 如何工作的。 程序清单 5.10 add_one.c 程序 /* add_one.c \u0026ndash; 递增：前缀和后缀 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int ultra = 0, super = 0; while (super \u0026lt; 5)\n{ # super++; ++ultra; printf(\u0026ldquo;super = %d, ultra = %d \\n\u0026rdquo;, super, ultra); } return 0; } 运行该程序后，其输出如下： super = 1, ultra = 1 super = 2, ultra = 2 super = 3, ultra = 3 super = 4, ultra = 4 super = 5, ultra = 5 该程序两次同时计数到 5 。用下面两条语句分别代替程序中的两条递增 语句，程序的输出相同： super = super + 1; ultra = ultra + 1; 这些都是很简单的语句，为何还要创建两个缩写形式？原因之一是，紧 凑结构的代码让程序更为简洁，可读性更高。这些运算符让程序看起来很美 观。例如，可重写程序清单5.2（shoes2.c）中的一部分代码：\nshoe = 3.0; while (shoe \u0026lt; 18.5) { foot = SCALE * size + ADJUST; printf(\u0026quot;%10.1f %20.2f inches\\n\u0026quot;, shoe, foot); ++shoe; } 但是，这样做也没有充分利用递增运算符的优势。还可以这样缩短这段 程序： shoe = 2.0; while (++shoe \u0026lt; 18.5) { foot = SCALE*shoe + ADJUST; printf(\u0026quot;%10.1f %20.2f inches\\n\u0026quot;, shoe, foot); } 如上代码所示，把变量的递增过程放入while循环的条件中。这种结构 在C语言中很普遍，我们来仔细分析一下。 首先，这样的while循环是如何工作的？很简单。shoe的值递增 1 ，然后 和18.5作比较。如果递增后的值小于18.5，则执行花括号内的语句一次。然 后，shoe的值再递增 1 ，重复刚才的步骤，直到shoe的值不小于18.5为止。注 意，我们把shoe的初始值从3.0改为2.0，因为在对foot第 1 次求值之前， shoe\n已经递增了 1 （见图5.4）。 # 图5.4 执行一次循环 其次，这样做有什么好处？它使得程序更加简洁。更重要的是，它把控 制循环的两个过程集中在一个地方。该循环的主要过程是判断是否继续循环 （本例中，要检查鞋子的尺码是否小于 18.5），次要过程是改变待测试的元 素（本例中是递增鞋子的尺码）。 如果忘记改变鞋子的尺码，shoe的值会一直小于18.5，循环不会停止。 计算机将陷入无限循环（infinite loop）中，生成无数相同的行。最后，只能 强行关闭这个程序。把循环测试和更新循环放在一处，就不会忘记更新循 环。 但是，把两个操作合并在一个表达式中，降低了代码的可读性，让代码 难以理解。而且，还容易产生计数错误。 递增运算符的另一个优点是，通常它生成的机器语言代码效率更高，因 为它和实际的机器语言指令很相似。尽管如此，随着商家推出的C编译器越 来越智能，这一优势可能会消失。一个智能的编译器可以把x = x + 1当作 ++x对待。 最后，递增运算符还有一个在某些场合特别有用的特性。我们通过程序\n清单5.11来说明。 # 程序清单 5.11 post_pre.c 程序 /* post_pre.c \u0026ndash; 前缀和后缀 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int a = 1, b = 1; int a_post, pre_b; a_post = a++; // 后缀递增 pre_b = ++b; // 前缀递增 printf(\u0026ldquo;a a_post b pre_b \\n\u0026rdquo;); printf(\u0026quot;%1d %5d %5d %5d\\n\u0026quot;, a, a_post, b, pre_b); return 0; } 如果你的编译器没问题，那么程序的输出应该是： a a_post b pre_b 2　1　2　2 a和b都递增了 1 ，但是，a_post是a递增之前的值，而b_pre是b递增之后 的值。这就是++的前缀形式和后缀形式的区别（见图5.5）。\n图5.5 前缀和后缀 a_post = a++; // 后缀：使用a的值乊后，递增a b_pre= ++b; // 前缀：使用b的值乊前，递增b 单独使用递增运算符时（如，ego++;），使用哪种形式都没关系。但 是，当运算符和运算对象是更复杂表达式的一部分时（如上面的示例），使 用前缀或后缀的效果不同。例如，我们曾经建议用下面的代码： while (++shoe \u0026lt; 18.5) 该测试条件相当于提供了一个鞋子尺码到 18 的表。如果使用shoe++而不 是++shoes，尺码表会增至 19 。因为shoe会在与18.5进行比较之后才递增，而 不是先递增再比较。 当然，使用下面这种形式也没错： shoe = shoe + 1; 只不过，有人会怀疑你是否是真正的C程序员。\n在学习本书的过程中，应多留意使用递增运算符的例子。自己思考是否 # 能互换使用前缀和后缀形式，或者当前环境是否只能使用某种形式。 # 如果使用前缀形式和后缀形式会对代码产生不同的影响，那么最为明智 # 的是不要那样使用它们。例如，不要使用下面的语句： # b = ++i; // 如果使用i++，会得到不同的结果 应该使用下列语句： ++i; // 第 1 行 b = i; // 如果第 1 行使用的是i++，幵不会影响b的值 尽管如此，有时小心翼翼地使用会更有意思。所以，本书会根据实际情 况，采用不同的写法。\n5.3.4 递减运算符： \u0026ndash; # 每种形式的递增运算符都有一个递减运算符（decrement operator）与之 对应，用\u0026ndash;代替++即可： \u0026ndash;count; // 前缀形式的递减运算符 count\u0026ndash;; // 后缀形式的递减运算符 程序清单5.12演示了计算机可以是位出色的填词家。 程序清单 5.12 bottles.c 程序 #include \u0026lt;stdio.h\u0026gt; #define MAX 100 int main(void)\n{ # int count = MAX + 1; while (\u0026ndash;count \u0026gt; 0) { printf(\u0026quot;%d bottles of spring water on the wall, \u0026quot; \u0026ldquo;%d bottles of spring water!\\n\u0026rdquo;, count, count); printf(\u0026ldquo;Take one down and pass it around,\\n\u0026rdquo;); printf(\u0026quot;%d bottles of spring water!\\n\\n\u0026quot;, count - 1); } return 0; } 该程序的输出如下（篇幅有限，省略了中间大部分输出）： 100　bottles of spring water on the wall, 100　bottles of spring water! Take one down and pass it around, 99　bottles of spring water! 99　bottles of spring water on the wall, 99　bottles of spring water! Take one down and pass it around, 98　bottles of spring water! \u0026hellip;\n1 bottles of spring water on the wall, 1 bottles of spring water! Take one down and pass it around, 0 bottles of spring water! 显然，这位填词家在复数的表达上有点问题。在学完第 7 章中的条件运 算符后，可以解决这个问题。 顺带一提，\u0026gt;运算符表示“大于”，\u0026lt;运算符表示“小于”，它们都是关系运 算符（relational operator）。我们将在第 6 章中详细介绍关系运算符。\n5.3.5 优先级 # 递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级 # 比它们高。因此，xy++表示的是(x)(y++)，而不是(x+y)++。不过后者无 效，因为递增和递减运算符只能影响一个变量（或者，更普遍地说，只能影 响一个可修改的左值），而组合x*y本身不是可修改的左值。 不要混淆这两个运算符的优先级和它们的求值顺序。假设有如下语句： y = 2; n = 3; nextnum = (y + n++)*6; nextnum的值是多少？把y和n的值带入上面的第 3 条语句得： nextnum = (2 + 3)6 = 56 = 30 n的值只有在被使用之后才会递增为 4 。根据优先级的规定，++只作用 于n，不作用与y + n。除此之外，根据优先级可以判断何时使用n的值对表达 式求值，而递增运算符的性质决定了何时递增n的值。 如果n++是表达式的一部分，可将其视为“先使用n，再递增”；而++n则\n表示“先递增n，再使用”。\n5.3.6 不要自作聪明 # 如果一次用太多递增运算符，自己都会糊涂。例如，利用递增运算符改 # 进 squares.c 程序（程序清单5.4），用下面的while循环替换原程序中的while 循环： while (num \u0026lt; 21) { printf(\u0026quot;%10d %10d\\n\u0026quot;, num, numnum++); } 这个想法看上去不错。打印num，然后计算numnum得到平方值，最后 把num递增 1 。但事实上，修改后的程序只能在某些系统上能正常运行。该 程序的问题是：当 printf()获取待打印的值时，可能先对最后一个参数（ ） 求值，这样在获取其他参数的值之前就递增了num。所以，本应打印： 5　25 却打印成： 6　25 它甚至可能从右往左执行，对最右边的num（++作用的num）使用 5 ，对 第 2 个num和最左边的num使用 6 ，结果打印出： 6　30 在C语言中，编译器可以自行选择先对函数中的哪个参数求值。这样做 提高了编译器的效率，但是如果在函数的参数中使用了递增运算符，就会有 一些问题。\n类似这样的语句，也会导致一些麻烦： # ans = num/2 + 5*(1 + num++); 同样，该语句的问题是：编译器可能不会按预想的顺序来执行。你可能 认为，先计算第 1 项（num/2），接着计算第 2 项（5*(1 + num++)）。但是， 编译器可能先计算第 2 项，递增num，然后在num/2中使用num递增后的新 值。因此，无法保证编译器到底先计算哪一项。 还有一种情况，也不确定： n = 3; y = n++ + n++; 可以肯定的是，执行完这两条语句后，n的值会比旧值大 2 。但是，y的 值不确定。在对y求值时，编译器可以使用n的旧值（ 3 ）两次，然后把n递增 1 两次，这使得y的值为 6 ，n的值为 5 。或者，编译器使用n的旧值（ 3 ）一 次，立即递增n，再对表达式中的第 2 个n使用递增后的新值，然后再递增n， 这使得 y 的值为 7 ，n 的值为 5 。两种方案都可行。对于这种情况更精确地 说，结果是未定义的，这意味着 C标准并未定义结果应该是什么。 遵循以下规则，很容易避免类似的问题： 如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或 递减运算符； 如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减 运算符。 另一方面，对于何时执行递增，C 还是做了一些保证。我们在本章后面 的“副作用和序列点”中学到序列点时再来讨论这部分内容。\n5.4 表达式和语句 # 在前几章中，我们已经多次使用了术语表达式（expression）和语句 （statement）。现在，我们来进一步学习它们。C的基本程序步骤由语句组 成，而大多数语句都由表达式构成。因此，我们先学习表达式。\n5.4.1 表达式 # 表达式（expression）由运算符和运算对象组成（前面介绍过，运算对 象是运算符操作的对象）。最简单的表达式是一个单独的运算对象，以此为 基础可以建立复杂的表达式。下面是一些表达式： 4 -6 4+21 a*(b + c/d)/20 q = 52 x = ++q % 3 q \u0026gt; 3 如你所见，运算对象可以是常量、变量或二者的组合。一些表达式由子 表达式（subexpression）组成（子表达式即较小的表达式）。例如，c/d是上 面例子中a(b + c/d)/20的子表达式。 每个表达式都有一个值 C 表达式的一个最重要的特性是，每个表达式都有一个值。要获得这个 值，必须根据运算符优先级规定的顺序来执行操作。在上面我们列出的表达 式中，前几个都很清晰明了。但是，有赋值运算符（=）的表达式的值是什\n么？这些表达式的值与赋值运算符左侧变量的值相同。因此，表达式q = 5*2 作为一个整体的值是 10 。那么，表达式q \u0026gt; 3的值是多少？这种关系表达式 的值不是 0 就是 1 ，如果条件为真，表达式的值为 1 ；如果条件为假，表达式 的值为 0 。表5.2列出了一些表达式及其值： 表5.2 一些表达式及其值\n虽然最后一个表达式看上去很奇怪，但是在C中完全合法（但不建议使 # 用），因为它是两个子表达式的和，每个子表达式都有一个值。 # 5.4.2 语句 # 语句（statement）是C程序的基本构建块。一条语句相当于一条完整的 计算机指令。在C中，大部分语句都以分号结尾。因此， legs = 4 只是一个表达式（它可能是一个较大表达式的一部分），而下面的代码 则是一条语句： legs = 4; 最简单的语句是空语句： ; // 空语句 C把末尾加上一个分号的表达式都看作是一条语句（即，表达式语 句）。因此，像下面这样写也没问题： 8;\n3 + 4; # 但是，这些语句在程序中什么也不做，不算是真正有用的语句。更确切 # 地说，语句可以改变值或调用函数： # x = 25; ++x; y = sqrt(x); 虽然一条语句（或者至少是一条有用的语句）相当于一条完整的指令， 但并不是所有的指令都是语句。考虑下面的语句： x = 6 + (y = 5); 该语句中的子表达式y = 5是一条完整的指令，但是它只是语句的一部 分。因为一条完整的指令不一定是一条语句，所以分号用于识别在这种情况 下的语句（即，简单语句）。 到目前为止，读者已经见过多种语句（不包括空语句）。程序清单5.13 演示了一些常见的语句。 程序清单 5.13 addemup.c 程序 /* addemup.c \u0026ndash; 几种常见的语句 / #include \u0026lt;stdio.h\u0026gt; int main(void) / 计算前 20 个整数的和　/ { int count, sum; / 声明[1] / count = 0; / 表达式语句　*/\nsum = 0; /* 表达式语句　/ while (count++ \u0026lt; 20) / 迭代语句　/ sum = sum + count; printf(\u0026ldquo;sum = %d\\n\u0026rdquo;, sum); / 表达式语句[2] / return 0; / 跳转语句　/ } 下面我们讨论程序清单 5.13。到目前为止，相信读者已经很熟悉声明 了。尽管如此，我们还是要提醒读者：声明创建了名称和类型，并为其分配 内存位置。注意，声明不是表达式语句。也就是说，如果删除声明后面的分 号，剩下的部分不是一个表达式，也没有值： int port / 不是表达式，没有值 */ 赋值表达式语句在程序中很常用：它为变量分配一个值。赋值表达式语 句的结构是，一个变量名，后面是一个赋值运算符，再跟着一个表达式，最 后以分号结尾。注意，在while循环中有一个赋值表达式语句。赋值表达式 语句是表达式语句的一个示例。 函数表达式语句会引起函数调用。在该例中，调用printf()函数打印结 果。while语句有 3 个不同的部分（见图5.6）。首先是关键字while；然后， 圆括号中是待测试的条件；最后如果测试条件为真，则执行while循环体中 的语句。该例的while循环中只有一条语句。可以是本例那样的一条语句， 不需要用花括号括起来，也可以像其他例子中那样包含多条语句。多条语句 需要用花括号括起来。这种语句是复合语句，稍后马上介绍。\n图5.6 简单的while循环结构 while语句是一种迭代语句，有时也被称为结构化语句，因为它的结构 比简单的赋值表达式语句复杂。在后面的章节里，我们会遇到许多这样的语 句。 副作用和序列点 我们再讨论一个C语言的术语副作用（side effect）。副作用是对数据对 象或文件的修改。例如，语句： states = 50; 它的副作用是将变量的值设置为 50 。副作用？这似乎更像是主要目的！ 但是从C语言的角度看，主要目的是对表达式求值。给出表达式4 + 6，C会 对其求值得 10 ；给出表达式states = 50，C会对其求值得 50 。对该表达式求值 的副作用是把变量states的值改为 50 。跟赋值运算符一样，递增和递减运算 符也有副作用，使用它们的主要目的就是使用其副作用。 类似地，调用 printf()函数时，它显示的信息其实是副作用（printf()的返 回值是待显示字符的个数）。\n序列点（sequence point）是程序执行的点，在该点上，所有的副作用都 在进入下一步之前发生。在 C语言中，语句中的分号标记了一个序列点。意 思是，在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做 的改变必须在程序执行下一条语句之前完成。后面我们要讨论的一些运算符 也有序列点。另外，任何一个完整表达式的结束也是一个序列点。 什么是完整表达式？所谓完整表达式（full expression），就是指这个表 达式不是另一个更大表达式的子表达式。例如，表达式语句中的表达式和 while循环中的作为测试条件的表达式，都是完整表达式。 序列点有助于分析后缀递增何时发生。例如，考虑下面的代码： while (guests++ \u0026lt; 10) printf(\u0026quot;%d \\n\u0026quot;, guests); 对于该例，C语言的初学者认为“先使用值，再递增它”的意思是，在 printf()语句中先使用guests，再递增它。但是，表达式guests++ \u0026lt; 10是一个完 整的表达式，因为它是while循环的测试条件，所以该表达式的结束就是一 个序列点。因此，C 保证了在程序转至执行 printf()之前发生副作用（即，递 增guests）。同时，使用后缀形式保证了guests在完成与 10 的比较后才进行递 增。 现在，考虑下面这条语句： y = (4 + x++) + (6 + x++); 表达式4 + x++不是一个完整的表达式，所以C无法保证x在子表达式4 + x++求值后立即递增x。这里，完整表达式是整个赋值表达式语句，分号标记 了序列点。所以，C 保证程序在执行下一条语句之前递增x两次。C并未指明 是在对子表达式求值以后递增x，还是对所有表达式求值后再递增x。因此， 要尽量避免编写类似的语句。\n5.4.3 复合语句（块） # 复合语句（compound statement）是用花括号括起来的一条或多条语句， 复合语句也称为块（block）。shoes2.c程序使用块让while语句包含多条语 句。比较下面两个程序段： /* 程序段 1 / index = 0; while (index++ \u0026lt; 10) sam = 10 * index + 2; printf(\u0026ldquo;sam = %d\\n\u0026rdquo;, sam); / 程序段 2 */ index = 0; while (index++ \u0026lt; 10) { sam = 10 * index + 2; printf(\u0026ldquo;sam = %d\\n\u0026rdquo;, sam); } 程序段 1 ，while循环中只有一条赋值表达式语句。没有花括号，while语 句从while这行运行至下一个分号。循环结束后，printf()函数只会被调用一 次。 程序段 2 ，花括号确保两条语句都是while循环的一部分，每执行一次循 环就调用一次printf()函数。根据while语句的结构，整个复合语句被视为一 条语句（见图5.7）。\n图5.7 带复合语句的while循环 提示 风格提示 再看一下前面的两个while程序段，注意循环体中的缩进。缩进对编译 器不起作用，编译器通过花括号和while循环的结构来识别和解释指令。这 里，缩进是为了让读者一眼就可以看出程序是如何组织的。 程序段 2 中，块或复合语句放置花括号的位置是一种常见的风格。另一 种常用的风格是： while (index++ \u0026lt; 10) { sam = 10*index + 2; printf(\u0026ldquo;sam = %d \\n\u0026rdquo;, sam); }\n这种风格突出了块附属于while循环，而前一种风格则强调语句形成一 个块。对编译器而言，这两种风格完全相同。 总而言之，使用缩进可以为读者指明程序的结构。 总结 表达式和语句 表达式： 表达式由运算符和运算对象组成。最简单的表达式是不带运算符的一个 常量或变量（如， 22 或beebop）。更复杂的例子是55 + 22和vap = 2 * (vip + (vup = 4))。 语句： 到目前为止，读者接触到的语句可分为简单语句和复合语句。简单语句 以一个分号结尾。如下所示： 赋值表达式语句: toes = 12; 函数表达式语句: printf(\u0026quot;%d\\n\u0026quot;, toes); 空语句: ; /* 什么也不做 */ 复合语句（或块）由花括号括起来的一条或多条语句组成。如下面的 while语句所示： while (years \u0026lt; 100) { wisdom = wisdom * 1.05; printf(\u0026quot;%d %d\\n\u0026quot;, years, wisdom); years = years + 1;\n} # 5.5 类型转换 # 通常，在语句和表达式中应使用类型相同的变量和常量。但是，如果使 # 用混合类型，C 不会像 Pascal那样停在那里死掉，而是采用一套规则进行自 动类型转换。虽然这很便利，但是有一定的危险性，尤其是在无意间混合使 用类型的情况下（许多UNIX系统都使用lint程序检查类型“冲突”。如果选择 更高错误级别，许多非UNIX C编译器也可能报告类型问题）。最好先了解 一些基本的类型转换规则。 1.当类型转换出现在表达式时，无论是unsigned还是signed的char和short 都会被自动转换成int，如有必要会被转换成unsigned int（如果short与int的大 小相同，unsigned short就比int大。这种情况下，unsigned short会被转换成 unsigned int）。在K\u0026amp;R那时的C中，float会被自动转换成double（目前的C不 是这样）。由于都是从较小类型转换为较大类型，所以这些转换被称为升级 （promotion）。 2.涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。 3.类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int。例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高。之所以short和char类 型没有列出，是因为它们已经被升级到int或unsigned int。 4.在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类 型。这个过程可能导致类型升级或降级（demotion）。所谓降级，是指把一 种类型转换成更低级别的类型。 5.当作为函数参数传递时，char和short被转换成int，float被转换成 double。第 9 章将介绍，函数原型会覆盖自动升级。 类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦。原 因很简单：较低类型可能放不下整个数字。例如，一个 8 位的char类型变量 储存整数 101 没问题，但是存不下 22334 。\n如果待转换的值与目标类型不匹配怎么办？这取决于转换涉及的类型。 # 待赋值的值与目标类型不匹配时，规则如下。 # 1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略。 # 例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模 256 。 2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而 异。 3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义 的。 如果把一个浮点值转换成整数类型会怎样？当浮点类型被降级为整数类 型时，原来的浮点值会被截断。例如，23.12和23.99都会被截断为 23 ，-23.5 会被截断为-23。 程序清单5.14演示了这些规则。 程序清单 5.14 convert.c 程序 /* convert.c \u0026ndash; 自动类型转换 / #include \u0026lt;stdio.h\u0026gt; int main(void) { char ch; int i; float fl; fl = i = ch = \u0026lsquo;C\u0026rsquo;; / 第 9 行　*/\nprintf(\u0026ldquo;ch = %c, i = %d, fl = %2.2f\\n\u0026rdquo;, ch, i, fl); /* 第 10 行 / ch = ch + 1; / 第 11 行 / i = fl + 2 * ch; / 第 12 行 / fl = 2.0 * ch + i; / 第 13 行 / printf(\u0026ldquo;ch = %c, i = %d, fl = %2.2f\\n\u0026rdquo;, ch, i, fl); / 第 14 行 / ch = 1107; / 第 15 行 / printf(\u0026ldquo;Now ch = %c\\n\u0026rdquo;, ch); / 第 16 行 / ch = 80.89; / 第 17 行 / printf(\u0026ldquo;Now ch = %c\\n\u0026rdquo;, ch); / 第 18 行 */ return 0; } 运行convert.c后输出如下： ch = C, i = 67, fl = 67.00 ch = D, i = 203, fl = 339.00 Now ch = S Now ch = P 在我们的系统中，char是 8 位，int是 32 位。程序的分析如下。 第 9 行和第 10 行：字符\u0026rsquo;C\u0026rsquo;被作为 1 字节的ASCII值储存在ch中。整数变量i 接受由\u0026rsquo;C\u0026rsquo;转换的整数，即按 4 字节储存 67 。最后，fl接受由 67 转换的浮点数 67.00。\n第 11 行和第 14 行：字符变量\u0026rsquo;C\u0026rsquo;被转换成整数 67 ，然后加 1 。计算结果是 4 # 字节整数 68 ，被截断成 1 字节储存在ch中。根据%c转换说明打印时， 68 被解 释成\u0026rsquo;D\u0026rsquo;的ASCII码。 第 12 行和第 14 行：ch的值被转换成 4 字节的整数（ 68 ），然后 2 乘以ch。 为了和fl相加，乘积整数（ 136 ）被转换成浮点数。计算结果（203.00f）被 转换成int类型，并储存在i中。 第 13 行和第 14 行：ch的值（\u0026lsquo;D\u0026rsquo;，或 68 ）被转换成浮点数，然后 2 乘以 ch。为了做加法，i的值（ 203 ）被转换为浮点类型。计算结果（339.00）被 储存在fl中。 第 15 行和第 16 行：演示了类型降级的示例。把ch设置为一个超出其类型 范围的值，忽略额外的位后，最终ch的值是字符S的ASCII码。或者，更确切 地说，ch的值是1107 % 265，即 83 。 第 17 行和第 18 行：演示了另一个类型降级的示例。把ch设置为一个浮点 数，发生截断后，ch的值是字符P的ASCII码。 5.5.1 强制类型转换运算符 通常，应该避免自动类型转换，尤其是类型降级。但是如果能小心使 用，类型转换也很方便。我们前面讨论的类型转换都是自动完成的。然而， 有时需要进行精确的类型转换，或者在程序中表明类型转换的意图。这种情 况下要用到强制类型转换（cast），即在某个量的前面放置用圆括号括起来 的类型名，该类型名即是希望转换成的目标类型。圆括号和它括起来的类型 名构成了强制类型转换运算符（cast operator），其通用形式是： (type) 用实际需要的类型（如，long）替换type即可。 考虑下面两行代码，其中mice是int类型的变量。第 2 行包含两次int强制 类型转换。\nmice = 1.6 + 1.7; mice = (int)1.6 + (int)1.7; 第 1 行使用自动类型转换。首先，1.6和1.7相加得3.3。然后，为了匹配 int 类型的变量，3.3被类型转换截断为整数 3 。第 2 行，1.6和1.7在相加之前都 被转换成整数（ 1 ），所以把1+1的和赋给变量mice。本质上，两种类型转换 都好不到哪里去，要考虑程序的具体情况再做取舍。 一般而言，不应该混合使用类型（因此有些语言直接不允许这样做）， 但是偶尔这样做也是有用的。C语言的原则是避免给程序员设置障碍，但是 程序员必须承担使用的风险和责任。 总结 C 的一些运算符 下面是我们学过的一些运算符。 赋值运算符： = 将其右侧的值赋给左侧的变量 算术运算符：\n将其左侧的值与右侧的值相加 将其左侧的值减去右侧的值 作为一元运算符，改变其右侧值的符号 将其左侧的值乘以右侧的值 /　将其左侧的值除以右侧的值，如果两数都是整数，计算结果 将被截断 %　当其左侧的值除以右侧的值时，取其余数（只能应用于整 数） ++ 对其右侧的值加 1 （前缀模式），或对其左侧的值加 1 （后缀 # 模式） # \u0026ndash; 对其右侧的值减 1 （前缀模式），或对其左侧的值减 1 （后缀模 # 式） # 其他运算符： # sizeof 获得其右侧运算对象的大小（以字节为单位），运算对象 可以是一个被圆括号括起来的类型说明符，如sizeof(float)，或者是一个具体 的变量名、数组名等，如sizeof foo (类型名)　强制类型转换运算符将其右侧的值转换成圆括号中指定 的类型，如(float)9把整数 9 转换成浮点数9.0\n5.6 带参数的函数 # 现在，相信读者已经熟悉了带参数的函数。要掌握函数，还要学习如何 # 编写自己的函数（在此之前，读者可能要复习一下程序清单2.3中的butler() 函数，该函数不带任何参数）。程序清单5.15中有一个pound()函数，打印指 定数量的#号（该符号也叫作编号符号或井号）。该程序还演示了类型转换 的应用。 程序清单 5.15 pound.c 程序 /* pound.c \u0026ndash; 定义一个带一个参数的函数　*/ #include \u0026lt;stdio.h\u0026gt; void pound(int n);// ANSI函数原型声明 int main(void) { int times = 5; char ch = \u0026lsquo;!\u0026rsquo;; // ASCII码是 33 float f = 6.0f; pound(times); // int类型的参数 pound(ch); // 和pound((int)ch);相同 pound(f); // 和pound((int)f);相同 return 0; }\nvoid pound(int n) // ANSI风格函数头 { // 表明该函数接受一个int类型的参数 while (n\u0026ndash; \u0026gt; 0) printf(\u0026quot;#\u0026quot;); printf(\u0026quot;\\n\u0026quot;); } 运行该程序后，输出如下：\n# #################################\n# 首先，看程序的函数头： void pound(int n) 如果函数不接受任何参数，函数头的圆括号中应该写上关键字 void。 由于该函数接受一个 int 类型的参数，所以圆括号中包含一个int类型变量n的 声明。参数名应遵循C语言的命名规则。 声明参数就创建了被称为形式参数（formal argument或formal parameter，简称形参）的变量。该例中，形式参数是 int 类型的变量 n。像 pound(10)这样的函数调用会把 10 赋给 n。在该程序中，调用pound(times)就 是把 times 的值（ 5 ）赋给 n。我们称函数调用传递的值为实际参数（actual argument或actual parameter），简称实参。所以，函数调用pound(10)把实际 参数 10 传递给函数，然后该函数把 10 赋给形式参数（变量n）。也就是说， main()中的变量times的值被拷贝给pound()中的新变量n。\n注意 实参和形参 # 在英文中，argument和parameter经常可以互换使用，但是C99标准规定 了：对于actual argument或actual parameter使用术语argument（译为实参）； 对于formal argument或formal parameter使用术语parameter（译为形参）。为 遵循这一规定，我们可以说形参是变量，实参是函数调用提供的值，实参被 赋给相应的形参。因此，在程序清单5.15中，times是pound()的实参，n是 pound()的形参。类似地，在函数调用pound(times + 4)中，表达式times + 4的 值是该函数的实参。 变量名是函数私有的，即在函数中定义的函数名不会和别处的相同名称 发生冲突。如果在pound()中用times代替n，那么这个times与main()中的times 不同。也就是说，程序中出现了两个同名的变量，但是程序可以区分它们。 现在，我们来学习函数调用。第 1 个函数调用是pound(times)，times的 值 5 被赋给n。因此， printf()函数打印了 5 个井号和 1 个换行符。第 2 个函数调 用是pound(ch)。这里，ch是char类型，被初始化为!字符，在ASCII中ch的数 值是 33 。但是pound()函数的参数类型是int，与char不匹配。程序开头的函数 原型在这里发挥了作用。原型（prototype）即是函数的声明，描述了函数的 返回值和参数。pound()函数的原型说明了两点： 该函数没有返回值（函数名前面有void关键字）； 该函数有一个int类型的参数。 该例中，函数原型告诉编译器pound()需要一个int类型的参数。相应 地，当编译器执行到pound(ch)表达式时，会把参数ch自动转换成int类型。在 我们的系统中，该参数从 1 字节的 33 变成 4 字节的 33 ，所以现在 33 的类型满足 函数的要求。与此类似，最后一次调用是pound(f)，使得float类型的变量被 转换成合适的类型。 在ANSI C之前，C使用的是函数声明，而不是函数原型。函数声明只指 明了函数名和返回类型，没有指明参数类型。为了向下兼容，C现在仍然允\n许这样的形式： # void pound(); /* ANSI C乊前的函数声明 */ 如果用这条函数声明代替pound.c程序中的函数原型会怎样？第 1 次函 数调用，pound(times)没问题，因为times是int类型。第 2 次函数调用， pound(ch)也没问题，因为即使缺少函数原型，C也会把char和short类型自动 升级为int类型。第 3 次函数调用，pound(f)会失败，因为缺少函数原型，float 会被自动升级为 double，这没什么用。虽然程序仍然能运行，但是输出的内 容不正确。在函数调用中显式使用强制类型转换，可以修复这个问题： pound ((int)f); // 把f强制类型转换为正确的类型 注意，如果f的值太大，超过了int类型表示的范围，这样做也不行。\n5.7 示例程序 # 程序清单5.16演示了本章介绍的几个概念，这个程序对某些人很有用。 # 程序看起来很长，但是所有的计算都在程序的后面几行中。我们尽量使用大 # 量的注释，让程序看上去清晰明了。请通读该程序，稍后我们会分析几处要 # 点。 # 程序清单 5.16 running.c 程序 // running.c -- A useful program for runners #include \u0026lt;stdio.h\u0026gt; const int S_PER_M = 60; // 1分钟的秒数 const int S_PER_H = 3600; // 1小时的分钟数 const double M_PER_K = 0.62137; // 1公里的英里数 int main(void) { double distk, distm; // 跑过的距离（分别以公里和英里为单位） double rate; // 平均速度（以英里/小时为单位） int min, sec; // 跑步用时（以分钟和秒为单位） int time; // 跑步用时（以秒为单位） double mtime; // 跑 1 英里需要的时间，以秒为单位 int mmin, msec; // 跑 1 英里需要的时间，以分钟和秒为单位 printf(\u0026#34;This program converts your time for a metric race\\n\u0026#34;); printf(\u0026ldquo;to a time for running a mile and to your average\\n\u0026rdquo;); printf(\u0026ldquo;speed in miles per hour.\\n\u0026rdquo;); printf(\u0026ldquo;Please enter, in kilometers, the distance run.\\n\u0026rdquo;); scanf(\u0026quot;%lf\u0026quot;, \u0026amp;distk); // %lf表示读取一个double类型的值 printf(\u0026ldquo;Next enter the time in minutes and seconds.\\n\u0026rdquo;); printf(\u0026ldquo;Begin by entering the minutes.\\n\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;min); printf(\u0026ldquo;Now enter the seconds.\\n\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;sec); time = S_PER_M * min + sec; // 把时间转换成秒 distm = M_PER_K * distk; // 把公里转换成英里 rate = distm / time * S_PER_H; // 英里/秒×秒/小时 = 英里/小时 mtime = (double) time / distm; // 时间/距离 = 跑 1 英里所用的时间 mmin = (int) mtime / S_PER_M; // 求出分钟数 msec = (int) mtime % S_PER_M; // 求出剩余的秒数 printf(\u0026ldquo;You ran %1.2f km (%1.2f miles) in %d min, %d sec.\\n\u0026rdquo;, distk, distm, min, sec); printf(\u0026ldquo;That pace corresponds to running a mile in %d min, \u0026ldquo;,\nmmin); printf(\u0026quot;%d sec.\\nYour average speed was %1.2f mph.\\n\u0026rdquo;, msec, rate); return 0; } 程序清单5.16使用了min_sec程序（程序清单5.9）中的方法把时间转换 成分钟和秒，除此之外还使用了类型转换。为什么要进行类型转换？因为程 序在秒转换成分钟的部分需要整型参数，但是在公里转换成英里的部分需要 浮点运算。我们使用强制类型转换运算符进行了显式转换。 实际上，我们曾经利用自动类型转换编写这个程序，即使用int类型的 mtime来强制时间计算转换成整数形式。但是，在测试的 11 个系统中，这个 版本的程序在 1 个系统上无法运行，这是由于编译器（版本比较老）没有遵 循C规则。而使用强制类型转换就没有问题。对读者而言，强制类型转换强 调了转换类型的意图，对编译器而言也是如此。 下面是程序清单5.16的输出示例： This program converts your time for a metric race to a time for running a mile and to your average speed in miles per hour. Please enter, in kilometers, the distance run. 10.0 Next enter the time in minutes and seconds. Begin by entering the minutes.\n36 # Now enter the seconds. 23 You ran 10.00 km (6.21 miles) in 36　min, 23　sec. That pace corresponds to running a mile in 5　min, 51　sec. Your average speed was 10.25 mph.\n5.8 关键概念 # C 通过运算符提供多种操作。每个运算符的特性包括运算对象的数量、 # 优先级和结合律。当两个运算符共享一个运算对象时，优先级和结合律决定 # 了先进行哪项运算。每个 C表达式都有一个值。如果不了解运算符的优先级 # 和结合律，写出的表达式可能不合法或者表达式的值与预期不符。这会影响 # 你成为一名优秀的程序员。 # 虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都 # 是相同的类型。因此，C会进行自动类型转换。尽管如此，不要养成依赖自 # 动类型转换的习惯，应该显式选择合适的类型或使用强制类型转换。这样， # 就不用担心出现不必要的自动类型转换。 # 5.9 本章小结 # C 语言有许多运算符，如本章讨论的赋值运算符和算术运算符。一般而 # 言，运算符需要一个或多个运算对象才能完成运算生成一个值。只需要一个 # 运算对象的运算符（如负号和 sizeof）称为一元运算符，需要两个运算对象 的运算符（如加法运算符和乘法运算符）称为二元运算符。 表达式由运算符和运算对象组成。在C语言中，每个表达式都有一个 值，包括赋值表达式和比较表达式。运算符优先级规则决定了表达式中各项 的求值顺序。当两个运算符共享一个运算对象时，先进行优先级高的运算。 如果运算符的优先级相等，由结合律（从左往右或从右往左）决定求值顺 序。 大部分语句都以分号结尾。最常用的语句是表达式语句。用花括号括起 来的一条或多条语句构成了复合语句（或称为块）。while语句是一种迭代 语句，只要测试条件为真，就重复执行循环体中的语句。 在C语言中，许多类型转换都是自动进行的。当char和short类型出现在 表达式里或作为函数的参数（函数原型除外）时，都会被升级为int类型； float类型在函数参数中时，会被升级为double类型。在K\u0026amp;R C（不是ANSI C）下，表达式中的float也会被升级为double类型。当把一种类型的值赋给 另一种类型的变量时，值将被转换成与变量的类型相同。当把较大类型转换 成较小类型时（如，long转换成short，或 double 转换成 float），可能会丢失 数据。根据本章介绍的规则，在混合类型的运算中，较小类型会被转换成较 大类型。 定义带一个参数的函数时，便在函数定义中声明了一个变量，或称为形 式参数。然后，在函数调用中传入的值会被赋给这个变量。这样，在函数中 就可以使用该值了。\n5.10 复习题 # 复习题的参考答案在附录A中。 # 1.假设所有变量的类型都是int，下列各项变量的值是多少： a.x = (2 + 3) * 6; b.x = (12 + 6)/23; c.y = x = (2 + 3)/4; d.y = 3 + 2(x = 7/2); 2.假设所有变量的类型都是int，下列各项变量的值是多少： a.x = (int)3.8 + 3.3; b.x = (2 + 3) * 10.5; c.x = 3 / 5 * 22.0; d.x = 22.0 * 3 / 5; 3.对下列各表达式求值： a.30.0 / 4.0 * 5.0; b.30.0 / (4.0 * 5.0); c.30 / 4 * 5; d.30 * 5 / 4; e.30 / 4.0 * 5; f.30 / 4 * 5.0;\n4.请找出下面的程序中的错误。 # int main(void) { int i = 1, float n; printf(\u0026ldquo;Watch out! Here come a bunch of fractions!\\n\u0026rdquo;); while (i \u0026lt; 30) n = 1/i; printf(\u0026rdquo; %f\u0026quot;, n); printf(\u0026ldquo;That\u0026rsquo;s all, folks!\\n\u0026rdquo;); return; } 5.这是程序清单 5.9 的另一个版本。从表面上看，该程序只使用了一条 scanf()语句，比程序清单5.9简单。请找出不如原版之处。 #include \u0026lt;stdio.h\u0026gt; #define S_TO_M 60 int main(void) { int sec, min, left;\nprintf(\u0026ldquo;This program converts seconds to minutes and \u0026ldquo;); printf(\u0026ldquo;seconds.\\n\u0026rdquo;); printf(\u0026ldquo;Just enter the number of seconds.\\n\u0026rdquo;); printf(\u0026ldquo;Enter 0　to end the program.\\n\u0026rdquo;); while (sec \u0026gt; 0) { scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;sec); min = sec/S_TO_M; left = sec % S_TO_M; printf(\u0026quot;%d sec is %d min, %d sec. \\n\u0026rdquo;, sec, min, left); printf(\u0026ldquo;Next input?\\n\u0026rdquo;); } printf(\u0026ldquo;Bye!\\n\u0026rdquo;); return 0; } 6.下面的程序将打印出什么内容？ #include \u0026lt;stdio.h\u0026gt; #define FORMAT \u0026ldquo;%s! C is cool!\\n\u0026rdquo; int main(void) {\nint num = 10; printf(FORMAT,FORMAT); printf(\u0026quot;%d\\n\u0026quot;, ++num); printf(\u0026quot;%d\\n\u0026quot;, num++); printf(\u0026quot;%d\\n\u0026quot;, num\u0026ndash;); printf(\u0026quot;%d\\n\u0026quot;, num); return 0; } 7.下面的程序将打印出什么内容？ #include \u0026lt;stdio.h\u0026gt; int main(void) { char c1, c2; int diff; float num; c1 = \u0026lsquo;S\u0026rsquo;; c2 = \u0026lsquo;O\u0026rsquo;; diff = c1 - c2; num = diff;\nprintf(\u0026quot;%c%c%c:%d %3.2f\\n\u0026quot;, c1, c2, c1, diff, num); return 0; } 8.下面的程序将打印出什么内容？ #include \u0026lt;stdio.h\u0026gt; #define TEN 10 int main(void) { int n = 0; while (n++ \u0026lt; TEN) printf(\u0026quot;%5d\u0026quot;, n); printf(\u0026quot;\\n\u0026quot;); return 0; } 9.修改上一个程序，使其可以打印字母a～g。 10.假设下面是完整程序中的一部分，它们分别打印什么？ a. int x = 0; while (++x \u0026lt; 3)\nprintf(\u0026quot;%4d\u0026quot;, x); b. int x = 100; while (x++ \u0026lt; 103) printf(\u0026quot;%4d\\n\u0026quot;,x); printf(\u0026quot;%4d\\n\u0026quot;,x); c. char ch = \u0026rsquo;s\u0026rsquo;; while (ch \u0026lt; \u0026lsquo;w\u0026rsquo;) { printf(\u0026quot;%c\u0026quot;, ch); ch++; } printf(\u0026quot;%c\\n\u0026quot;,ch); 11.下面的程序会打印出什么？ #define MESG \u0026ldquo;COMPUTER BYTES DOG\u0026rdquo; #include \u0026lt;stdio.h\u0026gt; int main(void) {\nint n = 0; while ( n \u0026lt; 5　) printf(\u0026quot;%s\\n\u0026quot;, MESG); n++; printf(\u0026ldquo;That\u0026rsquo;s all.\\n\u0026rdquo;); return 0; } 12.分别编写一条语句，完成下列各任务（或者说，使其具有以下副作 用）： a.将变量x的值增加 10 b.将变量x的值增加 1 c.将a与b之和的两倍赋给c d.将a与b的两倍之和赋给c 13.分别编写一条语句，完成下列各任务： a.将变量x的值减少 1 b.将n除以k的余数赋给m c.q除以b减去a，并将结果赋给p d.a与b之和除以c与d的乘积，并将结果赋给x\n5.11 编程练习 # 1.编写一个程序，把用分钟表示的时间转换成用小时和分钟表示的时 # 间。使用#define或const创建一个表示 60 的符号常量或const变量。通过while 循环让用户重复输入值，直到用户输入小于或等于 0 的值才停止循环。 2.编写一个程序，提示用户输入一个整数，然后打印从该数到比该数大 10 的所有整数（例如，用户输入 5 ，则打印 5 ～ 15 的所有整数，包括 5 和 15 ）。要求打印的各值之间用一个空格、制表符或换行符分开。 3.编写一个程序，提示用户输入天数，然后将其转换成周数和天数。例 如，用户输入 18 ，则转换成 2 周 4 天。以下面的格式显示结果： 18 days are 2 weeks, 4 days. 通过while循环让用户重复输入天数，当用户输入一个非正值时（如 0 或-20），循环结束。 4.编写一个程序，提示用户输入一个身高（单位：厘米），并分别以厘 米和英寸为单位显示该值，允许有小数部分。程序应该能让用户重复输入身 高，直到用户输入一个非正值。其输出示例如下： Enter a height in centimeters: 182 182.0 cm = 5　feet, 11.7 inches Enter a height in centimeters (\u0026lt;=0 to quit): 168.7 168.0 cm = 5　feet, 6.4 inches Enter a height in centimeters (\u0026lt;=0 to quit): 0 bye 5.修改程序addemup.c（程序清单5.13），你可以认为addemup.c是计算 20\n天里赚多少钱的程序（假设第 1 天赚$1、第 2 天赚$2、第 3 天赚$3，以此类 # 推）。修改程序，使其可以与用户交互，根据用户输入的数进行计算（即， # 用读入的一个变量来代替 20 ）。 # 6.修改编程练习 5 的程序，使其能计算整数的平方和（可以认为第 1 天赚 # $1、第 2 天赚$4、第 3 天赚$9，以此类推，这看起来很不错）。C没有平方函 # 数，但是可以用n * n来表示n的平方。 7.编写一个程序，提示用户输入一个double类型的数，并打印该数的立 方值。自己设计一个函数计算并打印立方值。main()函数要把用户输入的值 传递给该函数。 8.编写一个程序，显示求模运算的结果。把用户输入的第 1 个整数作为 求模运算符的第 2 个运算对象，该数在运算过程中保持不变。用户后面输入 的数是第 1 个运算对象。当用户输入一个非正值时，程序结束。其输出示例 如下： This program computes moduli. Enter an integer to serve as the second operand: 256 Now enter the first operand: 438 438　% 256　is 182 Enter next number for first operand (\u0026lt;= 0　to quit): 1234567 1234567　% 256　is 135 Enter next number for first operand (\u0026lt;= 0　to quit): 0 Done 9.编写一个程序，要求用户输入一个华氏温度。程序应读取double类型 的值作为温度值，并把该值作为参数传递给一个用户自定义的函数\nTemperatures()。该函数计算摄氏温度和开氏温度，并以小数点后面两位数字 的精度显示 3 种温度。要使用不同的温标来表示这 3 个温度值。下面是华氏温 度转摄氏温度的公式： 摄氏温度 = 5.0 / 9.0 * (华氏温度 - 32.0) 开氏温标常用于科学研究， 0 表示绝对零，代表最低的温度。下面是摄 氏温度转开氏温度的公式： 开氏温度 = 摄氏温度 + 273.16 Temperatures()函数中用const创建温度转换中使用的变量。在main()函数 中使用一个循环让用户重复输入温度，当用户输入 q 或其他非数字时，循环 结束。scanf()函数返回读取数据的数量，所以如果读取数字则返回 1 ，如果 读取q则不返回 1 。可以使用==运算符将scanf()的返回值和 1 作比较，测试两 值是否相等。\n[1].根据C标准，声明不是语句。这与C++有所不同。——译者注 [2].数调用语句在C语言中，赋值和函数调用都是表达式。没有所谓的”，这些语句实际上都是表达式语句。本书将“assignment“赋值语句”和“函 statement”均译为“赋值表达式语句”，以提醒读者注意。——译者注\n第 6 章 C 控制语句：循环 # 本章介绍以下内容： # 关键字：for、while、do while 运算符：\u0026lt;、\u0026gt;、\u0026gt;=、\u0026lt;=、!=、==、+=、*=、-=、/=、%= 函数：fabs() C语言有 3 种循环：for、while、do while 使用关系运算符构建控制循环的表达式 其他运算符 循环常用的数组 编写有返回值的函数 大多数人都希望自己是体格强健、天资聪颖、多才多艺的能人。虽然有 时事与愿违，但至少我们用 C能写出这样的程序。诀窍是控制程序流。对于 计算机科学（是研究计算机，不是用计算机做研究）而言，一门语言应该提 供以下 3 种形式的程序流： 执行语句序列； 如果满足某些条件就重复执行语句序列（循环 通过测试选择执行哪一个语句序列（分支）。 读者对第一种形式应该很熟悉，前面学过的程序中大部分都是由语句序 列组成。while循环属于第二种形式。本章将详细讲解while循环和其他两种 循环：for和do while。第三种形式用于在不同的执行方案之间进行选择，让\n程序更“智能”，且极大地提高了计算机的用途。不过，要等到下一章才介绍 # 这部分的内容。本章还将介绍数组，可以把新学的知识应用在数组上。另 # 外，本章还将继续介绍函数的相关内容。首先，我们从while循环开始学 习。\n6.1 再探 while 循环 # 经过上一章的学习，读者已经熟悉了 while 循环。这里，我们用一个程 序来回顾一下，程序清单 6.1根据用户从键盘输入的整数进行求和。程序利 用了scanf()的返回值来结束循环。 程序清单 6.1 summing.c 程序 /* summing.c \u0026ndash; 根据用户键入的整数求和 / #include \u0026lt;stdio.h\u0026gt; int main(void) { long num; long sum = 0L; / 把sum初始化为 0　/ int status; printf(\u0026ldquo;Please enter an integer to be summed \u0026ldquo;); printf(\u0026quot;(q to quit): \u0026ldquo;); status = scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;num); while (status == 1) / == 的意思是“等于” */ { sum = sum + num; printf(\u0026ldquo;Please enter next integer (q to quit): \u0026ldquo;);\nstatus = scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;num); } printf(\u0026ldquo;Those integers sum to %ld.\\n\u0026rdquo;, sum); return 0; } 该程序使用long类型以储存更大的整数。尽管C编译器会把 0 自动转换为 合适的类型，但是为了保持程序的一致性，我们把sum初始化为0L（long类 型的 0 ），而不是 0 （int类型的 0 ）。 该程序的运行示例如下： Please enter an integer to be summed (q to quit): 44 Please enter next integer (q to quit): 33 Please enter next integer (q to quit): 88 Please enter next integer (q to quit): 121 Please enter next integer (q to quit): q Those integers sum to 286.\n6.1.1 程序注释 # 先看while循环，该循环的测试条件是如下表达式： status == 1 ==运算符是C的相等运算符（equality operator），该表达式判断status是 否等于 1 。不要把status== 1与status = 1混淆，后者是把 1 赋给status。根据测试\n条件status == 1，只要status等于 1 ，循环就会重复。每次循环，num的当前值 都被加到sum上，这样sum的值始终是当前整数之和。当status的值不为 1 时， 循环结束。然后程序打印sum的最终值。 要让程序正常运行，每次循环都要获取num的一个新值，并重置status。 程序利用scanf()的两个不同的特性来完成。首先，使用scanf()读取num的一 个新值；然后，检查scanf()的返回值判断是否成功获取值。第 4 章中介绍 过，scanf()返回成功读取项的数量。如果scanf()成功读取一个整数，就把该 数存入num并返回 1 ，随后返回值将被赋给status（注意，用户输入的值储存 在num中，不是status中）。这样做同时更新了num和status的值，while循环进 入下一次迭代。如果用户输入的不是数字（如， q），scanf()会读取失败并 返回 0 。此时，status的值就是 0 ，循环结束。因为输入的字符q不是数字，所 以它会被放回输入队列中（实际上，不仅仅是 q，任何非数值的数据都会导 致循环终止，但是提示用户输入q退出程序比提示用户输入一个非数字字符 要简单）。 如果 scanf()在转换值之前出了问题（例如，检测到文件结尾或遇到硬件 问题），会返回一个特殊值EOF（其值通常被定义为-1）。这个值也会引起 循环终止。 如何告诉循环何时停止？该程序利用 scanf()的双重特性避免了在循环中 交互输入时的这个棘手的问题。例如，假设scanf()没有返回值，那么每次循 环只会改变num的值。虽然可以使用num的值来结束循环，比如把num \u0026gt; 0 （num大于 0 ）或num ！= 0（num不等于 0 ）作为测试条件，但是这样用户就 不能输入某些值，如-3或 0 。也可以在循环中添加代码，例如每次循环时询 问用户“是否继续循环？\u0026lt;y/n\u0026gt;”，然后判断用户是否输入y。这个方法有些笨 拙，而且还减慢了输入的速度。使用scanf()的返回值，轻松地避免了这些问 题。 现在，我们来看看该程序的结构。总结如下： 把sum初始化为 0\n提示用户输入数据 # 读取用户输入的数据 # 当输入的数据为整数时， # 输入添加给sum， 提示用户进行输入， 然后读取下一个输入 输入完成后，打印sum的值 顺带一提，这叫作伪代码（pseudocode），是一种用简单的句子表示程 序思路的方法，它与计算机语言的形式相对应。伪代码有助于设计程序的逻 辑。确定程序的逻辑无误之后，再把伪代码翻译成实际的编程代码。使用伪 代码的好处之一是，可以把注意力集中在程序的组织和逻辑上，不用在设计 程序时还要分心如何用编程语言来表达自己的想法。例如，可以用缩进来代 表一块代码，不用考虑C的语法要用花括号把这部分代码括起来。 总之，因为while循环是入口条件循环，程序在进入循环体之前必须获 取输入的数据并检查status的值，所以在 while 前面要有一个 scanf()。要让循 环继续执行，在循环内需要一个读取数据的语句，这样程序才能获取下一个 status的值，所以在while循环末尾还要有一个scanf()，它为下一次迭代做好 了准备。可以把下面的伪代码作为while循环的标准格式： 获得第 1 个用于测试的值 当测试为真时 处理值 获取下一个值\n6.1.2 C 风格读取循环 # 根据伪代码的设计思路，程序清单6.1可以用Pascal、BASIC或 FORTRAN来编写。但是C更为简洁，下面的代码： status = scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;num); while (status == 1) { /* 循环行为 */ status = scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;num); } 可以用这些代码替换： while (scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;num) == 1) { /循环行为/ } 第二种形式同时使用scanf()的两种不同的特性。首先，如果函数调用成 功，scanf()会把一个值存入num。然后，利用scanf()的返回值（ 0 或 1 ，不是 num的值）控制while循环。因为每次迭代都会判断循环的条件，所以每次迭 代都要调用scanf()读取新的num值来做判断。换句话说，C的语法特性让你可 以用下面的精简版本替换标准版本： 当获取值和判断值都成功 处理该值\n接下来，我们正式地学习while语句。\n6.2 while 语句 # while循环的通用形式如下： while ( expression ) statement statement部分可以是以分号结尾的简单语句，也可以是用花括号括起来 的复合语句。 到目前为止，程序示例中的expression部分都使用关系表达式。也就是 说，expression是值之间的比较，可以使用任何表达式。如果expression为真 （或者更一般地说，非零），执行 statement部分一次，然后再次判断 expression。在expression为假（ 0 ）之前，循环的判断和执行一直重复进行。 每次循环都被称为一次迭代（iteration），如图6.1所示。\n图6.1 while循环的结构 6.2.1 终止 while 循环 # while循环有一点非常重要：在构建while循环时，必须让测试表达式的 值有变化，表达式最终要为假。否则，循环就不会终止（实际上，可以使用 break和if语句来终止循环，但是你尚未学到）。考虑下面的例子： index = 1; while (index \u0026lt; 5) printf(\u0026ldquo;Good morning!\\n\u0026rdquo;); 上面的程序段将打印无数次 。为什么？因为循环中 index的值一直都是原来的值 1 ，不曾变过。现在，考虑下面的程序段：\n这段程序也好不到哪里去。虽然改变了index的值，但是改错了！不 过，这个版本至少在index减少到其类型到可容纳的最小负值并变成最大正 值时会终止循环（第 3 章3.4.2节中的toobig.c程序解释过，最大正值加 1 一般 会得到一个负值；类似地，最小负值减 1 一般会得到最大正值）。\n6.2.2 何时终止循环 # 要明确一点：只有在对测试条件求值时，才决定是终止还是继续循环。 # 例如，考虑程序清单6.2中的程序。 # 程序清单 6.2 when.c 程序 // when.c -- 何时退出循环 #include \u0026lt;stdio.h\u0026gt; int main(void) { # int n = 5; while (n \u0026lt; 7) // 第 7 行 { printf(\u0026ldquo;n = %d\\n\u0026rdquo;, n); n++; // 第 10 行 printf(\u0026ldquo;Now n = %d\\n\u0026rdquo;, n); // 第 11 行 } printf(\u0026ldquo;The loop has finished.\\n\u0026rdquo;); return 0; } 运行程序清单6.2，输出如下： n = 5 Now n = 6 n = 6 Now n = 7 The loop has finished. 在第 2 次循环时，变量n在第 10 行首次获得值 7 。但是，此时程序并未退 出，它结束本次循环（第 11 行），并在对第 7 行的测试条件求值时才退出循 环（变量n在第 1 次判断时为 5 ，第 2 次判断时为 6 ）。\n6.2.3 while ：入口条件循环 # while循环是使用入口条件的有条件循环。所谓“有条件”指的是语句部 分的执行取决于测试表达式描述的条件，如(index \u0026lt; 5)。该表达式是一个入 口条件（entry condition），因为必须满足条件才能进入循环体。在下面的情 况中，就不会进入循环体，因为条件一开始就为假： index = 10; while (index++ \u0026lt; 5) printf(\u0026ldquo;Have a fair day or better.\\n\u0026rdquo;); 把第 1 行改为： index = 3; 就可以运行这个循环了。\n6.2.4 语法要点 # 使用while时，要牢记一点：只有在测试条件后面的单独语句（简单语 句或复合语句）才是循环部分。程序清单6.3演示了忽略这点的后果。缩进 是为了让读者阅读方便，不是计算机的要求。 程序清单 6.3 while1.c 程序 /* while1.c \u0026ndash; 注意花括号的使用 / / 糟糕的代码创建了一个无限循环 */ #include \u0026lt;stdio.h\u0026gt; int main(void) {\nint n = 0; while (n \u0026lt; 3) printf(\u0026ldquo;n is %d\\n\u0026rdquo;, n); n++; printf(\u0026ldquo;That\u0026rsquo;s all this program does\\n\u0026rdquo;); return 0; } 该程序的输出如下： n is 0 n is 0 n is 0 n is 0 n is 0 \u0026hellip; 屏幕上会一直输出以上内容，除非强行关闭这个程序。 虽然程序中缩进了n++;这条语句，但是并未把它和上一条语句括在花括 号内。因此，只有直接跟在测试条件后面的一条语句是循环的一部分。变量 n的值不会改变，条件n \u0026lt; 3一直为真。该循环会一直打印n is 0，除非强行关 闭程序。这是一个无限循环（infinite loop）的例子，没有外部干涉就不会退 出。\n记住，即使while语句本身使用复合语句，在语句构成上，它也是一条 单独的语句。该语句从while开始执行，到第 1 个分号结束。在使用了复合语 句的情况下，到右花括号结束。 要注意放置分号的位置。例如，考虑程序清单6.4。 程序清单 6.4 while2.c 程序 /* while2.c \u0026ndash; 注意分号的位置 / #include \u0026lt;stdio.h\u0026gt; int main(void) { int n = 0; while (n++ \u0026lt; 3); / 第 7 行 / printf(\u0026ldquo;n is %d\\n\u0026rdquo;, n); / 第 8 行 */ printf(\u0026ldquo;That\u0026rsquo;s all this program does.\\n\u0026rdquo;); return 0; } 该程序的输出如下： n is 4 That\u0026rsquo;s all this program does. 如前所述，循环在执行完测试条件后面的第 1 条语句（简单语句或复合 语句）后进入下一轮迭代，直到测试条件为假才会结束。该程序中第 7 行的\n测试条件后面直接跟着一个分号，循环在此进入下一轮迭代，因为单独一个 # 分号被视为一条语句。虽然n的值在每次循环时都递增 1 ，但是第 8 行的语句 不是循环的一部分，因此只会打印一次循环结束后的n值。 在该例中，测试条件后面的单独分号是空语句（null statement），它什 么也不做。在C语言中，单独的分号表示空语句。有时，程序员会故意使用 带空语句的while语句，因为所有的任务都在测试条件中完成了，不需要在 循环体中做什么。例如，假设你想跳过输入到第 1 个非空白字符或数字，可 以这样写： while (scanf(\u0026quot;%d\u0026quot;, \u0026amp;num) == 1) ; /* 跳过整数输入 */ 只要scanf()读取一个整数，就会返回 1 ，循环继续执行。注意，为了提 高代码的可读性，应该让这个分号独占一行，不要直接把它放在测试表达式 同行。这样做一方面让读者更容易看到空语句，一方面也提醒自己和读者空 语句是有意而为之。处理这种情况更好的方法是使用下一章介绍的continue 语句。\n6.3 用关系运算符和表达式比较大小 # while循环经常依赖测试表达式作比较，这样的表达式被称为关系表达 式（relational expression），出现在关系表达式中间的运算符叫做关系运算 符（relational operator）。前面的示例中已经用过一些关系运算符，表 6.1 列出了 C 语言的所有关系运算符。该表也涵盖了所有的数值关系（数字之 间的关系再复杂也没有人与人之间的关系复杂）。 表 6.1 关系运算符\n关系运算符常用于构造while语句和其他C语句（稍后讨论）中用到的关 系表达式。这些语句都会检查关系表达式为真还是为假。下面有 3 个互不相 关的while语句，其中都包含关系表达式。 while (number \u0026lt; 6) { printf(\u0026ldquo;Your number is too small.\\n\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;number); } while (ch != \u0026lsquo;$\u0026rsquo;) {\ncount++; scanf(\u0026quot;%c\u0026quot;, \u0026amp;ch); } while (scanf(\u0026quot;%f\u0026quot;, \u0026amp;num) == 1) sum = sum + num; 注意，第 2 个while语句的关系表达式还可用于比较字符。比较时使用的 是机器字符码（假定为ASCII）。但是，不能用关系运算符比较字符串。第 11 章将介绍如何比较字符串。 虽然关系运算符也可用来比较浮点数，但是要注意：比较浮点数时，尽 量只使用\u0026lt;和\u0026gt;。因为浮点数的舍入误差会导致在逻辑上应该相等的两数却 不相等。例如， 3 乘以1/3的积是1.0。如果用把1/3表示成小数点后面 6 位数 字，乘积则是.999999，不等于 1 。使用fabs()函数（声明在math.h头文件中） 可以方便地比较浮点数，该函数返回一个浮点值的绝对值（即，没有代数符 号的值）。例如，可以用类似程序清单6.5的方法来判断一个数是否接近预 期结果。 程序清单 6.5 cmpflt.c 程序 // cmpflt.c \u0026ndash; 浮点数比较 #include \u0026lt;math.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main(void) { const double ANSWER = 3.14159;\ndouble response; printf(\u0026ldquo;What is the value of pi?\\n\u0026rdquo;); scanf(\u0026quot;%lf\u0026quot;, \u0026amp;response); while (fabs(response - ANSWER) \u0026gt; 0.0001) { printf(\u0026ldquo;Try again!\\n\u0026rdquo;); scanf(\u0026quot;%lf\u0026quot;, \u0026amp;response); } printf(\u0026ldquo;Close enough!\\n\u0026rdquo;); return 0; } 循环会一直提示用户继续输入，除非用户输入的值与正确值之间相差 0.0001： What is the value of pi? 3.14 Try again! 3.1416 Close enough!\n6.3.1 什么是真 # 这是一个古老的问题，但是对C而言还不算难。在C中，表达式一定有 # 一个值，关系表达式也不例外。程序清单6.6中的程序用于打印两个关系表 # 达式的值，一个为真，一个为假。 # 程序清单 6.6 t_and_f.c 程序 /* t_and_f.c \u0026ndash; C中的真和假的值 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int true_val, false_val; true_val = (10 \u0026gt; 2); // 关系为真的值 false_val = (10 == 2); // 关系为假的值 printf(\u0026ldquo;true = %d; false = %d \\n\u0026rdquo;, true_val, false_val); return 0; } 程序清单6.6把两个关系表达式的值分别赋给两个变量，即把表达式为 真的值赋给true_val，表达式为假的值赋给false_val。运行该程序后输出如 下： true = 1; false = 0 原来如此！对C而言，表达式为真的值是 1 ，表达式为假的值是 0 。一些 C程序使用下面的循环结构，由于 1 为真，所以循环会一直进行。 while (1)\n{ # \u0026hellip; # } # 6.3.2 其他真值 # 既然 1 或 0 可以作为while语句的测试表达式，是否还可以使用其他数 字？如果可以，会发生什么？我们用程序清单6.7来做个实验。 程序清单 6.7 truth.c 程序 // truth.c \u0026ndash; 哪些值为真 #include \u0026lt;stdio.h\u0026gt; int main(void) { int n = 3; while (n) printf(\u0026quot;%2d is true\\n\u0026quot;, n\u0026ndash;); printf(\u0026quot;%2d is false\\n\u0026quot;, n); n = -3; while (n) printf(\u0026quot;%2d is true\\n\u0026quot;, n++); printf(\u0026quot;%2d is false\\n\u0026quot;, n);\nreturn 0; } 该程序的输出如下： 3　is true 2　is true 1　is true 0　is false -3 is true -2 is true -1 is true 0　is false 执行第 1 个循环时，n分别是 3 、 2 、 1 ，当n等于 0 时，第 1 个循环结束。与 此类似，执行第 2 个循环时，n分别是-3、-2和-1，当n等于 0 时，第 2 个循环结 束。一般而言，所有的非零值都视为真，只有 0 被视为假。在C中，真的概 念还真宽！ 也可以说，只要测试条件的值为非零，就会执行 while 循环。这是从数 值方面而不是从真/假方面来看测试条件。要牢记：关系表达式为真，求值 得 1 ；关系表达式为假，求值得 0 。因此，这些表达式实际上相当于数值。 许多C程序员都会很好地利用测试条件的这一特性。例如，用while (goats)替换while (goats !=0)，因为表达式goats != 0和goats都只有在goats的值 为 0 时才为 0 或假。第 1 种形式（while (goats != 0)）对初学者而言可能比较清 楚，但是第 2 种形式（while (goats)）才是C程序员最常用的。要想成为一名\nC程序员，应该多熟悉while (goats)这种形式。\n6.3.3 真值的问题 # C对真的概念约束太少会带来一些麻烦。例如，我们稍微修改一下程序 # 清单6.1，修改后的程序如程序清单6.8所示。 # 程序清单 6.8 trouble.c 程序 // trouble.c -- 误用=会导致无限循环 #include \u0026lt;stdio.h\u0026gt; int main(void) { long num; long sum = 0L; int status; printf(\u0026#34;Please enter an integer to be summed \u0026#34;); printf(\u0026#34;(q to quit): \u0026#34;); status = scanf(\u0026#34;%ld\u0026#34;, \u0026amp;num); while (status = 1) { sum = sum + num; printf(\u0026#34;Please enter next integer (q to quit): \u0026#34;); status = scanf(\u0026quot;%ld\u0026quot;, \u0026amp;num); } printf(\u0026ldquo;Those integers sum to %ld.\\n\u0026rdquo;, sum); return 0; } 运行该程序，其输出如下： Please enter an integer to be summed (q to quit): 20 Please enter next integer (q to quit): 5 Please enter next integer (q to quit): 30 Please enter next integer (q to quit): q Please enter next integer (q to quit): Please enter next integer (q to quit): Please enter next integer (q to quit): Please enter next integer (q to quit): （„„屏幕上会一直显示最后的提示内容，除非强行关闭程序。也许你根 本不想运行这个示例。） 这个麻烦的程序示例改动了while循环的测试条件，把status == 1替换成 status = 1。后者是一个赋值表达式语句，所以 status 的值为 1 。而且，整个 赋值表达式的值就是赋值运算符左侧的值，所以status = 1的值也是 1 。这 里，while (status = 1)实际上相当于while (1)，也就是说，循环不会退出。虽 然用户输入q，status被设置为 0 ，但是循环的测试条件把status又重置为 1 ，进\n入了下一次迭代。 # 读者可能不太理解，程序的循环一直运行着，用户在输入q后完全没机 会继续输入。如果scanf()读取指定形式的输入失败，就把无法读取的输入留 在输入队列中，供下次读取。当scanf()把q作为整数读取时失败了，它把 q 留下。在下次循环时，scanf()从上次读取失败的地方（q）开始读取，scanf() 把q作为整数读取，又失败了。因此，这样修改后不仅创建了一个无限循 环，还创建了一个无限失败的循环，真让人沮丧。好在计算机觉察不出来。 对计算机而言，无限地执行这些愚蠢的指令比成功预测未来 10 年的股市行情 没什么两样。 不要在本应使用==的地方使用=。一些计算机语言（如，BASIC）用相 同的符号表示赋值运算符和关系相等运算符，但是这两个运算符完全不同 （见图 6.2）。赋值运算符把一个值赋给它左侧的变量；而关系相等运算符 检查它左侧和右侧的值是否相等，不会改变左侧变量的值（如果左侧是一个 变量）。\n图6.2 关系运算符==和赋值运算符= 示例如下： 要注意使用正确的运算符。编译器不会检查出你使用了错误的形式，得 # 出也不是预期的结果（误用=的人实在太多了，以至于现在大多数编译器都 # 会给出警告，提醒用户是否要这样做）。如果待比较的一个值是常量，可以 # 把该常量放在左侧有助于编译器捕获错误： # 可以这样做是因为C语言不允许给常量赋值，编译器会把赋值运算符的 # 这种用法作为语法错误标记出来。许多经验丰富的程序员在构建比较是否相 # 等的表达式时，都习惯把常量放在左侧。 # 总之，关系运算符用于构成关系表达式。关系表达式为真时值为 1 ，为 # 假时值为 0 。通常用关系表达式作为测试条件的语句（如while和if）可以使 用任何表达式作为测试条件，非零为真，零为假。\n6.3.4 新的 _Bool 类型 # 在C语言中，一直用int类型的变量表示真/假值。C99专门针对这种类型 的变量新增了_Bool类型。该类型是以英国数学家George Boole的名字命名 的，他开发了用代数表示逻辑和解决逻辑问题。在编程中，表示真或假的变 量被称为布尔变量（Boolean variable），所以_Bool是C语言中布尔变量的类 型名。_Bool类型的变量只能储存 1 （真）或 0 （假）。如果把其他非零数值 赋给_Bool类型的变量，该变量会被设置为 1 。这反映了C把所有的非零值都 视为真。 程序清单6.9修改了程序清单6.8中的测试条件，把int类型的变量status替 换为_Bool类型的变量input_is_good。给布尔变量取一个能表示真或假值的 变量名是一种常见的做法。\n程序清单 6.9 boolean.c 程序 // boolean.c \u0026ndash; 使用_Bool类型的变量 variable #include \u0026lt;stdio.h\u0026gt; int main(void) { long num; long sum = 0L; _Bool input_is_good; printf(\u0026ldquo;Please enter an integer to be summed \u0026ldquo;); printf(\u0026quot;(q to quit): \u0026ldquo;); input_is_good = (scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;num) == 1); while (input_is_good) { sum = sum + num; printf(\u0026ldquo;Please enter next integer (q to quit): \u0026ldquo;); input_is_good = (scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;num) == 1); } printf(\u0026ldquo;Those integers sum to %ld.\\n\u0026rdquo;, sum); return 0;\n} # 注意程序中把比较的结果赋值给_Bool类型的变量input_is_good： input_is_good = (scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;num) == 1); 这样做没问题，因为==运算符返回的值不是 1 就是 0 。顺带一提，从优 先级方面考虑的话，并不需要用圆括号把 括起来。但是，这样做可以提高代 码可读性。还要注意，如何为变量命名才能让while循环的测试简单易懂： while (input_is_good) C99提供了stdbool.h头文件，该头文件让bool成为_Bool的别名，而且还 把true和false分别定义为 1 和 0 的符号常量。包含该头文件后，写出的代码可 以与C++兼容，因为C++把bool、true和false定义为关键字。 如果系统不支持_Bool类型，导致无法运行该程序，可以把_Bool替换成 int即可。\n6.3.5 优先级和关系运算符 # 关系运算符的优先级比算术运算符（包括+和-）低，比赋值运算符高。 # 这意味着x \u0026gt; y + 2和x \u0026gt; (y+ 2)相同，x = y \u0026gt; 2和x = (y \u0026gt; 2)相同。换言之，如 果y大于 2 ，则给x赋值 1 ，否则赋值 0 。y的值不会赋给x。 关系运算符比赋值运算符的优先级高，因此，x_bigger = x \u0026gt; y;相当于 x_bigger = (x \u0026gt; y);。 关系运算符之间有两种不同的优先级。 高优先级组： \u0026laquo;= \u0026raquo;= 低优先级组： == !=\n与其他大多数运算符一样，关系运算符的结合律也是从左往右。因此： # ex != wye == zee与(ex != wye) == zee相同 首先，C判断ex与wye是否相等；然后，用得出的值 1 或 0 （真或假）再 与zee比较。我们并不推荐这样写，但是在这里有必要说明一下。 表6.2列出了目前我们学过的运算符的性质。附录B的参考资料II“C运算 符”中列出了全部运算符的完整优先级表。 表 6.2 运算符优先级\n小结： while 语句 关键字： while 一般注解： while语句创建了一个循环，重复执行直到测试表达式为假或 0 。while语 句是一种入口条件循环，也就是说，在执行多次循环之前已决定是否执行循 环。因此，循环有可能不被执行。循环体可以是简单语句，也可以是复合语 句。 形式： while ( expression ) statement\n在expression部分为假或 0 之前，重复执行statement部分。 示例： while (n++ \u0026lt; 100) printf(\u0026rdquo; %d %d\\n\u0026rdquo;,n, 2 * n + 1); // 简单语句 while (fargo \u0026lt; 1000) { // 复合语句 fargo = fargo + step; step = 2 * step; } 小结：关系运算符和表达式 关系运算符： 每个关系运算符都把它左侧的值和右侧的值进行比较。 \u0026lt;　小于 \u0026lt;= 小于或等于 == 等于\n= 大于或等于 大于 != 不等于 关系表达式：\n简单的关系表达式由关系运算符及其运算对象组成。如果关系为真，关 # 系表达式的值为 1 ；如果关系为假，关系表达式的值为 0 。 # 示例： # 5 \u0026gt; 2为真，关系表达式的值为 1 # (2 + a) == a 为假，关系表达式的值为 0 6.4 不确定循环和计数循环 # 一些while循环是不确定循环（indefinite loop）。所谓不确定循环，指 在测试表达式为假之前，预先不知道要执行多少次循环。例如，程序清单 6.1通过与用户交互获得数据来计算整数之和。我们事先并不知道用户会输 入什么整数。另外，还有一类是计数循环（counting loop）。这类循环在执 行循环之前就知道要重复执行多少次。程序清单6.10就是一个简单的计数循 环。 程序清单 6.10 sweetie1.c 程序 // sweetie1.c \u0026ndash; 一个计数循环 #include \u0026lt;stdio.h\u0026gt; int main(void) { const int NUMBER = 22; int count = 1; // 初始化 while (count \u0026lt;= NUMBER) // 测试 { printf(\u0026ldquo;Be my Valentine!\\n\u0026rdquo;); // 行为 count++; // 更新计数 } return 0; }\n虽然程序清单6.10运行情况良好，但是定义循环的行为并未组织在一 # 起，程序的编排并不是很理想。我们来仔细分析一下。 # 在创建一个重复执行固定次数的循环中涉及了 3 个行为： # 1.必须初始化计数器； # 2.计数器与有限的值作比较； # 3.每次循环时递增计数器。 # while循环的测试条件执行比较，递增运算符执行递增。程序清单6.10 中，递增发生在循环的末尾，这可以防止不小心漏掉递增。因此，这样做比 将测试和更新组合放在一起（即使用count++ \u0026lt;= NUMBER）要好，但是计数 器的初始化放在循环外，就有可能忘记初始化。实践告诉我们可能会发生的 事情终究会发生，所以我们来学习另一种控制语句，可以避免这些问题。\n6.5 for 循环 # for循环把上述 3 个行为（初始化、测试和更新）组合在一处。程序清单 6.11使用for循环修改了程序清单6.10的程序。 程序清单 6.11 sweetie2.c 程序 // sweetie2.c \u0026ndash; 使用for循环的计数循环 #include \u0026lt;stdio.h\u0026gt; int main(void) { const int NUMBER = 22; int count; for (count = 1; count \u0026lt;= NUMBER; count++) printf(\u0026ldquo;Be my Valentine!\\n\u0026rdquo;); return 0; } 关键字for后面的圆括号中有 3 个表达式，分别用两个分号隔开。第 1 个 表达式是初始化，只会在for循环开始时执行一次。第 2 个表达式是测试条 件，在执行循环之前对表达式求值。如果表达式为假（本例中，count大于 NUMBER时），循环结束。第 3 个表达式执行更新，在每次循环结束时求 值。程序清单6.10用这个表达式递增count 的值，更新计数。完整的for语句 还包括后面的简单语句或复合语句。for圆括号中的表达式也叫做控制表达 式，它们都是完整表达式，所以每个表达式的副作用（如，递增变量）都发 生在对下一个表达式求值之前。图6.3演示了for循环的结构。\n图6.3 for循环的结构 程序清单 6.12 for_cube.c 程序 /* for_cube.c \u0026ndash; 使用for循环创建一个立方表 / #include \u0026lt;stdio.h\u0026gt; int main(void) { int num; printf(\u0026quot; n n cubed\\n\u0026quot;); for (num = 1; num \u0026lt;= 6; num++) printf(\u0026quot;%5d %5d\\n\u0026quot;, num, numnum*num); return 0;\n} # 程序清单6.12打印整数 1 ～ 6 及其对应的立方，该程序的输出如下： # n n cubed 1　1 2　8 3　27 4　64 5　125 6　216 for循环的第 1 行包含了循环所需的所有信息：num的初值，num的终 值[1]和每次循环num的增量。 6.5.1 利用 for 的灵活性 虽然for循环看上去和FORTRAN的DO循环、Pascal的FOR循环、BASIC 的FOR\u0026hellip;NEXT循环类似，但是for循环比这些循环灵活。这些灵活性源于如 何使用for循环中的 3 个表达式。以前面程序示例中的for循环为例，第 1 个表 达式给计数器赋初值，第 2 个表达式表示计数器的范围，第 3 个表达式递增计 数器。这样使用for循环确实很像其他语言的循环。除此之外，for循环还有 其他 9 种用法。 可以使用递减运算符来递减计数器： /* for_down.c */ #include \u0026lt;stdio.h\u0026gt;\nint main(void) { int secs; for (secs = 5; secs \u0026gt; 0; secs\u0026ndash;) printf(\u0026quot;%d seconds!\\n\u0026quot;, secs); printf(\u0026ldquo;We have ignition!\\n\u0026rdquo;); return 0; } 该程序输出如下： 5 seconds! 4 seconds! 3 seconds! 2 seconds! 1 seconds! We have ignition! 可以让计数器递增 2 、 10 等： /* for_13s.c */ #include \u0026lt;stdio.h\u0026gt; int main(void)\n{ # int n; // 从 2 开始，每次递增 13 for (n = 2; n \u0026lt; 60; n = n + 13) printf(\u0026quot;%d \\n\u0026quot;, n); return 0; } 每次循环n递增 13 ，程序的输出如下： 2 15 28 41 54 可以用字符代替数字计数： /* for_char.c */ #include \u0026lt;stdio.h\u0026gt; int main(void) { char ch; for (ch = \u0026lsquo;a\u0026rsquo;; ch \u0026lt;= \u0026lsquo;z\u0026rsquo;; ch++)\nprintf(\u0026ldquo;The ASCII value for %c is %d.\\n\u0026rdquo;, ch, ch); return 0; } 该程序假定系统用ASCII码表示字符。由于篇幅有限，省略了大部分输 出： The ASCII value for a is 97. The ASCII value for b is 98. \u0026hellip; The ASCII value for x is 120. The ASCII value for y is 121. The ASCII value for z is 122. 该程序能正常运行是因为字符在内部是以整数形式储存的，因此该循环 实际上仍是用整数来计数。 除了测试迭代次数外，还可以测试其他条件。在for_cube程序中，可以 把： for (num = 1; num \u0026lt;= 6; num++) 替换成： for (num = 1; numnumnum \u0026lt;= 216; num++) 如果与控制循环次数相比，你更关心限制立方的大小，就可以使用这样 的测试条件。\n可以让递增的量几何增长，而不是算术增长。也就是说，每次都乘上而 # 不是加上一个固定的量： # /* for_geo.c */ #include \u0026lt;stdio.h\u0026gt; int main(void) { double debt; for (debt = 100.0; debt \u0026lt; 150.0; debt = debt * 1.1) printf(\u0026ldquo;Your debt is now $%.2f.\\n\u0026rdquo;, debt); return 0; } 该程序中，每次循环都把debt乘以1.1，即debt的值每次都增加10%，其 输出如下： Your debt is now $100.00. Your debt is now $110.00. Your debt is now $121.00. Your debt is now $133.10. Your debt is now $146.41. 第 3 个表达式可以使用任意合法的表达式。无论是什么表达式，每次迭 代都会更新该表达式的值。\n/* for_wild.c */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int x; int y = 55; for (x = 1; y \u0026lt;= 75; y = (++x * 5) + 50) printf(\u0026quot;%10d %10d\\n\u0026quot;, x, y); return 0; } 该循环打印x的值和表达式++x * 5 + 50的值，程序的输出如下： 1　55 2　60 3　65 4　70 5　75 注意，测试涉及y，而不是x。for循环中的 3 个表达式可以是不同的变量 （注意，虽然该例可以正常运行，但是编程风格不太好。如果不在更新部分 加入代数计算，程序会更加清楚）。 可以省略一个或多个表达式（但是不能省略分号），只要在循环中包含\n能结束循环的语句即可。 # /* for_none.c */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int ans, n; ans = 2; for (n = 3; ans \u0026lt;= 25;) ans = ans * n; printf(\u0026ldquo;n = %d; ans = %d.\\n\u0026rdquo;, n, ans); return 0; } 该程序的输出如下： n = 3; ans = 54. 该循环保持n的值为 3 。变量ans开始的值为 2 ，然后递增到 6 和 18 ，最终 是 54 （ 18 比 25 小，所以for循环进入下一次迭代， 18 乘以 3 得 54 ）。顺带一 提，省略第 2 个表达式被视为真，所以下面的循环会一直运行： for (; ; ) printf(\u0026ldquo;I want some action\\n\u0026rdquo;); 第 1 个表达式不一定是给变量赋初值，也可以使用printf()。记住，在执\n行循环的其他部分之前，只对第 1 个表达式求值一次或执行一次。 # /* for_show.c */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int num = 0; for (printf(\u0026#34;Keep entering numbers!\\n\u0026#34;); num != 6;) scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); printf(\u0026#34;That\u0026#39;s the one I want!\\n\u0026#34;); return 0; } 该程序打印第 1 行的句子一次，在用户输入 6 之前不断接受数字： Keep entering numbers! 3 5 8 6 That\u0026#39;s the one I want! 循环体中的行为可以改变循环头中的表达式。例如，假设创建了下面的 循环： # for (n = 1; n \u0026lt; 10000; n = n + delta) 如果程序经过几次迭代后发现delta太小或太大，循环中的if语句（详见 第 7 章）可以改变delta的大小。在交互式程序中，用户可以在循环运行时才 改变 delta 的值。这样做也有危险的一面，例如，把delta设置为 0 就没用了。 总而言之，可以自己决定如何使用for循环头中的表达式，这使得在执 行固定次数的循环外，还可以做更多的事情。接下来，我们将简要讨论一些 运算符，使for循环更加有用。 小结： for 语句 关键字： for 一般注解： for语句使用 3 个表达式控制循环过程，分别用分号隔开。initialize表达 式在执行for语句之前只执行一次；然后对test表达式求值，如果表达式为真 （或非零），执行循环一次；接着对update表达式求值，并再次检查test表达 式。for语句是一种入口条件循环，即在执行循环之前就决定了是否执行循 环。因此，for循环可能一次都不执行。statement部分可以是一条简单语句或 复合语句。 形式： for ( initialize; test; update ) statement 在test为假或 0 之前，重复执行statement部分。 示例：\nfor (n = 0; n \u0026lt; 10　; n++) printf(\u0026quot; %d %d\\n\u0026quot;, n, 2 * n + 1);\n6.6 其他赋值运算符： += 、 -= 、 *= 、 /= 、 %= # C有许多赋值运算符。最基本、最常用的是=，它把右侧表达式的值赋 # 给左侧的变量。其他赋值运算符都用于更新变量，其用法都是左侧是一个变 # 量名，右侧是一个表达式。赋给变量的新值是根据右侧表达式的值调整后的 # 值。确切的调整方案取决于具体的运算符。例如： # scores += 20　与　scores = scores + 20　相同 dimes -= 2　与　dimes = dimes - 2　相同 bunnies *= 2 与　bunnies = bunnies * 2　相同 time /= 2.73　与　time = time / 2.73　相同 reduce %= 3 与　reduce = reduce % 3 相同 上述所列的运算符右侧都使用了简单的数，还可以使用更复杂的表达 式，例如： x = 3 * y + 12 与 x = x * (3 * y + 12) 相同 以上提到的赋值运算符与=的优先级相同，即比+或优先级低。上面最 后一个例子也反映了赋值运算符的优先级，3 * y先与 12 相加，再把计算结果 与x相乘，最后再把乘积赋给x。 并非一定要使用这些组合形式的赋值运算符。但是，它们让代码更紧 凑，而且与一般形式相比，组合形式的赋值运算符生成的机器代码更高效。 当需要在for循环中塞进一些复杂的表达式时，这些组合的赋值运算符特别 有用。\n6.7 逗号运算符 # 逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达 式。例如，程序清单6.13演示了一个打印一类邮件资费（first-class postage rate）的程序（在撰写本书时，邮资为首重 40 美分/盎司，续重 20 美分/盎 司，可以在互联网上查看当前邮资）。 程序清单 6.13 postage.c 程序 // postage.c \u0026ndash; 一类邮资 #include \u0026lt;stdio.h\u0026gt; int main(void) { const int FIRST_OZ = 46; // 2013邮资 const int NEXT_OZ = 20; // 2013邮资 int ounces, cost; printf(\u0026quot; ounces cost\\n\u0026quot;); for (ounces = 1, cost = FIRST_OZ; ounces \u0026lt;= 16; ounces++,cost += NEXT_OZ) printf(\u0026quot;%5d $%4.2f\\n\u0026quot;, ounces, cost / 100.0); return 0; } 该程序的前 5 行输出如下：\nounces cost 1　$0.46 2　$0.66 3　$0.86 4　$1.06 该程序在初始化表达式和更新表达式中使用了逗号运算符。初始化表达 式中的逗号使ounces和cost都进行了初始化，更新表达式中的逗号使每次迭 代ounces递增 1 、cost递增 20 （NEXT_Z的值是 20 ）。绝大多数计算都在for循 环头中进行（见图6.4）。 逗号运算符并不局限于在for循环中使用，但是这是它最常用的地方。 逗号运算符有两个其他性质。首先，它保证了被它分隔的表达式从左往右求 值（换言之，逗号是一个序列点，所以逗号左侧项的所有副作用都在程序执 行逗号右侧项之前发生）。因此，ounces在cost之前被初始化。在该例中， 顺序并不重要，但是如果cost的表达式中包含了ounces时，顺序就很重要。 例如，假设有下面的表达式： ounces++, cost = ounces * FIRST_OZ 在该表达式中，先递增ounce，然后在第 2 个子表达式中使用ounce的新 值。作为序列点的逗号保证了左侧子表达式的副作用在对右侧子表达式求值 之前发生。\n图6.4 逗号运算符和for循环 其次，整个逗号表达式的值是右侧项的值。例如，下面语句 x = (y = 3, (z = ++y + 2) + 5);的效果是：先把 3 赋给y，递增y为 4 ，然后把 4 加 2 之和（ 6 ）赋给z，接着加上 5 ，最后把结果 11 赋给 x。至于为什么有人 编写这样的代码，在此不做评价。另一方面，假设在写数字时不小心输入了 逗号： houseprice = 249,500; 这不是语法错误，C 编译器会将其解释为一个逗号表达式，即 houseprice = 249 是逗号左侧的子表达式， 500 是右侧的子表达式。因此，整 个逗号表达式的值是逗号右侧表达式的值，而且左侧的赋值表达式把 249 赋 给变量houseprice。因此，这与下面代码的效果相同： houseprice = 249; 500;记住，任何表达式后面加上一个分号就成了表达式语句。所以， 500;也是一条语句，但是什么也不做。\n另外，下面的语句 # houseprice = (249,500); 赋给houseprice的值是逗号右侧子表达式的值，即 500 。 逗号也可用作分隔符。在下面语句中的逗号都是分隔符，不是逗号运算 符： char ch, date; printf(\u0026quot;%d %d\\n\u0026quot;, chimps, chumps); 小结：新的运算符 赋值运算符： 下面的运算符用右侧的值，根据指定的操作更新左侧的变量： +=　把右侧的值加到左侧的变量上 -=　从左侧的变量中减去右侧的值 *= 把左侧的变量乘以右侧的值 /=　把左侧的变量除以右侧的值 %=　左侧变量除以右侧值得到的余数 示例： rabbits *= 1.6;与rabbits = rabbits * 1.6;相同 这些组合赋值运算符与普通赋值运算符的优先级相同，都比算术运算符 的优先级低。因此， contents *= old_rate + 1.2;\n最终的效果与下面的语句相同： # contents = contents * (old_rate + 1.2); 逗号运算符： 逗号运算符把两个表达式连接成一个表达式，并保证最左边的表达式最 先求值。逗号运算符通常在for循环头的表达式中用于包含更多的信息。整 个逗号表达式的值是逗号右侧表达式的值。 示例： for (step = 2, fargo = 0; fargo \u0026lt; 1000; step *= 2) fargo += step; 6.7.1 当 Zeno 遇到 for 循环 接下来，我们看看 for 循环和逗号运算符如何解决古老的悖论。希腊哲 学家 Zeno 曾经提出箭永远不会达到它的目标。首先，他认为箭要到达目标 距离的一半，然后再达到剩余距离的一半，然后继续到达剩余距离的一半， 这样就无穷无尽。Zeno认为箭的飞行过程有无数个部分，所以要花费无数时 间才能结束这一过程。不过，我们怀疑Zeno是自愿甘做靶子才会得出这样的 结论。 我们采用一种定量的方法，假设箭用 1 秒钟走完一半的路程，然后用1/2 秒走完剩余距离的一半，然后用1/4秒再走完剩余距离的一半，等等。可以 用下面的无限序列来表示总时间： 1 + 1/2 + 1/4 + 1/8 + 1/16 +\u0026hellip;. 程序清单6.14中的程序求出了序列前几项的和。变量power_of_two的值 分别是1.0、2.0、4.0、8.0等。 程序清单 6.14 zeno.c 程序\n/* zeno.c \u0026ndash; 求序列的和 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int t_ct; // 项计数 double time, power_of_2; int limit; printf(\u0026ldquo;Enter the number of terms you want: \u0026ldquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;limit); for (time = 0, power_of_2 = 1, t_ct = 1; t_ct \u0026lt;= limit; t_ct++, power_of_2 *= 2.0) { time += 1.0 / power_of_2; printf(\u0026ldquo;time = %f when terms = %d.\\n\u0026rdquo;, time, t_ct); } return 0; } 下面是序列前 15 项的和： Enter the number of terms you want: 15\ntime = 1.000000 when terms = 1. time = 1.500000 when terms = 2. time = 1.750000 when terms = 3. time = 1.875000 when terms = 4. time = 1.937500 when terms = 5. time = 1.968750 when terms = 6. time = 1.984375 when terms = 7. time = 1.992188 when terms = 8. time = 1.996094 when terms = 9. time = 1.998047 when terms = 10. time = 1.999023 when terms = 11. time = 1.999512 when terms = 12. time = 1.999756 when terms = 13. time = 1.999878 when terms = 14. time = 1.999939 when terms = 15. 不难看出，尽管不断添加新的项，但是总和看起来变化不大。就像程序 输出显示的那样，数学家的确证明了当项的数目接近无穷时，总和无限接近 2.0。假设S表示总和，下面我们用数学的方法来证明一下： S = 1 + 1/2 + 1/4 + 1/8 + \u0026hellip; 这里的省略号表示“等等”。把S除以 2 得：\nS/2 = 1/2 + 1/4 + 1/8 + 1/16 + \u0026hellip; # 第 1 个式子减去第 2 个式子得： # S - S/2 = 1 +1/2 -1/2 + 1/4 -1/4 +\u0026hellip; # 除了第 1 个值为 1 ，其他的值都是一正一负地成对出现，所以这些项都可 # 以消去。只留下： # S/2 = 1 # 然后，两侧同乘以 2 ，得： # S = 2 # 从这个示例中得到的启示是，在进行复杂的计算之前，先看看数学上是 # 否有简单的方法可用。 # 程序本身是否有需要注意的地方？该程序演示了在表达式中可以使用多 # 个逗号运算符，在for循环中，初始化了time、power_of_2和count。构建完循 环条件之后，程序本身就很简短了。\n6.8 出口条件循环： do while # while循环和for循环都是入口条件循环，即在循环的每次迭代之前检查 测试条件，所以有可能根本不执行循环体中的内容。C语言还有出口条件循 环（exit-condition loop），即在循环的每次迭代之后检查测试条件，这保证 了至少执行循环体中的内容一次。这种循环被称为 do while循环。程序清单 6.15 演示了一个示例。 程序清单 6.15 do_while.c 程序 /* do_while.c \u0026ndash; 出口条件循环 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { const int secret_code = 13; int code_entered; do { printf(\u0026ldquo;To enter the triskaidekaphobia therapy club,\\n\u0026rdquo;); printf(\u0026ldquo;please enter the secret code number: \u0026ldquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;code_entered); } while (code_entered != secret_code); printf(\u0026ldquo;Congratulations! You are cured!\\n\u0026rdquo;);\nreturn 0; } 程序清单6.15在用户输入 13 之前不断提示用户输入数字。下面是一个运 行示例： To enter the triskaidekaphobia therapy club, please enter the secret code number: 12 To enter the triskaidekaphobia therapy club, please enter the secret code number: 14 To enter the triskaidekaphobia therapy club, please enter the secret code number: 13 Congratulations! You are cured! 使用while循环也能写出等价的程序，但是长一些，如程序清单6.16所 示。 程序清单 6.16 entry.c 程序 /* entry.c \u0026ndash; 出口条件循环 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { const int secret_code = 13; int code_entered;\nprintf(\u0026ldquo;To enter the triskaidekaphobia therapy club,\\n\u0026rdquo;); printf(\u0026ldquo;please enter the secret code number: \u0026ldquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;code_entered); while (code_entered != secret_code) { printf(\u0026ldquo;To enter the triskaidekaphobia therapy club,\\n\u0026rdquo;); printf(\u0026ldquo;please enter the secret code number: \u0026ldquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;code_entered); } printf(\u0026ldquo;Congratulations! You are cured!\\n\u0026rdquo;); return 0; } 下面是do while循环的通用形式： do statement while ( expression ); statement可以是一条简单语句或复合语句。注意，do while循环以分号 结尾，其结构见图6.5。 do while循环在执行完循环体后才执行测试条件，所以至少执行循环体 一次；而for循环或while循环都是在执行循环体之前先执行测试条件。do\nwhile循环适用于那些至少要迭代一次的循环。例如，下面是一个包含do while循环的密码程序伪代码：\n图6.5 do while循环的结构 do { 提示用户输入密码 读取用户输入的密码 } while (用户输入的密码不等于密码); 避免使用这种形式的do while结构： do { 询问用户是否继续 其他行为 # } while (回答是yes); 这样的结构导致用户在回答“no”之后，仍然执行“其他行为”部分，因为 测试条件执行晚了。 小结： do while 语句 关键字： do while 一般注解： do while 语句创建一个循环，在 expression 为假或 0 之前重复执行循环 体中的内容。do while语句是一种出口条件循环，即在执行完循环体后才根 据测试条件决定是否再次执行循环。因此，该循环至少必须执行一次。 statement部分可是一条简单语句或复合语句。 形式： do statement while ( expression ); 在test为假或 0 之前，重复执行statement部分。 示例： do scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;number); while (number != 20);\n6.9 如何选择循环 # 如何选择使用哪一种循环？首先，确定是需要入口条件循环还是出口条 # 件循环。通常，入口条件循环用得比较多，有几个原因。其一，一般原则是 # 在执行循环之前测试条件比较好。其二，测试放在循环的开头，程序的可读 # 性更高。另外，在许多应用中，要求在一开始不满足测试条件时就直接跳过 # 整个循环。 # 那么，假设需要一个入口条件循环，用for循环还是while循环？这取决 于个人喜好，因为二者皆可。要让for循环看起来像while循环，可以省略第 1 个和第 3 个表达式。例如： for ( ; test ; ) 与下面的while效果相同： while ( test ) 要让while循环看起来像for循环，可以在while循环的前面初始化变量， 并在while循环体中包含更新语句。例如： 初始化; while ( 测试 ) { 其他语句 更新语句 } 与下面的for循环效果相同：\nfor ( 初始化 ;测试 ; 更新 ) 其他语句 一般而言，当循环涉及初始化和更新变量时，用for循环比较合适，而 在其他情况下用while循环更好。对于下面这种条件，用while循环就很合 适： while (scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;num) == 1) 对于涉及索引计数的循环，用for循环更适合。例如： for (count = 1; count \u0026lt;= 100; count++)\n6.10 嵌套循环 # 嵌套循环（nested loop）指在一个循环内包含另一个循环。嵌套循环常 用于按行和列显示数据，也就是说，一个循环处理一行中的所有列，另一个 循环处理所有的行。程序清单6.17演示了一个简单的示例。 程序清单 6.17 rows1.c 程序 /* rows1.c \u0026ndash; 使用嵌套循环 / #include \u0026lt;stdio.h\u0026gt; #define ROWS 6 #define CHARS 10 int main(void) { int row; char ch; for (row = 0; row \u0026lt; ROWS; row++) / 第 10 行 / { for (ch = \u0026lsquo;A\u0026rsquo;; ch \u0026lt; (\u0026lsquo;A\u0026rsquo; + CHARS); ch++) / 第 12 行 */ printf(\u0026quot;%c\u0026rdquo;, ch); printf(\u0026quot;\\n\u0026rdquo;); }\nreturn 0; } 运行该程序后，输出如下： ABCDEFGHIJ ABCDEFGHIJ ABCDEFGHIJ ABCDEFGHIJ ABCDEFGHIJ ABCDEFGHIJ 6.10.1 程序分析 # 第 10 行开始的for循环被称为外层循环（outer loop），第 12 行开始的for 循环被称为内层循环（inner loop）。外层循环从row为 0 开始循环，到row为 6 时结束。因此，外层循环要执行 6 次，row的值从 0 变为 5 。每次迭代要执行 的第 1 条语句是内层的for循环，该循环要执行 10 次，在同一行打印字符A～ J；第 2 条语句是外层循环的printf(\u0026quot;\\n\u0026quot;);，该语句的效果是另起一行，这样在 下一次运行内层循环时，将在下一行打印的字符。 注意，嵌套循环中的内层循环在每次外层循环迭代时都执行完所有的循 环。在程序清单6.17中，内层循环一行打印 10 个字符，外层循环创建 6 行。\n6.10.2 嵌套变式 # 上一个实例中，内层循环和外层循环所做的事情相同。可以通过外层循 # 环控制内层循环，在每次外层循环迭代时内层循环完成不同的任务。把程序 # 清单6.17稍微修改后，如程序清单6.18所示。内层循环开始打印的字符取决 # 于外层循环的迭代次数。该程序的第 1 行使用了新的注释风格，而且用 # const 关键字代替#define，有助于读者熟悉这两种方法。 程序清单 6.18 rows2.c 程序 // rows2.c \u0026ndash; 依赖外部循环的嵌套循环 #include \u0026lt;stdio.h\u0026gt; int main(void) { const int ROWS = 6; const int CHARS = 6; int row; char ch; for (row = 0; row \u0026lt; ROWS; row++) { for (ch = (\u0026lsquo;A\u0026rsquo; + row); ch \u0026lt; (\u0026lsquo;A\u0026rsquo; + CHARS); ch++) printf(\u0026quot;%c\u0026quot;, ch); printf(\u0026quot;\\n\u0026quot;); } return 0; }\n该程序的输出如下： # ABCDEF # BCDEF # CDEF # DEF # EF # F # 因为每次迭代都要把row的值与‘A’相加，所以ch在每一行都被初始化为 不同的字符。然而，测试条件并没有改变，所以每行依然是以F结尾，这使 得每一行打印的字符都比上一行少一个。\n6.11 数组简介 # 在许多程序中，数组很重要。数组可以作为一种储存多个相关项的便利 # 方式。我们在第 10 章中将详细介绍数组，但是由于循环经常用到数组，所以 # 在这里先简要地介绍一下。 # 数组（array）是按顺序储存的一系列类型相同的值，如 10 个char类型的 字符或 15 个int类型的值。整个数组有一个数组名，通过整数下标访问数组中 单独的项或元素（element）。例如，以下声明： float debts[20]; 声明debts是一个内含 20 个元素的数组，每个元素都可以储存float类型的 值。数组的第 1 个元素是debts[0]，第 2 个元素是debts[1]，以此类推，直到 debts[19]。注意，数组元素的编号从 0 开始，不是从 1 开始。可以给每个元素 赋float类型的值。例如，可以这样写： debts[5] = 32.54; debts[6] = 1.2e+21; 实际上，使用数组元素和使用同类型的变量一样。例如，可以这样把值 读入指定的元素中： scanf(\u0026quot;%f\u0026quot;, \u0026amp;debts[4]); // 把一个值读入数组的第 5 个元素 这里要注意一个潜在的陷阱：考虑到影响执行的速度，C 编译器不会检 查数组的下标是否正确。下面的代码，都不正确： debts[20] = 88.32; // 该数组元素不存在 debts[33] = 828.12; // 该数组元素不存在 编译器不会查找这样的错误。当运行程序时，这会导致数据被放置在已\n被其他数据占用的地方，可能会破坏程序的结果甚至导致程序异常中断。 # 数组的类型可以是任意数据类型。 # int nannies[22]; /* 可储存 22 个int类型整数的数组 / char actors[26]; / 可储存 26 个字符的数组 / long big[500]; / 可储存 500 个long类型整数的数组 */ 我们在第 4 章中讨论过字符串，可以把字符串储存在char类型的数组中 （一般而言，char类型数组的所有元素都储存char类型的值）。如果char类 型的数组末尾包含一个表示字符串末尾的空字符\\0，则该数组中的内容就构 成了一个字符串（见图6.6）。\n图6.6 字符数组和字符串 用于识别数组元素的数字被称为下标（subscript）、索引（indice）或 偏移量（offset）。下标必须是整数，而且要从 0 开始计数。数组的元素被依 次储存在内存中相邻的位置，如图6.7所示。\n图6.7 内存中的char和int类型的数组 6.11.1 在 for 循环中使用数组 程序中有许多地方要用到数组，程序清单6.19是一个较为简单的例子。 该程序读取 10 个高尔夫分数，稍后进行处理。使用数组，就不用创建 10 个不 同的变量来储存 10 个高尔夫分数。而且，还可以用for循环来读取数据。程 序打印总分、平均分、差点（handicap，它是平均分与标准分的差值）。 程序清单 6.19 scores_in.c 程序 // scores_in.c \u0026ndash; 使用循环处理数组 #include \u0026lt;stdio.h\u0026gt; #define SIZE 10 #define PAR 72 int main(void) { int index, score[SIZE];\nint sum = 0; float average; printf(\u0026ldquo;Enter %d golf scores:\\n\u0026rdquo;, SIZE); for (index = 0; index \u0026lt; SIZE; index++) scanf(\u0026quot;%d\u0026quot;, \u0026amp;score[index]); // 读取 10 个分数 printf(\u0026ldquo;The scores read in are as follows:\\n\u0026rdquo;); for (index = 0; index \u0026lt; SIZE; index++) printf(\u0026quot;%5d\u0026quot;, score[index]); // 验证输入 printf(\u0026quot;\\n\u0026quot;); for (index = 0; index \u0026lt; SIZE; index++) sum += score[index]; // 求总分数 average = (float) sum / SIZE; // 求平均分 printf(\u0026ldquo;Sum of scores = %d, average = %.2f\\n\u0026rdquo;, sum, average); printf(\u0026ldquo;That\u0026rsquo;s a handicap of %.0f.\\n\u0026rdquo;, average - PAR); return 0; } 先看看程序清单6.19是否能正常工作，接下来再做一些解释。下面是程 序的输出： Enter 10　golf scores:\n99 95 109 105 100 # 96 98 93 99 97 98 # The scores read in are as follows: 99　95　109　105　100　96　98　93　99　97 Sum of scores = 991, average = 99.10 That\u0026rsquo;s a handicap of 27. 程序运行没问题，我们来仔细分析一下。首先，注意程序示例虽然打印 了 11 个数字，但是只读入了 10 个数字，因为循环只读了 10 个值。由于scanf() 会跳过空白字符，所以可以在一行输入 10 个数字，也可以每行只输入一个数 字，或者像本例这样混合使用空格和换行符隔开每个数字（因为输入是缓冲 的，只有当用户键入Enter键后数字才会被发送给程序）。 然后，程序使用数组和循环处理数据，这比使用 10 个单独的scanf()语句 和 10 个单独的printf()语句读取 10 个分数方便得多。for循环提供了一个简单直 接的方法来使用数组下标。注意，int类型数组元素的用法与int类型变量的用 法类似。要读取int类型变量fue，应这样写 。程序 清单6.19中要读取int类型的元素 ，所以这样写 。 该程序示例演示了一些较好的编程风格。第一，用#define 指令创建的 明示常量（SIZE）来指定数组的大小。这样就可以在定义数组和设置循环边 界时使用该明示常量。如果以后要扩展程序处理 20 个分数，只需简单地把 SIZE重新定义为 20 即可，不用逐一修改程序中使用了数组大小的每一处。 第二，下面的代码可以很方便地处理一个大小为SIZE的数组： for (index = 0; index \u0026lt; SIZE; index++)\n设置正确的数组边界很重要。第 1 个元素的下标是 0 ，因此循环开始时把 # index设置为 0 。因为从 0 开始编号，所以数组中最后一个元素的下标是SIZE - 1 。也就是说，第 10 个元素是score[9]。通过测试条件index \u0026lt; SIZE来控制循 环中使用的最后一个index的值是SIZE - 1。 第三，程序能重复显示刚读入的数据。这是很好的编程习惯，有助于确 保程序处理的数据与期望相符。 最后，注意该程序使用了 3 个独立的for循环。这是否必要？是否可以将 其合并成一个循环？当然可以，读者可以动手试试，合并后的程序显得更加 紧凑。但是，调整时要注意遵循模块化（modularity）的原则。模块化隐含 的思想是：应该把程序划分为一些独立的单元，每个单元执行一个任务。这 样做提高了程序的可读性。也许更重要的是，模块化使程序的不同部分彼此 独立，方便后续更新或修改程序。在掌握如何使用函数后，可以把每个执行 任务的单元放进函数中，提高程序的模块化。\n6.12 使用函数返回值的循环示例 # 本章最后一个程序示例要用一个函数计算数的整数次幂（math.h库提供 了一个更强大幂函数pow()，可以使用浮点指数）。该示例有 3 个主要任务： 设计算法、在函数中表示算法并返回计算结果、提供一个测试函数的便利方 法。 首先分析算法。为简化函数，我们规定该函数只处理正整数的幂。这 样，把n与n相乘p次便可计算n的p次幂。这里自然会用到循环。先把变量 pow设置为 1 ，然后将其反复乘以n： for(i = 1; i \u0026lt;= p; i++) pow = n; 回忆一下，=运算符把左侧的项乘以右侧的项，再把乘积赋给左侧的 项。第 1 次循环后，pow的值是 1 乘以n，即n；第 2 次循环后，pow的值是上一 次的值（n）乘以n，即n的平方；以此类推。这种情况使用for循环很合适， 因为在执行循环之前已预先知道了迭代的次数（已知p）。 现在算法已确定，接下来要决定使用何种数据类型。指数p是整数，其 类型应该是int。为了扩大n及其幂的范围，n和pow的类型都是double。 接下来，考虑如何把以上内容用函数来实现。要使用两个参数（分别是 double类型和int类型）才能把所需的信息传递给函数，并指定求哪个数的多 少次幂。而且，函数要返回一个值。如何把函数的返回值返回给主调函数？ 编写一个有返回值的函数，要完成以下内容： 1.定义函数时，确定函数的返回类型； 2.使用关键字return表明待返回的值。 例如，可以这样写：\ndouble power(double n, int p) // 返回一个double类型的值 { double pow = 1; int i; for (i = 1; i \u0026lt;= p; i++) pow *= n; return pow; // 返回pow的值 } 要声明函数的返回类型，在函数名前写出类型即可，就像声明一个变量 那样。关键字 return 表明该函数将把它后面的值返回给主调函数。根据上面 的代码，函数返回一个变量的值。返回值也可以是表达式的值，如下所示： return 2 * x + b; 函数将计算表达式的值，并返回该值。在主调函数中，可以把返回值赋 给另一个变量、作为表达式中的值、作为另一个函数的参数（如， ），或者忽略它。 现在，我们在一个程序中使用这个函数。要测试一个函数很简单，只需 给它提供几个值，看它是如何响应的。这种情况下可以创建一个输入循环， 选择 while 循环很合适。可以使用 scanf()函数一次读取两个值。如果成功读 取两个值，scanf()则返回 2 ，所以可以把scanf()的返回值与 2 作比较来控制循 环。还要注意，必须先声明power()函数（即写出函数原型）才能在程序中 使用它，就像先声明变量再使用一样。程序清单6.20演示了这个程序。 程序清单 6.20 powwer.c 程序\n// power.c \u0026ndash; 计算数的整数幂 #include \u0026lt;stdio.h\u0026gt; double power(double n, int p); // ANSI函数原型 int main(void) { double x, xpow; int exp; printf(\u0026ldquo;Enter a number and the positive integer power\u0026rdquo;); printf(\u0026quot; to which\\nthe number will be raised. Enter q\u0026quot;); printf(\u0026quot; to quit.\\n\u0026quot;); while (scanf(\u0026quot;%lf%d\u0026quot;, \u0026amp;x, \u0026amp;exp) == 2) { xpow = power(x, exp); // 函数调用 printf(\u0026quot;%.3g to the power %d is %.5g\\n\u0026quot;, x, exp, xpow); printf(\u0026ldquo;Enter next pair of numbers or q to quit.\\n\u0026rdquo;); } printf(\u0026ldquo;Hope you enjoyed this power trip \u0026ndash; bye!\\n\u0026rdquo;); return 0; }\ndouble power(double n, int p) // 函数定义 { double pow = 1; int i; for (i = 1; i \u0026lt;= p; i++) pow *= n; return pow; // 返回pow的值 } 运行该程序后，输出示例如下： Enter a number and the positive integer power to which the number will be raised. Enter q to quit. 1.2 12 1.2 to the power 12　is 8.9161 Enter next pair of numbers or q to quit. 2 16 2　to the power 16　is 65536 Enter next pair of numbers or q to quit. q\nHope you enjoyed this power trip -- bye! 6.12.1 程序分析 # 该程序示例中的main()是一个驱动程序（driver），即被设计用来测试 函数的小程序。 该例的while循环是前面讨论过的一般形式。输入1.2 12，scanf()成功读 取两值，并返回 2 ，循环继续。因为scanf()跳过空白，所以可以像输出示例 那样，分多行输入。但是输入q会使scanf()的返回值为 0 ，因为q与scanf()中的 转换说明%1f不匹配。scanf()将返回 0 ，循环结束。类似地，输入2.8 q会使 scanf()的返回值为 1 ，循环也会结束。 现在分析一下与函数相关的内容。powwer()函数在程序中出现了 3 次。 首次出现是： double power(double n, int p); // ANSI函数原型 这是power()函数的原型，它声明程序将使用一个名为power()的函数。 开头的关键字double表明power()函数返回一个double类型的值。编译器要知 道power()函数返回值的类型，才能知道有多少字节的数据，以及如何解释 它们。这就是为什么必须声明函数的原因。圆括号中的 double n, int p表示 power()函数的两个参数。第 1 个参数应该是double类型的值，第 2 个参数应该 是int类型的值。 第 2 次出现是： xpow = power(x,exp); // 函数调用 程序调用power()，把两个值传递给它。该函数计算x的exp次幂，并把 计算结果返回给主调函数。在主调函数中，返回值将被赋给变量xpow。 第 3 次出现是：\ndouble power(double n, int p) // 函数定义 这里，power()有两个形参，一个是double类型，一个是int类型，分别由 变量n和变量p表示。注意，函数定义的末尾没有分号，而函数原型的末尾有 分号。在函数头后面花括号中的内容，就是power()完成任务的代码。 power()函数用for循环计算n的p次幂，并把计算结果赋给pow，然后返 回pow的值，如下所示： return pow; //返回pow的值\n6.12.2 使用带返回值的函数 # 声明函数、调用函数、定义函数、使用关键字return，都是定义和使用 带返回值函数的基本要素。 这里，读者可能有一些问题。例如，既然在使用函数返回值之前要声明 函数，那么为什么在使用scanf()的返回值之前没有声明scanf()？为什么在定 义中说明了power()的返回类型为double，还要单独声明这个函数？ 我们先回答第 2 个问题。编译器在程序中首次遇到power()时，需要知道 power()的返回类型。此时，编译器尚未执行到power()的定义，并不知道函 数定义中的返回类型是double。因此，必须通过前置声明（forward declaration）预先说明函数的返回类型。前置声明告诉编译器，power()定义 在别处，其返回类型为double。如果把power()函数的定义置于main()的文件 顶部，就可以省略前置声明，因为编译器在执行到main()之前已经知道 power()的所有信息。但是，这不是C的标准风格。因为main()通常只提供整 个程序的框架，最好把 main()放在所有函数定义的前面。另外，通常把函数 放在其他文件中，所以前置声明必不可少。 接下来，为什么不用声明 scanf()函数就可以使用它？其实，你已经声明 了。stdio.h 头文件中包含了scanf()、printf()和其他I/O函数的原型。scanf()函 数的原型表明，它返回的类型是int。\n6.13 关键概念 # 循环是一个强大的编程工具。在创建循环时，要特别注意以下 3 个方 # 面： # 注意循环的测试条件要能使循环结束； # 确保循环测试中的值在首次使用之前已初始化； # 确保循环在每次迭代都更新测试的值。 # C通过求值来处理测试条件，结果为 0 表示假，非 0 表示真。带关系运算 # 符的表达式常用于循环测试，它们有些特殊。如果关系表达式为真，其值为 # 1 ；如果为假，其值为 0 。这与新类型_Bool的值保持一致。 数组由相邻的内存位置组成，只储存相同类型的数据。记住，数组元素 的编号从 0 开始，所有数组最后一个元素的下标一定比元素数目少 1 。C编 译器不会检查数组下标值是否有效，自己要多留心。 使用函数涉及 3 个步骤： 通过函数原型声明函数； 在程序中通过函数调用使用函数； 定义函数。 函数原型是为了方便编译器查看程序中使用的函数是否正确，函数定义 描述了函数如何工作。现代的编程习惯是把程序要素分为接口部分和实现部 分，例如函数原型和函数定义。接口部分描述了如何使用一个特性，也就是 函数原型所做的；实现部分描述了具体的行为，这正是函数定义所做的。\n6.14 本章小结 # 本章的主题是程序控制。C语言为实现结构化的程序提供了许多工具。 # while语句和for语句提供了入口条件循环。for语句特别适用于需要初始化和 更新的循环。使用逗号运算符可以在for循环中初始化和更新多个变量。有 些场合也需要使用出口条件循环，C为此提供了do while语句。 典型的while循环设计的伪代码如下： 获得初值 while (值满足测试条件) { 处理该值 获取下一个值 } for循环也可以完成相同的任务： for (获得初值; 值满足测试条件; 获得下一个值) 处理该值 这些循环都使用测试条件来判断是否继续执行下一次迭代。一般而言， 如果对测试表达式求值为非 0 ，则继续执行循环；否则，结束循环。通常， 测试条件都是关系表达式（由关系运算符和表达式构成）。表达式的关系为 真，则表达式的值为 1 ；如果关系为假，则表达式的值为 0 。C99新增了 _Bool类型，该类型的变量只能储存 1 或 0 ，分别表示真或假。 除了关系运算符，本章还介绍了其他的组合赋值运算符，如+=或*=。 这些运算符通过对其左侧运算对象执行算术运算来修改它的值。\n接下来还简单地介绍了数组。声明数组时，方括号中的值指明了该数组 # 的元素个数。数组的第 1 个元素编号为 0 ，第 2 个元素编号为 1 ，以此类推。 # 例如，以下声明： # double hippos[20]; 创建了一个有 20 个元素的数组hippos，其元素从hippos[0]～hippos[19]。 利用循环可以很方便地操控数组的下标。 最后，本章演示了如何编写和使用带返回值的函数。\n6.15 复习题 # 复习题的参考答案在附录A中。 # 1.写出执行完下列各行后quack的值是多少。后 5 行中使用的是第 1 行 quack的值。 int quack = 2; quack += 5; quack *= 10; quack -= 6; quack /= 8; quack %= 3; 2.假设value是int类型，下面循环的输出是什么？ for ( value = 36; value \u0026gt; 0; value /= 2) printf(\u0026quot;%3d\u0026quot;, value); 如果value是double类型，会出现什么问题？ 3.用代码表示以下测试条件： a.大于 5 b. 读取一个名为 的 类型值且失败 c.X的值等于 4.用代码表示以下测试条件：\na. 成功读入一个整数\nb. 不等于\nc. 大于或等于\n5.下面的程序有点问题，请找出问题所在。 #include \u0026lt;stdio.h\u0026gt; int main(void) { /* 第 3 行 / int i, j, list(10); / 第 4 行 / for (i = 1, i \u0026lt;= 10, i++) / 第 6 行 / { / 第 7 行 / list[i] = 2i + 3; /* 第 8 行 / for (j = 1, j \u0026gt; = i, j++) / 第 9 行 / printf(\u0026quot; %d\u0026quot;, list[j]); / 第 10 行 / printf(\u0026quot;\\n\u0026quot;); / 第 11 行 / } / 第 12 行 */ 6.编写一个程序打印下面的图案，要求使用嵌套循环： $$$$$$$$ $$$$$$$$ $$$$$$$$\n$$$$$$$$ # 7.下面的程序各打印什么内容？ # a. #include \u0026lt;stdio.h\u0026gt; int main(void) { int i = 0; while (++i \u0026lt; 4) printf(\u0026ldquo;Hi! \u0026ldquo;); do printf(\u0026ldquo;Bye! \u0026ldquo;); while (i++ \u0026lt; 8); return 0; } b. #include \u0026lt;stdio.h\u0026gt; int main(void) { int i;\nchar ch; for (i = 0, ch = \u0026lsquo;A\u0026rsquo;; i \u0026lt; 4; i++, ch += 2 * i) printf(\u0026quot;%c\u0026rdquo;, ch); return 0; } 8.假设用户输入的是 ，下面各程序的输出是什 么？（在ASCII码中，!紧跟在空格字符后面） a. #include \u0026lt;stdio.h\u0026gt; int main(void) { char ch; scanf(\u0026quot;%c\u0026rdquo;, \u0026amp;ch); while (ch != \u0026lsquo;g\u0026rsquo;) { printf(\u0026quot;%c\u0026rdquo;, ch); scanf(\u0026quot;%c\u0026rdquo;, \u0026amp;ch); } return 0;\n} # b. #include \u0026lt;stdio.h\u0026gt; int main(void) { char ch; scanf(\u0026quot;%c\u0026quot;, \u0026amp;ch); while (ch != \u0026lsquo;g\u0026rsquo;) { printf(\u0026quot;%c\u0026quot;, ++ch); scanf(\u0026quot;%c\u0026quot;, \u0026amp;ch); } return 0; } c. #include \u0026lt;stdio.h\u0026gt; int main(void) { char ch;\ndo { scanf(\u0026quot;%c\u0026quot;, \u0026amp;ch); printf(\u0026quot;%c\u0026quot;, ch); } while (ch != \u0026lsquo;g\u0026rsquo;); return 0; } d. #include \u0026lt;stdio.h\u0026gt; int main(void) { char ch; scanf(\u0026quot;%c\u0026quot;, \u0026amp;ch); for (ch = \u0026lsquo;$\u0026rsquo;; ch != \u0026lsquo;g\u0026rsquo;; scanf(\u0026quot;%c\u0026quot;, \u0026amp;ch)) printf(\u0026quot;%c\u0026quot;, ch); return 0; } 9.下面的程序打印什么内容？ #include \u0026lt;stdio.h\u0026gt; int main(void)\n{ # int n, m; n = 30; while (++n \u0026lt;= 33) printf(\u0026quot;%d|\u0026quot;, n); n = 30; do printf(\u0026quot;%d|\u0026quot;, n); while (++n \u0026lt;= 33); printf(\u0026quot;\\n***\\n\u0026quot;); for (n = 1; nn \u0026lt; 200; n += 4) printf(\u0026quot;%d\\n\u0026quot;, n); printf(\u0026quot;\\n**\\n\u0026quot;); for (n = 2, m = 6; n \u0026lt; m; n = 2, m += 2) printf(\u0026quot;%d %d\\n\u0026quot;, n, m); printf(\u0026quot;\\n**\\n\u0026quot;); for (n = 5; n \u0026gt; 0; n\u0026ndash;) { for (m = 0; m \u0026lt;= n; m++)\nprintf(\u0026quot;=\u0026quot;); printf(\u0026quot;\\n\u0026quot;); } return 0; } 10.考虑下面的声明： double mint[10]; a.数组名是什么？ b.该数组有多少个元素？ c.每个元素可以储存什么类型的值？ d.下面的哪一个scanf()的用法正确？ i.scanf(\u0026quot;%lf\u0026quot;, mint[2]) ii.scanf(\u0026quot;%lf\u0026quot;, \u0026amp;mint[2]) iii.scanf(\u0026quot;%lf\u0026quot;, \u0026amp;mint) 11.Noah先生喜欢以 2 计数，所以编写了下面的程序，创建了一个储存 2 、 4 、 6 、 8 等数字的数组。 这个程序是否有错误之处？如果有，请指出。 #include \u0026lt;stdio.h\u0026gt; #define SIZE 8\nint main(void) { int by_twos[SIZE]; int index; for (index = 1; index \u0026lt;= SIZE; index++) by_twos[index] = 2 * index; for (index = 1; index \u0026lt;= SIZE; index++) printf(\u0026quot;%d \u0026ldquo;, by_twos); printf(\u0026quot;\\n\u0026rdquo;); return 0; } 12.假设要编写一个返回long类型值的函数，函数定义中应包含什么？ 13.定义一个函数，接受一个int类型的参数，并以long类型返回参数的平 方值。 14.下面的程序打印什么内容？ #include \u0026lt;stdio.h\u0026gt; int main(void) { int k;\nfor (k = 1, printf(\u0026quot;%d: Hi!\\n\u0026quot;, k); printf(\u0026ldquo;k = %d\\n\u0026rdquo;, k), k*k \u0026lt; 26; k += 2, printf(\u0026ldquo;Now k is %d\\n\u0026rdquo;, k)) printf(\u0026ldquo;k is %d in the loop\\n\u0026rdquo;, k); return 0; }\n6.16 编程练习 # 1.编写一个程序，创建一个包含 26 个元素的数组，并在其中储存 26 个小 # 写字母。然后打印数组的所有内容。 # 2.使用嵌套循环，按下面的格式打印字符： # $ # $$ # $$$ # $$$$ # $$$$$ # 3.使用嵌套循环，按下面的格式打印字母： # F # FE # FED # FEDC # FEDCB # FEDCBA # 注意：如果你的系统不使用ASCII或其他以数字顺序编码的代码，可以 # 把字符数组初始化为字母表中的字母： # char lets[27] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; 然后用数组下标选择单独的字母，例如lets[0]是‘A’，等等。 4.使用嵌套循环，按下面的格式打印字母： A BC DEF GHIJ KLMNO PQRSTU 如果你的系统不使用以数字顺序编码的代码，请参照练习 3 的方案解 决。 5.编写一个程序，提示用户输入大写字母。使用嵌套循环以下面金字塔 型的格式打印字母： A ABA ABCBA ABCDCBA ABCDEDCBA 打印这样的图形，要根据用户输入的字母来决定。例如，上面的图形是 在用户输入E后的打印结果。 提示：用外层循环处理行，每行使用 3 个内层循环，分别处理空格、以\n升序打印字母、以降序打印字母。如果系统不使用ASCII或其他以数字顺序 # 编码的代码，请参照练习 3 的解决方案。 # 6.编写一个程序打印一个表格，每一行打印一个整数、该数的平方、该 # 数的立方。要求用户输入表格的上下限。使用一个for循环。 7.编写一个程序把一个单词读入一个字符数组中，然后倒序打印这个单 词。提示：strlen()函数（第 4 章介绍过）可用于计算数组最后一个字符的下 标。 8.编写一个程序，要求用户输入两个浮点数，并打印两数之差除以两数 乘积的结果。在用户输入非数字之前，程序应循环处理用户输入的每对值。 9.修改练习 8 ，使用一个函数返回计算的结果。 10.编写一个程序，要求用户输入一个上限整数和一个下限整数，计算 从上限到下限范围内所有整数的平方和，并显示计算结果。然后程序继续提 示用户输入上限和下限整数，并显示结果，直到用户输入的上限整数小于下 限整数为止。程序的运行示例如下： Enter lower and upper integer limits: 5　9 The sums of the squares from 25　to 81　is 255 Enter next set of limits: 3　25 The sums of the squares from 9　to 625　is 5520 Enter next set of limits: 5　5 Done 11.编写一个程序，在数组中读入 8 个整数，然后按倒序打印这 8 个整 数。\n12.考虑下面两个无限序列： # 1.0 + 1.0/2.0 + 1.0/3.0 + 1.0/4.0 + \u0026hellip; # 1.0 - 1.0/2.0 + 1.0/3.0 - 1.0/4.0 + \u0026hellip; # 编写一个程序计算这两个无限序列的总和，直到到达某次数。提示：奇 # 数个-1 相乘得-1，偶数个-1相乘得 1 。让用户交互地输入指定的次数，当用 # 户输入 0 或负值时结束输入。查看运行 100 项、 1000 项、 10000 项后的总和， # 是否发现每个序列都收敛于某值？ # 13.编写一个程序，创建一个包含 8 个元素的int类型数组，分别把数组元 素设置为 2 的前 8 次幂。使用for循环设置数组元素的值，使用do while循环显 示数组元素的值。 14.编写一个程序，创建两个包含 8 个元素的double类型数组，使用循环 提示用户为第一个数组输入 8 个值。第二个数组元素的值设置为第一个数组 对应元素的累积之和。例如，第二个数组的第 4 个元素的值是第一个数组前 4 个元素之和，第二个数组的第 5 个元素的值是第一个数组前 5 个元素之和 （用嵌套循环可以完成，但是利用第二个数组的第 5 个元素是第二个数组的 第 4 个元素与第一个数组的第 5 个元素之和，只用一个循环就能完成任务，不 需要使用嵌套循环）。最后，使用循环显示两个数组的内容，第一个数组显 示成一行，第二个数组显示在第一个数组的下一行，而且每个元素都与第一 个数组各元素相对应。 15.编写一个程序，读取一行输入，然后把输入的内容倒序打印出来。 可以把输入储存在char类型的数组中，假设每行字符不超过 255 。回忆一 下，根据%c转换说明，scanf()函数一次只能从输入中读取一个字符，而且 在用户按下Enter键时scanf()函数会生成一个换行字符（\\n）。 16.Daphne以10%的单利息投资了 100 美元（也就是说，每年投资获利相 当于原始投资的10%）。Deirdre以 5%的复合利息投资了 100 美元（也就是 说，利息是当前余额的 5%，包含之前的利息）。编写一个程序，计算需要\n多少年Deirdre的投资额才会超过Daphne，并显示那时两人的投资额。 17.Chuckie Lucky赢得了 100 万美元（税后），他把奖金存入年利率8%的 账户。在每年的最后一天， Chuckie取出 10 万美元。编写一个程序，计算多 少年后Chuckie会取完账户的钱？ 18.Rabnud博士加入了一个社交圈。起初他有 5 个朋友。他注意到他的朋 友数量以下面的方式增长。第 1 周少了 1 个朋友，剩下的朋友数量翻倍；第 2 周少了 2 个朋友，剩下的朋友数量翻倍。一般而言，第N周少了N个朋友，剩 下的朋友数量翻倍。编写一个程序，计算并显示Rabnud博士每周的朋友数 量。该程序一直运行，直到超过邓巴数（Dunbar’s number）。邓巴数是粗略 估算一个人在社交圈中有稳定关系的成员的最大值，该值大约是 150 。\n[1].但随后其实num++num的最终值不是使num的值为 67 ，而是，然后 (^7) num\u0026lt;= 6。虽然最后一次循环打印的为假，for循环结束。num——值是译者注 6 ，\n第 7 章 C 控制语句：分支和跳转 # 本章介绍以下内容： # 关键字：if、else、switch、continue、break、case、default、goto 运算符：\u0026amp;\u0026amp;、||、?: 函数：getchar()、putchar()、ctype.h系列 如何使用if和if else语句，如何嵌套它们 在更复杂的测试表达式中用逻辑运算符组合关系表达式 C的条件运算符 switch语句 break、continue和goto语句 使用C的字符I/O函数：getchar()和putchar() ctype.h头文件提供的字符分析函数系列 随着越来越熟悉C，可以尝试用C程序解决一些更复杂的问题。这时 候，需要一些方法来控制和组织程序，为此C提供了一些工具。前面已经学 过如何在程序中用循环重复执行任务。本章将介绍分支结构（如， if和 switch），让程序根据测试条件执行相应的行为。另外，还将介绍C语言的 逻辑运算符，使用逻辑运算符能在 while 或 if 的条件中测试更多关系。此 外，本章还将介绍跳转语句，它将程序流转换到程序的其他部分。学完本章 后，读者就可以设计按自己期望方式运行的程序。\n7.1 if 语句 # 我们从一个有if语句的简单示例开始学习，请看程序清单7.1。该程序读 取一列数据，每个数据都表示每日的最低温度（°C），然后打印统计的总天 数和最低温度在 0 °C以下的天数占总天数的百分比。程序中的循环通过 scanf()读入温度值。while循环每迭代一次，就递增计数器增加天数，其中的 if语句负责判断 0 °C以下的温度并单独统计相应的天数。 程序清单 7.1 colddays.c 程序 // colddays.c \u0026ndash; 找出 0 °C以下的天数占总天数的百分比 #include \u0026lt;stdio.h\u0026gt; int main(void) { const int FREEZING = 0; float temperature; int cold_days = 0; int all_days = 0; printf(\u0026ldquo;Enter the list of daily low temperatures.\\n\u0026rdquo;); printf(\u0026ldquo;Use Celsius, and enter q to quit.\\n\u0026rdquo;); while (scanf(\u0026quot;%f\u0026quot;, \u0026amp;temperature) == 1) { all_days++;\nif (temperature \u0026lt; FREEZING) cold_days++; } if (all_days != 0) printf(\u0026quot;%d days total: %.1f%% were below freezing.\\n\u0026quot;, all_days, 100.0 * (float) cold_days / all_days); if (all_days == 0) printf(\u0026ldquo;No data entered!\\n\u0026rdquo;); return 0; } 下面是该程序的输出示例： Enter the list of daily low temperatures. Use Celsius, and enter q to quit. 12 5 -2.5 0 6 8 -3 -10 5 10 q 10 days total: 30.0% were below freezing. while循环的测试条件利用scanf()的返回值来结束循环，因为scanf()在读 到非数字字符时会返回 0 。temperature的类型是float而不是int，这样程序既可 以接受-2.5这样的值，也可以接受 8 这样的值。 while循环中的新语句如下： if (temperature \u0026lt; FREEZING)\ncold_days++; if 语句指示计算机，如果刚读取的值（remperature）小于 0 ，就把 cold_days 递增 1 ；如果temperature不小于 0 ，就跳过cold_days++;语句，while 循环继续读取下一个温度值。 接着，该程序又使用了两次if语句控制程序的输出。如果有数据，就打 印结果；如果没有数据，就打印一条消息（稍后将介绍一种更好的方法来处 理这种情况）。 为避免整数除法，该程序示例把计算后的百分比强制转换为 float类 型。其实，也不必使用强制类型转换，因为在表达式100.0 * cold_days / all_days中，将首先对表达式100.0 * cold_days求值，由于C的自动转换类型 规则，乘积会被强制转换成浮点数。但是，使用强制类型转换可以明确表达 转换类型的意图，保护程序免受不同版本编译器的影响。if语句被称为分支 语句（branching statement）或选择语句（selection statement），因为它相当 于一个交叉点，程序要在两条分支中选择一条执行。if语句的通用形式如 下： if ( expression ) statement 如果对expression求值为真（非 0 ），则执行statement；否则，跳过 statement。与while循环一样，statement可以是一条简单语句或复合语句。if 语句的结构和while语句很相似，它们的主要区别是：如果满足条件可执行 的话，if语句只能测试和执行一次，而while语句可以测试和执行多次。 通常，expression 是关系表达式，即比较两个量的大小（如，表达式 x \u0026gt; y 或 c == 6）。如果expression为真（即x大于y，或c == 6），则执行 statement。否则，忽略statement。概括地说，可以使用任意表达式，表达式 的值为 0 则为假。\nstatement部分可以是一条简单语句，如本例所示，或者是一条用花括号 括起来的复合语句（或块）： if (score \u0026gt; big) printf(\u0026ldquo;Jackpot!\\n\u0026rdquo;); // 简单语句 if (joe \u0026gt; ron) { // 复合语句 joecash++; printf(\u0026ldquo;You lose, Ron.\\n\u0026rdquo;); } 注意，即使if语句由复合语句构成，整个if语句仍被视为一条语句。\n7.2 if else 语句 # 简单形式的if语句可以让程序选择执行一条语句，或者跳过这条语句。 C还提供了if else形式，可以在两条语句之间作选择。我们用if else形式修正 程序清单7.1中的程序段。 if (all_days != 0) printf(\u0026quot;%d days total: %.1f%% were below freezing.\\n\u0026quot;, all_days, 100.0 * (float) cold_days / all_days); if (all_days == 0) printf(\u0026ldquo;No data entered!\\n\u0026rdquo;); 如果程序发现all_days不等于 0 ，那么它应该知道另一种情况一定是 all_days等于 0 。用if else形式只需测试一次。重写上面的程序段如下： if (all_days!= 0) printf(\u0026quot;%d days total: %.1f%% were below freezing.\\n\u0026quot;, all_days, 100.0 * (float) cold_days / all_days); else printf(\u0026ldquo;No data entered!\\n\u0026rdquo;); 如果if语句的测试表达式为真，就打印温度数据；如果为假，就打印警 告消息。 注意，if else语句的通用形式是： if ( expression )\nstatement1 else statement2 如果expression为真（非 0 ），则执行statement1；如果expression为假或 0 ，则执行else后面的statement2。statement1和statement2可以是一条简单语句 或复合语句。C并不要求一定要缩进，但这是标准风格。缩进让根据测试条 件的求值结果来判断执行哪部分语句一目了然。 如果要在if和else之间执行多条语句，必须用花括号把这些语句括起来 成为一个块。下面的代码结构违反了C语法，因为在if和else之间只允许有一 条语句（简单语句或复合语句）： if (x \u0026gt; 0) printf(\u0026ldquo;Incrementing x:\\n\u0026rdquo;); x++; else // 将产生一个错误 printf(\u0026ldquo;x \u0026lt;= 0 \\n\u0026rdquo;); 编译器把printf()语句视为if语句的一部分，而把x++;看作一条单独的语 句，它不是if语句的一部分。然后，编译器发现else并没有所属的if，这是错 误的。上面的代码应该这样写： if (x \u0026gt; 0) { printf(\u0026ldquo;Incrementing x:\\n\u0026rdquo;); x++;\n} # else printf(\u0026ldquo;x \u0026lt;= 0 \\n\u0026rdquo;); if语句用于选择是否执行一个行为，而else if语句用于在两个行为之间 选择。图7.1比较了这两种语句。\n图7.1 if语句和if else语句 7.2.1 另一个示例：介绍 getchar() 和 putchar() # 到目前为止，学过的大多数程序示例都要求输入数值。接下来，我们看 # 看输入字符的示例。相信读者已经熟悉了如何用 scanf()和 printf()根据%c 转 换说明读写字符，我们马上要讲解的示例中要用到一对字符输入/输出函 数：getchar()和putchar()。 getchar()函数不带任何参数，它从输入队列中返回下一个字符。例如， 下面的语句读取下一个字符输入，并把该字符的值赋给变量ch： ch = getchar(); 该语句与下面的语句效果相同： scanf(\u0026quot;%c\u0026quot;, \u0026amp;ch); putchar()函数打印它的参数。例如，下面的语句把之前赋给ch的值作为 字符打印出来： putchar(ch); 该语句与下面的语句效果相同： printf(\u0026quot;%c\u0026quot;, ch); 由于这些函数只处理字符，所以它们比更通用的scanf()和printf()函数更 快、更简洁。而且，注意 getchar()和 putchar()不需要转换说明，因为它们只 处理字符。这两个函数通常定义在 stdio.h头文件中（而且，它们通常是预处 理宏，而不是真正的函数，第 16 章会讨论类似函数的宏）。 接下来，我们编写一个程序来说明这两个函数是如何工作的。该程序把 一行输入重新打印出来，但是每个非空格都被替换成原字符在ASCII序列中 的下一个字符，空格不变。这一过程可描述为“如果字符是空白，原样打\n印；否则，打印原字符在ASCII序列中的下一个字符”。 # C代码看上去和上面的描述很相似，请看程序清单7.2。 # 程序清单 7.2 cypher1.c 程序 // cypher1.c -- 更改输入，空格不变 #include \u0026lt;stdio.h\u0026gt; #define SPACE \u0026#39; \u0026#39; // SPACE表示单引号-空格-单引号 int main(void) { char ch; ch = getchar(); // 读取一个字符 while (ch != \u0026#39;\\n\u0026#39;) // 当一行未结束时 { if (ch == SPACE) // 留下空格 putchar(ch); // 该字符不变 else putchar(ch + 1); // 改变其他字符 ch = getchar(); // 获取下一个字符 } putchar(ch); // 打印换行符 return 0; } （如果编译器警告因转换可能导致数据丢失，不用担心。第 8 章在讲到 EOF时再解释。） 下面是该程序的输入示例： CALL ME HAL. DBMM NF IBM/ 把程序清单7.1中的循环和该例中的循环作比较。前者使用scanf()返回的 状态值判断是否结束循环，而后者使用输入项的值来判断是否结束循环。这 使得两程序所用的循环结构略有不同：程序清单7.1中在循环前面有一条“读 取语句”，程序清单7.2中在每次迭代的末尾有一条“读取语句”。不过，C的 语法比较灵活，读者也可以模仿程序清单7.1，把读取和测试合并成一个表 达式。也就是说，可以把这种形式的循环： ch = getchar(); /* 读取一个字符 / while (ch != \u0026lsquo;\\n\u0026rsquo;) / 当一行未结束时 / { \u0026hellip; / 处理字符 / ch = getchar(); / 获取下一个字符 */ } 替换成下面形式的循环： while ((ch = getchar()) != \u0026lsquo;\\n\u0026rsquo;)\n{ # \u0026hellip; /* 处理字符 */ # } # 关键的一行代码是： # while ((ch = getchar()) != \u0026lsquo;\\n\u0026rsquo;) 这体现了C特有的编程风格——把两个行为合并成一个表达式。C对代 码的格式要求宽松，这样写让其中的每个行为更加清晰： while ( (ch = getchar()) // 给ch赋一个值 != \u0026lsquo;\\n\u0026rsquo;) // 把ch和\\n作比较 以上执行的行为是赋值给ch和把ch的值与换行符作比较。表达式ch = getchar()两侧的圆括号使之成为!=运算符的左侧运算对象。要对该表达式求 值，必须先调用getchar()函数，然后把该函数的返回值赋给 ch。因为赋值表 达式的值是赋值运算符左侧运算对象的值，所以 ch = getchar()的值就是 ch 的新值，因此，读取ch的值后，测试条件相当于是ch != \u0026lsquo;\\n\u0026rsquo;（即，ch不是换 行符）。 这种独特的写法在C编程中很常见，应该多熟悉它。还要记住合理使用 圆括号组合子表达式。上面例子中的圆括号都必不可少。假设省略ch = getchar()两侧的圆括号： while (ch = getchar() != \u0026lsquo;\\n\u0026rsquo;) !=运算符的优先级比=高，所以先对表达式getchar() != \u0026lsquo;\\n\u0026rsquo;求值。由于这 是关系表达式，所以其值不是 1 就是 0 （真或假）。然后，把该值赋给ch。省 略圆括号意味着赋给ch的值是 0 或 1 ，而不是 getchar()的返回值。这不是我们\n的初衷。 # 下面的语句： # putchar(ch + 1); /* 改变其他字符 */ 再次演示了字符实际上是作为整数储存的。为方便计算，表达式ch + 1 中的ch被转换成int类型，然后int类型的计算结果被传递给接受一个int类型参 数的putchar()，该函数只根据最后一个字节确定显示哪个字符。\n7.2.2 ctype.h 系列的字符函数 # 注意到程序清单7.2的输出中，最后输入的点号（.）被转换成斜杠 # （/），这是因为斜杠字符对应的ASCII码比点号的 ASCII 码多 1 。如果程序 # 只转换字母，保留所有的非字母字符（不只是空格）会更好。本章稍后讨论 # 的逻辑运算符可用来测试字符是否不是空格、不是逗号等，但是列出所有的 # 可能性太繁琐。C 有一系列专门处理字符的函数，ctype.h头文件包含了这些 函数的原型。这些函数接受一个字符作为参数，如果该字符属于某特殊的类 别，就返回一个非零值（真）；否则，返回 0 （假）。例如，如果isalpha() 函数的参数是一个字母，则返回一个非零值。程序清单7.3在程序清单7.2的 基础上使用了这个函数，还使用了刚才精简后的循环。 程序清单 7.3 cypher2.c 程序 // cypher2.c \u0026ndash; 替换输入的字母，非字母字符保持不变 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; // 包含isalpha()的函数原型 int main(void) { char ch;\nwhile ((ch = getchar()) != \u0026lsquo;\\n\u0026rsquo;) { if (isalpha(ch)) // 如果是一个字符， putchar(ch + 1); // 显示该字符的下一个字符 else // 否则， putchar(ch); // 原样显示 } putchar(ch); // 显示换行符 return 0; } 下面是该程序的一个输出示例，注意大小写字母都被替换了，除了空格 和标点符号： Look! It\u0026rsquo;s a programmer! Mppl! Ju\u0026rsquo;t b qsphsbnnfs! 表7.1和表7.2列出了ctype.h头文件中的一些函数。有些函数涉及本地 化，指的是为适应特定区域的使用习惯修改或扩展 C 基本用法的工具（例 如，许多国家在书写小数点时，用逗号代替点号，于是特殊的本地化可以指 定C编译器使用逗号以相同的方式输出浮点数，这样123.45可以显示为 123,45）。注意，字符映射函数不会修改原始的参数，这些函数只会返回已 修改的值。也就是说，下面的语句不改变ch的值： tolower(ch); // 不影响ch的值\n这样做才会改变ch的值： ch = tolower(ch); // 把ch转换成小写字母 表7.1 ctype.h头文件中的字符测试函数 表7.2 ctype.h头文件中的字符映射函数 7.2.3 多重选择 else if # 现实生活中我们经常有多种选择。在程序中也可以用else if扩展if else结 构模拟这种情况。来看一个特殊的例子。电力公司通常根据客户的总用电量 来决定电费。下面是某电力公司的电费清单，单位是千瓦时（kWh）： 首 360kWh: $0.13230/kWh 续 108kWh: $0.15040/kWh 续 252kWh: $0.30025/kWh\n超过 720kWh: $0.34025/kWh 如果对用电管理感兴趣，可以编写一个计算电费的程序。程序清单7.4 是完成这一任务的第 1 步。 程序清单 7.4 electric.c 程序 // electric.c \u0026ndash; 计算电费 #include \u0026lt;stdio.h\u0026gt; #define RATE1 0.13230 // 首次使用 360 kwh 的费率 #define RATE2 0.15040 // 接着再使用 108 kwh 的费率 #define RATE3 0.30025 // 接着再使用 252 kwh 的费率 #define RATE4 0.34025 // 使用超过 720kwh 的费率 #define BREAK1 360.0 // 费率的第 1 个分界点 #define BREAK2 468.0 // 费率的第 2 个分界点 #define BREAK3 720.0 // 费率的第 3 个分界点 #define BASE1 (RATE1 * BREAK1) // 使用360kwh的费用 #define BASE2 (BASE1 + (RATE2 * (BREAK2 - BREAK1))) // 使用468kwh的费用 #define BASE3 (BASE1 + BASE2 + (RATE3 *(BREAK3 - BREAK2))) // 使用720kwh的费用\nint main(void) { double kwh; // 使用的千瓦时 double bill; // 电费 printf(\u0026ldquo;Please enter the kwh used.\\n\u0026rdquo;); scanf(\u0026quot;%lf\u0026quot;, \u0026amp;kwh); // %lf对应double类型 if (kwh \u0026lt;= BREAK1) bill = RATE1 * kwh; else if (kwh \u0026lt;= BREAK2) // 360～468 kwh bill = BASE1 + (RATE2 * (kwh - BREAK1)); else if (kwh \u0026lt;= BREAK3) // 468～720 kwh bill = BASE2 + (RATE3 * (kwh - BREAK2)); else // 超过 720 kwh bill = BASE3 + (RATE4 * (kwh - BREAK3)); printf(\u0026ldquo;The charge for %.1f kwh is $%1.2f.\\n\u0026rdquo;, kwh, bill); return 0; } 该程序的输出示例如下： Please enter the kwh used.\n580 # The charge for 580.0 kwh is $97.50. 程序清单 7.4 用符号常量表示不同的费率和费率分界点，以便把常量统 一放在一处。这样，电力公司在更改费率以及费率分界点时，更新数据非常 方便。BASE1和BASE2根据费率和费率分界点来表示。一旦费率或分界点发 生了变化，它们也会自动更新。预处理器是不进行计算的。程序中出现 BASE1的地方都会被替换成 0.13230*360.0。不用担心，编译器会对该表达 式求值得到一个数值（47.628），以便最终的程序代码使用的是47.628而不 是一个计算式。 程序流简单明了。该程序根据kwh的值在 3 个公式之间选择一个。特别 要注意的是，如果kwh大于或等于 360 ，程序只会到达第 1 个else。因此，else if (kwh \u0026lt;= BREAK2)这行相当于要求kwh在 360 ～ 482 之间，如程序注释所 示。类似地，只有当kwh的值超过 720 时，才会执行最后的else。最后，注意 BASE1、BASE2和BASE3分别代表 360 、 468 和 720 千瓦时的总费用。因此， 当电量超过这些值时，只需要加上额外的费用即可。 实际上，else if 是已学过的 if else 语句的变式。例如，该程序的核心部 分只不过是下面代码的另一种写法： if (kwh \u0026lt;= BREAK1) bill = RATE1 * kwh; else if (kwh \u0026lt;= BREAK2) // 360～468 kwh bill = BASE1 + (RATE2 * (kwh - BREAK1)); else if (kwh \u0026lt;= BREAK3) // 468～720 kwh\nbill = BASE2 + (RATE3 * (kwh - BREAK2)); else // 超过720 kwh bill = BASE3 + (RATE4 * (kwh - BREAK3)); 也就是说，该程序由一个ifelse语句组成，else部分包含另一个if else语 句，该if else语句的else部分又包含另一个if else语句。第 2 个if else语句嵌套 在第 1 个if else语句中，第 3 个if else语句嵌套在第 2 个if else语句中。回忆一 下，整个if else语句被视为一条语句，因此不必把嵌套的if else语句用花括号 括起来。当然，花括号可以更清楚地表明这种特殊格式的含义。 这两种形式完全等价。唯一不同的是使用空格和换行的位置不同，不过 编译器会忽略这些。尽管如此，第 1 种形式还是好些，因为这种形式更清楚 地显示了有 4 种选择。在浏览程序时，这种形式让读者更容易看清楚各项选 择。在需要时要缩进嵌套的部分，例如，必须测试两个单独的量时。本例 中，仅在夏季对用电量超过720kWh的用户加收10%的电费，就属于这种情 况。 可以把多个else if语句连成一串使用，如下所示（当然，要在编译器的 限制范围内）： if (score \u0026lt; 1000) bonus = 0; else if (score \u0026lt; 1500) bonus = 1; else if (score \u0026lt; 2000) bonus = 2; else if (score \u0026lt; 2500)\nbonus = 4; else bonus = 6; （这可能是一个游戏程序的一部分，bonus表示下一局游戏获得的光子 炸弹或补给。） 对于编译器的限制范围，C99标准要求编译器最少支持 127 层套嵌。\n7.2.4 else 与 if 配对 # 如果程序中有许多if和else，编译器如何知道哪个if对应哪个else？例 如，考虑下面的程序段： if (number \u0026gt; 6) if (number \u0026lt; 12) printf(\u0026ldquo;You\u0026rsquo;re close!\\n\u0026rdquo;); else printf(\u0026ldquo;Sorry, you lose a turn!\\n\u0026rdquo;); 何时打印Sorry, you lose a turn!？当number小于或等于 6 时，还是number大 于 12 时？换言之，else与第 1 个if还是第 2 个if匹配？答案是，else与第 2 个if匹 配。也就是说，输入的数字和匹配的响应如下： 数字　响应 5　None 10　You’re close!\n15　Sorry, you lose a turn! 规则是，如果没有花括号，else与离它最近的if匹配，除非最近的if被花 括号括起来（见图7.2）。\n图7.2 if else匹配的规则 注意：要缩进“语句”，“语句”可以是一条简单语句或复合语句。 第 1 个例子的缩进使得else看上去与第 1 个if相匹配，但是记住，编译器 是忽略缩进的。如果希望else与第 1 个if匹配，应该这样写： if (number \u0026gt; 6) { if (number \u0026lt; 12) printf(\u0026ldquo;You\u0026rsquo;re close!\\n\u0026rdquo;); } else printf(\u0026ldquo;Sorry, you lose a turn!\\n\u0026rdquo;); 这样改动后，响应如下： 数字　响应 5　Sorry, you lose a turn! 10　You’re close! 15　None\n7.2.5 多层嵌套的 if 语句 # 前面介绍的if\u0026hellip;else if\u0026hellip;else序列是嵌套if的一种形式，从一系列选项中选 择一个执行。有时，选择一个特定选项后又引出其他选择，这种情况可以使 用另一种嵌套 if。例如，程序可以使用 if else选择男女，if else的每个分支里 又包含另一个if else来区分不同收入的群体。 我们把这种形式的嵌套if应用在下面的程序中。给定一个整数，显示所 有能整除它的约数。如果没有约数，则报告该数是一个素数。\n在编写程序的代码之前要先规划好。首先，要总体设计一下程序。为方 # 便起见，程序应该使用一个循环让用户能连续输入待测试的数。这样，测试 # 一个新的数字时不必每次都要重新运行程序。下面是我们为这种循环开发的 # 一个模型（伪代码）： # 提示用户输入数字 # 当scanf()返回值为 1 分析该数并报告结果 提示用户继续输入 回忆一下在测试条件中使用scanf()，把读取数字和判断测试条件确定是 否结束循环合并在一起。 下一步，设计如何找出约数。也许最直接的方法是： for (div = 2; div \u0026lt; num; div++) if (num % div == 0) printf(\u0026quot;%d is divisible by %d\\n\u0026quot;, num, div); 该循环检查 2 ～num之间的所有数字，测试它们是否能被num整除。但 是，这个方法有点浪费时间。我们可以改进一下。例如，考虑如果144%2得 0 ，说明 2 是 144 的约数；如果 144 除以 2 得 72 ，那么 72 也是 144 的一个约数。所 以，num % div测试成功可以获得两个约数。为了弄清其中的原理，我们分 析一下循环中得到的成对约数： 2 和 72 、 2 和 48 、 4 和 36 、 6 和 24 、 8 和 18 、 9 和 16 、 12 和 12 、 16 和 9 、 18 和 8 ，等等。在得到 12 和 12 这对约数后，又开始得到 已找到的相同约数（次序相反）。因此，不用循环到 143 ，在达到 12 以后就 可以停止循环。这大大地节省了循环时间！ 分析后发现，必须测试的数只要到num的平方根就可以了，不用到 num。对于 9 这样的数字，不会节约很多时间，但是对于 10000 这样的数，使\n用哪一种方法求约数差别很大。不过，我们不用在程序中计算平方根，可以 # 这样编写测试条件： # for (div = 2; (div * div) \u0026lt;= num; div++) if (num % div == 0) printf(\u0026quot;%d is divisible by %d and %d.\\n\u0026quot;,num, div, num / div); 如果num是 144 ，当div = 12时停止循环。如果num是 145 ，当div = 13时停 止循环。 不使用平方根而用这样的测试条件，有两个原因。其一，整数乘法比求 平方根快。其二，我们还没有正式介绍平方根函数。 还要解决两个问题才能准备编程。第 1 个问题，如果待测试的数是一个 完全平方数怎么办？报告 144 可以被 12 和 12 整除显得有点傻。可以使用嵌套 if语句测试div是否等于num /div。如果是，程序只打印一个约数： for (div = 2; (div * div) \u0026lt;= num; div++) { if (num % div == 0) { if (div * div != num) printf(\u0026quot;%d is divisible by %d and %d.\\n\u0026quot;,num, div, num / div); else printf(\u0026quot;%d is divisible by %d.\\n\u0026quot;, num, div); }\n} # 注意 # 从技术角度看，if else语句作为一条单独的语句，不必使用花括号。外 层if也是一条单独的语句，也不必使用花括号。但是，当语句太长时，使用 花括号能提高代码的可读性，而且还可防止今后在if循环中添加其他语句时 忘记加花括号。 第 2 个问题，如何知道一个数字是素数？如果num是素数，程序流不会 进入if语句。要解决这个问题，可以在外层循环把一个变量设置为某个值 （如， 1 ），然后在if语句中把该变量重新设置为 0 。循环完成后，检查该变 量是否是 1 ，如果是，说明没有进入if语句，那么该数就是素数。这样的变 量通常称为标记（flag）。 一直以来，C都习惯用int作为标记的类型，其实新增的_Bool类型更合 适。另外，如果在程序中包含了stdbool.h头文件，便可用bool代替_Bool类 型，用true和false分别代替 1 和 0 。 程序清单7.5体现了以上分析的思路。为扩大该程序的应用范围，程序 用long类型而不是int类型（如果系统不支持_Bool类型，可以把isPrime的类 型改为int，并用 1 和 0 分别替换程序中的true和false）。 程序清单 7.5 divisors.c 程序 // divisors.c \u0026ndash; 使用嵌套if语句显示一个数的约数 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; int main(void) {\nunsigned long num; // 待测试的数 unsigned long div; // 可能的约数 bool isPrime; // 素数标记 printf(\u0026ldquo;Please enter an integer for analysis; \u0026ldquo;); printf(\u0026ldquo;Enter q to quit.\\n\u0026rdquo;); while (scanf(\u0026quot;%lu\u0026rdquo;, \u0026amp;num) == 1) { for (div = 2, isPrime = true; (div * div) \u0026lt;= num; div++) { if (num % div == 0) { if ((div * div) != num) printf(\u0026quot;%lu is divisible by %lu and %lu.\\n\u0026rdquo;, num, div, num / div); else printf(\u0026quot;%lu is divisible by %lu.\\n\u0026quot;, num, div); isPrime = false; // 该数不是素数 }\n} # if (isPrime) printf(\u0026quot;%lu is prime.\\n\u0026quot;, num); printf(\u0026ldquo;Please enter another integer for analysis; \u0026ldquo;); printf(\u0026ldquo;Enter q to quit.\\n\u0026rdquo;); } printf(\u0026ldquo;Bye.\\n\u0026rdquo;); return 0; } 注意，该程序在for循环的测试表达式中使用了逗号运算符，这样每次 输入新值时都可以把isPrime设置为true。 下面是该程序的一个输出示例： Please enter an integer for analysis; Enter q to quit. 123456789 123456789 is divisible by 3 and 41152263. 123456789 is divisible by 9 and 13717421. 123456789 is divisible by 3607 and 34227. 123456789 is divisible by 3803 and 32463. 123456789 is divisible by 10821 and 11409.\nPlease enter another integer for analysis; Enter q to quit. 149 149 is prime. Please enter another integer for analysis; Enter q to quit. 2013 2013 is divisible by 3 and 671. 2013 is divisible by 11 and 183. 2013 is divisible by 33 and 61. Please enter another integer for analysis; Enter q to quit. q Bye. 该程序会把 1 认为是素数，其实它不是。下一节将要介绍的逻辑运算符 可以排除这种特殊的情况。 小结：用 if 语句进行选择 关键字： if 、 else 一般注解： 下面各形式中，statement可以是一条简单语句或复合语句。表达式为真 说明其值是非零值。 形式 1 ： if (expression)\nstatement 如果expression为真，则执行statement部分。 形式 2 ： if (expression) statement1 else statement2 如果expression为真，执行statement1部分；否则，执行statement2部分。 形式 3 ： if (expression1) statement1 else if (expression2) statement2 else statement3 如果expression1为真，执行statement1部分；如果expression2为真，执行 statement2部分；否则，执行statement3部分。 示例： if (legs == 4)\nprintf(\u0026ldquo;It might be a horse.\\n\u0026rdquo;); else if (legs \u0026gt; 4) printf(\u0026ldquo;It is not a horse.\\n\u0026rdquo;); else /* 如果legs \u0026lt; 4 */ { legs++; printf(\u0026ldquo;Now it has one more leg.\\n\u0026rdquo;); }\n7.3 逻辑运算符 # 读者已经很熟悉了，if 语句和 while 语句通常使用关系表达式作为测试 条件。有时，把多个关系表达式组合起来会很有用。例如，要编写一个程 序，计算输入的一行句子中除单引号和双引号以外其他字符的数量。这种情 况下可以使用逻辑运算符，并使用句点（.）标识句子的末尾。程序清单7.6 用一个简短的程序进行演示。 程序清单 7.6 chcount.c 程序 // chcount.c \u0026ndash; 使用逻辑与运算符 #include \u0026lt;stdio.h\u0026gt; #define PERIOD \u0026lsquo;.\u0026rsquo; int main(void) { char ch; int charcount = 0; while ((ch = getchar()) != PERIOD) { if (ch != \u0026lsquo;\u0026rdquo;\u0026rsquo; \u0026amp;\u0026amp; ch != \u0026lsquo;'\u0026rsquo;) charcount++; } printf(\u0026ldquo;There are %d non-quote characters.\\n\u0026rdquo;, charcount);\nreturn 0; } 下面是该程序的一个输出示例： I didn\u0026rsquo;t read the \u0026ldquo;I\u0026rsquo;m a Programming Fool\u0026rdquo; best seller. There are 50 non-quote characters. 程序首先读入一个字符，并检查它是否是一个句点，因为句点标志一个 句子的结束。接下来，if语句的测试条件中使用了逻辑与运算符\u0026amp;\u0026amp;。该 if 语句翻译成文字是“如果待测试的字符不是双引号，并且它也不是单引号， 那么charcount递增1”。 逻辑运算符两侧的条件必须都为真，整个表达式才为真。逻辑运算符的 优先级比关系运算符低，所以不必在子表达式两侧加圆括号。 C有 3 种逻辑运算符，见表7.3。 表7.3 种逻辑运算符\n假设exp1和exp2是两个简单的关系表达式（如car \u0026gt; rat或debt == 1000 ），那么： 当且仅当exp1和exp2都为真时，exp1 \u0026amp;\u0026amp; exp2才为真； 如果exp1或exp2为真，则exp1 || exp2为真； 如果exp1为假，则!exp1为真；如果exp1为真，则!exp1为假。 下面是一些具体的例子：\n5 \u0026gt; 2 \u0026amp;\u0026amp; 4 \u0026gt; 7为假，因为只有一个子表达式为真； # 5 \u0026gt; 2 || 4 \u0026gt; 7为真，因为有一个子表达式为真； # !(4 \u0026gt; 7)为真，因为 4 不大于 7 。 # 顺带一提，最后一个表达式与下面的表达式等价： # 4 \u0026lt;= 7 # 如果不熟悉逻辑运算符或者觉得很别扭，请记住：(练习\u0026amp;\u0026amp;时间)== 完 # 美。 # 7.3.1 备选拼写： iso646.h 头文件 # C 是在美国用标准美式键盘开发的语言。但是在世界各地，并非所有的 # 键盘都有和美式键盘一样的符号。因此，C99标准新增了可代替逻辑运算符 # 的拼写，它们被定义在ios646.h头文件中。如果在程序中包含该头文件，便 可用and代替\u0026amp;\u0026amp;、or代替||、not代替!。例如，可以把下面的代码： if (ch != \u0026lsquo;\u0026rdquo;\u0026rsquo; \u0026amp;\u0026amp; ch != \u0026lsquo;'\u0026rsquo;) charcount++; 改写为： if (ch != \u0026lsquo;\u0026quot;\u0026rsquo; and ch != \u0026lsquo;'\u0026rsquo;) charcount++; 表7.4列出了逻辑运算符对应的拼写，很容易记。读者也许很好奇，为 何C不直接使用and、or和not？因为C一直坚持尽量保持较少的关键字。参考 资料V“新增C99和C11的标准ANSI C库”列出了一些运算符的备选拼写，有些 我们还没见过。 表7.4 逻辑运算符的备选拼写\n7.3.2 优先级 # !运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相 # 同，只比圆括号的优先级低。\u0026amp;\u0026amp;运算符的优先级比||运算符高，但是两者的 # 优先级都比关系运算符低，比赋值运算符高。因此，表达式a \u0026gt;b \u0026amp;\u0026amp; b \u0026gt; c || b \u0026gt; d相当于((a \u0026gt; b) \u0026amp;\u0026amp; (b \u0026gt; c)) || (b \u0026gt; d)。 也就是说，b介于a和c之间，或者b大于d。 尽管对于该例没必要使用圆括号，但是许多程序员更喜欢使用带圆括号 的第 2 种写法。这样做即使不记得逻辑运算符的优先级，表达式的含义也很 清楚。\n7.3.3 求值顺序 # 除了两个运算符共享一个运算对象的情况外，C 通常不保证先对复杂表 # 达式中哪部分求值。例如，下面的语句，可能先对表达式5 + 3求值，也可 # 能先对表达式9 + 6求值： # apples = (5 + 3) * (9 + 6); C 把先计算哪部分的决定权留给编译器的设计者，以便针对特定系统优 化设计。但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是 从左往右。\u0026amp;\u0026amp;和||运算符都是序列点，所以程序在从一个运算对象执行到下 一个运算对象之前，所有的副作用都会生效。而且，C 保证一旦发现某个元 素让整个表达式无效，便立即停止求值。正是由于有这些规定，才能写出这 样结构的代码： while ((c = getchar()) != \u0026rsquo; \u0026rsquo; \u0026amp;\u0026amp; c != \u0026lsquo;\\n\u0026rsquo;)\n如上代码所示，读取字符直至遇到第 1 个空格或换行符。第 1 个子表达 # 式把读取的值赋给c，后面的子表达式会用到c的值。如果没有求值循序的保 证，编译器可能在给c赋值之前先对后面的表达式求值。 这里还有一个例子： if (number != 0 \u0026amp;\u0026amp; 12/number == 2) printf(\u0026ldquo;The number is 5 or 6.\\n\u0026rdquo;); 如果number的值是 0 ，那么第 1 个子表达式为假，且不再对关系表达式求 值。这样避免了把 0 作为除数。许多语言都没有这种特性，知道number为 0 后，仍继续检查后面的条件。 最后，考虑这个例子： while ( x++ \u0026lt; 10 \u0026amp;\u0026amp; x + y \u0026lt; 20) 实际上，\u0026amp;\u0026amp;是一个序列点，这保证了在对\u0026amp;\u0026amp;右侧的表达式求值之前， 已经递增了x。 小结：逻辑运算符和表达式 逻辑运算符： 逻辑运算符的运算对象通常是关系表达式。!运算符只需要一个运算对 象，其他两个逻辑运算符都需要两个运算对象，左侧一个，右侧一个。\n逻辑表达式： # 当且仅当expression1和expression2都为真，expression1 \u0026amp;\u0026amp; expression2才 为真。如果 expression1 或 expression2 为真，expression1 || expression2 为 真。如果expression为假，!expression则为真，反之亦然。 求值顺序： 逻辑表达式的求值顺序是从左往右。一旦发现有使整个表达式为假的因 素，立即停止求值。 示例： 6 \u0026gt; 2 \u0026amp;\u0026amp; 3 == 3 真 !(6 \u0026gt; 2 \u0026amp;\u0026amp; 3 == 3)　假 x != 0 \u0026amp;\u0026amp; (20 / x) \u0026lt; 5 只有当x不等于 0 时，才会对第 2 个表达式求值\n7.3.4 范围 # \u0026amp;\u0026amp;运算符可用于测试范围。例如，要测试score是否在 90 ～ 100 的范围 内，可以这样写： if (range \u0026gt;= 90 \u0026amp;\u0026amp; range \u0026lt;= 100) printf(\u0026ldquo;Good show!\\n\u0026rdquo;); 千万不要模仿数学上的写法： if (90 \u0026lt;= range \u0026lt;= 100) // 千万不要这样写！ printf(\u0026ldquo;Good show!\\n\u0026rdquo;); 这样写的问题是代码有语义错误，而不是语法错误，所以编译器不会捕 获这样的问题（虽然可能会给出警告）。由于\u0026lt;=运算符的求值顺序是从左 往右，所以编译器把测试表达式解释为：\n(90 \u0026lt;= range) \u0026lt;= 100 子表达式90 \u0026lt;= range的值要么是 1 （为真），要么是 0 （为假）。这两个 值都小于 100 ，所以不管range的值是多少，整个表达式都恒为真。因此，在 范围测试中要使用\u0026amp;\u0026amp;。 许多代码都用范围测试来确定一个字符是否是小写字母。例如，假设ch 是char类型的变量： if (ch \u0026gt;= \u0026lsquo;a\u0026rsquo; \u0026amp;\u0026amp; ch \u0026lt;= \u0026lsquo;z\u0026rsquo;) printf(\u0026ldquo;That\u0026rsquo;s a lowercase character.\\n\u0026rdquo;); 该方法仅对于像ASCII这样的字符编码有效，这些编码中相邻字母与相 邻数字一一对应。但是，对于像EBCDIC这样的代码就没用了。相应的可移 植方法是，用ctype.h系列中的islower()函数（参见表7.1）： if (islower(ch)) printf(\u0026ldquo;That\u0026rsquo;s a lowercase character.\\n\u0026rdquo;); 无论使用哪种特定的字符编码，islower()函数都能正常运行（不过，一 些早期的编译器没有ctype.h系列）。\n7.4 一个统计单词的程序 # 现在，我们可以编写一个统计单词数量的程序（即，该程序读取并报告 # 单词的数量）。该程序还可以计算字符数和行数。先来看看编写这样的程序 # 要涉及那些内容。 # 首先，该程序要逐个字符读取输入，知道何时停止读取。然后，该程序 # 能识别并计算这些内容：字符、行数和单词。据此我们编写的伪代码如下： # 读取一个字符 # 当有更多输入时 # 递增字符计数 # 如果读完一行，递增行数计数 # 如果读完一个单词，递增单词计数 # 读取下一个字符 # 前面有一个输入循环的模型： # while ((ch = getchar()) != STOP) { \u0026hellip; } 这里，STOP表示能标识输入末尾的某个值。以前我们用过换行符和句 点标记输入的末尾，但是对于一个通用的统计单词程序，它们都不合适。我 们暂时选用一个文本中不常用的字符（如，|）作为输入的末尾标记。第 8 章 中会介绍更好的方法，以便程序既能处理文本文件，又能处理键盘输入。\n现在，我们考虑循环体。因为该程序使用getchar()进行输入，所以每次 迭代都要通过递增计数器来计数。为了统计行数，程序要能检查换行字符。 如果输入的字符是一个换行符，该程序应该递增行数计数器。这里要注意 STOP 字符位于一行的中间的情况。是否递增行数计数？我们可以作为特殊 行计数，即没有换行符的一行字符。可以通过记录之前读取的字符识别这种 情况，即如果读取时发现 STOP 字符的上一个字符不是换行符，那么这行就 是特殊行。 最棘手的部分是识别单词。首先，必须定义什么是该程序识别的单词。 我们用一个相对简单的方法，把一个单词定义为一个不含空白（即，没有空 格、制表符或换行符）的字符序列。因此，“glymxck”和“r2d2”都算是一个单 词。程序读取的第 1 个非空白字符即是一个单词的开始，当读到空白字符时 结束。判断非空白字符最直接的测试表达式是： c != \u0026rsquo; \u0026rsquo; \u0026amp;\u0026amp; c != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; c != \u0026lsquo;\\t\u0026rsquo; /* 如果c不是空白字符，该表达式为真*/ 检测空白字符最直接的测试表达式是： c == \u0026rsquo; \u0026rsquo; || c == \u0026lsquo;\\n\u0026rsquo; || c == \u0026lsquo;\\t\u0026rsquo; /如果c是空白字符，该表达式为真/ 然而，使用ctype.h头文件中的函数isspace()更简单，如果该函数的参数 是空白字符，则返回真。所以，如果c是空白字符，isspace(c)为真；如果c不 是空白字符，!isspace(c)为真。 要查找一个单词里是否有某个字符，可以在程序读入单词的首字符时把 一个标记（名为 inword）设置为 1 。也可以在此时递增单词计数。然后，只 要inword为 1 （或true），后续的非空白字符都不记为单词的开始。下一个空 白字符，必须重置标记为 0 （或false），然后程序就准备好读取下一个单 词。我们把以上分析写成伪代码： 如果c不是空白字符，且inword为假 设置inword为真，并给单词计数\n如果c是空白字符，且inword为真 设置inword为假 这种方法在读到每个单词的开头时把inword设置为 1 （真），在读到每 个单词的末尾时把inword设置为 0 （假）。只有在标记从 0 设置为 1 时，递增 单词计数。如果能使用_Bool类型，可以在程序中包含stdbool.h头文件，把 inword的类型设置为bool，其值用true和false表示。如果编译器不支持这种 用法，就把inword的类型设置为int，其值用 1 和 0 表示。 如果使用布尔类型的变量，通常习惯把变量自身作为测试条件。如下所 示： 用if (inword)代替if (inword == true) 用if (!inword)代替if (inword == false) 可以这样做的原因是，如果 inword为true，则表达式 inword == true为 true；如果 inword为false，则表达式inword == true为false。所以，还不如直 接用inword作为测试条件。类似地，!inword的值与表达式inword == false的 值相同（非真即false，非假即true）。 程序清单7.7把上述思路（识别行、识别不完整的行和识别单词）翻译 了成C代码。 程序清单 7.7 wordcnt.c 程序 // wordcnt.c \u0026ndash; 统计字符数、单词数、行数 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; // 为isspace()函数提供原型 #include \u0026lt;stdbool.h\u0026gt; // 为bool、true、false提供定义\n#define STOP \u0026lsquo;|\u0026rsquo; int main(void) { char c; // 读入字符 char prev; // 读入的前一个字符 long n_chars = 0L;// 字符数 int n_lines = 0; // 行数 int n_words = 0; // 单词数 int p_lines = 0; // 不完整的行数 bool inword = false; // 如果c在单词中，inword 等于 true printf(\u0026ldquo;Enter text to be analyzed (| to terminate):\\n\u0026rdquo;); prev = \u0026lsquo;\\n\u0026rsquo;; // 用于识别完整的行 while ((c = getchar()) != STOP) { n_chars++; // 统计字符 if (c == \u0026lsquo;\\n\u0026rsquo;) n_lines++; // 统计行 if (!isspace(c) \u0026amp;\u0026amp; !inword) {\ninword = true;// 开始一个新的单词 n_words++; // 统计单词 } if (isspace(c) \u0026amp;\u0026amp; inword) inword = false; // 打到单词的末尾 prev = c; // 保存字符的值 } if (prev != \u0026lsquo;\\n\u0026rsquo;) p_lines = 1; printf(\u0026ldquo;characters = %ld, words = %d, lines = %d, \u0026ldquo;, n_chars, n_words, n_lines); printf(\u0026ldquo;partial lines = %d\\n\u0026rdquo;, p_lines); return 0; } 下面是运行该程序后的一个输出示例： Enter text to be analyzed (| to terminate): Reason is a powerful servant but an inadequate master.\n| # characters = 55, words = 9, lines = 3, partial lines = 0 该程序使用逻辑运算符把伪代码翻译成C代码。例如，把下面的伪代 码： 如果c不是空白字符，且inword为假 翻译成如下C代码： if (!isspace(c) \u0026amp;\u0026amp;!inword) 再次提醒读者注意，!inword 与 inword == false 等价。上面的整个测试 条件比单独判断每个空白字符的可读性高： if (c != \u0026rsquo; \u0026rsquo; \u0026amp;\u0026amp; c != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; c != \u0026lsquo;\\t\u0026rsquo; \u0026amp;\u0026amp; !inword) 上面的两种形式都表示“如果c不是空白字符，且如果c不在单词里”。如 果两个条件都满足，则一定是一个新单词的开头，所以要递增n_words。如 果位于单词中，满足第 1 个条件，但是inword为true，就不递增 n_word。当 读到下一个空白字符时，inword 被再次设置为 false。检查代码，查看一下 如果单词之间有多个空格时，程序是否能正常运行。第 8 章讲解了如何修正 这个问题，让该程序能统计文件中的单词量。\n7.5 条件运算符： ?: # C提供条件表达式（conditional expression）作为表达if else语句的一种 便捷方式，该表达式使用?:条件运算符。该运算符分为两部分，需要 3 个运 算对象。回忆一下，带一个运算对象的运算符称为一元运算符，带两个运算 对象的运算符称为二元运算符。以此类推，带 3 个运算对象的运算符称为三 元运算符。条件运算符是C语言中唯一的三元运算符。下面的代码得到一个 数的绝对值： x = (y \u0026lt; 0)? -y : y; 在=和;之间的内容就是条件表达式，该语句的意思是“如果y小于 0 ，那 么x = -y;否则，x = y”。用if else可以这样表达： if (y \u0026lt; 0) x = -y; else x = y; 条件表达式的通用形式如下： expression1? expression2 : expression3 如果 expression1 为真（非 0 ），那么整个条件表达式的值与 expression2 的值相同；如果expression1为假（ 0 ），那么整个条件表达式的值与 expression3的值相同。 需要把两个值中的一个赋给变量时，就可以用条件表达式。典型的例子 是，把两个值中的最大值赋给变量： max = (a \u0026gt; b)? a : b;\n如果a大于b，那么将max设置为a；否则，设置为b。 通常，条件运算符完成的任务用 if else 语句也可以完成。但是，使用条 件运算符的代码更简洁，而且编译器可以生成更紧凑的程序代码。 我们来看程序清单7.8中的油漆程序，该程序计算刷给定平方英尺的面 积需要多少罐油漆。基本算法很简单：用平方英尺数除以每罐油漆能刷的面 积。但是，商店只卖整罐油漆，不会拆分来卖，所以如果计算结果是1.7 罐，就需要两罐。因此，该程序计算得到带小数的结果时应该进 1 。条件运 算符常用于处理这种情况，而且还要根据单复数分别打印can和cans。 程序清单 7.8 paint.c 程序 /* paint.c \u0026ndash; 使用条件运算符 */ #include \u0026lt;stdio.h\u0026gt; #define COVERAGE 350 // 每罐油漆可刷的面积（单位：平方英 尺） int main(void) { int sq_feet; int cans; printf(\u0026ldquo;Enter number of square feet to be painted:\\n\u0026rdquo;); while (scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;sq_feet) == 1) { cans = sq_feet / COVERAGE;\ncans += ((sq_feet % COVERAGE == 0))? 0 : 1; printf(\u0026ldquo;You need %d %s of paint.\\n\u0026rdquo;, cans, cans == 1? \u0026ldquo;can\u0026rdquo; : \u0026ldquo;cans\u0026rdquo;); printf(\u0026ldquo;Enter next value (q to quit):\\n\u0026rdquo;); } return 0; } 下面是该程序的运行示例： Enter number of square feet to be painted: 349 You need 1 can of paint. Enter next value (q to quit): 351 You need 2 cans of paint. Enter next value (q to quit): q 该程序使用的变量都是int类型，除法的计算结果（sq_feet / COVERAGE）会被截断。也就是说， 351/350得 1 。所以，cans被截断成整 数部分。如果sq_feet % COVERAGE得 0 ，说明sq_feet被COVERAGE整除， cans的值不变；否则，肯定有余数，就要给cans加 1 。这由下面的语句完成：\ncans += ((sq_feet % COVERAGE == 0))? 0 : 1; 该语句把+=右侧表达式的值加上cans，再赋给cans。右侧表达式是一个 条件表达式，根据sq_feet是否能被COVERAGE整除，其值为 0 或 1 。 printf()函数中的参数也是一个条件表达式： cans == 1? \u0026ldquo;can\u0026rdquo; : \u0026ldquo;cans\u0026rdquo;); 如果cans的值是 1 ，则打印can；否则，打印cans。这也说明了条件运算 符的第 2 个和第 3 个运算对象可以是字符串。 小结：条件运算符 条件运算符： ?: 一般注解： 条件运算符需要 3 个运算对象，每个运算对象都是一个表达式。其通用 形式如下： expression1? expression2 : expression3 如果expression1为真，整个条件表达式的值是expression2的值；否则， 是expression3的值。 示例： (5 \u0026gt; 3)? 1 : 2 值为 1 (3 \u0026gt; 5)? 1 : 2 值为 2 (a \u0026gt; b)? a : b 如果a \u0026gt;b，则取较大的值\n7.6 循环辅助： continue 和 break # 一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中 # 的所有语句。continue 和break语句可以根据循环体中的测试结果来忽略一部 分循环内容，甚至结束循环。\n7.6.1 continue 语句 # 3 种循环都可以使用continue语句。执行到该语句时，会跳过本次迭代的 剩余部分，并开始下一轮迭代。如果continue语句在嵌套循环内，则只会影 响包含该语句的内层循环。程序清单7.9中的简短程序演示了如何使用 continue。 程序清单 7.9 skippart.c 程序 /* skippart.c \u0026ndash; 使用continue跳过部分循环 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { const float MIN = 0.0f; const float MAX = 100.0f; float score; float total = 0.0f; int n = 0; float min = MAX;\nfloat max = MIN; printf(\u0026ldquo;Enter the first score (q to quit): \u0026ldquo;); while (scanf(\u0026quot;%f\u0026rdquo;, \u0026amp;score) == 1) { if (score \u0026lt; MIN || score \u0026gt; MAX) { printf(\u0026quot;%0.1f is an invalid value.Try again: \u0026ldquo;,score); continue; // 跳转至while循环的测试条件 } printf(\u0026ldquo;Accepting %0.1f:\\n\u0026rdquo;, score); min = (score \u0026lt; min)? score : min; max = (score \u0026gt; max)? score : max; total += score; n++; printf(\u0026ldquo;Enter next score (q to quit): \u0026ldquo;); } if (n \u0026gt; 0) { printf(\u0026ldquo;Average of %d scores is %0.1f.\\n\u0026rdquo;, n, total / n);\nprintf(\u0026ldquo;Low = %0.1f, high = %0.1f\\n\u0026rdquo;, min, max); } else printf(\u0026ldquo;No valid scores were entered.\\n\u0026rdquo;); return 0; } 在程序清单7.9中，while循环读取输入，直至用户输入非数值数据。循 环中的if语句筛选出无效的分数。假设输入 188 ，程序会报告：188 is an invalid value。在本例中，continue 语句让程序跳过处理有效输入部分的代 码。程序开始下一轮循环，准备读取下一个输入值。 注意，有两种方法可以避免使用continue，一是省略continue，把剩余部 分放在一个else块中： if (score \u0026lt; 0 || score \u0026gt; 100) /* printf()语句 / else { / 语句*/ } 另一种方法是，用以下格式来代替： if (score \u0026gt;= 0 \u0026amp;\u0026amp; score \u0026lt;= 100)\n{ # /* 语句 */ # } # 这种情况下，使用continue的好处是减少主语句组中的一级缩进。当语 句很长或嵌套较多时，紧凑简洁的格式提高了代码的可读性。 continue还可用作占位符。例如，下面的循环读取并丢弃输入的数据， 直至读到行末尾： while (getchar() != \u0026lsquo;\\n\u0026rsquo;) ; 当程序已经读取一行中的某些内容，要跳至下一行开始处时，这种用法 很方便。问题是，一般很难注意到一个单独的分号。如果使用continue，可 读性会更高： while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; 如果用了continue没有简化代码反而让代码更复杂，就不要使用 continue。例如，考虑下面的程序段： while ((ch = getchar() ) != \u0026lsquo;\\n\u0026rsquo;) { if (ch == \u0026lsquo;\\t\u0026rsquo;) continue; putchar(ch);\n} # 该循环跳过制表符，并在读到换行符时退出循环。以上代码这样表示更 # 简洁： # while ((ch = getchar()) != \u0026lsquo;\\n\u0026rsquo;) if (ch != \u0026lsquo;\\t\u0026rsquo;) putchar(ch); 通常，在这种情况下，把if的测试条件的关系反过来便可避免使用 continue。 以上介绍了continue语句让程序跳过循环体的余下部分。那么，从何处 开始继续循环？对于while和 do while 循环，执行 continue 语句后的下一个 行为是对循环的测试表达式求值。考虑下面的循环： count = 0; while (count \u0026lt; 10) { ch = getchar(); if (ch == \u0026lsquo;\\n\u0026rsquo;) continue; putchar(ch); count++; }\n该循环读取 10 个字符（除换行符外，因为当ch是换行符时，程序会跳过 count++;语句）并重新显示它们，其中不包括换行符。执行continue后，下一 个被求值的表达式是循环测试条件。 对于for循环，执行continue后的下一个行为是对更新表达式求值，然后 是对循环测试表达式求值。例如，考虑下面的循环： for (count = 0; count \u0026lt; 10; count++) { ch = getchar(); if (ch == \u0026lsquo;\\n\u0026rsquo;) continue; putchar(ch); } 该例中，执行完continue后，首先递增count，然后将递增后的值和 10 作 比较。因此，该循环与上面while循环的例子稍有不同。while循环的例子 中，除了换行符，其余字符都显示；而本例中，换行符也计算在内，所以读 取的 10 个字符中包含换行符。\n7.6.2 break 语句 # 程序执行到循环中的break语句时，会终止包含它的循环，并继续执行 下一阶段。把程序清单7.9中的continue替换成break，在输入 188 时，不是跳 至执行下一轮循环，而是导致退出当前循环。图7.3比较了break和continue。 如果break语句位于嵌套循环内，它只会影响包含它的当前循环。\n图7.3 比较break和continue\nbreak还可用于因其他原因退出循环的情况。程序清单7.10用一个循环计 算矩形的面积。如果用户输入非数字作为矩形的长或宽，则终止循环。 程序清单 7.10 break.c 程序 /* break.c \u0026ndash; 使用 break 退出循环 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { float length, width; printf(\u0026ldquo;Enter the length of the rectangle:\\n\u0026rdquo;); while (scanf(\u0026quot;%f\u0026rdquo;, \u0026amp;length) == 1) { printf(\u0026ldquo;Length = %0.2f:\\n\u0026rdquo;, length); printf(\u0026ldquo;Enter its width:\\n\u0026rdquo;); if (scanf(\u0026quot;%f\u0026rdquo;, \u0026amp;width) != 1) break; printf(\u0026ldquo;Width = %0.2f:\\n\u0026rdquo;, width); printf(\u0026ldquo;Area = %0.2f:\\n\u0026rdquo;, length * width); printf(\u0026ldquo;Enter the length of the rectangle:\\n\u0026rdquo;); }\nprintf(\u0026ldquo;Done.\\n\u0026rdquo;); return 0; } 可以这样控制循环： while (scanf(\u0026quot;%f %f\u0026rdquo;, \u0026amp;length, \u0026amp;width) == 2) 但是，用break可以方便显示用户输入的值。 和continue一样，如果用了break代码反而更复杂，就不要使用break。例 如，考虑下面的循环： while ((ch = getchar()) != \u0026lsquo;\\n\u0026rsquo;) { if (ch == \u0026lsquo;\\t\u0026rsquo;) break; putchar(ch); } 如果把两个测试条件放在一起，逻辑就更清晰了： while ((ch = getchar() ) != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; ch != \u0026lsquo;\\t\u0026rsquo;) putchar(ch); break语句对于稍后讨论的switch语句而言至关重要。 在for循环中的break和continue的情况不同，执行完break语句后会直接执 行循环后面的第 1 条语句，连更新部分也跳过。嵌套循环内层的break只会让\n程序跳出包含它的当前循环，要跳出外层循环还需要一个break： int p, q; scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;p); while (p \u0026gt; 0) { printf(\u0026quot;%d\\n\u0026rdquo;, p); scanf(\u0026quot;%d\u0026quot;, \u0026amp;q); while (q \u0026gt; 0) { printf(\u0026quot;%d\\n\u0026quot;, p*q); if (q \u0026gt; 100) break; // 跳出内层循环 scanf(\u0026quot;%d\u0026quot;, \u0026amp;q); } if (q \u0026gt; 100) break; // 跳出外层循环 scanf(\u0026quot;%d\u0026quot;, \u0026amp;p); }\n7.7 多重选择： switch 和 break # 使用条件运算符和 if else 语句很容易编写二选一的程序。然而，有时程 序需要在多个选项中进行选择。可以用if else if\u0026hellip;else来完成。但是，大多数 情况下使用switch语句更方便。程序清单7.11演示了如何使用switch语句。该 程序读入一个字母，然后打印出与该字母开头的动物名。 程序清单 7.11 animals.c 程序 /* animals.c \u0026ndash; 使用switch语句 / #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; int main(void) { char ch; printf(\u0026ldquo;Give me a letter of the alphabet, and I will give \u0026ldquo;); printf(\u0026ldquo;an animal name\\nbeginning with that letter.\\n\u0026rdquo;); printf(\u0026ldquo;Please type in a letter; type # to end my act.\\n\u0026rdquo;); while ((ch = getchar()) != \u0026lsquo;#\u0026rsquo;) { if (\u0026rsquo;\\n\u0026rsquo; == ch) continue; if (islower(ch)) / 只接受小写字母*/\nswitch (ch) { case \u0026lsquo;a\u0026rsquo;: printf(\u0026ldquo;argali, a wild sheep of Asia\\n\u0026rdquo;); break; case \u0026lsquo;b\u0026rsquo;: printf(\u0026ldquo;babirusa, a wild pig of Malay\\n\u0026rdquo;); break; case \u0026lsquo;c\u0026rsquo;: printf(\u0026ldquo;coati, racoonlike mammal\\n\u0026rdquo;); break; case \u0026rsquo;d\u0026rsquo;: printf(\u0026ldquo;desman, aquatic, molelike critter\\n\u0026rdquo;); break; case \u0026rsquo;e\u0026rsquo;: printf(\u0026ldquo;echidna, the spiny anteater\\n\u0026rdquo;); break; case \u0026lsquo;f\u0026rsquo;: printf(\u0026ldquo;fisher, brownish marten\\n\u0026rdquo;);\nbreak; default: printf(\u0026ldquo;That\u0026rsquo;s a stumper!\\n\u0026rdquo;); } /* switch结束　/ else printf(\u0026ldquo;I recognize only lowercase letters.\\n\u0026rdquo;); while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; / 跳过输入行的剩余部分　/ printf(\u0026ldquo;Please type another letter or a #.\\n\u0026rdquo;); } / while循环结束　*/ printf(\u0026ldquo;Bye!\\n\u0026rdquo;); return 0; } 篇幅有限，我们只编到f，后面的字母以此类推。在进一步解释该程序 之前，先看看输出示例： Give me a letter of the alphabet, and I will give an animal name beginning with that letter. Please type in a letter; type # to end my act. a [enter]\nargali, a wild sheep of Asia Please type another letter or a #. dab [enter] desman, aquatic, molelike critter Please type another letter or a #. r [enter] That\u0026rsquo;s a stumper! Please type another letter or a #. Q [enter] I recognize only lowercase letters. Please type another letter or a #. # [enter] Bye! 该程序的两个主要特点是：使用了switch语句和它对输出的处理。我们 先分析switch的工作原理。\n7.7.1 switch 语句 # 要对紧跟在关键字 switch 后圆括号中的表达式求值。在程序清单 7.11 中，该表达式是刚输入给 ch的值。然后程序扫描标签（这里指，case \u0026lsquo;a\u0026rsquo; :、 case \u0026lsquo;b\u0026rsquo; :等）列表，直到发现一个匹配的值为止。然后程序跳转至那一行。 如果没有匹配的标签怎么办？如果有default :标签行，就跳转至该行；否 则，程序继续执行在switch后面的语句。\nbreak语句在其中起什么作用？它让程序离开switch语句，跳至switch语 句后面的下一条语句（见图7.4）。如果没有break语句，就会从匹配标签开 始执行到switch末尾。例如，如果删除该程序中的所有break语句，运行程序 后输入d，其交互的输出结果如下：\n图7.4 switch中有break和没有break的程序流 Give me a letter of the alphabet, and I will give an animal name\nbeginning with that letter. Please type in a letter; type # to end my act. d [enter] desman, aquatic, molelike critter echidna, the spiny anteater fisher, a brownish marten That\u0026rsquo;s a stumper! Please type another letter or a #. # [enter] Bye! 如上所示，执行了从case \u0026rsquo;d\u0026rsquo;:到switch语句末尾的所有语句。 顺带一提，break语句可用于循环和switch语句中，但是continue只能用 于循环中。尽管如此，如果switch语句在一个循环中，continue便可作为 switch语句的一部分。这种情况下，就像在其他循环中一样，continue让程序 跳出循环的剩余部分，包括switch语句的其他部分。 如果读者熟悉Pascal，会发现switch语句和Pascal的case语句类似。它们 最大的区别在于，如果只希望处理某个带标签的语句，就必须在switch语句 中使用break语句。另外，C语言的case一般都指定一个值，不能使用一个范 围。 switch在圆括号中的测试表达式的值应该是一个整数值（包括char类 型）。case标签必须是整数类型（包括char类型）的常量或整型常量表达式 （即，表达式中只包含整型常量）。不能用变量作为case标签。switch的构\n造如下： # switch ( 整型表达式) { case 常量1: 语句　\u0026lt;--可选 case 常量2: 语句　\u0026lt;--可选 default : \u0026lt;--可选 语句　\u0026lt;--可选 } 7.7.2 只读每行的首字符 # animals.c（程序清单7.11）的另一个独特之处是它读取输入的方式。运 行程序时读者可能注意到了，当输入dab时，只处理了第 1 个字符。这种丢弃 一行中其他字符的行为，经常出现在响应单字符的交互程序中。可以用下面 的代码实现这样的行为： while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; /* 跳过输入行的其余部分 */ 循环从输入中读取字符，包括按下Enter键产生的换行符。注意，函数 的返回值并没有赋给ch，以上代码所做的只是读取并丢弃字符。由于最后丢 弃的字符是换行符，所以下一个被读取的字符是下一行的首字母。在外层的 while循环中，getchar()读取首字母并赋给ch。\n假设用户一开始就按下Enter键，那么程序读到的首个字符就是换行 符。下面的代码处理这种情况： if (ch == \u0026lsquo;\\n\u0026rsquo;) continue;\n7.7.3 多重标签 # 如程序清单7.12所示，可以在switch语句中使用多重case标签。 程序清单 7.12 vowels.c 程序 // vowels.c -- 使用多重标签 #include \u0026lt;stdio.h\u0026gt; int main(void) { char ch; int a_ct, e_ct, i_ct, o_ct, u_ct; a_ct = e_ct = i_ct = o_ct = u_ct = 0; printf(\u0026#34;Enter some text; enter # to quit.\\n\u0026#34;); while ((ch = getchar()) != \u0026#39;#\u0026#39;) { switch (ch) { case \u0026lsquo;a\u0026rsquo;: case \u0026lsquo;A\u0026rsquo;: a_ct++; break; case \u0026rsquo;e\u0026rsquo;: case \u0026lsquo;E\u0026rsquo;: e_ct++; break; case \u0026lsquo;i\u0026rsquo;: case \u0026lsquo;I\u0026rsquo;: i_ct++; break; case \u0026lsquo;o\u0026rsquo;: case \u0026lsquo;O\u0026rsquo;: o_ct++; break; case \u0026lsquo;u\u0026rsquo;: case \u0026lsquo;U\u0026rsquo;: u_ct++; break; default: break; } // switch结束 } // while循环结束 printf(\u0026ldquo;number of vowels: A E I O U\\n\u0026rdquo;);\nprintf(\u0026rdquo; %4d %4d %4d %4d %4d\\n\u0026rdquo;, a_ct, e_ct, i_ct, o_ct, u_ct); return 0; } 假设如果ch是字母i，switch语句会定位到标签为case \u0026lsquo;i\u0026rsquo; :的位置。由于 该标签没有关联break语句，所以程序流直接执行下一条语句，即i_ct++;。 如果 ch是字母I，程序流会直接定位到case \u0026lsquo;I\u0026rsquo; :。本质上，两个标签都指的是 相同的语句。 严格地说，case \u0026lsquo;U\u0026rsquo;的 break 语句并不需要。因为即使删除这条 break 语 句，程序流会接着执行switch中的下一条语句，即default : break;。所以，可 以把case \u0026lsquo;U\u0026rsquo;的break语句去掉以缩短代码。但是从另一方面看，保留这条 break语句可以防止以后在添加新的case（例如，把y作为元音）时遗漏break 语句。 下面是该程序的运行示例： Enter some text; enter # to quit. I see under the overseer.# number of vowels: A E I O U 0　7　1　1　1 在该例中，如果使用ctype.h系列的toupper()函数（参见表7.2）可以避免 使用多重标签，在进行测试之前就把字母转换成大写字母： while ((ch = getchar()) != \u0026lsquo;#\u0026rsquo;) {\nch = toupper(ch); switch (ch) { case \u0026lsquo;A\u0026rsquo;: a_ct++; break; case \u0026lsquo;E\u0026rsquo;: e_ct++; break; case \u0026lsquo;I\u0026rsquo;: i_ct++; break; case \u0026lsquo;O\u0026rsquo;: o_ct++; break; case \u0026lsquo;U\u0026rsquo;: u_ct++; break; default: break; } // switch结束 } // while循环结束 或者，也可以先不转换ch，把toupper(ch)放进switch的测试条件中： switch(toupper(ch))。 小结：带多重选择的 switch 语句\n关键字： switch 一般注解： 程序根据expression的值跳转至相应的case标签处。然后，执行剩下的所 有语句，除非执行到break语句进行重定向。expression和case标签都必须是 整数值（包括char类型），标签必须是常量或完全由常量组成的表达式。如 果没有case标签与expression的值匹配，控制则转至标有default的语句（如果 有的话）；否则，将转至执行紧跟在switch语句后面的语句。 形式： switch ( expression ) { case label1 : statement1//使用break跳出switch case label2 : statement2 default : statement3 } 可以有多个标签语句，default语句可选。 示例： switch (choice) { case 1 : case 2 : printf(\u0026ldquo;Darn tootin\u0026rsquo;!\\n\u0026rdquo;); break;\ncase 3 : printf(\u0026ldquo;Quite right!\\n\u0026rdquo;); case 4 : printf(\u0026ldquo;Good show!\\n\u0026rdquo;); break; default: printf(\u0026ldquo;Have a nice day.\\n\u0026rdquo;); } 如果choice的值是 1 或 2 ，打印第 1 条消息；如果choice的值是 3 ，打印第 2 条和第 3 条消息（程序继续执行后续的语句，因为case 3后面没有break语 句）；如果choice的值是 4 ，则打印第 3 条消息；如果choice的值是其他值只 打印最后一条消息。\n7.7.4 switch 和 if else # 何时使用switch？何时使用if else？你经常会别无选择。如果是根据浮 点类型的变量或表达式来选择，就无法使用 switch。如果根据变量在某范围 内决定程序流的去向，使用 switch 就很麻烦，这种情况用if就很方便： if (integer \u0026lt; 1000 \u0026amp;\u0026amp; integer \u0026gt; 2) 使用switch要涵盖以上范围，需要为每个整数（ 3 ～ 999 ）设置case标 签。但是，如果使用switch，程序通常运行快一些，生成的代码少一些。\n7.8 goto 语句 # 早期版本的BASIC和FORTRAN所依赖的goto语句，在C中仍然可用。但 是C和其他两种语言不同，没有goto语句C程序也能运行良好。Kernighan和 Ritchie提到goto语句“易被滥用”，并建议“谨慎使用，或者根本不用”。首 先，介绍一下如何使用goto语句；然后，讲解为什么通常不需要它。 goto语句有两部分：goto和标签名。标签的命名遵循变量命名规则，如 下所示： goto part2; 要让这条语句正常工作，函数还必须包含另一条标为part2的语句，该 语句以标签名后紧跟一个冒号开始： part2: printf(\u0026ldquo;Refined analysis:\\n\u0026rdquo;); 7.8.1 避免使用 goto 原则上，根本不用在C程序中使用goto语句。但是，如果你曾经学过 FORTRAN或BASIC（goto对这两种语言而言都必不可少），可能还会依赖 用goto来编程。为了帮助你克服这个习惯，我们先概述一些使用goto的常见 情况，然后再介绍C的解决方案。 处理包含多条语句的if语句： if (size \u0026gt; 12) goto a; goto b; a: cost = cost * 1.05; flag = 2;\nb: bill = cost * flag; 对于以前的BASIC和FORTRAN，只有直接跟在if条件后面的一条语句才 属于if，不能使用块或复合语句。我们把以上模式转换成等价的C代码，标 准C用复合语句或块来处理这种情况： if (size \u0026gt; 12) { cost = cost * 1.05; flag = 2; } bill = cost * flag; 二选一： if (ibex \u0026gt; 14) goto a; sheds = 2; goto b; a: sheds= 3; b: help = 2 * sheds; C通过if else表达二选一更清楚： if (ibex \u0026gt; 14) sheds = 3;\nelse sheds = 2; help = 2 * sheds; 实际上，新版的BASIC和FORTRAN已经把else纳入新的语法中。 创建不确定循环： readin: scanf(\u0026quot;%d\u0026quot;, \u0026amp;score); if (score \u0026lt; O) goto stage2; lots of statements goto readin; stage2: more stuff; C用while循环代替： scanf(\u0026quot;%d\u0026quot;, \u0026amp;score); while (score \u0026lt;= 0) { lots of statements scanf(\u0026quot;%d\u0026quot;, \u0026amp;score); } more stuff;\n跳转至循环末尾，并开始下一轮迭代。C使用continue语句代替。 跳出循环。C使用break语句。实际上，break和continue是goto的特殊形 式。使用break和 continue 的好处是：其名称已经表明它们的用法，而且这些 语句不使用标签，所以不用担心把标签放错位置导致的危险。 胡乱跳转至程序的不同部分。简而言之，不要这样做！ 但是，C程序员可以接受一种goto的用法——出现问题时从一组嵌套循 环中跳出（一条break语句只能跳出当前循环）： while (funct \u0026gt; 0) { for (i = 1, i \u0026lt;= 100; i++) { for (j = 1; j \u0026lt;= 50; j++) { 其他语句 if (问题) goto help; 其他语句 } 其他语句 }\n其他语句 # } # 其他语句 # help: 语句 从其他例子中也能看出，程序中使用其他形式比使用goto的条理更清 晰。当多种情况混在一起时，这种差异更加明显。哪些goto语句可以帮助if 语句？哪些可以模仿if else？哪些控制循环？哪些是因为程序无路可走才不 得已放在那里？过度地使用 goto 语句，会让程序错综复杂。如果不熟悉goto 语句，就不要使用它。如果已经习惯使用goto语句，试着改掉这个毛病。讽 刺地是，虽然C根本不需要goto，但是它的goto比其他语言的goto好用，因为 C允许在标签中使用描述性的单词而不是数字。 小结：程序跳转 关键字： break 、 continue 、 goto 一般注解： 这 3 种语句都能使程序流从程序的一处跳转至另一处。 break语句： 所有的循环和switch语句都可以使用break语句。它使程序控制跳出当前 循环或switch语句的剩余部分，并继续执行跟在循环或switch后面的语句。 示例： switch (number) { case 4: printf(\u0026ldquo;That\u0026rsquo;s a good choice.\\n\u0026rdquo;);\nbreak; case 5: printf(\u0026ldquo;That\u0026rsquo;s a fair choice.\\n\u0026rdquo;); break; default: printf(\u0026ldquo;That\u0026rsquo;s a poor choice.\\n\u0026rdquo;); } continue语句： 所有的循环都可以使用continue语句，但是switch语句不行。continue语 句使程序控制跳出循环的剩余部分。对于while或for循环，程序执行到 continue语句后会开始进入下一轮迭代。对于do while循环，对出口条件求值 后，如有必要会进入下一轮迭代。 示例： while ((ch = getchar()) != \u0026lsquo;\\n\u0026rsquo;) { if (ch == \u0026rsquo; \u0026lsquo;) continue; putchar(ch); chcount++; } 以上程序段把用户输入的字符再次显示在屏幕上，并统计非空格字符。 goto语句：\ngoto语句使程序控制跳转至相应标签语句。冒号用于分隔标签和标签语 句。标签名遵循变量命名规则。标签语句可以出现在goto的前面或后面。 形式： goto label ;\nlabel : statement 示例： top : ch = getchar(); if (ch != \u0026#39;y\u0026#39;) goto top; 7.9 关键概念 # 智能的一个方面是，根据情况做出相应的响应。所以，选择语句是开发 # 具有智能行为程序的基础。C语言通过if、if else和switch语句，以及条件运 算符（?:）可以实现智能选择。 if 和 if else 语句使用测试条件来判断执行哪些语句。所有非零值都被视 为 true，零被视为false。测试通常涉及关系表达式（比较两个值）、逻辑表 达式（用逻辑运算符组合或更改其他表达式）。 要记住一个通用原则，如果要测试两个条件，应该使用逻辑运算符把两 个完整的测试表达式组合起来。例如，下面这些是错误的： if (a \u0026lt; x \u0026lt; z) // 错误，没有使用逻辑运算符 \u0026hellip; if (ch != \u0026lsquo;q\u0026rsquo; \u0026amp;\u0026amp; != \u0026lsquo;Q\u0026rsquo;) // 错误，缺少完整的测试表达式 \u0026hellip; 正确的方式是用逻辑运算符连接两个关系表达式： if (a \u0026lt; x \u0026amp;\u0026amp; x \u0026lt; z) // 使用\u0026amp;\u0026amp;组合两个表达式 \u0026hellip; if (ch != \u0026lsquo;q\u0026rsquo; \u0026amp;\u0026amp; ch != \u0026lsquo;Q\u0026rsquo;) // 使用\u0026amp;\u0026amp;组合两个表达式 \u0026hellip; 对比这两章和前几章的程序示例可以发现：使用第 6 章、第 7 章介绍的语 句，可以写出功能更强大、更有趣的程序。\n7.10 本章小结 # 本章介绍了很多内容，我们来总结一下。if语句使用测试条件控制程序 是否执行测试条件后面的一条简单语句或复合语句。如果测试表达式的值是 非零值，则执行语句；如果测试表达式的值是零，则不执行语句。if else语 句可用于二选一的情况。如果测试条件是非零，则执行else前面的语句；如 果测试表达式的值是零，则执行else后面的语句。在else后面使用另一个if语 句形成else if，可构造多选一的结构。 测试条件通常都是关系表达式，即用一个关系运算符（如，\u0026lt;或==）的 表达式。使用C的逻辑运算符，可以把关系表达式组合成更复杂的测试条 件。 在多数情况下，用条件运算符（?:）写成的表达式比if else语句更简 洁。 ctype.h系列的字符函数（如，issapce()和isalpha()）为创建以分类字符为 基础的测试表达式提供了便捷的工具。 switch 语句可以在一系列以整数作为标签的语句中进行选择。如果紧跟 在 switch 关键字后的测试条件的整数值与某标签匹配，程序就转至执行匹 配的标签语句，然后在遇到break之前，继续执行标签语句后面的语句。 break、continue和goto语句都是跳转语句，使程序流跳转至程序的另一 处。break语句使程序跳转至紧跟在包含break语句的循环或switch末尾的下一 条语句。continue语句使程序跳出当前循环的剩余部分，并开始下一轮迭 代。\n7.11 复习题 # 复习题的参考答案在附录A中。 # 1.判断下列表达式是true还是false。 a 100 \u0026gt; 3 \u0026amp;\u0026amp; \u0026lsquo;a\u0026rsquo;\u0026gt;\u0026lsquo;c\u0026rsquo;\nb 100 \u0026gt; 3 || \u0026lsquo;a\u0026rsquo;\u0026gt;\u0026lsquo;c\u0026rsquo;\nc !(100\u0026gt;3)\n2.根据下列描述的条件，分别构造一个表达式： a umber等于或大于 90 ，但是小于 100\nb h不是字符q或k\nc umber在 1 ～ 9 之间（包括 1 和 9 ），但不是 5\nd umber不在 1 ～ 9 之间\n3.下面的程序关系表达式过于复杂，而且还有些错误，请简化并改正。 #include \u0026lt;stdio.h\u0026gt; int main(void) /* 1 / { / 2 / int weight, height; / weight以磅为单位，height以英寸为单位 // 4 / scanf(\u0026quot;%d , weight, height); / 5 / if (weight \u0026lt; 100 \u0026amp;\u0026amp; height \u0026gt; 64) / 6 */\nif (height \u0026gt;= 72) /* 7 / printf(\u0026ldquo;You are very tall for your weight.\\n\u0026rdquo;); else if (height \u0026lt; 72 \u0026amp;\u0026amp;\u0026gt; 64) / 9 / printf(\u0026ldquo;You are tall for your weight.\\n\u0026rdquo;);/ 10 / else if (weight \u0026gt; 300 \u0026amp;\u0026amp; !(weight \u0026lt;= 300) / 11 / \u0026amp;\u0026amp; height \u0026lt; 48) / 12 / if (!(height \u0026gt;= 48)) / 13 / printf(\u0026quot; You are quite short for your weight.\\n\u0026quot;); else / 15 / printf(\u0026ldquo;Your weight is ideal.\\n\u0026rdquo;); / 16 / / 17 */ return 0; } 4.下列个表达式的值是多少？ a.5 \u0026gt; 2 b.3 + 4 \u0026gt; 2 \u0026amp;\u0026amp; 3 \u0026lt; 2 c.x \u0026gt;= y || y \u0026gt; x d.d = 5 + ( 6 \u0026gt; 2 ) e.\u0026lsquo;X\u0026rsquo; \u0026gt; \u0026lsquo;T\u0026rsquo;? 10 : 5\nf.x \u0026gt; y? y \u0026gt; x : x \u0026gt; y 5.下面的程序将打印什么？ #include \u0026lt;stdio.h\u0026gt; int main(void) { int num; for (num = 1; num \u0026lt;= 11; num++) { if (num % 3 == 0) putchar(\u0026rsquo;$\u0026rsquo;); else putchar(\u0026rsquo;*\u0026rsquo;); putchar(\u0026rsquo;#\u0026rsquo;); putchar(\u0026rsquo;%\u0026rsquo;); } putchar(\u0026rsquo;\\n\u0026rsquo;); return 0; } 6.下面的程序将打印什么？\n#include \u0026lt;stdio.h\u0026gt; int main(void) { int i = 0; while (i \u0026lt; 3) { switch (i++) { case 0: printf(\u0026ldquo;fat \u0026ldquo;); case 1: printf(\u0026ldquo;hat \u0026ldquo;); case 2: printf(\u0026ldquo;cat \u0026ldquo;); default: printf(\u0026ldquo;Oh no!\u0026rdquo;); } putchar(\u0026rsquo;\\n\u0026rsquo;); } return 0; } 7.下面的程序有哪些错误？ #include \u0026lt;stdio.h\u0026gt; int main(void) {\nchar ch; int lc = 0; /* 统计小写字母 int uc = 0; /* 统计大写字母 int oc = 0; /* 统计其他字母 while ((ch = getchar()) != \u0026lsquo;#\u0026rsquo;) { if (\u0026lsquo;a\u0026rsquo; \u0026lt;= ch \u0026gt;= \u0026lsquo;z\u0026rsquo;) lc++; else if (!(ch \u0026lt; \u0026lsquo;A\u0026rsquo;) || !(ch \u0026gt; \u0026lsquo;Z\u0026rsquo;) uc++; oc++; } printf(%d lowercase, %d uppercase, %d other, lc, uc, oc); return 0; } 8.下面的程序将打印什么？ /* retire.c */ #include \u0026lt;stdio.h\u0026gt; int main(void)\n{ # int age = 20; while (age++ \u0026lt;= 65) { if ((age % 20) == 0) /* age是否能被 20 整除？ */ printf(\u0026ldquo;You are %d.Here is a raise.\\n\u0026rdquo;, age); if (age = 65) printf(\u0026ldquo;You are %d.Here is your gold watch.\\n\u0026rdquo;, age); } return 0; } 9.给定下面的输入时，以下程序将打印什么？ q c h b #include \u0026lt;stdio.h\u0026gt; int main(void) {\nchar ch; while ((ch = getchar()) != \u0026lsquo;#\u0026rsquo;) { if (ch == \u0026lsquo;\\n\u0026rsquo;) continue; printf(\u0026ldquo;Step 1\\n\u0026rdquo;); if (ch == \u0026lsquo;c\u0026rsquo;) continue; else if (ch == \u0026lsquo;b\u0026rsquo;) break; else if (ch == \u0026lsquo;h\u0026rsquo;) goto laststep; printf(\u0026ldquo;Step 2\\n\u0026rdquo;); laststep: printf(\u0026ldquo;Step 3\\n\u0026rdquo;); } printf(\u0026ldquo;Done\\n\u0026rdquo;); return 0; } 10.重写复习题 9 ，但这次不能使用continue和goto语句。\n7.12 编程练习 # 1.编写一个程序读取输入，读到#字符停止，然后报告读取的空格数、 # 换行符数和所有其他字符的数量。 # 2.编写一个程序读取输入，读到#字符停止。程序要打印每个输入的字 # 符以及对应的ASCII码（十进制）。一行打印 8 个字符。建议:使用字符计数 # 和求模运算符（%）在每 8 个循环周期时打印一个换行符。 # 3.编写一个程序，读取整数直到用户输入 0 。输入结束后，程序应报告 # 用户输入的偶数（不包括 0 ）个数、这些偶数的平均值、输入的奇数个数及 # 其奇数的平均值。 # 4.使用if else语句编写一个程序读取输入，读到#停止。用感叹号替换句 号，用两个感叹号替换原来的感叹号，最后报告进行了多少次替换。 5.使用switch重写练习 4 。 6.编写程序读取输入，读到#停止，报告ei出现的次数。 注意 该程序要记录前一个字符和当前字符。用“Receive your eieio award”这 样的输入来测试。 7.编写一个程序，提示用户输入一周工作的小时数，然后打印工资总 额、税金和净收入。做如下假设： a.基本工资 = 1000美元/小时 b.加班（超过 40 小时） = 1.5倍的时间 c.税率： 前 300 美元为15% 续 150 美元为20%\n余下的为25% # 用#define定义符号常量。不用在意是否符合当前的税法。 8.修改练习 7 的假设a，让程序可以给出一个供选择的工资等级菜单。使 用switch完成工资等级选择。运行程序后，显示的菜单应该类似这样：\nEnter the number corresponding to the desired pay rate or action:\n$8.75/hr 2) $9.33/hr $10.00/hr 4) $11.20/hr quit 如果选择 1 ～ 4 其中的一个数字，程序应该询问用户工作的小时数。程 序要通过循环运行，除非用户输入 5 。如果输入 1 ～ 5 以外的数字，程序应 提醒用户输入正确的选项，然后再重复显示菜单提示用户输入。使用#define 创建符号常量表示各工资等级和税率。 9.编写一个程序，只接受正整数输入，然后显示所有小于或等于该数的 素数。 10.1988年的美国联邦税收计划是近代最简单的税收方案。它分为 4 个类 别，每个类别有两个等级。 下面是该税收计划的摘要（美元数为应征税的收入）：\n例如，一位工资为 20000 美元的单身纳税人，应缴纳税费 # 0.15×17850+0.28×（20000−17850）美元。编写一个程序，让用户指定缴纳 # 税金的种类和应纳税收入，然后计算税金。程序应通过循环让用户可以多次 # 输入。 # 11.ABC 邮购杂货店出售的洋蓟售价为 2.05 美元/磅，甜菜售价为 1.15 # 美元/磅，胡萝卜售价为 1.09美元/磅。在添加运费之前， 100 美元的订单有 # 5%的打折优惠。少于或等于 5 磅的订单收取6.5美元的运费和包装费， 5 磅～ # 20 磅的订单收取 14 美元的运费和包装费，超过 20 磅的订单在 14 美元的基础上 # 每续重 1 磅增加0.5美元。编写一个程序，在循环中用switch语句实现用户输 入不同的字母时有不同的响应，即输入a的响应是让用户输入洋蓟的磅数，b 是甜菜的磅数，c是胡萝卜的磅数，q 是退出订购。程序要记录累计的重 量。即，如果用户输入 4 磅的甜菜，然后输入 5 磅的甜菜，程序应报告 9 磅 的甜菜。然后，该程序要计算货物总价、折扣（如果有的话）、运费和包装 费。随后，程序应显示所有的购买信息：物品售价、订购的重量（单位： 磅）、订购的蔬菜费用、订单的总费用、折扣（如果有的话）、运费和包装 费，以及所有的费用总额。\n第 8 章 字符输入 / 输出和输入验证 # 本章介绍以下内容： # 更详细地介绍输入、输出以及缓冲输入和无缓冲输入的区别 # 如何通过键盘模拟文件结尾条件 # 如何使用重定向把程序和文件相连接 # 创建更友好的用户界面 # 在涉及计算机的话题时，我们经常会提到输入（input）和输出 （output）。我们谈论输入和输出设备（如键盘、U盘、扫描仪和激光打印 机），讲解如何处理输入数据和输出数据，讨论执行输入和输出任务的函 数。本章主要介绍用于输入和输出的函数（简称I/O函数）。 I/O函数（如printf()、scanf()、getchar()、putchar()等）负责把信息传送 到程序中。前几章简单介绍过这些函数，本章将详细介绍它们的基本概念。 同时，还会介绍如何设计与用户交互的界面。 最初，输入/输出函数不是C定义的一部分，C把开发这些函数的任务留 给编译器的实现者来完成。在实际应用中，UNIX 系统中的 C 实现为这些函 数提供了一个模型。ANSI C 库吸取成功的经验，把大量的UNIX I/O函数囊 括其中，包括一些我们曾经用过的。由于必须保证这些标准函数在不同的计 算机环境中能正常工作，所以它们很少使用某些特殊系统才有的特性。因 此，许多C供应商会利用硬件的特性，额外提供一些I/O函数。其他函数或函 数系列需要特殊的操作系统支持，如Winsows或Macintosh OS提供的特殊图 形界面。这些有针对性、非标准的函数让程序员能更有效地使用特定计算机 编写程序。本章只着重讲解所有系统都通用的标准 I/O 函数，用这些函数编 写的可移植程序很容易从一个系统移植到另一个系统。处理文件输入/输出 的程序也可以使用这些函数。\n许多程序都有输入验证，即判断用户的输入是否与程序期望的输入匹 # 配。本章将演示一些与输入验证相关的问题和解决方案。 # 8.1 单字符 I/O ： getchar() 和 putchar() # 第 7 章中提到过，getchar()和 putchar()每次只处理一个字符。你可能认 为这种方法实在太笨拙了，毕竟与我们的阅读方式相差甚远。但是，这种方 法很适合计算机。而且，这是绝大多数文本（即，普通文字）处理程序所用 的核心方法。为了帮助读者回忆这些函数的工作方式，请看程序清单8.1。 该程序获取从键盘输入的字符，并把这些字符发送到屏幕上。程序使用 while 循环，当读到#字符时停止。 程序清单 8.1 echo.c 程序 /* echo.c \u0026ndash; 重复输入 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { char ch; while ((ch = getchar()) != \u0026lsquo;#\u0026rsquo;) putchar(ch); return 0; } 自从ANSI C标准发布以后，C就把stdio.h头文件与使用getchar()和 putchar()相关联，这就是为什么程序中要包含这个头文件的原因（其实， getchar()和 putchar()都不是真正的函数，它们被定义为供预处理器使用的 宏，我们在第 16 章中再详细讨论）。运行该程序后，与用户的交互如下： Hello, there. I would[enter]\nHello, there. I would like a #3 bag of potatoes.[enter] like a 读者可能好奇，为何输入的字符能直接显示在屏幕上？如果用一个特殊 字符（如，#）来结束输入，就无法在文本中使用这个字符，是否有更好的 方法结束输入？要回答这些问题，首先要了解 C程序如何处理键盘输入，尤 其是缓冲和标准输入文件的概念。\n8.2 缓冲区 # 如果在老式系统运行程序清单8.1，你输入文本时可能显示如下： # HHeelllloo,, tthheerree..II wwoouulldd[enter] lliikkee aa # 以上行为是个例外。像这样回显用户输入的字符后立即重复打印该字符 是属于无缓冲（或直接）输入，即正在等待的程序可立即使用输入的字符。 对于该例，大部分系统在用户按下Enter键之前不会重复打印刚输入的字 符，这种输入形式属于缓冲输入。用户输入的字符被收集并储存在一个被称 为缓冲区（buffer）的临时存储区，按下Enter键后，程序才可使用用户输入 的字符。图8.1比较了这两种输入。\n图8.1 缓冲输入和无缓冲输入 为什么要有缓冲区？首先，把若干字符作为一个块进行传输比逐个发送 这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错\n误。当最后按下Enter键时，传输的是正确的输入。 虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例 如，在游戏中，你希望按下一个键就执行相应的指令。因此，缓冲输入和无 缓冲输入都有用武之地。 缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲 区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入 中。缓冲区的大小取决于系统，常见的大小是 512 字节和 4096 字节。行缓 冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所 以在按下Enter键后才刷新缓冲区。 那么，使用缓冲输入还是无缓冲输入？ANSI C和后续的C标准都规定输 入是缓冲的，不过最初K\u0026amp;R把这个决定权交给了编译器的编写者。读者可 以运行echo.c程序观察输出的情况，了解所用的输出类型。 ANSI C决定把缓冲输入作为标准的原因是：一些计算机不允许无缓冲 输入。如果你的计算机允许无缓冲输入，那么你所用的C编译器很可能会提 供一个无缓冲输入的选项。例如，许多IBM PC兼容机的编译器都为支持无 缓冲输入提供一系列特殊的函数，其原型都在conio.h头文件中。这些函数包 括用于回显无缓冲输入的getche()函数和用于无回显无缓冲输入的getch()函数 （回显输入意味着用户输入的字符直接显示在屏幕上，无回显输入意味着击 键后对应的字符不显示）。UNIX系统使用另一种不同的方式控制缓冲。在 UNIX系统中，可以使用ioctl()函数（该函数属于UNIX库，但是不属于C标 准）指定待输入的类型，然后用getchar()执行相应的操作。在ANSI C中，用 setbuf()和setvbuf()函数（详见第 13 章）控制缓冲，但是受限于一些系统的内 部设置，这些函数可能不起作用。总之，ANSI没有提供调用无缓冲输入的 标准方式，这意味着是否能进行无缓冲输入取决于计算机系统。在这里要对 使用无缓冲输入的朋友说声抱歉，本书假设所有的输入都是缓冲输入。\n8.3 结束键盘输入 # 在echo.c程序（程序清单8.1）中，只要输入的字符中不含#，那么程序 在读到#时才会结束。但是， #也是一个普通的字符，有时不可避免要用 到。应该用一个在文本中用不到的字符来标记输入完成，这样的字符不会无 意间出现在输入中，在你不希望结束程序的时候终止程序。C 的确提供了这 样的字符，不过在此之前，先来了解一下C处理文件的方式。\n8.3.1 文件、流和键盘输入 # 文件（file）是存储器中储存信息的区域。通常，文件都保存在某种永 久存储器中（如，硬盘、U盘或DVD等）。毫无疑问，文件对于计算机系统 相当重要。例如，你编写的C程序就保存在文件中，用来编译C程序的程序 也保存在文件中。后者说明，某些程序需要访问指定的文件。当编译储存在 名为 echo.c 文件中的程序时，编译器打开echo.c文件并读取其中的内容。当 编译器处理完后，会关闭该文件。其他程序，例如文字处理器，不仅要打 开、读取和关闭文件，还要把数据写入文件。 C 是一门强大、灵活的语言，有许多用于打开、读取、写入和关闭文件 的库函数。从较低层面上，C可以使用主机操作系统的基本文件工具直接处 理文件，这些直接调用操作系统的函数被称为底层 I/O （low-level I/O）。 由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库， ANSI C也不打算这样做。然而从较高层面上，C还可以通过标准I/O包 （standard I/O package）来处理文件。这涉及创建用于处理文件的标准模型 和一套标准I/O函数。在这一层面上，具体的C实现负责处理不同系统的差 异，以便用户使用统一的界面。 上面讨论的差异指的是什么？例如，不同的系统储存文件的方式不同。 有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处；有些 系统在文件中创建一份文件描述。在处理文件方面，有些系统使用单个换行 符标记行末尾，而其他系统可能使用回车符和换行符的组合来表示行末尾。 有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡\n量。 # 如果使用标准 I/O 包，就不用考虑这些差异。因此，可以用 if (ch == )检查换行符。即使系统实际用的是回车符和换行符的组合来标记行 末尾，I/O函数会在两种表示法之间相互转换。 从概念上看，C程序处理的是流而不是直接处理文件。流（stream）是 一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的 输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相 关联，而且读写都通过流来完成。 第 13 章将更详细地讨论文件。本章着重理解C把输入和输出设备视为存 储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的 文件。stdin流表示键盘输入，stdout流表示屏幕输出。getchar()、putchar()、 printf()和scanf()函数都是标准I/O包的成员，处理这两个流。 以上讨论的内容说明，可以用处理文件的方式来处理键盘输入。例如， 程序读文件时要能检测文件的末尾才知道应在何处停止。因此，C 的输入函 数内置了文件结尾检测器。既然可以把键盘输入视为文件，那么也应该能使 用文件结尾检测器结束键盘输入。下面我们从文件开始，学习如何结束文 件。\n8.3.2 文件结尾 # 计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的 # 一种方法是，在文件末尾放一个特殊的字符标记文件结尾。CP/M、IBM- # DOS和MS-DOS的文本文件曾经用过这种方法。如今，这些操作系统可以使 # 用内嵌的Ctrl+Z字符来标记文件结尾。这曾经是操作系统使用的唯一标记， 不过现在有一些其他的选择，例如记录文件的大小。所以现代的文本文件不 一定有嵌入的Ctrl+Z，但是如果有，该操作系统会将其视为一个文件结尾标 记。图8.2演示了这种方法。\n图8.2 带文件结尾标记的文件 操作系统使用的另一种方法是储存文件大小的信息。如果文件有 3000 字 节，程序在读到 3000 字节时便达到文件的末尾。MS-DOS 及其相关系统使用 这种方法处理二进制文件，因为用这种方法可以在文件中储存所有的字符， 包括Ctrl+Z。新版的DOS也使用这种方法处理文本文件。UNIX使用这种方法 处理所有的文件。 无论操作系统实际使用何种方法检测文件结尾，在C语言中，用 getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF（end of file的缩写）。scanf()函数检测到文件结尾时也返回EOF。通常， EOF定义 在stdio.h文件中： #define EOF (-1) 为什么是-1？因为getchar()函数的返回值通常都介于 0 ～ 127 ，这些值对 应标准字符集。但是，如果系统能识别扩展字符集，该函数的返回值可能在 0 ～ 255 之间。无论哪种情况，-1都不对应任何字符，所以，该值可用于标记 文件结尾。 某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符 所产生的返回值不同。如果包含stdio.h文件，并使用EOF符号，就不必担心 EOF值不同的问题。这里关键要理解EOF是一个值，标志着检测到文件结 尾，并不是在文件中找得到的符号。\n那么，如何在程序中使用EOF？把getchar()的返回值和EOF作比较。如 果两值不同，就说明没有到达文件结尾。也就是说，可以使用下面这样的表 达式： while ((ch = getchar()) != EOF) 如果正在读取的是键盘输入不是文件会怎样？绝大部分系统（不是全 部）都有办法通过键盘模拟文件结尾条件。了解这些以后，读者可以重写程 序清单8.1的程序，如程序清单8.2所示。 程序清单 8.2 echo_eof.c 程序 /* echo_eof.c \u0026ndash; 重复输入，直到文件结尾 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int ch; while ((ch = getchar()) != EOF) putchar(ch); return 0; } 注意下面几点。 不用定义EOF，因为stdio.h中已经定义过了。 不用担心EOF的实际值，因为EOF在stdio.h中用#define预处理指令定 义，可直接使用，不必再编写代码假定EOF为某值。\n变量ch的类型从char变为int，因为char类型的变量只能表示 0 ～ 255 的无 符号整数，但是EOF的值是-1。还好，getchar()函数实际返回值的类型是 int，所以它可以读取EOF字符。如果实现使用有符号的char类型，也可以把 ch声明为char类型，但最好还是用更通用的形式。 由于getchar()函数的返回类型是int，如果把getchar()的返回值赋给char类 型的变量，一些编译器会警告可能丢失数据。 ch是整数不会影响putchar()，该函数仍然会打印等价的字符。 使用该程序进行键盘输入，要设法输入EOF字符。不能只输入字符 EOF，也不能只输入-1（输入-1会传送两个字符：一个连字符和一个数字 1 ）。正确的方法是，必须找出当前系统的要求。例如，在大多数UNIX和 Linux系统中，在一行开始处按下Ctrl+D会传输文件结尾信号。许多微型计算 机系统都把一行开始处的Ctrl+Z识别为文件结尾信号，一些系统把任意位置 的Ctrl+Z解释成文件结尾信号。 下面是在UNIX系统下运行echo_eof.c程序的缓冲示例： She walks in beauty, like the night She walks in beauty, like the night Of cloudless climes and starry skies\u0026hellip; Of cloudless climes and starry skies\u0026hellip; Lord Byron Lord Byron [Ctrl+D] 每次按下Enter键，系统便会处理缓冲区中储存的字符，并在下一行打 印该输入行的副本。这个过程一直持续到以UNIX风格模拟文件结尾（按下\nCtrl+D）。在PC中，要按下Ctrl+Z。 我们暂停一会。既然echo_eof.c程序能把用户输入的内容拷贝到屏幕 上，那么考虑一下该程序还可以做什么。假设以某种方式把一个文件传送给 它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时 停止。或者，假设以某种方式把程序的输出定向到一个文件，然后通过键盘 输入数据，用echo_eof.c 来储存在文件中输入的内容。假设同时使用这两种 方法：把输入从一个文件定向到echo_eof.c中，并把输出发送至另一个文 件，然后便可以使用echo_eof.c来拷贝文件。这个小程序有查看文件内容、 创建一个新文件、拷贝文件的潜力，没想到一个小程序竟然如此多才多艺！ 关键是要控制输入流和输出流，这是我们下一个要讨论的主题。 注意 模拟 EOF 和图形界面 模拟EOF的概念是在使用文本界面的命令行环境中产生的。在这种环境 中，用户通过击键与程序交互，由操作系统生成EOF信号。但是在一些实际 应用中，却不能很好地转换成图形界面（如Windows和Macintosh），这些用 户界面包含更复杂的鼠标移动和按钮点击。程序要模拟EOF的行为依赖于编 译器和项目类型。例如，Ctrl+Z可以结束输入或整个程序，这取决于特定的 设置。\n8.4 重定向和文件 # 输入和输出涉及函数、数据和设备。例如，考虑 echo_eof.c，该程序使 用输入函数 getchar()。输出设备（我们假设）是键盘，输入数据流由字符组 成。假设你希望输入函数和数据类型不变，仅改变程序查找数据的位置。那 么，程序如何知道去哪里查找输入？ 在默认情况下，C程序使用标准I/O包查找标准输入作为输入源。这就是 前面介绍过的stdin流，它是把数据读入计算机的常用方式。它可以是一个过 时的设备，如磁带、穿孔卡或电传打印机，或者（假设）是键盘，甚至是一 些先进技术，如语音输入。然而，现代计算机非常灵活，可以让它到别处查 找输入。尤其是，可以让一个程序从文件中查找输入，而不是从键盘。 程序可以通过两种方式使用文件。第 1 种方法是，显式使用特定的函数 打开文件、关闭文件、读取文件、写入文件，诸如此类。我们在第 13 章中再 详细介绍这种方法。第 2 种方法是，设计能与键盘和屏幕互动的程序，通过 不同的渠道重定向输入至文件和从文件输出。换言之，把stdin流重新赋给文 件。继续使用getchar()函数从输入流中获取数据，但它并不关心从流的什么 位置获取数据。虽然这种重定向的方法在某些方面有些限制，但是用起来比 较简单，而且能让读者熟悉普通的文件处理技术。 重定向的一个主要问题与操作系统有关，与C无关。尽管如此，许多C 环境中（包括UNIX、Linux和Windows命令提示模式）都有重定向特性，而 且一些C实现还在某些缺乏重定向特性的系统中模拟它。在UNIX上运行苹果 OS X，可以用UNIX命令行模式启动Terminal应用程序。接下来我们介绍 UNIX、Linux和Windows的重定向。 8.4.1 UNIX 、 Linux 和 DOS 重定向 UNIX（运行命令行模式时）、Linux（ditto）和Window命令行提示（模 仿旧式DOS命令行环境）都能重定向输入、输出。重定向输入让程序使用文 件而不是键盘来输入，重定向输出让程序输出至文件而不是屏幕。\n1. 重定向输入 # 假设已经编译了echo_eof.c 程序，并把可执行版本放入一个名为 echo_eof（或者在Windows系统中名为echo_eof.exe）的文件中。运行该程 序，输入可执行文件名： echo_eof 该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入。现 在，假设你要用该程序处理名为words的文本文件。文本文件（text file）是 内含文本的文件，其中储存的数据是我们可识别的字符。文件的内容可以是 一篇散文或者C程序。内含机器语言指令的文件（如储存可执行程序的文 件）不是文本文件。由于该程序的操作对象是字符，所以要使用文本文件。 只需用下面的命令代替上面的命令即可： echo_eof \u0026lt; words \u0026lt;符号是UNIX和DOS/Windows的重定向运算符。该运算符使words文件 与stdin流相关联，把文件中的内容导入echo_eof程序。echo_eof程序本身并 不知道（或不关心）输入的内容是来自文件还是键盘，它只知道这是需要导 入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直至读到文 件结尾。因为C把文件和I/O设备放在一个层面，所以文件就是现在的I/O设 备。试试看！ 注意 重定向 对于UNIX、Linux和Windows命令提示，\u0026lt;两侧的空格是可选的。一些系 统，如AmigaDOS（那些喜欢怀旧的人使用的系统），支持重定向，但是在 重定向符号和文件名之间不允许有空格。 下面是一个特殊的words文件的运行示例，$是UNIX和Linux的标准提示 符。在Windows/DOS系统中见到的DOS提示可能是A\u0026gt;或C\u0026gt;。 $ echo_eof \u0026lt; words\nThe world is too much with us: late and soon, Getting and spending, we lay waste our powers: Little we see in Nature that is ours; We have given our hearts away, a sordid boon! $ 2. 重定向输出 现在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件 中。然后，输入以下命令并开始输入： echo_eof\u0026gt;mywords\n符号是第 2 个重定向运算符。它创建了一个名为mywords的新文件，然 后把echo_eof的输出（即，你输入字符的副本）重定向至该文件中。重定向 把stdout从显示设备（即，显示器）赋给mywords文件。如果已经有一个名为 mywords的文件，通常会擦除该文件的内容，然后替换新的内容（但是，许 多操作系统有保护现有文件的选项，使其成为只读文件）。所有出现在屏幕 的字母都是你刚才输入的，其副本储存在文件中。在下一行的开始处按下 Ctrl+D（UNIX）或Ctrl+Z（DOS）即可结束该程序。如果不知道输入什么内 容，可参照下面的示例。这里，我们使用UNIX提示符$。记住在每行的末尾 单击Enter键，这样才能把缓冲区的内容发送给程序。 $ echo_eof \u0026gt; mywords You should have no problem recalling which redirection operator does what. Just remember that each operator points in the direction the information flows. Think of it as\na funnel. [Ctrl+D] $ 按下Ctrl+D或Ctrl+Z后，程序会结束，你的系统会提示返回。程序是否 起作用了？UNIX的ls命令或Windows命令行提示模式的dir命令可以列出文件 名，会显示mywords文件已存在。可以使用UNIX或Linux的cat或DOS的type命 令检查文件中的内容，或者再次使用echo_eof，这次把文件重定向到程序： $ echo_eof \u0026lt; mywords You should have no problem recalling which redirection operator does what. Just remember that each operator points in the direction the information flows. Think of it as a funnel. $\n3. 组合重定向 现在，假设你希望制作一份mywords文件的副本，并命名为savewords。 只需输入以下命令即可： echo_eof \u0026lt; mywords \u0026gt; savewords 下面的命令也起作用，因为命令与重定向运算符的顺序无关： echo_eof \u0026gt; savewords \u0026lt; mywords 注意：在一条命令中，输入文件名和输出文件名不能相同。\necho_eof \u0026lt; mywords \u0026gt; mywords\u0026hellip;.\u0026lt;\u0026ndash;错误 原因是\u0026gt; mywords在输入之前已导致原mywords的长度被截断为 0 。 总之，在UNIX、Linux或Windows/DOS系统中使用两个重定向运算符 （\u0026lt;和\u0026gt;）时，要遵循以下原则。 重定向运算符连接一个可执行程序（包括标准操作系统命令）和一个数 据文件，不能用于连接一个数据文件和另一个数据文件，也不能用于连接一 个程序和另一个程序。 使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个 文件。 通常，文件名和运算符之间的空格不是必须的，除非是偶尔在UNIX shell、Linux shell或Windows命令行提示模式中使用的有特殊含义的字符。例 如，我们用过的echo_eof\u0026lt;words。 以上介绍的都是正确的例子，下面来看一下错误的例子，addup和count 是两个可执行程序，fish和beets是两个文本文件： fish \u0026gt; beets ←违反第 1 条规则 addup \u0026lt; count ←违反第 1 条规则 addup \u0026lt; fish \u0026lt; beets ←违反第 2 条规则 count \u0026gt; beets fish ←违反第 2 条规则 UNIX、Linux或Windows/DOS 还有\u0026raquo;运算符，该运算符可以把数据添加 到现有文件的末尾，而 | 运算符能把一个文件的输出连接到另一个文件的输 入。欲了解所有相关运算符的内容，请参阅 UNIX 的相关书籍，如UNIX Primer Plus，Third Edition（Wilson、Pierce和Wessler合著）。\n4. 注释\n重定位让你能使用键盘输入程序文件。要完成这一任务，程序要测试文 # 件的末尾。例如，第 7 章演示的统计单词程序（程序清单7.7），计算单词 # 个数直至遇到第 1 个|字符。把ch的char类型改成int类型，把循环测试中的|替 换成EOF，便可用该程序来计算文本文件中的单词量。 重定向是一个命令行概念，因为我们要在命令行输入特殊的符号发出指 令。如果不使用命令行环境，也可以使用重定向。首先，一些集成开发环境 提供了菜单选项，让用户指定重定向。其次，对于 Windows系统，可以打开 命令提示窗口，并在命令行运行可执行文件。Microsoft Visual Studio的默认 设置是把可执行文件放在项目文件夹的子文件夹，称为Debug。文件名和项 目名的基本名相同，文件名的扩展名为.exe。默认情况下，Xcode在给项目 命名后才能命名可执行文件，并将其放在Debug文件夹中。在UNIX系统中， 可以通过Terminal工具运行可执行文件。从使用上看，Terminal比命令行编译 器（GCC或Clang）简单。 如果用不了重定向，可以用程序直接打开文件。程序清单8.3演示了一 个注释较少的示例。我们学到第 13 章时再详细讲解。待读取的文件应该与可 执行文件位于同一目录。 程序清单 8.3 file_eof.c 程序 // file_eof.c \u0026ndash;打开一个文件并显示该文件 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 为了使用exit() int main() { int ch; FILE * fp;\nchar fname[50]; // 储存文件名 printf(\u0026ldquo;Enter the name of the file: \u0026ldquo;); scanf(\u0026quot;%s\u0026rdquo;, fname); fp = fopen(fname, \u0026ldquo;r\u0026rdquo;); // 打开待读取文件 if (fp == NULL) // 如果失败 { printf(\u0026ldquo;Failed to open file. Bye\\n\u0026rdquo;); exit(1); // 退出程序 } // getc(fp)从打开的文件中获取一个字符 while ((ch = getc(fp)) != EOF) putchar(ch); fclose(fp); // 关闭文件 return 0; } 小结：如何重定向输入和输出 绝大部分C系统都可以使用重定向，可以通过操作系统重定向所有程 序，或只在C编译器允许的情况下重定向C程序。假设prog是可执行程序 名，file1和file2是文件名。 把输出重定向至文件： \u0026gt;\nprog \u0026gt;file1 把输入重定向至文件： \u0026lt; prog \u0026lt;file2 组合重定向： prog file1 prog \u0026gt;file1 \u0026lt;file2 这两种形式都是把file2作为输入、file1作为输出。 留白： 一些系统要求重定向运算符左侧有一个空格，右侧没有空格。而其他系 统（如，UNIX）允许在重定位运算符两侧有空格或没有空格。\n8.5 创建更友好的用户界面 # 大部分人偶尔会写一些中看不中用的程序。还好，C提供了大量工具让 # 输入更顺畅，处理过程更顺利。不过，学习这些工具会导致新的问题。本节 # 的目标是，指导读者解决这些问题并创建更友好的用户界面，让交互数据输 # 入更方便，减少错误输入的影响。 # 8.5.1 使用缓冲输入 # 缓冲输入用起来比较方便，因为在把输入发送给程序之前，用户可以编 # 辑输入。但是，在使用输入的字符时，它也会给程序员带来麻烦。前面示例 # 中看到的问题是，缓冲输入要求用户按下Enter键发送输入。这一动作也传 送了换行符，程序必须妥善处理这个麻烦的换行符。我们以一个猜谜程序为 例。用户选择一个数字，程序猜用户选中的数字是多少。该程序使用的方法 单调乏味，先不要在意算法，我们关注的重点在输入和输出。查看程序清单 8.4，这是猜谜程序的最初版本，后面我们会改进。 程序清单 8.4 guess.c 程序 /* guess.c \u0026ndash; 一个拖沓且错误的猜数字程序 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int guess = 1; printf(\u0026ldquo;Pick an integer from 1　to 100. I will try to guess \u0026ldquo;); printf(\u0026ldquo;it.\\nRespond with a y if my guess is right and with\u0026rdquo;);\nprintf(\u0026quot;\\nan n if it is wrong.\\n\u0026rdquo;); printf(\u0026ldquo;Uh\u0026hellip;is your number %d?\\n\u0026rdquo;, guess); while (getchar() != \u0026lsquo;y\u0026rsquo;) /* 获取响应，与 y 做对比 */ printf(\u0026ldquo;Well, then, is it %d?\\n\u0026rdquo;, ++guess); printf(\u0026ldquo;I knew I could do it!\\n\u0026rdquo;); return 0; } 下面是程序的运行示例： Pick an integer from 1　to 100. I will try to guess it. Respond with a y if my guess is right and with an n if it is wrong. Uh\u0026hellip;is your number 1? n Well, then, is it 2? Well, then, is it 3? n Well, then, is it 4? Well, then, is it 5? y\nI knew I could do it! 撇开这个程序糟糕的算法不谈，我们先选择一个数字。注意，每次输入 n 时，程序打印了两条消息。这是由于程序读取n作为用户否定了数字 1 ，然 后还读取了一个换行符作为用户否定了数字 2 。 一种解决方案是，使用while循环丢弃输入行最后剩余的内容，包括换 行符。这种方法的优点是，能把no和no way这样的响应视为简单的n。程序 清单8.4的版本会把no当作两个响应。下面用循环修正 char response;这个问题： while (getchar() != \u0026lsquo;y\u0026rsquo;) /* 获取响应，与 y 做对比*/ { printf(\u0026ldquo;Well, then, is it %d?\\n\u0026rdquo;, ++guess); while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; /* 跳过剩余的输入行 */ } 使用以上循环后，该程序的输出示例如下： Pick an integer from 1　to 100. I will try to guess it. Respond with a y if my guess is right and with an n if it is wrong. Uh\u0026hellip;is your number 1? n\nWell, then, is it 2? no Well, then, is it 3? no sir Well, then, is it 4? forget it Well, then, is it 5? y I knew I could do it! 这的确是解决了换行符的问题。但是，该程序还是会把f被视为n。我们 用if语句筛选其他响应。首先，添加一个char类型的变量储存响应： 修改后的循环如下： while ((response = getchar()) != \u0026lsquo;y\u0026rsquo;) /* 获取响应 */ { if (response == \u0026rsquo;n\u0026rsquo;) printf(\u0026ldquo;Well, then, is it %d?\\n\u0026rdquo;, ++guess); else printf(\u0026ldquo;Sorry, I understand only y or n.\\n\u0026rdquo;); while (getchar() != \u0026lsquo;\\n\u0026rsquo;)\ncontinue; /* 跳过剩余的输入行 */ } 现在，程序的运行示例如下： Pick an integer from 1　to 100. I will try to guess it. Respond with a y if my guess is right and with an n if it is wrong. Uh\u0026hellip;is your number 1? n Well, then, is it 2? no Well, then, is it 3? no sir Well, then, is it 4? forget it Sorry, I understand only y or n. n Well, then, is it 5? y I knew I could do it!\n在编写交互式程序时，应该事先预料到用户可能会输入错误，然后设计 # 程序处理用户的错误输入。在用户出错时通知用户再次输入。 # 当然，无论你的提示写得多么清楚，总会有人误解，然后抱怨这个程序 # 设计得多么糟糕。 # 8.5.2 混合数值和字符输入 # 假设程序要求用 getchar()处理字符输入，用 scanf()处理数值输入，这两 个函数都能很好地完成任务，但是不能把它们混用。因为 getchar()读取每个 字符，包括空格、制表符和换行符；而 scanf()在读取数字时则会跳过空格、 制表符和换行符。 我们通过程序清单8.5来解释这种情况导致的问题。该程序读入一个字 符和两个数字，然后根据输入的两个数字指定的行数和列数打印该字符。 程序清单 8.5 showchar1.c 程序 /* showchar1.c \u0026ndash; 有较大 I/O 问题的程序 / #include \u0026lt;stdio.h\u0026gt; void display(char cr, int lines, int width); int main(void) { int ch; / 待打印字符　/ int rows, cols; / 行数和列数 */ printf(\u0026ldquo;Enter a character and two integers:\\n\u0026rdquo;); while ((ch = getchar()) != \u0026lsquo;\\n\u0026rsquo;)\n{ # scanf(\u0026quot;%d %d\u0026rdquo;, \u0026amp;rows, \u0026amp;cols); display(ch, rows, cols); printf(\u0026ldquo;Enter another character and two integers;\\n\u0026rdquo;); printf(\u0026ldquo;Enter a newline to quit.\\n\u0026rdquo;); } printf(\u0026ldquo;Bye.\\n\u0026rdquo;); return 0; } void display(char cr, int lines, int width) { int row, col; for (row = 1; row \u0026lt;= lines; row++) { for (col = 1; col \u0026lt;= width; col++) putchar(cr); putchar(\u0026rsquo;\\n\u0026rsquo;);/* 结束一行并开始新的一行 */ } }\n注意，该程序以 int 类型读取字符（这样做可以检测 EOF），但是却以 char 类型把字符传递给display()函数。因为char比int小，一些编译器会给出 类型转换的警告。可以忽略这些警告，或者用下面的强制类型转换消除警 告： display(char(ch), rows, cols); 在该程序中，main()负责获取数据，display()函数负责打印数据。下面 是该程序的一个运行示例，看看有什么问题： Enter a character and two integers: c 2 3 ccc ccc Enter another character and two integers; Enter a newline to quit. Bye. 该程序开始时运行良好。你输入c 2 3，程序打印c字符 2 行 3 列。然后， 程序提示输入第 2 组数据，还没等你输入数据程序就退出了！这是什么情 况？又是换行符在捣乱，这次是输入行中紧跟在 3 后面的换行符。scanf()函 数把这个换行符留在输入队列中。和 scanf()不同，getchar()不会跳过换行 符，所以在进入下一轮迭代时，你还没来得及输入字符，它就读取了换行 符，然后将其赋给ch。而ch是换行符正式终止循环的条件。 要解决这个问题，程序要跳过一轮输入结束与下一轮输入开始之间的所 有换行符或空格。另外，如果该程序不在getchar()测试时，而在scanf()阶段 终止程序会更好。修改后的版本如程序清单8.6所示。\n程序清单 8.6 showchar2.c 程序 /* showchar2.c \u0026ndash; 按指定的行列打印字符 / #include \u0026lt;stdio.h\u0026gt; void display(char cr, int lines, int width); int main(void) { int ch; / 待打印字符*/ int rows, cols; /* 行数和列数 */ printf(\u0026ldquo;Enter a character and two integers:\\n\u0026rdquo;); while ((ch = getchar()) != \u0026lsquo;\\n\u0026rsquo;) { if (scanf(\u0026quot;%d %d\u0026rdquo;, \u0026amp;rows, \u0026amp;cols) != 2) break; display(ch, rows, cols); while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; printf(\u0026ldquo;Enter another character and two integers;\\n\u0026rdquo;); printf(\u0026ldquo;Enter a newline to quit.\\n\u0026rdquo;); }\nprintf(\u0026ldquo;Bye.\\n\u0026rdquo;); return 0; } void display(char cr, int lines, int width) { int row, col; for (row = 1; row \u0026lt;= lines; row++) { for (col = 1; col \u0026lt;= width; col++) putchar(cr); putchar(\u0026rsquo;\\n\u0026rsquo;); /* 结束一行并开始新的一行 */ } } while循环实现了丢弃scanf()输入后面所有字符（包括换行符）的功能， 为循环的下一轮读取做好了准备。该程序的运行示例如下： Enter a character and two integers: c 1 2 cc Enter another character and two integers;\nEnter a newline to quit. ! 3 6 !!!!!! !!!!!! !!!!!! Enter another character and two integers; Enter a newline to quit. Bye. 在if语句中使用一个break语句，可以在scanf()的返回值不等于 2 时终止 程序，即如果一个或两个输入值不是整数或者遇到文件结尾就终止程序。\n8.6 输入验证 # 在实际应用中，用户不一定会按照程序的指令行事。用户的输入和程序 # 期望的输入不匹配时常发生，这会导致程序运行失败。作为程序员，除了完 # 成编程的本职工作，还要事先预料一些可能的输入错误，这样才能编写出能 # 检测并处理这些问题的程序。 # 例如，假设你编写了一个处理非负数整数的循环，但是用户很可能输入 # 一个负数。你可以使用关系表达式来排除这种情况： # long n; scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;n); // 获取第 1 个值 while (n \u0026gt;= 0) // 检测不在范围内的值 { // 处理n scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;n); // 获取下一个值 } 另一类潜在的陷阱是，用户可能输入错误类型的值，如字符 q。排除这 种情况的一种方法是，检查scanf()的返回值。回忆一下，scanf()返回成功读 取项的个数。因此，下面的表达式当且仅当用户输入一个整数时才为真： scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;n) == 1 结合上面的while循环，可改进为： long n; while (scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;n) == 1　\u0026amp;\u0026amp; n \u0026gt;= 0)\n{ # //处理n } while循环条件可以描述为“当输入是一个整数且该整数为正时”。 对于最后的例子，当用户输入错误类型的值时，程序结束。然而，也可 以让程序友好些，提示用户再次输入正确类型的值。在这种情况下，要处理 有问题的输入。如果scanf()没有成功读取，就会将其留在输入队列中。这里 要明确，输入实际上是字符流。可以使用getchar()函数逐字符地读取输入， 甚至可以把这些想法都结合在一个函数中，如下所示： long get_long(void) { long input; char ch; while (scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;input) != 1) { while ((ch = getchar()) != \u0026lsquo;\\n\u0026rsquo;) putchar(ch); // 处理错误的输入 printf(\u0026rdquo; is not an integer.\\nPlease enter an \u0026ldquo;); printf(\u0026ldquo;integer value, such as 25, -178, or 3: \u0026ldquo;); }\nreturn input; } 该函数要把一个int类型的值读入变量input中。如果读取失败，函数则进 入外层while循环体。然后内层循环逐字符地读取错误的输入。注意，该函 数丢弃该输入行的所有剩余内容。还有一个方法是，只丢弃下一个字符或单 词，然后该函数提示用户再次输入。外层循环重复运行，直到用户成功输入 整数，此时scanf()的返回值为 1 。 在用户输入整数后，程序可以检查该值是否有效。考虑一个例子，要求 用户输入一个上限和一个下限来定义值的范围。在该例中，你可能希望程序 检查第 1 个值是否大于第 2 个值（通常假设第 1 个值是较小的那个值），除此 之外还要检查这些值是否在允许的范围内。例如，当前的档案查找一般不会 接受 1958 年以前和 2014 年以后的查询任务。这个限制可以在一个函数中实 现。 假设程序中包含了stdbool.h 头文件。如果当前系统不允许使用_Bool， 把bool替换成int，把true 替换成 1 ，把 false 替换成 0 即可。注意，如果输入 无效，该函数返回 true，所以函数名为bad_limits()： bool bad_limits(long begin, long end,long low, long high) { bool not_good = false; if (begin \u0026gt; end) { printf(\u0026quot;%ld isn\u0026rsquo;t smaller than %ld.\\n\u0026rdquo;, begin, end); not_good = true;\n} # if (begin \u0026lt; low || end \u0026lt; low) { printf(\u0026ldquo;Values must be %ld or greater.\\n\u0026rdquo;, low); not_good = true; } if (begin \u0026gt; high || end \u0026gt; high) { printf(\u0026ldquo;Values must be %ld or less.\\n\u0026rdquo;, high); not_good = true; } return not_good; } 程序清单8.7使用了上面的两个函数为一个进行算术运算的函数提供整 数，该函数计算特定范围内所有整数的平方和。程序限制了范围的上限是 10000000 ，下限是-10000000。 程序清单 8.7 checking.c 程序 // checking.c \u0026ndash; 输入验证 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt;\n// 验证输入是一个整数 # long get_long(void); // 验证范围的上下限是否有效 bool bad_limits(long begin, long end, long low, long high); // 计算a～b之间的整数平方和 double sum_squares(long a, long b); int main(void) { const long MIN = -10000000L; // 范围的下限 const long MAX = +10000000L; // 范围的上限 long start; // 用户指定的范围最小值 long stop; // 用户指定的范围最大值 double answer; printf(\u0026ldquo;This program computes the sum of the squares of \u0026quot; \u0026ldquo;integers in a range.\\nThe lower bound should not \u0026quot; \u0026ldquo;be less than -10000000 and\\nthe upper bound \u0026quot; \u0026ldquo;should not be more than +10000000.\\nEnter the \u0026quot; \u0026ldquo;limits (enter 0　for both limits to quit):\\n\u0026rdquo;\n\u0026ldquo;lower limit: \u0026ldquo;); start = get_long(); printf(\u0026ldquo;upper limit: \u0026ldquo;); stop = get_long(); while (start != 0　|| stop != 0) { if (bad_limits(start, stop, MIN, MAX)) printf(\u0026ldquo;Please try again.\\n\u0026rdquo;); else { answer = sum_squares(start, stop); printf(\u0026ldquo;The sum of the squares of the integers \u0026ldquo;); printf(\u0026ldquo;from %ld to %ld is %g\\n\u0026rdquo;, start, stop, answer); } printf(\u0026ldquo;Enter the limits (enter 0　for both \u0026quot; \u0026ldquo;limits to quit):\\n\u0026rdquo;); printf(\u0026ldquo;lower limit: \u0026ldquo;); start = get_long();\nprintf(\u0026ldquo;upper limit: \u0026ldquo;); stop = get_long(); } printf(\u0026ldquo;Done.\\n\u0026rdquo;); return 0; } long get_long(void) { long input; char ch; while (scanf(\u0026quot;%ld\u0026rdquo;, \u0026amp;input) != 1) { while ((ch = getchar()) != \u0026lsquo;\\n\u0026rsquo;) putchar(ch); // 处理错误输入 printf(\u0026rdquo; is not an integer.\\nPlease enter an \u0026ldquo;); printf(\u0026ldquo;integer value, such as 25, -178, or 3: \u0026ldquo;); } return input; }\ndouble sum_squares(long a, long b) { double total = 0; long i; for (i = a; i \u0026lt;= b; i++) total += (double) i * (double) i; return total; } bool bad_limits(long begin, long end, long low, long high) { bool not_good = false; if (begin \u0026gt; end) { printf(\u0026quot;%ld isn\u0026rsquo;t smaller than %ld.\\n\u0026rdquo;, begin, end); not_good = true; } if (begin \u0026lt; low || end \u0026lt; low) {\nprintf(\u0026ldquo;Values must be %ld or greater.\\n\u0026rdquo;, low); not_good = true; } if (begin \u0026gt; high || end \u0026gt; high) { printf(\u0026ldquo;Values must be %ld or less.\\n\u0026rdquo;, high); not_good = true; } return not_good; } 下面是该程序的输出示例： This program computes the sum of the squares of integers in a range. The lower bound should not be less than -10000000 and the upper bound should not be more than +10000000. Enter the limits (enter 0　for both limits to quit): lower limit: low low is not an integer. Please enter an integer value, such as 25, -178, or 3: 3\nupper limit: a big number a big number is not an integer. Please enter an integer value, such as 25, -178, or 3: 12 The sum of the squares of the integers from 3　to 12　is 645 Enter the limits (enter 0　for both limits to quit): lower limit: 80 upper limit: 10 80　isn\u0026rsquo;t smaller than 10. Please try again. Enter the limits (enter 0　for both limits to quit): lower limit: 0 upper limit: 0 Done.\n8.6.1 分析程序 # 虽然checking.c程序的核心计算部分（sum_squares()函数）很短，但是输 入验证部分比以往程序示例要复杂。接下来分析其中的一些要素，先着重讨 论程序的整体结构。 程序遵循模块化的编程思想，使用独立函数（模块）来验证输入和管理 显示。程序越大，使用模块化编程就越重要。\nmain()函数管理程序流，为其他函数委派任务。它使用 get_long()获取 值、while 循环处理值、badlimits()函数检查值是否有效、sum_squres()函数 处理实际的计算： start = get_long(); printf(\u0026ldquo;upper limit: \u0026ldquo;); stop = get_long(); while (start != 0　|| stop != 0) { if (bad_limits(start, stop, MIN, MAX)) printf(\u0026ldquo;Please try again.\\n\u0026rdquo;); else { answer = sum_squares(start, stop); printf(\u0026ldquo;The sum of the squares of the integers \u0026ldquo;); printf(\u0026ldquo;from %ld to %ld is %g\\n\u0026rdquo;, start, stop, answer); } printf(\u0026ldquo;Enter the limits (enter 0　for both \u0026quot; \u0026ldquo;limits to quit):\\n\u0026rdquo;); printf(\u0026ldquo;lower limit: \u0026ldquo;); start = get_long();\nprintf(\u0026#34;upper limit: \u0026#34;); stop = get_long(); } 8.6.2 输入流和数字 # 在编写处理错误输入的代码时（如程序清单8.7），应该很清楚C是如何 # 处理输入的。考虑下面的输入： # is 28 12.4 在我们眼中，这就像是一个由字符、整数和浮点数组成的字符串。但是 对 C程序而言，这是一个字节流。第 1 个字节是字母i的字符编码，第 2 个字 节是字母s的字符编码，第 3 个字节是空格字符的字符编码，第 4 个字节是数 字 2 的字符编码，等等。所以，如果get_long()函数处理这一行输入，第 1 个 字符是非数字，那么整行输入都会被丢弃，包括其中的数字，因为这些数字 只是该输入行中的其他字符： while ((ch = getchar()) != \u0026lsquo;\\n\u0026rsquo;) putchar(ch); // 处理错误的输入 虽然输入流由字符组成，但是也可以设置scanf()函数把它们转换成数 值。例如，考虑下面的输入： 42 如果在scanf()函数中使用%c转换说明，它只会读取字符 4 并将其储存在 char类型的变量中。如果使用%s转换说明，它会读取字符 4 和字符 2 这两个字 符，并将其储存在字符数组中。如果使用%d转换说明，scanf()同样会读取 两个字符，但是随后会计算出它们对应的整数值：4×10+2，即 42 ，然后将 表示该整数的二进制数储存在 int 类型的变量中。如果使用%f 转换说明，\nscanf()也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示 法表示该值，并将结果储存在float类型的变量中。 简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮 点数值。使用转换说明（如%d或%f）限制了可接受输入的字符类型，而 getchar()和使用%c的scanf()接受所有的字符。\n8.7 菜单浏览 # 许多计算机程序都把菜单作为用户界面的一部分。菜单给用户提供方便 # 的同时，却给程序员带来了一些麻烦。我们看看其中涉及了哪些问题。 # 菜单给用户提供了一份响应程序的选项。假设有下面一个例子： # Enter the letter of your choice: a. advice b. bell c. count q. quit 理想状态是，用户输入程序所列选项之一，然后程序根据用户所选项完 成任务。作为一名程序员，自然希望这一过程能顺利进行。因此，第 1 个目 标是：当用户遵循指令时程序顺利运行；第 2 个目标是：当用户没有遵循指 令时，程序也能顺利运行。显而易见，要实现第 2 个目标难度较大，因为很 难预料用户在使用程序时的所有错误情况。 现在的应用程序通常使用图形界面，可以点击按钮、查看对话框、触摸 图标，而不是我们示例中的命令行模式。但是，两者的处理过程大致相同： 给用户提供选项、检查并执行用户的响应、保护程序不受误操作的影响。除 了界面不同，它们底层的程序结构也几乎相同。但是，使用图形界面更容易 通过限制选项控制输入。\n8.7.1 任务 # 我们来更具体地分析一个菜单程序需要执行哪些任务。它要获取用户的 # 响应，根据响应选择要执行的动作。另外，程序应该提供返回菜单的选项。 # C 的 switch 语句是根据选项决定行为的好工具，用户的每个选择都可以对应 一个特定的case标签。使用while语句可以实现重复访问菜单的功能。因此， 我们写出以下伪代码： 获取选项\n当选项不是\u0026#39;q\u0026#39;时 转至相应的选项并执行 获取下一个选项 8.7.2 使执行更顺利 # 当你决定实现这个程序时，就要开始考虑如何让程序顺利运行（顺利运 # 行指的是，处理正确输入和错误输入时都能顺利运行）。例如，你能做的是 # 让“获取选项”部分的代码筛选掉不合适的响应，只把正确的响应传入 # switch。这表明需要为输入过程提供一个只返回正确响应的函数。结合while 循环和switch语句，其程序结构如下： #include \u0026lt;stdio.h\u0026gt; char get_choice(void); void count(void); int main(void) { int choice; while ((choice = get_choice()) != \u0026lsquo;q\u0026rsquo;) { switch (choice) { case \u0026lsquo;a\u0026rsquo;: printf(\u0026ldquo;Buy low, sell high.\\n\u0026rdquo;);\nbreak; case \u0026lsquo;b\u0026rsquo;: putchar(\u0026rsquo;\\a\u0026rsquo;); /* ANSI */ break; case \u0026lsquo;c\u0026rsquo;: count(); break; default: printf(\u0026ldquo;Program error!\\n\u0026rdquo;); break; } } return 0; } 定义get_choice()函数只能返回\u0026rsquo;a\u0026rsquo;、\u0026lsquo;b\u0026rsquo;、\u0026lsquo;c\u0026rsquo;和\u0026rsquo;q\u0026rsquo;。get_choice()的用法和 getchar()相同，两个函数都是获取一个值，并与终止值（该例中是\u0026rsquo;q\u0026rsquo;）作比 较。我们尽量简化实际的菜单选项，以便读者把注意力集中在程序结构上。 稍后再讨论 count()函数。default 语句可以方便调试。如果get_choice()函数没 能把返回值限制为菜单指定的几个选项值，default语句有助于发现问题所 在。 get_choice()函数 下面的伪代码是设计这个函数的一种方案： 显示选项 获取用户的响应\n当响应不合适时 # 提示用户再次输入 # 获取用户的响应 # 下面是一个简单而笨拙的实现： # char get_choice(void) { int ch; printf(\u0026ldquo;Enter the letter of your choice:\\n\u0026rdquo;); printf(\u0026ldquo;a. advice b. bell\\n\u0026rdquo;); printf(\u0026ldquo;c. count q. quit\\n\u0026rdquo;); ch = getchar(); while ((ch \u0026lt; \u0026lsquo;a\u0026rsquo; || ch \u0026gt; \u0026lsquo;c\u0026rsquo;) \u0026amp;\u0026amp; ch != \u0026lsquo;q\u0026rsquo;) { printf(\u0026ldquo;Please respond with a, b, c, or q.\\n\u0026rdquo;); ch = getchar(); } return ch; } 缓冲输入依旧带来些麻烦，程序把用户每次按下 Return 键产生的换行\n符视为错误响应。为了让程序的界面更流畅，该函数应该跳过这些换行符。 # 这类问题有多种解决方案。一种是用名为get_first()的新函数替换 getchar()函数，读取一行的第 1 个字符并丢弃剩余的字符。这种方法的优点 是，把类似act这样的输入视为简单的a，而不是继续把act中的c作为选项c的 一个有效的响应。我们重写输入函数如下： char get_choice(void) { int ch; printf(\u0026ldquo;Enter the letter of your choice:\\n\u0026rdquo;); printf(\u0026ldquo;a. advice b. bell\\n\u0026rdquo;); printf(\u0026ldquo;c. count q. quit\\n\u0026rdquo;); ch = get_first(); while ((ch \u0026lt; \u0026lsquo;a\u0026rsquo; || ch \u0026gt; \u0026lsquo;c\u0026rsquo;) \u0026amp;\u0026amp; ch != \u0026lsquo;q\u0026rsquo;) { printf(\u0026ldquo;Please respond with a, b, c, or q.\\n\u0026rdquo;); ch = getfirst(); } return ch; } char get_first(void)\n{ # int ch; ch = getchar(); /* 读取下一个字符 */ while (getchar() != \u0026#39;\\n\u0026#39;) continue; /* 跳过该行剩下的内容 */ return ch; } 8.7.3 混合字符和数值输入 # 前面分析过混合字符和数值输入会产生一些问题，创建菜单也有这样的 # 问题。例如，假设count()函数（选择c）的代码如下： void count(void) { int n, i; printf(\u0026ldquo;Count how far? Enter an integer:\\n\u0026rdquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;n); for (i = 1; i \u0026lt;= n; i++) printf(\u0026quot;%d\\n\u0026rdquo;, i); } 如果输入 3 作为响应，scanf()会读取 3 并把换行符留在输入队列中。下次 调用 get_choice()将导致get_first()返回这个换行符，从而导致我们不希望出\n现的行为。 # 重写 get_first()，使其返回下一个非空白字符而不仅仅是下一个字符， 即可修复这个问题。我们把这个任务留给读者作为练习。另一种方法是，在 count()函数中清理换行符，如下所示： void count(void) { int n, i; printf(\u0026ldquo;Count how far? Enter an integer:\\n\u0026rdquo;); n = get_int(); for (i = 1; i \u0026lt;= n; i++) printf(\u0026quot;%d\\n\u0026rdquo;, i); while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } 该函数借鉴了程序清单8.7中的get_long()函数，将其改为get_int()获取int 类型的数据而不是long类型的数据。回忆一下，原来的get_long()函数如何检 查有效输入和让用户重新输入。程序清单8.8演示了菜单程序的最终版本。 程序清单 8.8 menuette.c 程序 /* menuette.c \u0026ndash; 菜单程序 */ #include \u0026lt;stdio.h\u0026gt;\nchar get_choice(void); char get_first(void); int get_int(void); void count(void); int main(void) { int choice; void count(void); while ((choice = get_choice()) != \u0026lsquo;q\u0026rsquo;) { switch (choice) { case \u0026lsquo;a\u0026rsquo;: printf(\u0026ldquo;Buy low, sell high.\\n\u0026rdquo;); break; case \u0026lsquo;b\u0026rsquo;: putchar(\u0026rsquo;\\a\u0026rsquo;); /* ANSI */ break; case \u0026lsquo;c\u0026rsquo;: count(); break; default: printf(\u0026ldquo;Program error!\\n\u0026rdquo;);\nbreak; } } printf(\u0026ldquo;Bye.\\n\u0026rdquo;); return 0; } void count(void) { int n, i; printf(\u0026ldquo;Count how far? Enter an integer:\\n\u0026rdquo;); n = get_int(); for (i = 1; i \u0026lt;= n; i++) printf(\u0026quot;%d\\n\u0026rdquo;, i); while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } char get_choice(void) { int ch;\nprintf(\u0026ldquo;Enter the letter of your choice:\\n\u0026rdquo;); printf(\u0026ldquo;a. advice b. bell\\n\u0026rdquo;); printf(\u0026ldquo;c. count q. quit\\n\u0026rdquo;); ch = get_first(); while ((ch \u0026lt; \u0026lsquo;a\u0026rsquo; || ch \u0026gt; \u0026lsquo;c\u0026rsquo;) \u0026amp;\u0026amp; ch != \u0026lsquo;q\u0026rsquo;) { printf(\u0026ldquo;Please respond with a, b, c, or q.\\n\u0026rdquo;); ch = get_first(); } return ch; } char get_first(void) { int ch; ch = getchar(); while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; return ch; }\nint get_int(void) { int input; char ch; while (scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;input) != 1) { while ((ch = getchar()) != \u0026lsquo;\\n\u0026rsquo;) putchar(ch); // 处理错误输出 printf(\u0026rdquo; is not an integer.\\nPlease enter an \u0026ldquo;); printf(\u0026ldquo;integer value, such as 25, -178, or 3: \u0026ldquo;); } return input; } 下面是该程序的一个运行示例： Enter the letter of your choice: a. advice b. bell c. count q. quit a Buy low, sell high.\nEnter the letter of your choice: a. advice b. bell c. count q. quit count Count how far? Enter an integer: two two is not an integer. Please enter an integer value, such as 25, -178, or 3: 5 1 2 3 4 5 Enter the letter of your choice: a. advice b. bell c. count q. quit d Please respond with a, b, c, or q. q\n要写出一个自己十分满意的菜单界面并不容易。但是，在开发了一种可 # 行的方案后，可以在其他情况下复用这个菜单界面。 # 学完以上程序示例后，还要注意在处理较复杂的任务时，如何让函数把 # 任务委派给另一个函数。这样让程序更模块化。 # 8.8 关键概念 # C程序把输入作为传入的字节流。getchar()函数把每个字符解释成一个 字符编码。scanf()函数以同样的方式看待输入，但是根据转换说明，它可以 把字符输入转换成数值。许多操作系统都提供重定向，允许用文件代替键盘 输入，用文件代替显示器输出。 程序通常接受特殊形式的输入。可以在设计程序时考虑用户在输入时可 能犯的错误，在输入验证部分处理这些错误情况，让程序更强健更友好。 对于一个小型程序，输入验证可能是代码中最复杂的部分。处理这类问 题有多种方案。例如，如果用户输入错误类型的信息，可以终止程序，也可 以给用户提供有限次或无限次机会重新输入。\n8.9 本章小结 # 许多程序使用 getchar()逐字符读取输入。通常，系统使用行缓冲输入， 即当用户按下 Enter 键后输入才被传送给程序。按下Enter键也传送了一个换 行符，编程时要注意处理这个换行符。ANSI C把缓冲输入作为标准。 通过标准I/O包中的一系列函数，以统一的方式处理不同系统中的不同 文件形式，是C语言的特性之一。getchar()和 scanf()函数也属于这一系列。 当检测到文件结尾时，这两个函数都返回 EOF（被定义在stdio.h头文件 中）。在不同系统中模拟文件结尾条件的方式稍有不同。在UNIX系统中， 在一行开始处按下Ctrl+D可以模拟文件结尾条件；而在DOS系统中则使用 Ctrl+Z。 许多操作系统（包括UNIX和DOS）都有重定向的特性，因此可以用文 件代替键盘和屏幕进行输入和输出。读到EOF即停止读取的程序可用于键盘 输入和模拟文件结尾信号，或者用于重定向文件。 混合使用 getchar()和 scanf()时，如果在调用 getchar()之前，scanf()在输 入行留下一个换行符，会导致一些问题。不过，意识到这个问题就可以在程 序中妥善处理。 编写程序时，要认真设计用户界面。事先预料一些用户可能会犯的错 误，然后设计程序妥善处理这些错误情况。\n8.10 复习题 # 复习题的参考答案在附录A中。 # 1.putchar(getchar())是一个有效表达式，它实现什么功能？ getchar(putchar())是否也是有效表达式？ 2.下面的语句分别完成什么任务？ a.putchar(\u0026lsquo;H\u0026rsquo;); b.putchar(\u0026rsquo;\\007\u0026rsquo;); c.putchar(\u0026rsquo;\\n\u0026rsquo;); d.putchar(\u0026rsquo;\\b\u0026rsquo;); 3.假设有一个名为 count 的可执行程序，用于统计输入的字符数。设计 一个使用 count 程序统计essay文件中字符数的命令行，并把统计结果保存在 essayct文件中。 4.给定复习题 3 中的程序和文件，下面哪一条是有效的命令？ a.essayct count 5.EOF是什么？ 6.对于给定的输出（ch是int类型，而且是缓冲输入），下面各程序段的 输出分别是什么？ a.输入如下：\nIf you quit, I will.[enter] 程序段如下： while ((ch = getchar()) != \u0026lsquo;i\u0026rsquo;) putchar(ch); b.输入如下： Harhar[enter] 程序段如下： while ((ch = getchar()) != \u0026lsquo;\\n\u0026rsquo;) { putchar(ch++); putchar(++ch); } 7.C如何处理不同计算机系统中的不同文件和换行约定？ 8.在使用缓冲输入的系统中，把数值和字符混合输入会遇到什么潜在的 问题？\n8.11 编程练习 # 下面的一些程序要求输入以EOF终止。如果你的操作系统很难或根本无 # 法使用重定向，请使用一些其他的测试来终止输入，如读到\u0026amp;字符时停止。 # 1.设计一个程序，统计在读到文件结尾之前读取的字符数。 # 2.编写一个程序，在遇到 EOF 之前，把输入作为字符流读取。程序要 # 打印每个输入的字符及其相应的ASCII十进制值。注意，在ASCII序列中，空 # 格字符前面的字符都是非打印字符，要特殊处理这些字符。如果非打印字符 # 是换行符或制表符，则分别打印\\n或\\t。否则，使用控制字符表示法。例 如，ASCII的 1 是Ctrl+A，可显示为^A。注意，A的ASCII值是Ctrl+A的值加上 64 。其他非打印字符也有类似的关系。除每次遇到换行符打印新的一行之 外，每行打印 10 对值。（注意：不同的操作系统其控制字符可能不同。） 3.编写一个程序，在遇到 EOF 之前，把输入作为字符流读取。该程序 要报告输入中的大写字母和小写字母的个数。假设大小写字母数值是连续 的。或者使用ctype.h库中合适的分类函数更方便。 4.编写一个程序，在遇到EOF之前，把输入作为字符流读取。该程序要 报告平均每个单词的字母数。不要把空白统计为单词的字母。实际上，标点 符号也不应该统计，但是现在暂时不同考虑这么多（如果你比较在意这点， 考虑使用ctype.h系列中的ispunct()函数）。 5.修改程序清单8.4的猜数字程序，使用更智能的猜测策略。例如，程序 最初猜 50 ，询问用户是猜大了、猜小了还是猜对了。如果猜小了，那么下一 次猜测的值应是 50 和 100 中值，也就是 75 。如果这次猜大了，那么下一次猜 测的值应是 50 和 75 的中值，等等。使用二分查找（binary search）策略，如 果用户没有欺骗程序，那么程序很快就会猜到正确的答案。 6.修改程序清单8.8中的get_first()函数，让该函数返回读取的第 1 个非空 白字符，并在一个简单的程序中测试。\n7.修改第 7 章的编程练习 8 ，用字符代替数字标记菜单的选项。用q代替 5 作为结束输入的标记。 8.编写一个程序，显示一个提供加法、减法、乘法、除法的菜单。获得 用户选择的选项后，程序提示用户输入两个数字，然后执行用户刚才选择的 操作。该程序只接受菜单提供的选项。程序使用float类型的变量储存用户输 入的数字，如果用户输入失败，则允许再次输入。进行除法运算时，如果用 户输入 0 作为第 2 个数（除数），程序应提示用户重新输入一个新值。该程序 的一个运行示例如下： Enter the operation of your choice: a. add s. subtract m. multiply d. divide q. quit a Enter first number: 22　.4 Enter second number: one one is not an number. Please enter a number, such as 2.5, -1.78E8, or 3: 1 22.4 + 1　= 23.4 Enter the operation of your choice: a. add s. subtract m. multiply d. divide\nq. quit d Enter first number: 18.4 Enter second number: 0 Enter a number other than 0: 0.2 18.4 / 0.2 = 92 Enter the operation of your choice: a. add s. subtract m. multiply d. divide q. quit q Bye.\n第 9 章 函数 # 本章介绍以下内容： # 关键字：return 运算符：*（一元）、\u0026amp;（一元） 函数及其定义方式 如何使用参数和返回值 如何把指针变量用作函数参数 函数类型 ANSI C原型 递归 如何组织程序？C的设计思想是，把函数用作构件块。我们已经用过C 标准库的函数，如printf()、scanf()、getchar()、putchar()和 strlen()。现在要进 一步学习如何创建自己的函数。前面章节中已大致介绍了相关过程，本章将 巩固以前学过的知识并做进一步的拓展。\n9.1 复习函数 # 首先，什么是函数？函数（function）是完成特定任务的独立程序代码 单元。语法规则定义了函数的结构和使用方式。虽然C中的函数和其他语言 中的函数、子程序、过程作用相同，但是细节上略有不同。一些函数执行某 些动作，如printf()把数据打印到屏幕上；一些函数找出一个值供程序使用， 如strlen()把指定字符串的长度返回给程序。一般而言，函数可以同时具备以 上两种功能。 为什么要使用函数？首先，使用函数可以省去编写重复代码的苦差。如 果程序要多次完成某项任务，那么只需编写一个合适的函数，就可以在需要 时使用这个函数，或者在不同的程序中使用该函数，就像许多程序中使用 putchar()一样。其次，即使程序只完成某项任务一次，也值得使用函数。因 为函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修 改、完善。例如，假设要编写一个程序完成以下任务： 读入一系列数字； 分类这些数字； 找出这些数字的平均值； 打印一份柱状图。 可以使用下面的程序： #include \u0026lt;stdio.h\u0026gt; #define SIZE 50 int main(void) {\nfloat list[SIZE]; readlist(list, SIZE); sort(list, SIZE); average(list, SIZE); bargraph(list, SIZE); return 0; } 当然，还要编写 4 个函数readlist()、sort()、average()和bargraph()的实现 细节。描述性的函数名能清楚地表达函数的用途和组织结构。然后，单独设 计和测试每个函数，直到函数都能正常完成任务。如果这些函数够通用，还 可以用于其他程序。 许多程序员喜欢把函数看作是根据传入信息（输入）及其生成的值或响 应的动作（输出）来定义的“黑盒”。如果不是自己编写函数，根本不用关心 黑盒的内部行为。例如，使用printf()时，只需知道给该函数传入格式字符串 或一些参数以及 printf()生成的输出，无需了解 printf()的内部代码。以这种 方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细 节上。因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务， 以及函数和程序整体的关系。 如何了解函数？首先要知道如何正确地定义函数、如何调用函数和如何 建立函数间的通信。我们从一个简单的程序示例开始，帮助读者理清这些内 容，然后再详细讲解。\n9.1.1 创建并使用简单函数 # 我们的第 1 个目标是创建一个在一行打印 40 个星号的函数，并在一个打 # 印表头的程序中使用该函数。如程序清单9.1所示，该程序由main()和 starbar()组成。 程序清单 9.1 lethead1.c 程序 /* lethead1.c / #include \u0026lt;stdio.h\u0026gt; #define NAME \u0026ldquo;GIGATHINK, INC.\u0026rdquo; #define ADDRESS \u0026ldquo;101 Megabuck Plaza\u0026rdquo; #define PLACE \u0026ldquo;Megapolis, CA 94904\u0026rdquo; #define WIDTH 40 void starbar(void); / 函数原型 / int main(void) { starbar(); printf(\u0026quot;%s\\n\u0026rdquo;, NAME); printf(\u0026quot;%s\\n\u0026rdquo;, ADDRESS); printf(\u0026quot;%s\\n\u0026rdquo;, PLACE); starbar(); / 使用函数 */ return 0; }\nvoid starbar(void) /* 定义函数　*/ { int count; for (count = 1; count \u0026lt;= WIDTH; count++) putchar(\u0026#39;*\u0026#39;); putchar(\u0026#39;\\n\u0026#39;); } 该程序的输出如下： **************************************** GIGATHINK, INC. 101　Megabuck Plaza Megapolis, CA 94904 **************************************** 9.1.2 分析程序 # 该程序要注意以下几点。 # 程序在 3 处使用了starbar标识符：函数原型（function prototype）告诉编 译器函数starbar()的类型；函数调用（function call）表明在此处执行函数； 函数定义（function definition）明确地指定了函数要做什么。 函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函 数的类型。因此，在main()函数定义的前面出现了下面的ANSI C风格的函数\n原型： # void starbar(void); 圆括号表明starbar是一个函数名。第 1 个void是函数类型，void类型表明 函数没有返回值。第 2 个void（在圆括号中）表明该函数不带参数。分号表 明这是在声明函数，不是定义函数。也就是说，这行声明了程序将使用一个 名为starbar()、没有返回值、没有参数的函数，并告诉编译器在别处查找该 函数的定义。对于不识别ANSI C风格原型的编译器，只需声明函数的类 型，如下所示： void starbar(); 注意，一些老版本的编译器甚至连void都识别不了。如果使用这种编译 器，就要把没有返回值的函数声明为int类型。当然，最好还是换一个新的编 译器。 一般而言，函数原型指明了函数的返回值类型和函数接受的参数类型。 这些信息称为该函数的签名（signature）。对于starbar()函数而言，其签名是 该函数没有返回值，没有参数。 程序把 starbar()原型置于 main()的前面。当然，也可以放在 main()里面 的声明变量处。放在哪个位置都可以。 在main()中，执行到下面的语句时调用了starbar()函数： starbar(); 这是调用void类型函数的一种形式。当计算机执行到starbar();语句时， 会找到该函数的定义并执行其中的内容。执行完starbar()中的代码后，计算 机返回主调函数（calling function）继续执行下一行（本例中，主调函数是 main()），见图9.1（更确切地说，编译器把C程序翻译成执行以上操作的机 器语言代码）。\n程序中strarbar()和main()的定义形式相同。首先函数头包括函数类型、 函数名和圆括号，接着是左花括号、变量声明、函数表达式语句，最后以右 花括号结束（见图9.2）。注意，函数头中的starbar()后面没有分号，告诉编 译器这是定义starbar()，而不是调用函数或声明函数原型。 程序把 starbar()和 main()放在一个文件中。当然，也可以把它们分别放 在两个文件中。把函数都放在一个文件中的单文件形式比较容易编译，而使 用多个文件方便在不同的程序中使用同一个函数。如果把函数放在一个单独 的文件中，要把#define 和#include 指令也放入该文件。我们稍后会讨论使用 多个文件的情况。现在，先把所有的函数都放在一个文件中。main()的右花 括号告诉编译器该函数结束的位置，后面的starbar()函数头告诉编译器 starbar()是一个函数。\n图9.1 lethead1.c（程序清单9.1）的程序流\n图9.2 简单函数的结构 starbar()函数中的变量count是局部变量（local variable），意思是该变 量只属于starbar()函数。可以在程序中的其他地方（包括main()中）使用 count，这不会引起名称冲突，它们是同名的不同变量。 如果把starbar()看作是一个黑盒，那么它的行为是打印一行星号。不用 给该函数提供任何输入，因为调用它不需要其他信息。而且，它没有返回 值，所以也不给 main()提供（或返回）任何信息。简而言之，starbar()不需 要与主调函数通信。 接下来介绍一个函数间需要通信的例子。\n9.1.3 函数参数 # 在程序清单9.1的输出中，如果文字能居中，信头会更加美观。可以通 # 过在打印文字之前打印一定数量的空格来实现，这和打印一定数量的星号 # （starbar()函数）类似，只不过现在要打印的是一定数量的空格。虽然这是 两个任务，但是任务非常相似，与其分别为它们编写一个函数，不如写一个 更通用的函数，可以在两种情况下使用。我们设计一个新的函数 show_n_char()（显示一个字符n次）。唯一要改变的是使用内置的值来显示 字符和重复的次数，show_n_char()将使用函数参数来传递这些值。 我们来具体分析。假设可用的空间是 40 个字符宽。调用show_n_char(\u0026rsquo;\u0026rsquo;, 40)应该正好打印一行 40 个星号，就像starbar()之前做的那样。第 2 行 GIGATHINK, INT.的空格怎么处理？GIGATHINK, INT.是 15 个字符宽，所以 第 1 个版本中，文字后面有 25 个空格。为了让文字居中，文字的左侧应该有 12 个空格，右侧有 13 个空格。因此，可以调用show_n_char(\u0026rsquo;\u0026rsquo;, 12)。 show_n_char()与starbar()很相似，但是show_n_char()带有参数。从功能 上看，前者不会添加换行符，而后者会，因为show_n_char()要把空格和文本 打印成一行。程序清单9.2是修改后的版本。为强调参数的工作原理，程序 使用了不同的参数形式。 程序清单 9.2 lethead2.c 程序 /* lethead2.c / #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; / 为strlen()提供原型 */ #define NAME \u0026ldquo;GIGATHINK, INC.\u0026rdquo; #define ADDRESS \u0026ldquo;101 Megabuck Plaza\u0026rdquo; #define PLACE \u0026ldquo;Megapolis, CA 94904\u0026rdquo; #define WIDTH 40 #define SPACE \u0026rsquo; '\nvoid show_n_char(char ch, int num); int main(void) { int spaces; show_n_char(\u0026rsquo;\u0026rsquo;, WIDTH); / 用符号常量作为参数 / putchar(\u0026rsquo;\\n\u0026rsquo;); show_n_char(SPACE, 12); / 用符号常量作为参数 / printf(\u0026quot;%s\\n\u0026rdquo;, NAME); spaces = (WIDTH - strlen(ADDRESS)) / 2; / 计算要跳过多少个空格*/ show_n_char(SPACE, spaces); /* 用一个变量作为参数*/ printf(\u0026quot;%s\\n\u0026rdquo;, ADDRESS); show_n_char(SPACE, (WIDTH - strlen(PLACE)) / 2); printf(\u0026quot;%s\\n\u0026rdquo;, PLACE); /* 用一个表达式作为参数　/ show_n_char(\u0026rsquo;\u0026rsquo;, WIDTH); putchar(\u0026rsquo;\\n\u0026rsquo;); return 0; } /* show_n_char()函数的定义 */\nvoid show_n_char(char ch, int num) { int count; for (count = 1; count \u0026lt;= num; count++) putchar(ch); } 该函数的运行结果如下：\nGIGATHINK, INC. 101　Megabuck Plaza Megapolis, CA 94904\n下面我们回顾一下如何编写一个带参数的函数，然后介绍这种函数的用 法。\n9.1.4 定义带形式参数的函数 # 函数定义从下面的ANSI C风格的函数头开始： # void show_n_char(char ch, int num) 该行告知编译器show_n_char()使用两个参数ch和num，ch是char类型， num是int类型。这两个变量被称为形式参数（formal argument，但是最近的标 准推荐使用formal parameter），简称形参。和定义在函数中变量一样，形式\n参数也是局部变量，属该函数私有。这意味着在其他函数中使用同名变量不 # 会引起名称冲突。每次调用函数，就会给这些变量赋值。 # 注意，ANSI C要求在每个变量前都声明其类型。也就是说，不能像普 # 通变量声明那样使用同一类型的变量列表： # void dibs(int x, y, z) /* 无效的函数头 / void dubs(int x, int y, int z) / 有效的函数头 / ANSI C也接受ANSI C之前的形式，但是将其视为废弃不用的形式： void show_n_char(ch, num) char ch; int num; 这里，圆括号中只有参数名列表，而参数的类型在后面声明。注意，普 通的局部变量在左花括号之后声明，而上面的变量在函数左花括号之前声 明。如果变量是同一类型，这种形式可以用逗号分隔变量名列表，如下所 示： void dibs(x, y, z) int x, y, z; / 有效 */ 当前的标准正逐渐淘汰 ANSI 之前的形式。读者应对此有所了解，以便 能看懂以前编写的程序，但是自己编写程序时应使用现在的标准形式（C99 和C11标准继续警告这些过时的用法即将被淘汰）。 虽然show_n_char()接受来自main()的值，但是它没有返回值。因此， show_n_char()的类型是void。 下面，我们来学习如何使用函数。\n9.1.5 声明带形式参数函数的原型 # 在使用函数之前，要用ANSI C形式声明函数原型： # void show_n_char(char ch, int num); 当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类 型。根据个人喜好，你也可以省略变量名： void show_n_char(char, int); 在原型中使用变量名并没有实际创建变量，char仅代表了一个char类型 的变量，以此类推。再次提醒读者注意，ANSI C也接受过去的声明函数形 式，即圆括号内没有参数列表： void show_n_char(); 这种形式最终会从标准中剔除。即使没有被剔除，现在函数原型的设计 也更有优势（稍后会介绍）。了解这种形式的写法是为了以后读得懂以前写 的代码。\n9.1.6 调用带实际参数的函数 # 在函数调用中，实际参数（actual argument，简称实参）提供了ch和num 的值。考虑程序清单9.2中第 1 次调用show_n_char()： show_n_char(SPACE, 12); 实际参数是空格字符和 12 。这两个值被赋给show_n_char()中相应的形式 参数：变量ch和num。简而言之，形式参数是被调函数（called function）中 的变量，实际参数是主调函数（calling function）赋给被调函数的具体值。 如上例所示，实际参数可以是常量、变量，或甚至是更复杂的表达式。无论 实际参数是何种形式都要被求值，然后该值被拷贝给被调函数相应的形式参 数。以程序清单 9.2 中最后一次调用show_n_char()为例：\nshow_n_char(SPACE, (WIDTH - strlen(PLACE)) / 2); 构成该函数第 2 个实际参数的是一个很长的表达式，对该表达式求值为 10 。然后， 10 被赋给变量num。被调函数不知道也不关心传入的数值是来自 常量、变量还是一般表达式。再次强调，实际参数是具体的值，该值要被赋 给作为形式参数的变量（见图 9.3）。因为被调函数使用的值是从主调函数 中拷贝而来，所以无论被调函数对拷贝数据进行什么操作，都不会影响主调 函数中的原始数据。 注意 实际参数和形式参数 实际参数是出现在函数调用圆括号中的表达式。形式参数是函数定义的 函数头中声明的变量。调用函数时，创建了声明为形式参数的变量并初始化 为实际参数的求值结果。程序清单 9.2 中，\u0026rsquo;*\u0026lsquo;和WIDTH都是第 1 次调用 show_n_char()时的实际参数，而SPACE和 11 是第 2 次调用show_n_char()时的 实际参数。在函数定义中，ch和num都是该函数的形式参数。\n图9.3 形式参数和实际参数 9.1.7 黑盒视角 # 从黑盒的视角看 show_n_char()，待显示的字符和显示的次数是输入。 执行后的结果是打印指定数量的字符。输入以参数的形式被传递给函数。这 些信息清楚地表明了如何在 main()中使用该函数。而且，这也可以作为编写 该函数的设计说明。 黑盒方法的核心部分是：ch、num和count都是show_n_char()私有的局部 变量。如果在main()中使用同名变量，那么它们相互独立，互不影响。也就 是说，如果main()有一个count变量，那么改变它的值不会改变show_n_char() 中的count，反之亦然。黑盒里发生了什么对主调函数是不可见的。\n9.1.8 使用 return 从函数中返回值 # 前面介绍了如何把信息从主调函数传递给被调函数。反过来，函数的返 # 回值可以把信息从被调函数传回主调函数。为进一步说明，我们将创建一个 # 返回两个参数中较小值的函数。由于函数被设计用来处理int类型的值，所以 被命名为imin()。另外，还要创建一个简单的main()，用于检查imin()是否正 常工作。这种被设计用于测试函数的程序有时被称为驱动程序（driver）， 该驱动程序调用一个函数。如果函数成功通过了测试，就可以安装在一个更 重要的程序中使用。程序清单9.3演示了这个驱动程序和返回最小值的函 数。 程序清单 9.3 lesser.c 程序 /* lesser.c \u0026ndash; 找出两个整数中较小的一个 */ #include \u0026lt;stdio.h\u0026gt; int imin(int, int); int main(void) { int evil1, evil2; printf(\u0026ldquo;Enter a pair of integers (q to quit):\\n\u0026rdquo;); while (scanf(\u0026quot;%d %d\u0026rdquo;, \u0026amp;evil1, \u0026amp;evil2) == 2) { printf(\u0026ldquo;The lesser of %d and %d is %d.\\n\u0026rdquo;, evil1, evil2, imin(evil1, evil2)); printf(\u0026ldquo;Enter a pair of integers (q to quit):\\n\u0026rdquo;);\n} # printf(\u0026ldquo;Bye.\\n\u0026rdquo;); return 0; } int imin(int n, int m) { int min; if (n \u0026lt; m) min = n; else min = m; return min; } 回忆一下，scanf()返回成功读数据的个数，所以如果输入不是两个整数 会导致循环终止。下面是一个运行示例： Enter a pair of integers (q to quit): 509 333 The lesser of 509　and 333　is 333. Enter a pair of integers (q to quit):\n-9393 6 # The lesser of -9393 and 6　is -9393. Enter a pair of integers (q to quit): q Bye. 关键字return后面的表达式的值就是函数的返回值。在该例中，该函数 返回的值就是变量min的值。因为min是int类型的变量，所以imin()函数的类 型也是int。 变量min属于imin()函数私有，但是return语句把min的值传回了主调函 数。下面这条语句的作用是把min的值赋给lesser: lesser = imin(n,m); 是否能像写成下面这样： imin(n,m); lesser = min; 不能。因为主调函数甚至不知道min的存在。记住，imin()中的变量是 imin()的局部变量。函数调用imin(evil1, evil2)只是把两个变量的值拷贝了一 份。 返回值不仅可以赋给变量，也可以被用作表达式的一部分。例如，可以 这样： answer = 2 * imin(z, zstar) + 25; printf(\u0026quot;%d\\n\u0026rdquo;, imin(-32 + answer, LIMIT));\n返回值不一定是变量的值，也可以是任意表达式的值。例如，可以用以 # 下的代码简化程序示例： # /* 返回最小值的函数，第 2 个版本 */ # imin(int n,int m) { return (n \u0026lt; m)? n : m; } 条件表达式的值是n和m中的较小者，该值要被返回给主调函数。虽然 这里不要求用圆括号把返回值括起来，但是如果想让程序条理更清楚或统一 风格，可以把返回值放在圆括号内。 如果函数返回值的类型与函数声明的类型不匹配会怎样？ int what_if(int n) { double z = 100.0 / (double) n; return z; // 会发生什么？ } 实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的 变量所得到的值。因此在本例中，相当于把z的值赋给int类型的变量，然后 返回int类型变量的值。例如，假设有下面的函数调用： result = what_if(64); 虽然在what_if()函数中赋给z的值是1.5625，但是return语句返回确实int\n类型的值 1 。 # 使用 return 语句的另一个作用是，终止函数并把控制返回给主调函数的 下一条语句。因此，可以这样编写imin()： /返回最小值的函数，第 3 个版本/ imin(int n,int m) { if (n \u0026lt; m) return n; else return m; } 许多C程序员都认为只在函数末尾使用一次return语句比较好，因为这样 做更方便浏览程序的人理解函数的控制流。但是，在函数中使用多个return 语句也没有错。无论如何，对用户而言，这 3 个版本的函数用起来都一样， 因为所有的输入和输出都完全相同，不同的是函数内部的实现细节。下面的 版本也没问题： /返回最小值的函数，第 4 个版本/ imin(int n, int m) { if (n \u0026lt; m) return n;\nelse return m; printf(\u0026ldquo;Professor Fleppard is like totally a fopdoodle.\\n\u0026rdquo;); } return语句导致printf()语句永远不会被执行。如果Fleppard教授在自己的 程序中使用这个版本的函数，可能永远不知道编写这个函数的学生对他的看 法。 另外，还可以这样使用return： return; 这条语句会导致终止函数，并把控制返回给主调函数。因为 return 后面 没有任何表达式，所以没有返回值，只有在void函数中才会用到这种形式。\n9.1.9 函数类型 # 声明函数时必须声明函数的类型。带返回值的函数类型应该与其返回值 # 类型相同，而没有返回值的函数应声明为void类型。如果没有声明函数的类 型，旧版本的C编译器会假定函数的类型是int。这一惯例源于C的早期，那 时的函数绝大多数都是int类型。然而，C99标准不再支持int类型函数的这种 假定设置。 类型声明是函数定义的一部分。要记住，函数类型指的是返回值的类 型，不是函数参数的类型。例如，下面的函数头定义了一个带两个int类型参 数的函数，但是其返回值是double类型。 double klink(int a, int b) 要正确地使用函数，程序在第 1 次使用函数之前必须知道函数的类型。 方法之一是，把完整的函数定义放在第 1 次调用函数的前面。然而，这种方\n法增加了程序的阅读难度。而且，要使用的函数可能在C库或其他文件中。 # 因此，通常的做法是提前声明函数，把函数的信息告知编译器。例如，程序 # 清单 9.3 中的main()函数包含以下几行代码： #include \u0026lt;stdio.h\u0026gt; int imin(int, int); int main(void) { int evil1, evil2, lesser; 第 2 行代码说明imin是一个函数名，有两个int类型的形参，且返回int类 型的值。现在，编译器在程序中调用imin()函数时就知道应该如何处理。 在程序清单9.3中，我们把函数的前置声明放在主调函数外面。当然， 也可以放在主调函数里面。例如，重写lesser.c（程序清单9.3）的开头部 分： #include \u0026lt;stdio.h\u0026gt; int main(void) { int imin(int, int); /* 声明imin()函数的原型*/ int evil1, evil2, lesser; 注意在这两种情况中，函数原型都声明在使用函数之前。 ANSI C标准库中，函数被分成多个系列，每一系列都有各自的头文 件。这些头文件中除了其他内容，还包含了本系列所有函数的声明。例如， stdio.h 头文件包含了标准 I/O 库函数（如，printf()和scanf()）的声明。math.h\n头文件包含了各种数学函数的声明。例如，下面的声明： # double sqrt(double); 告知编译器sqrt()函数有一个double类型的形参，而且返回double类型的 值。不要混淆函数的声明和定义。函数声明告知编译器函数的类型，而函数 定义则提供实际的代码。在程序中包含 math.h 头文件告知编译器：sqrt()返 回double类型，但是sqrt()函数的代码在另一个库函数的文件中。\n9.2 ANSI C 函数原型 # 在ANSI C标准之前，声明函数的方案有缺陷，因为只需要声明函数的 # 类型，不用声明任何参数。下面我们看一下使用旧式的函数声明会导致什么 # 问题。 # 下面是ANSI之前的函数声明，告知编译器imin()返回int类型的值： int imin(); 然而，以上函数声明并未给出imin()函数的参数个数和类型。因此，如 果调用imin()时使用的参数个数不对或类型不匹配，编译器根本不会察觉出 来。\n9.2.1 问题所在 # 我们看看与imax()函数相关的一些示例，该函数与imin()函数关系密 切。程序清单9.4演示了一个程序，用过去声明函数的方式声明了imax()函 数，然后错误地使用该函数。 程序清单 9.4 misuse.c 程序 /* misuse.c \u0026ndash; 错误地使用函数 / #include \u0026lt;stdio.h\u0026gt; int imax(); / 旧式函数声明 */ int main(void) { printf(\u0026ldquo;The maximum of %d and %d is %d.\\n\u0026rdquo;,3, 5, imax(3)); printf(\u0026ldquo;The maximum of %d and %d is %d.\\n\u0026rdquo;,3, 5,\nimax(3.0, 5.0)); return 0; } int imax(n, m) int n, m; { return (n \u0026gt; m? n : m); } 第 1 次调用printf()时省略了imax()的一个参数，第 2 次调用printf()时用两 个浮点参数而不是整数参数。尽管有些问题，但程序可以编译和运行。 下面是使用Xcode 4.6运行的输出示例： The maximum of 3　and 5　is 1606416656. The maximum of 3　and 5　is 3886. 使用gcc运行该程序，输出的值是 1359379472 和 1359377160 。这两个编 译器都运行正常，之所以输出错误的结果，是因为它们运行的程序没有使用 函数原型。 到底是哪里出了问题？由于不同系统的内部机制不同，所以出现问题的 具体情况也不同。下面介绍的是使用P C和VA X的情况。主调函数把它的参 数储存在被称为栈（stack）的临时存储区，被调函数从栈中读取这些参数。 对于该例，这两个过程并未相互协调。主调函数根据函数调用中的实际参数 决定传递的类型，而被调函数根据它的形式参数读取值。因此，函数调用 imax(3)把一个整数放在栈中。当imax()函数开始执行时，它从栈中读取两个\n整数。而实际上栈中只存放了一个待读取的整数，所以读取的第 2 个值是当 # 时恰好在栈中的其他值。 # 第 2 次使用imax()函数时，它传递的是float类型的值。这次把两个double 类型的值放在栈中（回忆一下，当float类型被作为参数传递时会被升级为 double类型）。在我们的系统中，两个double类型的值就是两个 64 位的值， 所以 128 位的数据被放在栈中。当imax()从栈中读取两个int类型的值时，它 从栈中读取前 64 位。在我们的系统中，每个int类型的变量占用 32 位。这些数 据对应两个整数，其中较大的是 3886 。\n9.2.2 ANSI 的解决方案 # 针对参数不匹配的问题，ANSI C标准要求在函数声明时还要声明变量 # 的类型，即使用函数原型（function prototype）来声明函数的返回类型、参 数的数量和每个参数的类型。未标明 imax()函数有两个 int 类型的参数，可 以使用下面两种函数原型来声明： int imax(int, int); int imax(int a, int b); 第 1 种形式使用以逗号分隔的类型列表，第 2 种形式在类型后面添加了变 量名。注意，这里的变量名是假名，不必与函数定义的形式参数名一致。 有了这些信息，编译器可以检查函数调用是否与函数原型匹配。参数的 数量是否正确？参数的类型是否匹配？以 imax()为例，如果两个参数都是数 字，但是类型不匹配，编译器会把实际参数的类型转换成形式参数的类型。 例如，imax(3.0, 5.0)会被转换成imax(3, 5)。我们用函数原型替换程序清单9.4 中的函数声明，如程序清单9.5所示。 程序清单 9.5 proto.c 程序 /* proto.c \u0026ndash; 使用函数原型 */\n#include \u0026lt;stdio.h\u0026gt; int imax(int, int); /* 函数原型 */ int main(void) { printf(\u0026ldquo;The maximum of %d and %d is %d.\\n\u0026rdquo;, 3, 5, imax(3)); printf(\u0026ldquo;The maximum of %d and %d is %d.\\n\u0026rdquo;, 3, 5, imax(3.0, 5.0)); return 0; } int imax(int n, int m) { return (n \u0026gt; m? n : m); } 编译程序清单9.5时，我们的编译器给出调用的imax()函数参数太少的错 误消息。 如果是类型不匹配会怎样？为探索这个问题，我们用imax(3, 5)替换 imax(3)，然后再次编译该程序。这次编译器没有给出任何错误信息，程序 的输出如下： The maximum of 3 and 5 is 5.\nThe maximum of 3 and 5 is 5. 如上文所述，第 2 次调用中的3.0和5.0被转换成 3 和 5 ，以便函数能正确地 处理输入。 虽然没有错误消息，但是我们的编译器还是给出了警告：double转换成 int可能会导致丢失数据。例如，下面的函数调用： imax(3.9, 5.4) 相当于: imax(3, 5) 错误和警告的区别是：错误导致无法编译，而警告仍然允许编译。一些 编译器在进行类似的类型转换时不会通知用户，因为C标准中对此未作要 求。不过，许多编译器都允许用户选择警告级别来控制编译器在描述警告时 的详细程度。\n9.2.3 无参数和未指定参数 # 假设有下面的函数原型： # void print_name(); 一个支持ANSI C的编译器会假定用户没有用函数原型来声明函数，它 将不会检查参数。为了表明函数确实没有参数，应该在圆括号中使用void关 键字： void print_name(void); 支持ANSI C的编译器解释为print_name()不接受任何参数。然后在调用 该函数时，编译器会检查以确保没有使用参数。 一些函数接受（如，printf()和scanf()）许多参数。例如对于printf()，第 1\n个参数是字符串，但是其余参数的类型和数量都不固定。对于这种情况， # ANSI C允许使用部分原型。例如，对于printf()可以使用下面的原型： int printf(const char *, \u0026hellip;); 这种原型表明，第 1 个参数是一个字符串（第 11 章中将详细介绍），可 能还有其他未指定的参数。 C库通过stdarg.h头文件提供了一个定义这类（形参数量不固定的）函数 的标准方法。第 16 章中详细介绍相关内容。\n9.2.4 函数原型的优点 # 函数原型是C语言的一个强有力的工具，它让编译器捕获在使用函数时 # 可能出现的许多错误或疏漏。如果编译器没有发现这些问题，就很难觉察出 # 来。是否必须使用函数原型？不一定。你也可以使用旧式的函数声明（即不 # 用声明任何形参），但是这样做的弊大于利。 # 有一种方法可以省略函数原型却保留函数原型的优点。首先要明白，之 # 所以使用函数原型，是为了让编译器在第 1 次执行到该函数之前就知道如何 # 使用它。因此，把整个函数定义放在第 1 次调用该函数之前，也有相同的效 # 果。此时，函数定义也相当于函数原型。对于较小的函数，这种用法很普 # 遍： # // 下面这行代码既是函数定义，也是函数原型 # int imax(int a, int b) { return a \u0026gt; b? a : b; } int main() { int x, z; ... z = imax(x, 50); \u0026hellip; }\n9.3 递归 # C允许函数调用它自己，这种调用过程称为递归（recursion）。递归有 时难以捉摸，有时却很方便实用。结束递归是使用递归的难点，因为如果递 归代码中没有终止递归的条件测试部分，一个调用自己的函数会无限递归。 可以使用循环的地方通常都可以使用递归。有时用循环解决问题比较 好，但有时用递归更好。递归方案更简洁，但效率却没有循环高。\n9.3.1 演示递归 # 我们通过一个程序示例，来学习什么是递归。程序清单 9.6 中的 main() 函数调用 up_and_down()函数，这次调用称为“第 1 级递归”。然后 up_and_down()调用自己，这次调用称为“第 2 级递归”。接着第 2 级递归调用 第 3 级递归，以此类推。该程序示例共有 4 级递归。为了进一步深入研究递归 时发生了什么，程序不仅显示了变量n的值，还显示了储存n的内存地址 \u0026amp;n（。本章稍后会详细讨论\u0026amp;运算符，printf()函数使用%p转换说明打印地 址，如果你的系统不支持这种格式，请使用%u或%lu代替%p）。 程序清单 9.6 recur.c 程序 /* recur.c \u0026ndash; 递归演示 */ #include \u0026lt;stdio.h\u0026gt; void up_and_down(int); int main(void) { up_and_down(1); return 0;\n} # void up_and_down(int n) { printf(\u0026ldquo;Level %d: n location %p\\n\u0026rdquo;, n, \u0026amp;n); // #1 if (n \u0026lt; 4) up_and_down(n + 1); printf(\u0026ldquo;LEVEL %d: n location %p\\n\u0026rdquo;, n, \u0026amp;n); // #2 } 下面是在我们系统中的输出： Level 1: n location 0x0012ff48 Level 2: n location 0x0012ff3c Level 3: n location 0x0012ff30 Level 4: n location 0x0012ff24 LEVEL 4: n location 0x0012ff24 LEVEL 3: n location 0x0012ff30 LEVEL 2: n location 0x0012ff3c LEVEL 1: n location 0x0012ff48 我们来仔细分析程序中的递归是如何工作的。首先，main()调用了带参 数 1 的up_and_down()函数，执行结果是up_and_down()中的形式参数n的值是 1 ，所以打印语句#1打印Level 1。然后，由于n小于 4 ，up_and_down()（第 1\n级）调用实际参数为n + 1（或 2 ）的up_and_down()（第 2 级）。于是第 2 级调 用中的n的值是 2 ，打印语句#1打印Level 2。与此类似，下面两次调用打印的 分别是Level 3和Level 4。 当执行到第 4 级时，n的值是 4 ，所以if测试条件为假。up_and_down()函 数不再调用自己。第 4 级调用接着执行打印语句#2，即打印LEVEL 4，因为n 的值是 4 。此时，第 4 级调用结束，控制被传回它的主调函数（即第 3 级调 用）。在第 3 级调用中，执行的最后一条语句是调用if语句中的第 4 级调用。 被调函数（第 4 级调用）把控制返回在这个位置，因此，第 3 级调用继续执行 后面的代码，打印语句#2打印LEVEL 3。然后第 3 级调用结束，控制被传回 第 2 级调用，接着打印LEVEL 2，以此类推。 注意，每级递归的变量 n 都属于本级递归私有。这从程序输出的地址值 可以看出（当然，不同的系统表示的地址格式不同，这里关键要注意， Level 1和LEVEL 1的地址相同，Level 2和LEVEL 2的地址相同，等等）。 如果觉得不好理解，可以假设有一条函数调用链——fun1()调用 fun2()、fun2()调用 fun3()、fun3()调用fun4()。当 fun4()结束时，控制传回 fun3()；当fun3()结束时，控制传回 fun2()；当fun2()结束时，控制传回 fun1()。递归的情况与此类似，只不过fun1()、fun2()、fun3()和fun4()都是相同 的函数。\n9.3.2 递归的基本原理 # 初次接触递归会觉得较难理解。为了帮助读者理解递归过程，下面以程 # 序清单9.6为例讲解几个要点。 # 第 1 ，每级函数调用都有自己的变量。也就是说，第 1 级的n和第 2 级的n 不同，所以程序创建了 4 个单独的变量，每个变量名都是n，但是它们的值各 不相同。当程序最终返回 up_and_down()的第 1 级调用时，最初的n仍然是它 的初值 1 （见图9.4）。\n图9.4 递归中的变量 第 2 ，每次函数调用都会返回一次。当函数执行完毕后，控制权将被传 回上一级递归。程序必须按顺序逐级返回递归，从某级up_and_down()返回 上一级的up_and_down()，不能跳级回到main()中的第 1 级调用。 第 3 ，递归函数中位于递归调用之前的语句，均按被调函数的顺序执 行。例如，程序清单9.6中的打印语句#1位于递归调用之前，它按照递归的 顺序：第 1 级、第 2 级、第 3 级和第 4 级，被执行了 4 次。 第 4 ，递归函数中位于递归调用之后的语句，均按被调函数相反的顺序 执行。例如，打印语句#2位于递归调用之后，其执行的顺序是第 4 级、第 3 级、第 2 级、第 1 级。递归调用的这种特性在解决涉及相反顺序的编程问题时 很有用。稍后将介绍一个这样的例子。 第 5 ，虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程 序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代 码。除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。 实际上，递归有时可用循环来代替，循环有时也能用递归来代替。\n最后，递归函数必须包含能让递归调用停止的语句。通常，递归函数都 # 使用if或其他等价的测试条件在函数形参等于某特定值时终止递归。为此， 每次递归调用的形参都要使用不同的值。例如，程序清单9.6中的 up_and_down(n)调用up_and_down(n+1)。最终，实际参数等于 4 时，if的测试 条件(n \u0026lt; 4)为假。\n9.3.3 尾递归 # 最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句 之前。这种形式的递归被称为尾递归（tail recursion），因为递归调用在函 数的末尾。尾递归是最简单的递归形式，因为它相当于循环。 下面要介绍的程序示例中，分别用循环和尾递归计算阶乘。一个正整数 的阶乘（factorial）是从 1 到该整数的所有整数的乘积。例如， 3 的阶乘（写 作 3 ！）是1×2×3。另外， 0 ！等于 1 ，负数没有阶乘。程序清单9.7中，第 1 个 函数使用for循环计算阶乘，第 2 个函数使用递归计算阶乘。 程序清单 9.7 factor.c 程序 // factor.c \u0026ndash; 使用循环和递归计算阶乘 #include \u0026lt;stdio.h\u0026gt; long fact(int n); long rfact(int n); int main(void) { int num; printf(\u0026ldquo;This program calculates factorials.\\n\u0026rdquo;);\nprintf(\u0026ldquo;Enter a value in the range 0-12 (q to quit):\\n\u0026rdquo;); while (scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;num) == 1) { if (num \u0026lt; 0) printf(\u0026ldquo;No negative numbers, please.\\n\u0026rdquo;); else if (num \u0026gt; 12) printf(\u0026ldquo;Keep input under 13.\\n\u0026rdquo;); else { printf(\u0026ldquo;loop: %d factorial = %ld\\n\u0026rdquo;, num, fact(num)); printf(\u0026ldquo;recursion: %d factorial = %ld\\n\u0026rdquo;, num, rfact(num)); } printf(\u0026ldquo;Enter a value in the range 0-12 (q to quit):\\n\u0026rdquo;); } printf(\u0026ldquo;Bye.\\n\u0026rdquo;); return 0; }\nlong fact(int n) // 使用循环的函数 { long ans; for (ans = 1; n \u0026gt; 1; n\u0026ndash;) ans *= n; return ans; } long rfact(int n) // 使用递归的函数 { long ans; if (n \u0026gt; 0) ans = n * rfact(n - 1); else ans = 1; return ans; } 测试驱动程序把输入限制在0~12。因为12!已快接近 5 亿，而13!比 62 亿 还大，已超过我们系统中long类型能表示的范围。要计算超过 12 的阶乘，必 须使用能表示更大范围的类型，如double或long long。 下面是该程序的运行示例：\nThis program calculates factorials. Enter a value in the range 0-12 (q to quit): 5 loop: 5　factorial = 120 recursion: 5　factorial = 120 Enter a value in the range 0-12 (q to quit): 10 loop: 10　factorial = 3628800 recursion: 10　factorial = 3628800 Enter a value in the range 0-12 (q to quit): q Bye. 使用循环的函数把ans初始化为 1 ，然后把ans与从n~2的所有递减整数相 乘。根据阶乘的公式，还应该乘以 1 ，但是这并不会改变结果。 现在考虑使用递归的函数。该函数的关键是n! = n×(n-1)!。可以这样做 是因为(n-1)!是n-1~1的所有正整数的乘积。因此，n乘以n-1就得到n的阶乘。 阶乘的这一特性很适合使用递归。如果调用函数rfact()，rfact(n)是 n*rfact(n- 1)。因此，通过调用 rfact(n-1)来计算rfact(n)，如程序清单9.7中所示。当 然，必须要在满足某条件时结束递归，可以在n等于 0 时把返回值设为 1 。 程序清单9.7中使用递归的输出和使用循环的输出相同。注意，虽然 rfact()的递归调用不是函数的最后一行，但是当n\u0026gt;0时，它是该函数执行的最 后一条语句，因此它也是尾递归。\n既然用递归和循环来计算都没问题，那么到底应该使用哪一个？一般而 # 言，选择循环比较好。首先，每次递归都会创建一组变量，所以递归使用的 # 内存更多，而且每次递归调用都会把创建的一组新变量放在栈中。递归调用 # 的数量受限于内存空间。其次，由于每次函数调用要花费一定的时间，所以 # 递归的执行速度较慢。那么，演示这个程序示例的目的是什么？因为尾递归 # 是递归中最简单的形式，比较容易理解。在某些情况下，不能用简单的循环 # 代替递归，因此读者还是要好好理解递归。 # 9.3.4 递归和倒序计算 # 递归在处理倒序时非常方便（在解决这类问题中，递归比循环简单）。 # 我们要解决的问题是：编写一个函数，打印一个整数的二进制数。二进制表 # 示法根据 2 的幂来表示数字。例如，十进制数 234 实际上是 # 2×10^2 +3×10^1 +4×10^0 ，所以二进制数 101 实际上是1×2^2 +0×2^1 +1×2^0 。二进制数 # 由 0 和 1 表示。 # 我们要设计一个以二进制形式表示整数的方法或算法（algorithm）。例 如，如何用二进制表示十进制数 5 ？在二进制中，奇数的末尾一定是 1 ，偶数 的末尾一定是 0 ，所以通过5 % 2即可确定 5 的二进制数的最后一位是 1 还是 0 。一般而言，对于数字n，其二进制的最后一位是n % 2。因此，计算的第 一位数字实际上是待输出二进制数的最后一位。这一规律提示我们，在递归 函数的递归调用之前计算n % 2，在递归调用之后打印计算结果。这样，计 算的第 1 个值正好是最后一个打印的值。 要获得下一位数字，必须把原数除以 2 。这种计算方法相当于在十进制 下把小数点左移一位，如果计算结果是偶数，那么二进制的下一位数就是 0 ；如果是奇数，就是 1 。例如，5/2得 2 （整数除法）， 2 是偶数（2%2 得 0 ），所以下一位二进制数是 0 。到目前为止，我们已经获得 01 。继续重复 这个过程。2/2得 1 ，1%2得 1 ，所以下一位二进制数是 1 。因此，我们得到 5 的等价二进制数是 101 。那么，程序应该何时停止计算？当与 2 相除的结果小 于 2 时停止计算，因为只要结果大于或等于 2 ，就说明还有二进制位。每次除 以 2 就相当于去掉一位二进制，直到计算出最后一位为止（如果不好理解，\n可以拿十进制数来做类比：628%10得 8 ，因此 8 就是该数最后一位；而 # 628/10得 62 ，而62%10得 2 ，所以该数的下一位是 2 ，以此类推）。程序清单 # 9.8演示了上述算法。 # 程序清单 9.8 binary.c 程序 /* binary.c -- 以二进制形式打印制整数 */ #include \u0026lt;stdio.h\u0026gt; void to_binary(unsigned long n); int main(void) { unsigned long number; printf(\u0026#34;Enter an integer (q to quit):\\n\u0026#34;); while (scanf(\u0026#34;%lu\u0026#34;, \u0026amp;number) == 1) { printf(\u0026#34;Binary equivalent: \u0026#34;); to_binary(number); putchar(\u0026#39;\\n\u0026#39;); printf(\u0026#34;Enter an integer (q to quit):\\n\u0026#34;); } printf(\u0026#34;Done.\\n\u0026#34;); return 0; } # void to_binary(unsigned long n) /* 递归函数 */ { int r; r = n % 2; if (n \u0026gt;= 2) to_binary(n / 2); putchar(r == 0　? \u0026lsquo;0\u0026rsquo; : \u0026lsquo;1\u0026rsquo;); return; } 在该程序中，如果r的值是 0 ，to_binary()函数就显示字符'0\u0026rsquo;；如果r的值 是 1 ，to_binary()函数则显示字符'1\u0026rsquo;。条件表达式r == 0? \u0026lsquo;0\u0026rsquo; : \u0026lsquo;1\u0026rsquo;用于把数值转 换成字符。 下面是该程序的运行示例： Enter an integer (q to quit): 9 Binary equivalent: 1001 Enter an integer (q to quit): 255 Binary equivalent: 11111111\nEnter an integer (q to quit): 1024 Binary equivalent: 10000000000 Enter an integer (q to quit): q done. 不用递归，是否能实现这种用二进制形式表示整数的算法？当然可以。 但是由于这种算法要首先计算最后一位二进制数，所以在显示结果之前必须 把所有的位数都储存在别处（例如，数组）。第 15 章中会介绍一个不用递 归实现该算法的例子。\n9.3.5 递归的优缺点 # 递归既有优点也有缺点。优点是递归为某些编程问题提供了最简单的解 # 决方案。缺点是一些递归算法会快速消耗计算机的内存资源。另外，递归不 # 方便阅读和维护。我们用一个例子来说明递归的优缺点。 # 斐波那契数列的定义如下：第 1 个和第 2 个数字都是 1 ，而后续的每个数 # 字都是其前两个数字之和。例如，该数列的前几个数是： 1 、 1 、 2 、 3 、 5 、 # 8 、 13 。斐波那契数列在数学界深受喜爱，甚至有专门研究它的刊物。不 # 过，这不在本书的讨论范围之内。下面，我们要创建一个函数，接受正整数 # n，返回相应的斐波那契数值。 首先，来看递归。递归提供一个简单的定义。如果把函数命名为 Fibonacci()，那么如果n是 1 或 2 ， Fibonacci(n)应返回 1 ；对于其他数值，则应 返回Fibonacci(n-1)+Fibonacci(n-2)： unsigned long Fibonacci(unsigned n)\n{ # if (n \u0026gt; 2) return Fibonacci(n-1) + Fibonacci(n-2); else return 1; } 这个递归函数只是重述了数学定义的递归。该函数使用了双递归 （double recursion），即函数每一级递归都要调用本身两次。这暴露了一个 问题。 为了说明这个问题，假设调用 Fibonacci(40)。这是第 1 级递归调用，将 创建一个变量 n。然后在该函数中要调用Fibonacci()两次，在第 2 级递归中要 分别创建两个变量n。这两次调用中的每次调用又会进行两次调用，因而在 第 3 级递归中要创建 4 个名为n的变量。此时总共创建了 7 个变量。由于每级递 归创建的变量都是上一级递归的两倍，所以变量的数量呈指数增长！在第 5 章中介绍过一个计算小麦粒数的例子，按指数增长很快就会产生非常大的 值。在本例中，指数增长的变量数量很快就消耗掉计算机的大量内存，很可 能导致程序崩溃。 虽然这是个极端的例子，但是该例说明：在程序中使用递归要特别注 意，尤其是效率优先的程序。 所有的 C 函数皆平等 程序中的每个C函数与其他函数都是平等的。每个函数都可以调用其他 函数，或被其他函数调用。这点与Pascal和Modula-2中的过程不同，虽然过 程可以嵌套在另一个过程中，但是嵌套在不同过程中的过程之间不能相互调 用。\nmain()函数是否与其他函数不同？是的，main()的确有点特殊。当 main()与程序中的其他函数放在一起时，最开始执行的是main()函数中的第 1 条语句，但是这也是局限之处。main()也可以被自己或其他函数递归调用 ——尽管很少这样做。\n9.4 编译多源代码文件的程序 # 使用多个函数最简单的方法是把它们都放在同一个文件中，然后像编译 # 只有一个函数的文件那样编译该文件即可。其他方法因操作系统而异，下面 # 将举例说明。 # 9.4.1 UNIX # 假定在UNIX系统中安装了UNIX C编译器cc（最初的cc已经停用，但是 许多UNIX系统都给cc命令起了一个别名用作其他编译器命令，典型的是gcc 或clang）。假设file1.c和file2.c是两个内含C函数的文件，下面的命令将编译 两个文件并生成一个名为a.out的可执行文件： cc file1.c file2.c 另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了 file1.c，而file2.c不变，可以使用以下命令编译第 1 个文件，并与第 2 个文件 的目标代码合并： cc file1.c file2.o UNIX系统的make命令可自动管理多文件程序，但是这超出了本书的讨 论范围。 注意，OS X的Terminal工具可以打开UNIX命令行环境，但是必须先下 载命令行编译器（GCC和Clang）。\n9.4.2 Linux # 假定Linux系统安装了GNU C编译器GCC。假设file1.c和file2.c是两个内 含C函数的文件，下面的命令将编译两个文件并生成名为a.out的可执行文 件： gcc file1.c file2.c\n另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了 file1.c，而file2.c不变，可以使用以下命令编译第 1 个文件，并与第 2 个文件 的目标代码合并： gcc file1.c file2.o\n9.4.3 DOS 命令行编译器 # 绝大多数DOS命令行编译器的工作原理和UNIX的cc命令类似，只不过 使用不同的名称而已。其中一个区别是，对象文件的扩展名是.obj，而不 是.o。一些编译器生成的不是目标代码文件，而是汇编语言或其他特殊代码 的中间文件。\n9.4.4 Windows 和苹果的 IDE 编译器 # Windows和Macintosh系统使用的集成开发环境中的编译器是面向项目 的。项目（project）描述的是特定程序使用的资源。资源包括源代码文件。 这种IDE中的编译器要创建项目来运行单文件程序。对于多文件程序，要使 用相应的菜单命令，把源代码文件加入一个项目中。要确保所有的源代码文 件都在项目列表中列出。许多IDE都不用在项目列表中列出头文件（即扩展 名为.h的文件），因为项目只管理使用的源代码文件，源代码文件中的 #include指令管理该文件中使用的头文件。但是，Xcode要在项目中添加头文 件。\n9.4.5 使用头文件 # 如果把main()放在第 1 个文件中，把函数定义放在第 2 个文件中，那么第 1 个文件仍然要使用函数原型。把函数原型放在头文件中，就不用在每次使 用函数文件时都写出函数的原型。C 标准库就是这样做的，例如，把I/O函 数原型放在stdio.h中，把数学函数原型放在math.h中。你也可以这样用自定 义的函数文件。 另外，程序中经常用C预处理器定义符号常量。这种定义只储存了那些\n包含#define指令的文件。如果把程序的一个函数放进一个独立的文件中，你 也可以使用#define指令访问每个文件。最直接的方法是在每个文件中再次输 入指令，但是这个方法既耗时又容易出错。另外，还会有维护的问题：如果 修改了#define 定义的值，就必须在每个文件中修改。更好的做法是，把 #define 指令放进头文件，然后在每个源文件中使用#include指令包含该文件 即可。 总之，把函数原型和已定义的字符常量放在头文件中是一个良好的编程 习惯。我们考虑一个例子：假设要管理 4 家酒店的客房服务，每家酒店的房 价不同，但是每家酒店所有房间的房价相同。对于预订住宿多天的客户，第 2 天的房费是第 1 天的95%，第 3 天是第 2 天的95%，以此类推（暂不考虑这种 策略的经济效益）。设计一个程序让用户指定酒店和入住天数，然后计算并 显示总费用。同时，程序要实现一份菜单，允许用户反复输入数据，除非用 户选择退出。 程序清单9.9、程序清单9.10和程序清单9.11演示了如何编写这样的程 序。第 1 个程序清单包含main()函数，提供整个程序的组织结构。第 2 个程 序清单包含支持的函数，我们假设这些函数在独立的文件中。最后，程序清 单9.11列出了一个头文件，包含了该程序所有源文件中使用的自定义符号常 量和函数原型。前面介绍过，在UNIX和DOS环境中，#include \u0026ldquo;hotels.h\u0026quot;指令 中的双引号表明被包含的文件位于当前目录中（通常是包含源代码的目 录）。如果使用IDE，需要知道如何把头文件合并成一个项目。 程序清单 9.9 usehotel.c 控制模块 /* usehotel.c \u0026ndash; 房间费率程序 / / 与程序清单9.10一起编译　/ #include \u0026lt;stdio.h\u0026gt; #include \u0026ldquo;hotel.h\u0026rdquo; / 定义符号常量，声明函数 */\nint main(void) { int nights; double hotel_rate; int code; while ((code = menu()) != QUIT) { switch (code) { case 1: hotel_rate = HOTEL1; break; case 2: hotel_rate = HOTEL2; break; case 3: hotel_rate = HOTEL3; break; case 4: hotel_rate = HOTEL4; break; default: hotel_rate = 0.0; printf(\u0026ldquo;Oops!\\n\u0026rdquo;);\nbreak; } nights = getnights(); showprice(hotel_rate, nights); } printf(\u0026ldquo;Thank you and goodbye.\\n\u0026rdquo;); return 0; } 程序清单 9.10 hotel.c 函数支持模块 /* hotel.c \u0026ndash; 酒店管理函数 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026ldquo;hotel.h\u0026rdquo; int menu(void) { int code, status; printf(\u0026quot;\\n%s%s\\n\u0026rdquo;, STARS, STARS); printf(\u0026ldquo;Enter the number of the desired hotel:\\n\u0026rdquo;); printf(\u0026ldquo;1) Fairfield Arms 2) Hotel Olympic\\n\u0026rdquo;); printf(\u0026ldquo;3) Chertworthy Plaza 4) The Stockton\\n\u0026rdquo;);\nprintf(\u0026ldquo;5) quit\\n\u0026rdquo;); printf(\u0026quot;%s%s\\n\u0026rdquo;, STARS, STARS); while ((status = scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;code)) != 1　|| (code \u0026lt; 1　|| code \u0026gt; 5)) { if (status != 1) scanf(\u0026rdquo;%*s\u0026rdquo;); // 处理非整数输入 printf(\u0026ldquo;Enter an integer from 1　to 5, please.\\n\u0026rdquo;); } return code; } int getnights(void) { int nights; printf(\u0026ldquo;How many nights are needed? \u0026ldquo;); while (scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;nights) != 1) { scanf(\u0026rdquo;%*s\u0026rdquo;); // 处理非整数输入 printf(\u0026ldquo;Please enter an integer, such as 2.\\n\u0026rdquo;);\n} # return nights; } void showprice(double rate, int nights) { int n; double total = 0.0; double factor = 1.0; for (n = 1; n \u0026lt;= nights; n++, factor = DISCOUNT) total += rate * factor; printf(\u0026ldquo;The total cost will be $%0.2f.\\n\u0026rdquo;, total); } 程序清单 9.11 hotel.h 头文件 / hotel.h \u0026ndash; 符号常量和 hotel.c 中所有函数的原型 */ #define QUIT 5 #define HOTEL1 180.00 #define HOTEL2 225.00 #define HOTEL3 255.00 #define HOTEL4 355.00\n#define DISCOUNT 0.95 #define STARS \u0026ldquo;**********************************\u0026rdquo; // 显示选择列表 int menu(void); // 返回预订天数 int getnights(void); // 根据费率、入住天数计算费用 // 并显示结果 void showprice(double rate, int nights); 下面是这个多文件程序的运行示例：\nEnter the number of the desired hotel:\nFairfield Arms 2) Hotel Olympic Chertworthy Plaza 4) The Stockton quit 3 How many nights are needed? 1 The total cost will be $255.00.\n******************************************************************** # Enter the number of the desired hotel:\nFairfield Arms 2) Hotel Olympic Chertworthy Plaza 4) The Stockton quit 4 How many nights are needed? 3 The total cost will be $1012.64.\nEnter the number of the desired hotel:\nFairfield Arms 2) Hotel Olympic Chertworthy Plaza 4) The Stockton quit 5 Thank you and goodbye. 顺带一提，该程序中有几处编写得很巧妙。尤其是，menu()和getnights() 函数通过测试scanf()的返回值来跳过非数值数据，而且调用 scanf(\u0026rdquo;%*s\u0026rdquo;)跳 至下一个空白字符。注意，menu()函数中是如何检查非数值输入和超出范围\n的数据： # while ((status = scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;code)) != 1 ||(code \u0026lt; 1 || code \u0026gt; 5)) 以上代码段利用了C语言的两个规则：从左往右对逻辑表达式求值；一 旦求值结果为假，立即停止求值。在该例中，只有在scanf()成功读入一个整 数值后，才会检查code的值。 用不同的函数处理不同的任务时应检查数据的有效性。当然，首次编写 menu()或getnights()函数时可以暂不添加这一功能，只写一个简单的scanf()即 可。待基本版本运行正常后，再逐步改善各模块。\n9.5 查找地址： \u0026amp; 运算符 # 指针（pointer）是 C 语言最重要的（有时也是最复杂的）概念之一，用 于储存变量的地址。前面使用的scanf()函数中就使用地址作为参数。概括地 说，如果主调函数不使用return返回的值，则必须通过地址才能修改主调函 数中的值。接下来，我们将介绍带地址参数的函数。首先介绍一元\u0026amp;运算符 的用法。 一元\u0026amp;运算符给出变量的存储地址。如果pooh是变量名，那么\u0026amp;pooh是 变量的地址。可以把地址看作是变量在内存中的位置。假设有下面的语句： pooh = 24; 假设pooh的存储地址是0B76（PC地址通常用十六进制形式表示）。那 么，下面的语句： printf(\u0026quot;%d %p\\n\u0026rdquo;, pooh, \u0026amp;pooh); 将输出如下内容（%p是输出地址的转换说明）： 24 0B76 程序清单9.12中使用了这个运算符查看不同函数中的同名变量分别储存 在什么位置。 程序清单 9.12 loccheck.c 程序 /* loccheck.c \u0026ndash; 查看变量被储存在何处　/ #include \u0026lt;stdio.h\u0026gt; void mikado(int); / 函数原型 */ int main(void)\n{ # int pooh = 2, bah = 5; /* main()的局部变量 / printf(\u0026ldquo;In main(), pooh = %d and \u0026amp;pooh = %p\\n\u0026rdquo;, pooh, \u0026amp;pooh); printf(\u0026ldquo;In main(), bah = %d and \u0026amp;bah = %p\\n\u0026rdquo;, bah, \u0026amp;bah); mikado(pooh); return 0; } void mikado(int bah) / 定义函数 / { int pooh = 10; / mikado()的局部变量 */ printf(\u0026ldquo;In mikado(), pooh = %d and \u0026amp;pooh = %p\\n\u0026rdquo;, pooh, \u0026amp;pooh); printf(\u0026ldquo;In mikado(), bah = %d and \u0026amp;bah = %p\\n\u0026rdquo;, bah, \u0026amp;bah); } 程序清单9.12中使用ANSI C的%p格式打印地址。我们的系统输出如 下： In main(), pooh = 2　and \u0026amp;pooh = 0x7fff5fbff8e8 In main(), bah = 5　and \u0026amp;bah = 0x7fff5fbff8e4\nIn mikado(), pooh = 10　and \u0026amp;pooh = 0x7fff5fbff8b8 In mikado(), bah = 2　and \u0026amp;bah = 0x7fff5fbff8bc 实现不同，%p表示地址的方式也不同。然而，许多实现都如本例所 示，以十六进制显示地址。顺带一提，每个十六进制数对应 4 位，该例显示 12 个十六进制数，对应 48 位地址。 该例的输出说明了什么？首先，两个pooh的地址不同，两个bah的地址 也不同。因此，和前面介绍的一样，计算机把它们看成 4 个独立的变量。其 次，函数调用mikado(pooh)把实际参数（main()中的pooh）的值（ 2 ）传递给 形式参数（mikado()中的bah）。注意，这种传递只传递了值。涉及的两个变 量（main()中的pooh和mikado()中的bah）并未改变。 我们强调第 2 点，是因为这并不是在所有语言中都成立。例如，在 FORTRAN中，子例程会影响主调例程的原始变量。子例程的变量名可能与 原始变量不同，但是它们的地址相同。但是，在 C语言中不是这样。每个C 函数都有自己的变量。这样做更可取，因为这样做可以防止原始变量被被调 函数中的副作用意外修改。然而，正如下节所述，这也带来了一些麻烦。\n9.6 更改主调函数中的变量 # 有时需要在一个函数中更改其他函数的变量。例如，普通的排序任务中 # 交换两个变量的值。假设要交换两个变量x和y的值。简单的思路是： x = y; y = x; 这完全不起作用，因为执行到第 2 行时，x的原始值已经被y的原始值替 换了。因此，要多写一行代码，储存x的原始值： temp = x; x = y; y = temp; 上面这 3 行代码便可实现交换值的功能，可以编写成一个函数并构造一 个驱动程序来测试。在程序清单9.13中，为清楚地表明变量属于哪个函数， 在main()中使用变量x和y，在intercharge()中使用u和v。 程序清单 9.13 swap1.c 程序 /* swap1.c \u0026ndash; 第 1 个版本的交换函数 / #include \u0026lt;stdio.h\u0026gt; void interchange(int u, int v); / 声明函数 */ int main(void) { int x = 5, y = 10;\nprintf(\u0026ldquo;Originally x = %d and y = %d.\\n\u0026rdquo;, x, y); interchange(x, y); printf(\u0026ldquo;Now x = %d and y = %d.\\n\u0026rdquo;, x, y); return 0; } void interchange(int u, int v) /* 定义函数　/ { int temp; temp = u; u = v; v = temp; } 运行该程序后，输出如下： Originally x = 5　and y = 10. Now x = 5　and y = 10. 两个变量的值并未交换！我们在interchange()中添加一些打印语句来检 查错误（见程序清单9.14）。 程序清单 9.14 swap2.c 程序 / swap2.c \u0026ndash; 查找swap1.c的问题 */\n#include \u0026lt;stdio.h\u0026gt; void interchange(int u, int v); int main(void) { int x = 5, y = 10; printf(\u0026ldquo;Originally x = %d and y = %d.\\n\u0026rdquo;, x, y); interchange(x, y); printf(\u0026ldquo;Now x = %d and y = %d.\\n\u0026rdquo;, x, y); return 0; } void interchange(int u, int v) { int temp; printf(\u0026ldquo;Originally u = %d and v = %d.\\n\u0026rdquo;, u, v); temp = u; u = v; v = temp; printf(\u0026ldquo;Now u = %d and v = %d.\\n\u0026rdquo;, u, v); }\n下面是该程序的输出： # Originally x = 5　and y = 10. Originally u = 5　and v = 10. Now u = 10　and v = 5. Now x = 5　and y = 10. 看来，interchange()没有问题，它交换了 u 和 v 的值。问题出在把结果 传回 main()时。interchange()使用的变量并不是main()中的变量。因此，交换 u和v的值对x和y的值没有影响！是否能用return语句把值传回main()？当然可 以，在interchange()的末尾加上下面一行语句： return(u); 然后修改main()中的调用： x = interchange(x,y); 这只能改变x的值，而y的值依旧没变。用return语句只能把被调函数中 的一个值传回主调函数，但是现在要传回两个值。这没问题！不过，要使用 指针。\n9.7 指针简介 # 指针？什么是指针？从根本上看，指针（pointer）是一个值为内存地址 的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是 整数，指针变量的值是地址。在C语言中，指针有许多用法。本章将介绍如 何把指针作为函数参数使用，以及为何要这样用。 假设一个指针变量名是ptr，可以编写如下语句： ptr = \u0026amp;pooh; // 把pooh的地址赋给ptr 对于这条语句，我们说ptr“指向”pooh。ptr和\u0026amp;pooh的区别是ptr是变量， 而\u0026amp;pooh是常量。或者，ptr是可修改的左值，而\u0026amp;pooh是右值。还可以把ptr 指向别处： ptr = \u0026amp;bah; // 把ptr指向bah，而不是pooh 现在ptr的值是bah的地址。 要创建指针变量，先要声明指针变量的类型。假设想把ptr声明为储存 int类型变量地址的指针，就要使用下面介绍的新运算符。\n9.7.1 间接运算符： * # 假设已知ptr指向bah，如下所示： ptr = \u0026amp;bah; 然后使用间接运算符*（indirection operator）找出储存在bah中的值，该 运算符有时也称为解引用运算符（dereferencing operator）。不要把间接运算 符和二元乘法运算符（*）混淆，虽然它们使用的符号相同，但语法功能不 同。 val = *ptr; // 找出ptr指向的值\n语句ptr = \u0026amp;bah;和val = *ptr;放在一起相当于下面的语句： val = bah; 由此可见，使用地址和间接运算符可以间接完成上面这条语句的功能， 这也是“间接运算符”名称的由来。 小结：与指针相关的运算符 地址运算符： \u0026amp; 一般注解： 后跟一个变量名时，\u0026amp;给出该变量的地址。 示例： \u0026amp;nurse表示变量nurse的地址。 地址运算符： ***** 一般注解： 后跟一个指针名或地址时，*给出储存在指针指向地址上的值。 示例： nurse = 22; ptr = \u0026amp;nurse; // 指向nurse的指针 val = *ptr; // 把ptr指向的地址上的值赋给val 执行以上 3 条语句的最终结果是把 22 赋给val。\n9.7.2 声明指针 # 相信读者已经很熟悉如何声明int类型和其他基本类型的变量，那么如何 声明指针变量？你也许认为是这样声明： pointer ptr; // 不能这样声明指针 为什么不能这样声明？因为声明指针变量时必须指定指针所指向变量的 类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操 作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。long和 float可能占用相同的存储空间，但是它们储存数字却大相径庭。下面是一些 指针的声明示例： int * pi; // pi是指向int类型变量的指针 char * pc; // pc是指向char类型变量的指针 float * pf, * pg; // pf、pg都是指向float类型变量的指针 类型说明符表明了指针所指向对象的类型，星号（*）表明声明的变量 是一个指针。int * pi;声明的意思是pi是一个指针，*pi是int类型（见图 9.5）。\n图9.5 声明并使用指针 *和指针名之间的空格可有可无。通常，程序员在声明时使用空格，在 解引用变量时省略空格。 pc指向的值（*pc）是char类型。pc本身是什么类型？我们描述它的类型 是“指向char类型的指针”。pc 的值是一个地址，在大部分系统内部，该地址 由一个无符号整数表示。但是，不要把指针认为是整数类型。一些处理整数 的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，但是不 能把两个指针相乘。所以，指针实际上是一个新类型，不是整数类型。因 此，如前所述，ANSI C专门为指针提供了%p格式的转换说明。\n9.7.3 使用指针在函数间通信 # 我们才刚刚接触指针，指针的世界丰富多彩。本节着重介绍如何使用指 # 针解决函数间的通信问题。请看程序清单9.15，该程序在interchange()函数中 使用了指针参数。稍后我们将对该程序做详细分析。 程序清单 9.15 swap3.c 程序 /* swap3.c \u0026ndash; 使用指针解决交换函数的问题 */ #include \u0026lt;stdio.h\u0026gt; void interchange(int * u, int * v); int main(void) { int x = 5, y = 10; printf(\u0026ldquo;Originally x = %d and y = %d.\\n\u0026rdquo;, x, y); interchange(\u0026amp;x, \u0026amp;y); // 把地址发送给函数\nprintf(\u0026ldquo;Now x = %d and y = %d.\\n\u0026rdquo;, x, y); return 0; } void interchange(int * u, int * v) { int temp; temp = *u; // temp获得 u 所指向对象的值 *u = *v; *v = temp; } 该程序是否能正常运行？下面是程序的输出： Originally x = 5　and y = 10. Now x = 10　and y = 5. 没问题，一切正常。接下来，我们分析程序清单9.15的运行情况。首先 看函数调用： interchange(\u0026amp;x, \u0026amp;y); 该函数传递的不是x和y的值，而是它们的地址。这意味着出现在 interchange()原型和定义中的形式参数u和v将把地址作为它们的值。因此， 应把它们声明为指针。由于x和y是整数，所以u和v是指向整数的指针，其声 明如下：\nvoid interchange (int * u, int * v) 接下来，在函数体中声明了一个交换值时必需的临时变量： int temp; 通过下面的语句把x的值储存在temp中： temp = u; 记住，u的值是\u0026amp;x，所以u指向x。这意味着用u即可表示x的值，这正是 我们需要的。不要写成这样： temp = u; /* 不要这样做 */ 因为这条语句赋给temp的是x的地址（u的值就是x的地址），而不是x的 值。函数要交换的是x和y的值，而不是它们的地址。 与此类似，把y的值赋给x，要使用下面的语句： *u = v; 这条语句相当于： x = y; 我们总结一下该程序示例做了什么。我们需要一个函数交换x和y的值。 把x和y的地址传递给函数，我们让interchange()访问这两个函数。使用指针 和运算符，该函数可以访问储存在这些位置的值并改变它们。 可以省略ANSI C风格的函数原型中的形参名，如下所示： void interchange(int *, int *); 一般而言，可以把变量相关的两类信息传递给函数。如果这种形式的函 数调用，那么传递的是x的值：\nfunction1(x); 如果下面形式的函数调用，那么传递的是x的地址： function2(\u0026amp;x); 第 1 种形式要求函数定义中的形式参数必须是一个与x的类型相同的变 量： int function1(int num) 第 2 种形式要求函数定义中的形式参数必须是一个指向正确类型的指 针： int function2(int * ptr) 如果要计算或处理值，那么使用第 1 种形式的函数调用；如果要在被调 函数中改变主调函数的变量，则使用第 2 种形式的函数调用。我们用过的 scanf()函数就是这样。当程序要把一个值读入变量时（如本例中的num）， 调用的是scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;num)。scanf()读取一个值，然后把该值储存到指定的 地址上。 对本例而言，指针让interchange()函数通过自己的局部变量改变main()中 变量的值。 熟悉Pascal和Modula-2的读者应该看出第 1 种形式和Pascal的值参数相 同，第 2 种形式和Pascal的变量参数类似。C++程序员可能认为，既然C和 C++都使用指针变量，那么C应该也有引用变量。让他们失望了，C没有引 用变量。对BASIC程序员而言，可能很难理解整个程序。如果觉得本节的内 容晦涩难懂，请多做一些相关的编程练习，你会发现指针非常简单实用（见 图9.6）。\n图9.6 按字节寻址系统（如PC）中变量的名称、地址和值 变量：名称、地址和值 通过前面的讨论发现，变量的名称、地址和变量的值之间关系密切。我 们来进一步分析。 编写程序时，可以认为变量有两个属性：名称和值（还有其他性质，如 类型，暂不讨论）。计算机编译和加载程序后，认为变量也有两个属性：地 址和值。地址就是变量在计算机内部的名称。 在许多语言中，地址都归计算机管，对程序员隐藏。然而在 C 中，可 以通过\u0026amp;运算符访问地址，通过运算符获得地址上的值。例如，\u0026amp;barn表示 变量barn的地址，使用函数名即可获得变量的数值。例如，printf(\u0026quot;%d\\n\u0026rdquo;, barn)打印barn的值，使用运算符即可获得储存在地址上的值。如果pbarn= \u0026amp;barn;，那么pbarn表示的是储存在\u0026amp;barn地址上的值。 简而言之，普通变量把值作为基本量，把地址作为通过\u0026amp;运算符获得的 派生量，而指针变量把地址作为基本量，把值作为通过运算符获得的派生 量。 虽然打印地址可以满足读者好奇心，但是这并不是\u0026amp;运算符的主要用 途。更重要的是使用\u0026amp;、*和指针可以操纵地址和地址上的内容，如swap3.c\n程序（程序清单9.15）所示。 # 小结：函数 # 形式： # 典型的ANSI C函数的定义形式为： # 返回类型 名称（形参声明列表） # 函数体 # 形参声明列表是用逗号分隔的一系列变量声明。除形参变量外，函数的 # 其他变量均在函数体的花括号之内声明。 # 示例： # int diff(int x, int y) // ANSI C { // 函数体开始 int z; // 声明局部变量 z = x - y; return z; // 返回一个值 } // 函数体结束 传递值： 实参用于把值从主调函数传递给被调函数。如果变量a和b的值分别是 5 和 2 ，那么调用： c = diff(a,b); 把 5 和 2 分别传递给变量x和y。 5 和 2 称为实际参数（简称实参），diff()函\n数定义中的变量x和y称为形式参数（简称形参）。使用关键字return把被调 函数中的一个值传回主调函数。本例中， c接受z的值 3 。被调函数一般不会 改变主调函数中的变量，如果要改变，应使用指针作为参数。如果希望把更 多的值传回主调函数，必须这么做。 函数的返回类型： 函数的返回类型指的是函数返回值的类型。如果返回值的类型与声明的 返回类型不匹配，返回值将被转换成函数声明的返回类型。 函数签名： 函数的返回类型和形参列表构成了函数签名。因此，函数签名指定了传 入函数的值的类型和函数返回值的类型。 示例： double duff(double, int); // 函数原型 int main(void) { double q, x; int n; \u0026hellip; q = duff(x,n); //函数调用 \u0026hellip; } double duff(double u, int k) //函数定义\n{ # double tor; \u0026hellip; return tor; //返回double类型的值 }\n9.8 关键概念 # 如果想用C编出高效灵活的程序，必须理解函数。把大型程序组织成若 # 干函数非常有用，甚至很关键。如果让一个函数处理一个任务，程序会更好 # 理解，更方便调试。要理解函数是如何把信息从一个函数传递到另一函数， # 也就是说，要理解函数参数和返回值的工作原理。另外，要明白函数形参和 # 其他局部变量都属于函数私有，因此，声明在不同函数中的同名变量是完全 # 不同的变量。而且，函数无法直接访问其他函数中的变量。这种限制访问保 # 护了数据的完整性。但是，当确实需要在函数中访问另一个函数的数据时， # 可以把指针作为函数的参数。 # 9.9 本章小结 # 函数可以作为组成大型程序的构件块。每个函数都应该有一个单独且定 # 义好的功能。使用参数把值传给函数，使用关键字return把值返回函数。如 果函数返回的值不是int类型，则必须在函数定义和函数原型中指定函数的类 型。如果需要在被调函数中修改主调函数的变量，使用地址或指针作为参 数。 ANSI C提供了一个强大的工具——函数原型，允许编译器验证函数调 用中使用的参数个数和类型是否正确。 C 函数可以调用本身，这种调用方式被称为递归。一些编程问题要用递 归来解决，但是递归不仅消耗内存多，效率不高，而且费时。\n9.10 复习题 # 复习题的参考答案在附录A中。 # 1.实际参数和形式参数的区别是什么？ # 2.根据下面各函数的描述，分别编写它们的ANSI C函数头。注意，只需 # 写出函数头，不用写函数体。 # a.donut()接受一个int类型的参数，打印若干（参数指定数目）个 0 b.gear()接受两个int类型的参数，返回int类型的值 c.guess()不接受参数，返回一个int类型的值 d.stuff_it()接受一个double类型的值和double类型变量的地址，把第 1 个 值储存在指定位置 3.根据下面各函数的描述，分别编写它们的ANSI C函数头。注意，只需 写出函数头，不用写函数体。 a.n_to_char()接受一个int类型的参数，返回一个char类型的值 b.digit()接受一个double类型的参数和一个int类型的参数，返回一个int类 型的值 c.which()接受两个可储存double类型变量的地址，返回一个double类型 的地址 d.random()不接受参数，返回一个int类型的值 4.设计一个函数，返回两整数之和。 5.如果把复习题 4 改成返回两个double类型的值之和，应如何修改函数？ 6.设计一个名为alter()的函数，接受两个int类型的变量x和y，把它们的\n值分别改成两个变量之和以及两变量之差。 # 7.下面的函数定义是否正确？ # void salami(num) { int num, count; for (count = 1; count \u0026lt;= num; num++) printf(\u0026rdquo; O salami mio!\\n\u0026quot;); } 8.编写一个函数，返回 3 个整数参数中的最大值。 9.给定下面的输出： Please choose one of the following:\ncopy files 2) move files remove files 4) quit Enter the number of your choice: a.编写一个函数，显示一份有 4 个选项的菜单，提示用户进行选择（输 出如上所示）。 b.编写一个函数，接受两个int类型的参数分别表示上限和下限。该函数 从用户的输入中读取整数。如果整数超出规定上下限，函数再次打印菜单 （使用a部分的函数）提示用户输入，然后获取一个新值。如果用户输入的 整数在规定范围内，该函数则把该整数返回主调函数。如果用户输入一个非 整数字符，该函数应返回 4 。 c.使用本题a和b部分的函数编写一个最小型的程序。最小型的意思是， 该程序不需要实现菜单中各选项的功能，只需显示这些选项并获取有效的响 应即可。\n9.11 编程练习 # 1.设计一个函数min(x, y)，返回两个double类型值的较小值。在一个简单 的驱动程序中测试该函数。 2.设计一个函数chline(ch, i, j)，打印指定的字符j行i列。在一个简单的驱 动程序中测试该函数。 3.编写一个函数，接受 3 个参数：一个字符和两个整数。字符参数是待 打印的字符，第 1 个整数指定一行中打印字符的次数，第 2 个整数指定打印指 定字符的行数。编写一个调用该函数的程序。 4.两数的调和平均数这样计算：先得到两数的倒数，然后计算两个倒数 的平均值，最后取计算结果的倒数。编写一个函数，接受两个double类型的 参数，返回这两个参数的调和平均数。 5.编写并测试一个函数larger_of()，该函数把两个double类型变量的值替 换为较大的值。例如， larger_of(x, y)会把x和y中较大的值重新赋给两个变 量。 6.编写并测试一个函数，该函数以 3 个double变量的地址作为参数，把最 小值放入第 1 个函数，中间值放入第 2 个变量，最大值放入第 3 个变量。 7.编写一个函数，从标准输入中读取字符，直到遇到文件结尾。程序要 报告每个字符是否是字母。如果是，还要报告该字母在字母表中的数值位 置。例如，c和C在字母表中的位置都是 3 。合并一个函数，以一个字符作为 参数，如果该字符是一个字母则返回一个数值位置，否则返回-1。 8.第 6 章的程序清单6.20中，power()函数返回一个double类型数的正整数 次幂。改进该函数，使其能正确计算负幂。另外，函数要处理 0 的任何次幂 都为 0 ，任何数的 0 次幂都为 1 （函数应报告 0 的 0 次幂未定义，因此把该值处 理为 1 ）。要使用一个循环，并在程序中测试该函数。\n9.使用递归函数重写编程练习 8 。 # 10.为了让程序清单9.8中的to_binary()函数更通用，编写一个to_base_n() 函数接受两个在 2 ～ 10 范围内的参数，然后以第 2 个参数中指定的进制打印第 1 个参数的数值。例如，to_base_n(129， 8)显示的结果为 201 ，也就是 129 的 八进制数。在一个完整的程序中测试该函数。 11.编写并测试Fibonacci()函数，该函数用循环代替递归计算斐波那契 数。\n第 10 章 数组和指针 # 本章介绍以下内容： # 关键字：static 运算符：\u0026amp;、*（一元） 如何创建并初始化数组 指针（在已学过的基础上）、指针和数组的关系 编写处理数组的函数 二维数组 人们通常借助计算机完成统计每月的支出、日降雨量、季度销售额等任 务。企业借助计算机管理薪资、库存和客户交易记录等。作为程序员，不可 避免地要处理大量相关数据。通常，数组能高效便捷地处理这种数据。第 6 章简单地介绍了数组，本章将进一步地学习如何使用数组，着重分析如何编 写处理数组的函数。这种函数把模块化编程的优势应用到数组。通过本章的 学习，你将明白数组和指针关系密切。\n10.1 数组 # 前面介绍过，数组由数据类型相同的一系列元素组成。需要使用数组 # 时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译 # 器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可 # 以用。考虑下面的数组声明： # /* 一些数组声明*/ # int main(void) { float candy[365]; /* 内含 365 个float类型元素的数组 */ char code[12]; /内含 12 个char类型元素的数组/ int states[50]; /*内含 50 个int类型元素的数组 */ \u0026hellip; } 方括号（[]）表明candy、code和states都是数组，方括号中的数字表明 数组中的元素个数。 要访问数组中的元素，通过使用数组下标数（也称为索引）表示数组中 的各元素。数组元素的编号从 0 开始，所以candy[0]表示candy数组的第 1 个元 素，candy[364]表示第 365 个元素，也就是最后一个元素。读者对这些内容应 该比较熟悉，下面我们介绍一些新内容。\n10.1.1 初始化数组 # 数组通常被用来储存程序需要的数据。例如，一个内含 12 个整数元素的 # 数组可以储存 12 个月的天数。在这种情况下，在程序一开始就初始化数组比 # 较好。下面介绍初始化数组的方法。 # 只储存单个值的变量有时也称为标量变量（scalar variable），我们已经 很熟悉如何初始化这种变量： int fix = 1; float flax = PI * 2; 代码中的PI已定义为宏。C使用新的语法来初始化数组，如下所示： int main(void) { int powers[8] = {1,2,4,6,8,16,32,64}; /* 从ANSI C开始支持这种初始化 / \u0026hellip; } 如上所示，用以逗号分隔的值列表（用花括号括起来）来初始化数组， 各值之间用逗号分隔。在逗号和值之间可以使用空格。根据上面的初始化， 把 1 赋给数组的首元素（powers[0]），以此类推（不支持ANSI的编译器会 把这种形式的初始化识别为语法错误，在数组声明前加上关键字static可解 决此问题。第 12 章将详细讨论这个关键字）。 程序清单10.1演示了一个小程序，打印每个月的天数。 程序清单 10.1 day_mon1.c 程序 / day_mon1.c \u0026ndash; 打印每个月的天数 */ #include \u0026lt;stdio.h\u0026gt; #define MONTHS 12\nint main(void) { int days[MONTHS] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31　}; int index; for (index = 0; index \u0026lt; MONTHS; index++) printf(\u0026ldquo;Month %2d has %2d days.\\n\u0026rdquo;, index + 1, days[index]); return 0; } 该程序的输出如下： Month 1　has 31　days. Month 2　has 28　days. Month 3　has 31　days. Month 4　has 30　days. Month 5　has 31　days. Month 6　has 30　days. Month 7　has 31　days. Month 8　has 31　days. Month 9　has 30　days.\nMonth 10　has 31　days. Month 11　has 30　days. Month 12　has 31　days. 这个程序还不够完善，每 4 年打错一个月份的天数（即， 2 月份的天 数）。该程序用初始化列表初始化days[]，列表（用花括号括起来）中用逗 号分隔各值。 注意该例使用了符号常量 MONTHS 表示数组大小，这是我们推荐且常 用的做法。例如，如果要采用一年 13 个月的记法，只需修改#define这行代码 即可，不用在程序中查找所有使用过数组大小的地方。 注意 使用 const 声明数组 有时需要把数组设置为只读。这样，程序只能从数组中检索值，不能把 新值写入数组。要创建只读数组，应该用const声明和初始化数组。因此， 程序清单10.1中初始化数组应改成： const int days[MONTHS] = {31,28,31,30,31,30,31,31,30,31,30,31}; 这样修改后，程序在运行过程中就不能修改该数组中的内容。和普通变 量一样，应该使用声明来初始化 const 数据，因为一旦声明为 const，便不能 再给它赋值。明确了这一点，就可以在后面的例子中使用const了。 如果初始化数组失败怎么办？程序清单10.2演示了这种情况。 程序清单 10.2 no_data.c 程序 /* no_data.c \u0026ndash; 为初始化数组 */ #include \u0026lt;stdio.h\u0026gt; #define SIZE 4\nint main(void) { int no_data[SIZE]; /* 未初始化数组 */ int i; printf(\u0026quot;%2s%14s\\n\u0026quot;, \u0026ldquo;i\u0026rdquo;, \u0026ldquo;no_data[i]\u0026rdquo;); for (i = 0; i \u0026lt; SIZE; i++) printf(\u0026quot;%2d%14d\\n\u0026quot;, i, no_data[i]); return 0; } 该程序的输出如下（系统不同，输出的结果可能不同）： i no_data[i] 0　0 1　4204937 2　4219854 3　2147348480 使用数组前必须先初始化它。与普通变量类似，在使用数组元素之前， 必须先给它们赋初值。编译器使用的值是内存相应位置上的现有值，因此， 读者运行该程序后的输出会与该示例不同。 注意 存储类别警告 数组和其他变量类似，可以把数组创建成不同的存储类别（storage\nclass）。第 12 章将介绍存储类别的相关内容，现在只需记住：本章描述的数 组属于自动存储类别，意思是这些数组在函数内部声明，且声明时未使用关 键字static。到目前为止，本书所用的变量和数组都是自动存储类别。 在这里提到存储类别的原因是，不同的存储类别有不同的属性，所以不 能把本章的内容推广到其他存储类别。对于一些其他存储类别的变量和数 组，如果在声明时未初始化，编译器会自动把它们的值设置为 0 。 初始化列表中的项数应与数组的大小一致。如果不一致会怎样？我们还 是以上一个程序为例，但初始化列表中缺少两个元素，如程序清单10.3所 示： 程序清单 10.3 somedata.c 程序 /* some_data.c \u0026ndash; 部分初始化数组 */ #include \u0026lt;stdio.h\u0026gt; #define SIZE 4 int main(void) { int some_data[SIZE] = { 1492, 1066　}; int i; printf(\u0026quot;%2s%14s\\n\u0026quot;, \u0026ldquo;i\u0026rdquo;, \u0026ldquo;some_data[i]\u0026rdquo;); for (i = 0; i \u0026lt; SIZE; i++) printf(\u0026quot;%2d%14d\\n\u0026quot;, i, some_data[i]); return 0;\n} # 下面是该程序的输出： # i some_data[i] 0　1492 1　1066 2　0 3　0 如上所示，编译器做得很好。当初始化列表中的值少于数组元素个数 时，编译器会把剩余的元素都初始化为 0 。也就是说，如果不初始化数组， 数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；但是，如果 部分初始化数组，剩余的元素就会被初始化为 0 。 如果初始化列表的项数多于数组元素个数，编译器可没那么仁慈，它会 毫不留情地将其视为错误。但是，没必要因此嘲笑编译器。其实，可以省略 方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数（见程 序清单10.4） 程序清单 10.4 day_mon2.c 程序 /* day_mon2.c \u0026ndash; 让编译器计算元素个数 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { const int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31　};\nint index; for (index = 0; index \u0026lt; sizeof days / sizeof days[0]; index++) printf(\u0026ldquo;Month %2d has %d days.\\n\u0026rdquo;, index + 1, days[index]); return 0; } 在程序清单10.4中，要注意以下两点。 如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的 项数来确定数组的大小。 注意for循环中的测试条件。由于人工计算容易出错，所以让计算机来 计算数组的大小。sizeof运算符给出它的运算对象的大小（以字节为单 位）。所以sizeof days是整个数组的大小（以字节为单位），sizeof day[0]是 数组中一个元素的大小（以字节为单位）。整个数组的大小除以单个元素的 大小就是数组元素的个数。 下面是该程序的输出： Month 1　has 31　days. Month 2　has 28　days. Month 3　has 31　days. Month 4　has 30　days. Month 5　has 31　days. Month 6　has 30　days.\nMonth 7　has 31　days. Month 8　has 31　days. Month 9　has 30　days. Month 10　has 31　days. 我们的本意是防止初始化值的个数超过数组的大小，让程序找出数组大 小。我们初始化时用了 10 个值，结果就只打印了 10 个值！这就是自动计数的 弊端：无法察觉初始化列表中的项数有误。 还有一种初始化数组的方法，但这种方法仅限于初始化字符数组。我们 在下一章中介绍。\n10.1.2 指定初始化器（ C99 ） # C99 增加了一个新特性：指定初始化器（designated initializer）。利用 该特性可以初始化指定的数组元素。例如，只初始化数组中的最后一个元 素。对于传统的C初始化语法，必须初始化最后一个元素之前的所有元素， 才能初始化它： int arr[6] = {0,0,0,0,0,212}; // 传统的语法 而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的 元素： int arr[6] = {[5] = 212}; // 把arr[5]初始化为 212 对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置 为 0 。程序清单10.5中的初始化比较复杂。 程序清单 10.5 designate.c 程序 // designate.c \u0026ndash; 使用指定初始化器\n#include \u0026lt;stdio.h\u0026gt; #define MONTHS 12 int main(void) { int days[MONTHS] = { 31, 28, [4] = 31, 30, 31, [1] = 29　}; int i; for (i = 0; i \u0026lt; MONTHS; i++) printf(\u0026quot;%2d %d\\n\u0026quot;, i + 1, days[i]); return 0; } 该程序在支持C99的编译器中输出如下： 1　31 2　29 3　0 4　0 5　31 6　30 7　31\n8　0 # 9　0 # 10　0 # 11　0 # 12　0 # 以上输出揭示了指定初始化器的两个重要特性。第一，如果指定初始化 # 器后面有更多的值，如该例中的初始化列表中的片段：[4] = 31,30,31，那么 # 后面这些值将被用于初始化指定元素后面的元素。也就是说，在days[4]被初 始化为 31 后，days[5]和days[6]将分别被初始化为 30 和 31 。第二，如果再次初 始化指定的元素，那么最后的初始化将会取代之前的初始化。例如，程序清 单10.5中，初始化列表开始时把days[1]初始化为 28 ，但是days[1]又被后面的 指定初始化[1] = 29初始化为 29 。 如果未指定元素大小会怎样？ int stuff[] = {1, [6] = 23}; //会发生什么？ int staff[] = {1, [6] = 4, 9, 10}; //会发生什么？ 编译器会把数组的大小设置为足够装得下初始化的值。所以，stuff数组 有 7 个元素，编号为 0 ～ 6 ；而staff数组的元素比stuff数组多两个（即有 9 个元 素）。\n10.1.3 给数组元素赋值 # 声明数组后，可以借助数组下标（或索引）给数组元素赋值。例如，下 # 面的程序段给数组的所有元素赋值： # /* 给数组的元素赋值 */ # #include \u0026lt;stdio.h\u0026gt; #define SIZE 50 int main(void) { int counter, evens[SIZE]; for (counter = 0; counter \u0026lt; SIZE; counter++) evens[counter] = 2　* counter; \u0026hellip; } 注意这段代码中使用循环给数组的元素依次赋值。C 不允许把数组作为 一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋 值。下面的代码段演示了一些错误的赋值形式: /* 一些无效的数组赋值 / #define SIZE 5 int main(void) { int oxen[SIZE] = {5,3,2,8}; / 初始化没问题 / int yaks[SIZE]; yaks = oxen; / 不允许 / yaks[SIZE] = oxen[SIZE]; / 数组下标越界 */\nyaks[SIZE] = {5,3,2,8}; /* 不起作用 */ oxen数组的最后一个元素是oxen[SIZE-1]，所以oxen[SIZE]和yaks[SIZE] 都超出了两个数组的末尾。\n10.1.4 数组边界 # 在使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是 # 有效的值。例如，假设有下面的声明： # int doofi[20]; 那么在使用该数组时，要确保程序中使用的数组下标在 0 ～ 19 的范围 内，因为编译器不会检查出这种错误（但是，一些编译器发出警告，然后继 续编译程序）。 考虑程序清单10.6的问题。该程序创建了一个内含 4 个元素的数组，然 后错误地使用了-1～ 6 的下标。 程序清单 10.6 bounds.c 程序 // bounds.c \u0026ndash; 数组下标越界 #include \u0026lt;stdio.h\u0026gt; #define SIZE 4 int main(void) { int value1 = 44; int arr[SIZE]; int value2 = 88;\nint i; printf(\u0026ldquo;value1 = %d, value2 = %d\\n\u0026rdquo;, value1, value2); for (i = -1; i \u0026lt;= SIZE; i++) arr[i] = 2 * i + 1; for (i = -1; i \u0026lt; 7; i++) printf(\u0026quot;%2d %d\\n\u0026quot;, i, arr[i]); printf(\u0026ldquo;value1 = %d, value2 = %d\\n\u0026rdquo;, value1, value2); printf(\u0026ldquo;address of arr[-1]: %p\\n\u0026rdquo;, \u0026amp;arr[-1]); printf(\u0026ldquo;address of arr[4]: %p\\n\u0026rdquo;, \u0026amp;arr[4]); printf(\u0026ldquo;address of value1: %p\\n\u0026rdquo;, \u0026amp;value1); printf(\u0026ldquo;address of value2: %p\\n\u0026rdquo;, \u0026amp;value2); return 0; } 编译器不会检查数组下标是否使用得当。在C标准中，使用越界下标的 结果是未定义的。这意味着程序看上去可以运行，但是运行结果很奇怪，或 异常中止。下面是使用GCC的输出示例： value1 = 44, value2 = 88 -1 -1 0　1 1　3\n2　5 # 3　7 # 4　9 # 5　1624678494 # 6　32767 # value1 = 9, value2 = -1 address of arr[-1]: 0x7fff5fbff8cc address of arr[4]: 0x7fff5fbff8e0 address of value1: 0x7fff5fbff8e0 address of value2: 0x7fff5fbff8cc 注意，该编译器似乎把value2储存在数组的前一个位置，把value1储存 在数组的后一个位置（其他编译器在内存中储存数据的顺序可能不同）。在 上面的输出中，arr[-1]与value2对应的内存地址相同， arr[4]和value1对应的 内存地址相同。因此，使用越界的数组下标会导致程序改变其他变量的值。 不同的编译器运行该程序的结果可能不同，有些会导致程序异常中止。 C 语言为何会允许这种麻烦事发生？这要归功于 C 信任程序员的原 则。不检查边界，C 程序可以运行更快。编译器没必要捕获所有的下标错 误，因为在程序运行之前，数组的下标值可能尚未确定。因此，为安全起 见，编译器必须在运行时添加额外代码检查数组的每个下标值，这会降低程 序的运行速度。C 相信程序员能编写正确的代码，这样的程序运行速度更 快。但并不是所有的程序员都能做到这一点，所以就出现了下标越界的问 题。 还要记住一点：数组元素的编号从 0 开始。最好是在声明数组时使用符\n号常量来表示数组的大小： # #define SIZE 4 int main(void) { int arr[SIZE]; for (i = 0; i \u0026lt; SIZE; i++) .... 这样做能确保整个程序中的数组大小始终一致。 10.1.5 指定数组的大小 # 本章前面的程序示例都使用整型常量来声明数组： # #define SIZE 4 int main(void) { int arr[SIZE]; // 整数符号常量 double lots[144]; // 整数字面常量 \u0026hellip; 在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所 谓整型常量表达式，是由整型常量构成的表达式。sizeof表达式被视为整型 常量，但是（与C++不同）const值不是。另外，表达式的值必须大于 0 ： int n = 5;\nint m = 8; float a1[5]; // 可以 float a2[5*2 + 1]; //可以 float a3[sizeof(int) + 1]; //可以 float a4[-4]; // 不可以，数组大小必须大于 0 float a5[0]; // 不可以，数组大小必须大于 0 float a6[2.5]; // 不可以，数组大小必须是整数 float a7[(int)2.5]; // 可以，已被强制转换为整型常量 float a8[n]; // C99之前不允许 float a9[m]; // C99之前不允许 上面的注释表明，以前支持C90标准的编译器不允许后两种声明方式。 而C99标准允许这样声明，这创建了一种新型数组，称为变长数组 （variable-length array）或简称 VLA（C11 放弃了这一创新的举措，把VLA 设定为可选，而不是语言必备的特性）。 C99引入变长数组主要是为了让C成为更好的数值计算语言。例如， VLA简化了把FORTRAN现有的数值计算例程库转换为C代码的过程。VLA有 一些限制，例如，声明VLA时不能进行初始化。在充分了解经典的C数组 后，我们再详细介绍VLA。\n10.2 多维数组 # 气象研究员Tempest Cloud为完成她的研究项目要分析 5 年内每个月的降 水量数据，她首先要解决的问题是如何表示数据。一个方案是创建 60 个变 量，每个变量储存一个数据项（我们曾经提到过这一笨拙的方案，和以前一 样，这个方案并不合适）。使用一个内含 60 个元素的数组比将建 60 个变量 好，但是如果能把各年的数据分开储存会更好，即创建 5 个数组，每个数组 12 个元素。然而，这样做也很麻烦，如果Tempest决定研究 50 年的降水量， 岂不是要创建 50 个数组。是否能有更好的方案？ 处理这种情况应该使用数组的数组。主数组（master array）有 5 个元素 （每个元素表示一年），每个元素是内含 12 个元素的数组（每个元素表示一 个月）。下面是该数组的声明： float rain[5][12]; // 内含 5 个数组元素的数组，每个数组元素内含 12 个 float类型的元素 理解该声明的一种方法是，先查看中间部分（粗体部分）： float rain[5][12]; // rain是一个内含 5 个元素的数组 这说明数组rain有 5 个元素，至于每个元素的情况，要查看声明的其余 部分（粗体部分）： floatrain[5][12] ; // 一个内含 12 个float类型元素的数组 这说明每个元素的类型是float[12]，也就是说，rain的每个元素本身都 是一个内含 12 个float类型值的数组。 根据以上分析可知，rain的首元素rain[0]是一个内含 12 个float类型值的 数组。所以，rain[1]、rain[2]等也是如此。如果 rain[0]是一个数组，那么它 的首元素就是 rain[0][0]，第 2 个元素是rain[0][1]，以此类推。简而言之， 数组rain有 5 个元素，每个元素都是内含 12 个float类型元素的数组，rain[0]是\n内含 12 个float值的数组，rain[0][0]是一个float类型的值。假设要访问位于 2 行 3 列的值，则使用rain[2][3]（记住，数组元素的编号从 0 开始，所以 2 行指 的是第 3 行）。\n图10.1 二维数组 该二维视图有助于帮助读者理解二维数组的两个下标。在计算机内部， 这样的数组是按顺序储存的，从第 1 个内含 12 个元素的数组开始，然后是第 2 个内含 12 个元素的数组，以此类推。 我们要在气象分析程序中用到这个二维数组。该程序的目标是，计算每 年的总降水量、年平均降水量和月平均降水量。要计算年总降水量，必须对 一行数据求和；要计算某月份的平均降水量，必须对一列数据求和。二维数 组很直观，实现这些操作也很容易。程序清单10.7演示了这个程序。 程序清单 10.7 rain.c 程序 /* rain.c \u0026ndash; 计算每年的总降水量、年平均降水量和 5 年中每月的平均降 水量 */ #include \u0026lt;stdio.h\u0026gt;\n#define MONTHS 12 // 一年的月份数 #define YEARS 5　// 年数 int main(void) { // 用 2010 ～ 2014 年的降水量数据初始化数组 const float rain[YEARS][MONTHS] = { { 4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6 }, { 8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.3 }, { 9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.1, 8.4 }, { 7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 6.2 }, { 7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 5.2 } }; int year, month; float subtot, total; printf(\u0026quot; YEAR RAINFALL (inches)\\n\u0026quot;);\nfor (year = 0, total = 0; year \u0026lt; YEARS; year++) { // 每一年，各月的降水量总和 for (month = 0, subtot = 0; month \u0026lt; MONTHS; month++) subtot += rain[year][month]; printf(\u0026quot;%5d %15.1f\\n\u0026quot;, 2010　+ year, subtot); total += subtot; // 5年的总降水量 } printf(\u0026quot;\\nThe yearly average is %.1f inches.\\n\\n\u0026quot;, total / YEARS); printf(\u0026ldquo;MONTHLY AVERAGES:\\n\\n\u0026rdquo;); printf(\u0026quot; Jan Feb Mar Apr May Jun Jul Aug Sep Oct \u0026ldquo;); printf(\u0026rdquo; Nov Dec\\n\u0026quot;); for (month = 0; month \u0026lt; MONTHS; month++) { // 每个月， 5 年的总降水量 for (year = 0, subtot = 0; year \u0026lt; YEARS; year++) subtot += rain[year][month]; printf(\u0026quot;%4.1f \u0026ldquo;, subtot / YEARS); } printf(\u0026quot;\\n\u0026rdquo;);\nreturn 0; } 下面是该程序的输出： YEAR RAINFALL (inches) 2010　32.4 2011　37.9 2012　49.8 2013　44.0 2014　32.9 The yearly average is 39.4 inches. MONTHLY AVERAGES: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec 7.3 7.3 4.9 3.0 2.3 0.6 1.2 0.3 0.5 1.7 3.6 6.7 学习该程序的重点是数组初始化和计算方案。初始化二维数组比较复 杂，我们先来看较为简单的计算部分。 程序使用了两个嵌套for循环。第 1 个嵌套for循环的内层循环，在year不 变的情况下，遍历month计算某年的总降水量；而外层循环，改变year的 值，重复遍历month，计算 5 年的总降水量。这种嵌套循环结构常用于处理二 维数组，一个循环处理数组的第 1 个下标，另一个循环处理数组的第 2 个下 标： for (year = 0, total = 0; year \u0026lt; YEARS; year++)\n{ // 处理每一年的数据 # for (month = 0, subtot = 0; month \u0026lt; MONTHS; month++) \u0026hellip;// 处理每月的数据 \u0026hellip;//处理每一年的数据 } 第 2 个嵌套for循环和第 1 个的结构相同，但是内层循环遍历year，外层循 环遍历month。记住，每执行一次外层循环，就完整遍历一次内层循环。因 此，在改变月份之前，先遍历完年，得到某月 5 年间的平均降水量，以此类 推： for (month = 0; month \u0026lt; MONTHS; month++) { // 处理每月的数据 for (year = 0, subtot =0; year \u0026lt; YEARS; year++) \u0026hellip;// 处理每年的数据 \u0026hellip;// 处理每月的数据 }\n10.2.1 初始化二维数组 # 初始化二维数组是建立在初始化一维数组的基础上。首先，初始化一维 # 数组如下： # sometype ar1[5] = {val1, val2, val3, val4, val5}; 这里，val1、val2等表示sometype类型的值。例如，如果sometype是int， 那么val1可能是 7 ；如果sometype是double，那么val1可能是11.34，诸如此\n类。但是rain是一个内含 5 个元素的数组，每个元素又是内含 12 个float类型元 素的数组。所以，对rain而言，val1应该包含 12 个值，用于初始化内含 12 个 float类型元素的一维数组，如下所示： {4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6} 也就是说，如果sometype是一个内含 12 个double类型元素的数组，那么 val1就是一个由 12 个double类型值构成的数值列表。因此，为了初始化二维 数组rain，要用逗号分隔 5 个这样的数值列表： const float rain[YEARS][MONTHS] = { {4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6}, {8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3}, {9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4}, {7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2}, {7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2} }; 这个初始化使用了 5 个数值列表，每个数值列表都用花括号括起来。第 1 个列表的数据用于初始化数组的第 1 行，第 2 个列表的数据用于初始化数组的 第 2 行，以此类推。前面讨论的数据个数和数组大小不匹配的问题同样适用 于这里的每一行。也就是说，如果第 1 个列表中只有 10 个数，则只会初始化 数组第 1 行的前 10 个元素，而最后两个元素将被默认初始化为 0 。如果某列表 中的数值个数超出了数组每行的元素个数，则会出错，但是这并不会影响其 他行的初始化。 初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保\n证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数 # 值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始 # 化的元素被统一初始化为 0 。图10.2演示了这种初始化数组的方法。 # 图10.2 初始化二维数组的两种方法 因为储存在数组rain中的数据不能修改，所以程序使用了const关键字声 明该数组。\n10.2.2 其他多维数组 # 前面讨论的二维数组的相关内容都适用于三维数组或更多维的数组。可 # 以这样声明一个三维数组： # int box[10][20][30]; 可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数 组想象成一叠数据表。例如，把上面声明的三维数组box想象成由 10 个二维 数组（每个二维数组都是 20 行 30 列）堆叠起来。 还有一种理解box的方法是，把box看作数组的数组。也就是说，box内 含 10 个元素，每个元素是内含 20 个元素的数组，这 20 个数组元素中的每个元 素是内含 30 个元素的数组。或者，可以简单地根据所需的下标值去理解数 组。 通常，处理三维数组要使用 3 重嵌套循环，处理四维数组要使用 4 重嵌套 循环。对于其他多维数组，以此类推。在后面的程序示例中，我们只使用二 维数组。\n10.3 指针和数组 # 第 9 章介绍过指针，指针提供一种以符号形式使用地址的方法。因为计 # 算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令 # 以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针 # 能有效地处理数组。我们很快就会学到，数组表示法其实是在变相地使用指 # 针。 # 我们举一个变相使用指针的例子：数组名是数组首元素的地址。也就是 # 说，如果flizny是一个数组，下面的语句成立： flizny == \u0026amp;flizny[0]; // 数组名是该数组首元素的地址 flizny 和\u0026amp;flizny[0]都表示数组首元素的内存地址（\u0026amp;是地址运算符）。 两者都是常量，在程序的运行过程中，不会改变。但是，可以把它们赋值给 指针变量，然后可以修改指针变量的值，如程序清单10.8所示。注意指针加 上一个数时，它的值发生了什么变化（转换说明%p通常以十六进制显示指 针的值）。 程序清单 10.8 pnt_add.c 程序 // pnt_add.c \u0026ndash; 指针地址 #include \u0026lt;stdio.h\u0026gt; #define SIZE 4 int main(void) { short dates[SIZE]; short * pti;\nshort index; double bills[SIZE]; double * ptf; pti = dates; // 把数组地址赋给指针 ptf = bills; printf(\u0026quot;%23s %15s\\n\u0026quot;, \u0026ldquo;short\u0026rdquo;, \u0026ldquo;double\u0026rdquo;); for (index = 0; index \u0026lt; SIZE; index++) printf(\u0026ldquo;pointers + %d: %10p %10p\\n\u0026rdquo;, index, pti + index, ptf + index); return 0; } 下面是该例的输出示例： short double pointers + 0: 0x7fff5fbff8dc 0x7fff5fbff8a0 pointers + 1: 0x7fff5fbff8de 0x7fff5fbff8a8 pointers + 2: 0x7fff5fbff8e0 0x7fff5fbff8b0 pointers + 3: 0x7fff5fbff8e2 0x7fff5fbff8b8 第 2 行打印的是两个数组开始的地址，下一行打印的是指针加 1 后的地 址，以此类推。注意，地址是十六进制的，因此dd比dc大 1 ，a1比a0大 1 。但 是，显示的地址是怎么回事？\n0x7fff5fbff8dc + 1是否是0x7fff5fbff8de? 0x7fff5fbff8a0 + 1是否是0x7fff5fbff8a8? 我们的系统中，地址按字节编址，short类型占用 2 字节，double类型占 用 8 字节。在C中，指针加 1 指的是增加一个存储单元。对数组而言，这意味 着把加 1 后的地址是下一个元素的地址，而不是下一个字节的地址（见图 10.3）。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址 不够，因为计算机要知道储存对象需要多少字节（即使指针指向的是标量变 量，也要知道变量的类型，否则*pt 就无法正确地取回地址上的值）。\n图10.3 数组和指针加法 现在可以更清楚地定义指向int的指针、指向float的指针，以及指向其他 数据对象的指针。 指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的\n硬件。许多计算机（包括PC和Macintosh）都是按字节编址，意思是内存中 的每个字节都按顺序编号。这里，一个较大对象的地址（如double类型的变 量）通常是该对象第一个字节的地址。 在指针前面使用运算符可以得到该指针所指向对象的值。 指针加 1 ，指针的值递增它所指向类型的大小（以字节为单位）。 下面的等式体现了C语言的灵活性： dates + 2 == \u0026amp;date[2] // 相同的地址 (dates + 2) == dates[2] // 相同的值 以上关系表明了数组和指针的关系十分密切，可以使用指针标识数组的 元素和获得元素的值。从本质上看，同一个对象有两种表示法。实际上，C 语言标准在描述数组表示法时确实借助了指针。也就是说，定义ar[n]的意思 是(ar + n)。可以认为(ar + n)的意思是“到内存的ar位置，然后移动n个单 元，检索储存在那里的值”。 顺带一提，不要混淆 (dates+2)和dates+2。间接运算符（）的优先级 高于+，所以dates+2相当于(*dates)+2： *(dates + 2) // dates第 3 个元素的值 dates + 2 // dates第 1 个元素的值加 2 明白了数组和指针的关系，便可在编写程序时适时使用数组表示法或指 针表示法。运行程序清单 10.9后输出的结果和程序清单10.1输出的结果相 同。 程序清单 10.9 day_mon3.c 程序 / day_mon3.c \u0026ndash; uses pointer notation */\n#include \u0026lt;stdio.h\u0026gt; #define MONTHS 12 int main(void) { int days[MONTHS] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31　}; int index; for (index = 0; index \u0026lt; MONTHS; index++) printf(\u0026ldquo;Month %2d has %d days.\\n\u0026rdquo;, index + 1, (days + index)); //与 days[index]相同 return 0; } 这里，days是数组首元素的地址，days + index是元素days[index]的地 址，而(days + index)则是该元素的值，相当于days[index]。for循环依次引用 数组中的每个元素，并打印各元素的内容。 这样编写程序是否有优势？不一定。编译器编译这两种写法生成的代码 相同。程序清单 10.9 要注意的是，指针表示法和数组表示法是两种等效的 方法。该例演示了可以用指针表示数组，反过来，也可以用数组表示指针。 在使用以数组为参数的函数时要注意这点。\n10.4 函数、数组和指针 # 假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待 # 处理的是名为marbles的int类型数组。应该如何调用该函数？也许是下面这 样： total = sum(marbles); // 可能的函数调用 那么，该函数的原型是什么？记住，数组名是该数组首元素的地址，所 以实际参数marbles是一个储存int类型值的地址，应把它赋给一个指针形式 参数，即该形参是一个指向int的指针： int sum(int * ar); // 对应的函数原型 sum()从该参数获得了什么信息？它获得了该数组首元素的地址，知道 要在该位置上找出一个整数。注意，该参数并未包含数组元素个数的信息。 我们有两种方法让函数获得这一信息。第一种方法是，在函数代码中写上固 定的数组大小： int sum(int * ar) // 相应的函数定义 { int i; int total = 0; for (i = 0; i \u0026lt; 10; i++) // 假设数组有 10 个元素 total += ar[i]; // ar[i] 与 *(ar + i) 相同 return total; }\n既然能使用指针表示数组名，也可以用数组名表示指针。另外，回忆一 # 下，+=运算符把右侧运算对象加到左侧运算对象上。因此，total是当前数组 元素之和。 该函数定义有限制，只能计算 10 个int类型的元素。另一个比较灵活的方 法是把数组大小作为第 2 个参数： int sum(int * ar, int n) // 更通用的方法 { int i; int total = 0; for (i = 0; i \u0026lt; n; i++) // 使用 n 个元素 total += ar[i]; // ar[i] 和 *(ar + i) 相同 return total; } 这里，第 1 个形参告诉函数该数组的地址和数据类型，第 2 个形参告诉函 数该数组中元素的个数。 关于函数的形参，还有一点要注意。只有在函数原型或函数定义头中， 才可以用int ar[]代替int * ar： int sum (int ar[], int n); int *ar形式和int ar[]形式都表示ar是一个指向int的指针。但是，int ar[]只 能用于声明形式参数。第 2 种形式（int ar[]）提醒读者指针ar指向的不仅仅 一个int类型值，还是一个int类型数组的元素。 注意 声明数组形参\n因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参 # 数是一个与之匹配的指针。只有在这种情况下，C才会把int ar[]和int * ar解 释成一样。也就是说，ar是指向int的指针。由于函数原型可以省略参数名， 所以下面 4 种原型都是等价的： int sum(int *ar, int n); int sum(int *, int); int sum(int ar[], int n); int sum(int [], int); 但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价： int sum(int *ar, int n) { // 其他代码已省略 } int sum(int ar[], int n); { //其他代码已省略 } 可以使用以上提到的任意一种函数原型和函数定义。 程序清单 10.10 演示了一个程序，使用 sum()函数。该程序打印原始数 组的大小和表示该数组的函数形参的大小（如果你的编译器不支持用转换说 明%zd打印sizeof返回值，可以用%u或%lu来代替）。\n程序清单 10.10 sum_arr1.c 程序 // sum_arr1.c \u0026ndash; 数组元素之和 // 如果编译器不支持 %zd，用 %u 或 %lu 替换它 #include \u0026lt;stdio.h\u0026gt; #define SIZE 10 int sum(int ar[], int n); int main(void) { int marbles[SIZE] = { 20, 10, 5, 39, 4, 16, 19, 26, 31, 20　}; long answer; answer = sum(marbles, SIZE); printf(\u0026ldquo;The total number of marbles is %ld.\\n\u0026rdquo;, answer); printf(\u0026ldquo;The size of marbles is %zd bytes.\\n\u0026rdquo;, sizeof marbles); return 0; } int sum(int ar[], int n) // 这个数组的大小是？ {\nint i; int total = 0; for (i = 0; i \u0026lt; n; i++) total += ar[i]; printf(\u0026ldquo;The size of ar is %zd bytes.\\n\u0026rdquo;, sizeof ar); return total; } 该程序的输出如下： The size of ar is 8　bytes. The total number of marbles is 190. The size of marbles is 40　bytes. 注意，marbles的大小是 40 字节。这没问题，因为marbles内含 10 个int类 型的值，每个值占 4 字节，所以整个marbles的大小是 40 字节。但是，ar才 8 字 节。这是因为ar并不是数组本身，它是一个指向 marbles 数组首元素的指 针。我们的系统中用 8 字节储存地址，所以指针变量的大小是 8 字节（其他 系统中地址的大小可能不是 8 字节）。简而言之，在程序清单10.10中， marbles是一个数组， ar是一个指向marbles数组首元素的指针，利用C中数组 和指针的特殊关系，可以用数组表示法来表示指针ar。\n10.4.1 使用指针形参 # 函数要处理数组必须知道何时开始、何时结束。sum()函数使用一个指 针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数（指针 形参也表明了数组中的数据类型）。但是这并不是给函数传递必备信息的唯\n一方法。还有一种方法是传递两个指针，第 1 个指针指明数组的开始处（与 # 前面用法相同），第 2 个指针指明数组的结束处。程序清单10.11演示了这种 # 方法，同时该程序也表明了指针形参是变量，这意味着可以用索引表明访问 # 数组中的哪一个元素。 # 程序清单 10.11 sum_arr2.c 程序 /* sum_arr2.c \u0026ndash; 数组元素之和 / #include \u0026lt;stdio.h\u0026gt; #define SIZE 10 int sump(int * start, int * end); int main(void) { int marbles[SIZE] = { 20, 10, 5, 39, 4, 16, 19, 26, 31, 20　}; long answer; answer = sump(marbles, marbles + SIZE); printf(\u0026ldquo;The total number of marbles is %ld.\\n\u0026rdquo;, answer); return 0; } / 使用指针算法 */ int sump(int * start, int * end)\n{ # int total = 0; while (start \u0026lt; end) { total += *start; // 把数组元素的值加起来 start++; // 让指针指向下一个元素 } return total; } 指针start开始指向marbles数组的首元素，所以赋值表达式total += *start 把首元素（ 20 ）加给total。然后，表达式start++递增指针变量start，使其指 向数组的下一个元素。因为start是指向int的指针，start递增 1 相当于其值递增 int类型的大小。 注意，sump()函数用另一种方法结束加法循环。sum()函数把元素的个数 作为第 2 个参数，并把该参数作为循环测试的一部分： for( i = 0; i \u0026lt; n; i++) 而sump()函数则使用第 2 个指针来结束循环： while (start \u0026lt; end) 因为while循环的测试条件是一个不相等的关系，所以循环最后处理的 一个元素是end所指向位置的前一个元素。这意味着end指向的位置实际上在 数组最后一个元素的后面。C保证在给数组分配空间时，指向数组后面第一 个位置的指针仍是有效的指针。这使得 while循环的测试条件是有效的，因\n为 start在循环中最后的值是end[1]。注意，使用这种“越界”指针的函数调用 更为简洁： answer = sump(marbles, marbles + SIZE); 因为下标从 0 开始，所以marbles + SIZE指向数组末尾的下一个位置。如 果end指向数组的最后一个元素而不是数组末尾的下一个位置，则必须使用 下面的代码： answer = sump(marbles, marbles + SIZE - 1); 这种写法既不简洁也不好记，很容易导致编程错误。顺带一提，虽然C 保证了marbles + SIZE有效，但是对marbles[SIZE]（即储存在该位置上的 值）未作任何保证，所以程序不能访问该位置。 还可以把循环体压缩成一行代码： total += start++; 一元运算符和++的优先级相同，但结合律是从右往左，所以start++先 求值，然后才是start。也就是说，指针start先递增后指向。使用后缀形式 （即start++而不是++start）意味着先把指针指向位置上的值加到total上，然 后再递增指针。如果使用++start，顺序则反过来，先递增指针，再使用指 针指向位置上的值。如果使用(start)++，则先使用start指向的值，再递增该 值，而不是递增指针。这样，指针将一直指向同一个位置，但是该位置上的 值发生了变化。虽然start++的写法比较常用，但是*(start++)这样写更清 楚。程序清单10.12的程序演示了这些优先级的情况。 程序清单 10.12 order.c 程序 /* order.c \u0026ndash; 指针运算中的优先级 */ #include \u0026lt;stdio.h\u0026gt; int data[2] = { 100, 200　};\nint moredata[2] = { 300, 400　}; int main(void) { int * p1, *p2, *p3; p1 = p2 = data; p3 = moredata; printf(\u0026quot; *p1 = %d, *p2 = %d, *p3 = %d\\n\u0026quot;,*p1, *p2, *p3); printf(\u0026quot;*p1++ = %d, *++p2 = %d, (*p3)++ = %d\\n\u0026quot;,*p1++, *++p2, (*p3)++); printf(\u0026quot; *p1 = %d, *p2 = %d, *p3 = %d\\n\u0026quot;,*p1, *p2, *p3); return 0; } 下面是该程序的输出： *p1 = 100, *p2 = 100, *p3 = 300 *p1++ = 100, *++p2 = 200, (*p3)++ = 300 *p1 = 200, *p2 = 200, *p3 = 301 只有(*p3)++改变了数组元素的值，其他两个操作分别把p1和p2指向数 组的下一个元素。\n10.4.2 指针表示法和数组表示法 # 从以上分析可知，处理数组的函数实际上用指针作为参数，但是在编写 # 这样的函数时，可以选择是使用数组表示法还是指针表示法。如程序清单 # 10.10所示，使用数组表示法，让函数是处理数组的这一意图更加明显。另 # 外，许多其他语言的程序员对数组表示法更熟悉，如FORTRAN、Pascal、 Modula-2或BASIC。其他程序员可能更习惯使用指针表示法，觉得使用指针 更自然，如程序清单10.11所示。 至于C语言，ar[i]和*(ar+1)这两个表达式都是等价的。无论ar是数组名 还是指针变量，这两个表达式都没问题。但是，只有当ar是指针变量时，才 能使用ar++这样的表达式。 指针表示法（尤其与递增运算符一起使用时）更接近机器语言，因此一 些编译器在编译时能生成效率更高的代码。然而，许多程序员认为他们的主 要任务是确保代码正确、逻辑清晰，而代码优化应该留给编译器去做。\n10.5 指针操作 # 可以对指针进行哪些操作？C提供了一些基本的指针操作，下面的程序 # 示例中演示了 8 种不同的操作。为了显示每种操作的结果，该程序打印了指 # 针的值（该指针指向的地址）、储存在指针指向地址上的值，以及指针自己 # 的地址。如果编译器不支持%p 转换说明，可以用%u 或%lu 代替%p；如果 编译器不支持用%td转换说明打印地址的差值，可以用%d或%ld来代替。 程序清单10.13演示了指针变量的 8 种基本操作。除了这些操作，还可以 使用关系运算符来比较指针。 程序清单 10.13 ptr_ops.c 程序 // ptr_ops.c \u0026ndash; 指针操作 #include \u0026lt;stdio.h\u0026gt; int main(void) { int urn[5] = { 100, 200, 300, 400, 500　}; int * ptr1, *ptr2, *ptr3; ptr1 = urn; // 把一个地址赋给指针 ptr2 = \u0026amp;urn[2]; // 把一个地址赋给指针 // 解引用指针，以及获得指针的地址 printf(\u0026ldquo;pointer value, dereferenced pointer, pointer address:\\n\u0026rdquo;); printf(\u0026ldquo;ptr1 = %p, *ptr1 =%d, \u0026amp;ptr1 = %p\\n\u0026rdquo;, ptr1, *ptr1, \u0026amp;ptr1); // 指针加法\nptr3 = ptr1 + 4; printf(\u0026quot;\\nadding an int to a pointer:\\n\u0026quot;); printf(\u0026ldquo;ptr1 + 4 = %p, *(ptr1 + 4) = %d\\n\u0026rdquo;, ptr1 + 4, *(ptr1 + 4)); ptr1++; // 递增指针 printf(\u0026quot;\\nvalues after ptr1++:\\n\u0026quot;); printf(\u0026ldquo;ptr1 = %p, *ptr1 =%d, \u0026amp;ptr1 = %p\\n\u0026rdquo;, ptr1, *ptr1, \u0026amp;ptr1); ptr2\u0026ndash;; // 递减指针 printf(\u0026quot;\\nvalues after \u0026ndash;ptr2:\\n\u0026quot;); printf(\u0026ldquo;ptr2 = %p, *ptr2 = %d, \u0026amp;ptr2 = %p\\n\u0026rdquo;, ptr2, *ptr2, \u0026amp;ptr2); \u0026ndash;ptr1; // 恢复为初始值 ++ptr2; // 恢复为初始值 printf(\u0026quot;\\nPointers reset to original values:\\n\u0026quot;); printf(\u0026ldquo;ptr1 = %p, ptr2 = %p\\n\u0026rdquo;, ptr1, ptr2); // 一个指针减去另一个指针 printf(\u0026quot;\\nsubtracting one pointer from another:\\n\u0026quot;); printf(\u0026ldquo;ptr2 = %p, ptr1 = %p, ptr2 - ptr1 = %td\\n\u0026rdquo;, ptr2, ptr1, ptr2 - ptr1); // 一个指针减去一个整数 printf(\u0026quot;\\nsubtracting an int from a pointer:\\n\u0026quot;);\nprintf(\u0026ldquo;ptr3 = %p, ptr3 - 2　= %p\\n\u0026rdquo;, ptr3, ptr3 - 2); return 0; } 下面是我们的系统运行该程序后的输出： pointer value, dereferenced pointer, pointer address: ptr1 = 0x7fff5fbff8d0, *ptr1 =100, \u0026amp;ptr1 = 0x7fff5fbff8c8 adding an int to a pointer: ptr1 + 4 = 0x7fff5fbff8e0, *(ptr1 + 4) = 500 values after ptr1++: ptr1 = 0x7fff5fbff8d4, *ptr1 =200, \u0026amp;ptr1 = 0x7fff5fbff8c8 values after \u0026ndash;ptr2: ptr2 = 0x7fff5fbff8d4, *ptr2 = 200, \u0026amp;ptr2 = 0x7fff5fbff8c0 Pointers reset to original values: ptr1 = 0x7fff5fbff8d0, ptr2 = 0x7fff5fbff8d8 subtracting one pointer from another: ptr2 = 0x7fff5fbff8d8, ptr1 = 0x7fff5fbff8d0, ptr2 - ptr1 = 2 subtracting an int from a pointer: ptr3 = 0x7fff5fbff8e0, ptr3 - 2 = 0x7fff5fbff8d8 下面分别描述了指针变量的基本操作。\n赋值：可以把地址赋给指针。例如，用数组名、带地址运算符（\u0026amp;）的 # 变量名、另一个指针进行赋值。在该例中，把urn数组的首地址赋给了ptr1， 该地址的编号恰好是0x7fff5fbff8d0。变量ptr2获得数组urn的第 3 个元素 （urn[2]）的地址。注意，地址应该和指针类型兼容。也就是说，不能把 double类型的地址赋给指向int的指针，至少要避免不明智的类型转换。 C99/C11已经强制不允许这样做。 解引用：*运算符给出指针指向地址上储存的值。因此，*ptr1的初值是 100 ，该值储存在编号为0x7fff5fbff8d0的地址上。 取址：和所有变量一样，指针变量也有自己的地址和值。对指针而言， \u0026amp;运算符给出指针本身的地址。本例中，ptr1 储存在内存编号为 0x7fff5fbff8c8 的地址上，该存储单元储存的内容是0x7fff5fbff8d0，即urn的地 址。因此\u0026amp;ptr1是指向ptr1的指针，而ptr1是指向utn[0]的指针。 指针与整数相加：可以使用+运算符把指针与整数相加，或整数与指针 相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位） 相乘，然后把结果与初始地址相加。因此ptr1 +4与\u0026amp;urn[4]等价。如果相加 的结果超出了初始指针指向的数组范围，计算结果则是未定义的。除非正好 超过数组末尾第一个位置，C保证该指针有效。 递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个 元素。因此，ptr1++相当于把ptr1的值加上 4 （我们的系统中int为 4 字节）， ptr1指向urn[1]（见图10.4，该图中使用了简化的地址）。现在ptr1的值是 0x7fff5fbff8d4（数组的下一个元素的地址），*ptr的值为 200 （即urn[1]的 值）。注意，ptr1本身的地址仍是 0x7fff5fbff8c8。毕竟，变量不会因为值发 生变化就移动位置。\n图10.4 递增指向int的指针 指针减去一个整数：可以使用-运算符从一个指针中减去一个整数。指 针必须是第 1 个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向 类型的大小（以字节为单位），然后用初始地址减去乘积。所以ptr3 - 2与 \u0026amp;urn[2]等价，因为ptr3指向的是\u0026amp;arn[4]。如果相减的结果超出了初始指针所 指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位 置，C保证该指针有效。 递减指针：当然，除了递增指针还可以递减指针。在本例中，递减ptr3 使其指向数组的第 2 个元素而不是第 3 个元素。前缀或后缀的递增和递减运算 符都可以使用。注意，在重置ptr1和ptr2前，它们都指向相同的元素urn[1]。 指针求差：可以计算两个指针的差值。通常，求差的两个指针分别指向 同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数 组类型的单位相同。例如，程序清单10.13的输出中，ptr2 - ptr1得 2 ，意思是 这两个指针所指向的两个元素相隔两个int，而不是 2 字节。只要两个指针都 指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能 保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出 一个值，或者导致运行时错误。 比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向\n相同类型的对象。 # 注意，这里的减法有两种。可以用一个指针减去另一个指针得到一个整 # 数，或者用一个指针减去一个整数得到另一个指针。 # 在递增或递减指针时还要注意一些问题。编译器不会检查指针是否仍指 # 向数组元素。C 只能保证指向数组任意元素的指针和指向数组后面第 1 个位 # 置的指针有效。但是，如果递增或递减一个指针后超出了这个范围，则是未 # 定义的。另外，可以解引用指向数组任意元素的指针。但是，即使指针指向 # 数组后面一个位置是有效的，也能解引用这样的越界指针。 # 解引用未初始化的指针 # 说到注意事项，一定要牢记一点：千万不要解引用未初始化的指针。例 # 如，考虑下面的例子： # int * pt;// 未初始化的指针 *pt = 5; // 严重的错误 为何不行？第 2 行的意思是把 5 储存在pt指向的位置。但是pt未被初始 化，其值是一个随机值，所以不知道 5 将储存在何处。这可能不会出什么 错，也可能会擦写数据或代码，或者导致程序崩溃。切记：创建一个指针 时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。因此， 在使用指针之前，必须先用已分配的地址初始化它。例如，可以用一个现有 变量的地址初始化该指针（使用带指针形参的函数时，就属于这种情况）。 或者还可以使用第 12 章将介绍的malloc()函数先分配内存。无论如何，使用 指针时一定要注意，不要解引用未初始化的指针！ double * pd; // 未初始化的指针 *pd = 2.4; // 不要这样做 假设\nint urn[3]; int * ptr1, * ptr2; 下面是一些有效和无效的语句： 有效语句　无效语句 ptr1++; urn++; ptr2 = ptr1 + 2; ptr2 = ptr2 + ptr1; ptr2 = urn + 1; ptr2 = urn * ptr1; 基于这些有效的操作，C 程序员创建了指针数组、函数指针、指向指针 的指针数组、指向函数的指针数组等。别紧张，接下来我们将根据已学的内 容介绍指针的一些基本用法。指针的第 1 个基本用法是在函数间传递信息。 前面学过，如果希望在被调函数中改变主调函数的变量，必须使用指针。指 针的第 2 个基本用法是用在处理数组的函数中。下面我们再来看一个使用函 数和数组的编程示例。\n10.6 保护数组中的数据 # 编写一个处理基本类型（如，int）的函数时，要选择是传递int类型的值 还是传递指向int的指针。通常都是直接传递数值，只有程序需要在函数中改 变该数值时，才会传递指针。对于数组别无选择，必须传递指针，因为这样 做效率高。如果一个函数按值传递数组，则必须分配足够的空间来储存原数 组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址 传递给函数，让函数直接处理原数组则效率要高。 传递地址会导致一些问题。C 通常都按值传递数据，因为这样做可以保 证数据的完整性。如果函数使用的是原始数据的副本，就不会意外修改原始 数据。但是，处理数组的函数通常都需要使用原始数据，因此这样的函数可 以修改原数组。有时，这正是我们需要的。例如，下面的函数给数组的每个 元素都加上一个相同的值： void add_to(double ar[], int n, double val) { int i; for (i = 0; i \u0026lt; n; i++) ar[i] += val; } 因此，调用该函数后，prices数组中的每个元素的值都增加了2.5： add_to(prices, 100, 2.50); 该函数修改了数组中的数据。之所以可以这样做，是因为函数通过指针 直接使用了原始数据。\n然而，其他函数并不需要修改数据。例如，下面的函数计算数组中所有 # 元素之和，它不用改变数组的数据。但是，由于ar实际上是一个指针，所以 编程错误可能会破坏原始数据。例如，下面示例中的ar[i]++会导致数组中每 个元素的值都加 1 ： int sum(int ar[], int n) // 错误的代码 { int i; int total = 0; for( i = 0; i \u0026lt; n; i++) total += ar[i]++; // 错误递增了每个元素的值 return total; }\n10.6.1 对形式参数使用 const # 在K\u0026amp;R C的年代，避免类似错误的唯一方法是提高警惕。ANSI C提供 # 了一种预防手段。如果函数的意图不是修改数组中的数据内容，那么在函数 # 原型和函数定义中声明形式参数时应使用关键字const。例如，sum()函数的 原型和定义如下： int sum(const int ar[], int n); /* 函数原型 / int sum(const int ar[], int n) / 函数定义 */ { int i;\nint total = 0; for( i = 0; i \u0026lt; n; i++) total += ar[i]; return total; } 以上代码中的const告诉编译器，该函数不能修改ar指向的数组中的内 容。如果在函数中不小心使用类似ar[i]++的表达式，编译器会捕获这个错 误，并生成一条错误信息。 这里一定要理解，这样使用const并不是要求原数组是常量，而是该函 数在处理数组时将其视为常量，不可更改。这样使用const可以保护数组的 数据不被修改，就像按值传递可以保护基本数据类型的原始值不被改变一 样。一般而言，如果编写的函数需要修改数组，在声明数组形参时则不使用 const；如果编写的函数不用修改数组，那么在声明数组形参时最好使用 const。 程序清单10.14的程序中，一个函数显示数组的内容，另一个函数给数 组每个元素都乘以一个给定值。因为第 1 个函数不用改变数组，所以在声明 数组形参时使用了const；而第 2 个函数需要修改数组元素的值，所以不使用 const。 程序清单 10.14 arf.c 程序 /* arf.c \u0026ndash; 处理数组的函数 */ #include \u0026lt;stdio.h\u0026gt; #define SIZE 5 void show_array(const double ar[], int n);\nvoid mult_array(double ar[], int n, double mult); int main(void) { double dip[SIZE] = { 20.0, 17.66, 8.2, 15.3, 22.22 }; printf(\u0026ldquo;The original dip array:\\n\u0026rdquo;); show_array(dip, SIZE); mult_array(dip, SIZE, 2.5); printf(\u0026ldquo;The dip array after calling mult_array():\\n\u0026rdquo;); show_array(dip, SIZE); return 0; } /* 显示数组的内容 */ void show_array(const double ar[], int n) { int i; for (i = 0; i \u0026lt; n; i++) printf(\u0026quot;%8.3f \u0026ldquo;, ar[i]); putchar(\u0026rsquo;\\n\u0026rsquo;); }\n/* 把数组的每个元素都乘以相同的值 */ # void mult_array(double ar[], int n, double mult) { int i; for (i = 0; i \u0026lt; n; i++) ar[i] *= mult; } 下面是该程序的输出： The original dip array: 20.000 17.660 8.200 15.300 22.220 The dip array after calling mult_array(): 50.000 44.150 20.500 38.250 55.550 注意该程序中两个函数的返回类型都是void。虽然mult_array()函数更新 了dip数组的值，但是并未使用return机制。\n10.6.2 const 的其他内容 # 我们在前面使用const创建过变量： const double PI = 3.14159; 虽然用#define指令可以创建类似功能的符号常量，但是const的用法更加 灵活。可以创建const数组、const指针和指向const的指针。 程序清单10.4演示了如何使用const关键字保护数组：\n#define MONTHS 12 \u0026hellip; const int days[MONTHS] = {31,28,31,30,31,30,31,31,30,31,30,31}; 如果程序稍后尝试改变数组元素的值，编译器将生成一个编译期错误消 息： days[9] = 44; /* 编译错误 */ 指向const的指针不能用于改变值。考虑下面的代码： double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5}; const double * pd = rates; // pd指向数组的首元素 第 2 行代码把pd指向的double类型的值声明为const，这表明不能使用pd 来更改它所指向的值： pd = 29.89; // 不允许 pd[2] = 222.22; //不允许 rates[0] = 99.99; // 允许，因为rates未被const限定 无论是使用指针表示法还是数组表示法，都不允许使用pd修改它所指向 数据的值。但是要注意，因为rates并未被声明为const，所以仍然可以通过 rates修改元素的值。另外，可以让pd指向别处： pd++; / 让pd指向rates[1] \u0026ndash; 没问题 */ 指向 const 的指针通常用于函数形参中，表明该函数不会使用指针改变 数据。例如，程序清单 10.14中的show_array()函数原型如下： void show_array(const double *ar, int n);\n关于指针赋值和const需要注意一些规则。首先，把const数据或非const 数据的地址初始化为指向const的指针或为其赋值是合法的： double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5}; const double locked[4] = {0.08, 0.075, 0.0725, 0.07}; const double * pc = rates; // 有效 pc = locked; //有效 pc = \u0026amp;rates[3]; //有效 然而，只能把非const数据的地址赋给普通指针： double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5}; const double locked[4] = {0.08, 0.075, 0.0725, 0.07}; double * pnc = rates; // 有效 pnc = locked; // 无效 pnc = \u0026amp;rates[3]; // 有效 这个规则非常合理。否则，通过指针就能改变const数组中的数据。 应用以上规则的例子，如 show_array()函数可以接受普通数组名和 const 数组名作为参数，因为这两种参数都可以用来初始化指向const的指针： show_array(rates, 5); // 有效 show_array(locked, 4); // 有效 因此，对函数的形参使用const不仅能保护数据，还能让函数处理const 数组。\n另外，不应该把const数组名作为实参传递给mult_array()这样的函数： mult_array(rates, 5, 1.2); // 有效 mult_array(locked, 4, 1.2); // 不要这样做 C标准规定，使用非const标识符（如，mult_arry()的形参ar）修改const 数据（如，locked）导致的结果是未定义的。 const还有其他的用法。例如，可以声明并初始化一个不能指向别处的 指针，关键是const的位置： double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5}; double * const pc = rates; // pc指向数组的开始 pc = \u0026amp;rates[2]; // 不允许，因为该指针不能指向别处 *pc = 92.99; // 没问题 \u0026ndash; 更改rates[0]的值 可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地 址。 最后，在创建指针时还可以使用const两次，该指针既不能更改它所指 向的地址，也不能修改指向地址上的值： double rates[5] = {88.99, 100.12, 59.45, 183.11, 340.5}; const double * const pc = rates; pc = \u0026amp;rates[2]; //不允许 *pc = 92.99; //不允许\n10.7 指针和多维数组 # 指针和多维数组有什么关系？为什么要了解它们的关系？处理多维数组 # 的函数要用到指针，所以在使用这种函数之前，先要更深入地学习指针。至 # 于第 1 个问题，我们通过几个示例来回答。为简化讨论，我们使用较小的数 # 组。假设有下面的声明： # int zippo[4][2]; /* 内含int数组的数组 / 然后数组名zippo是该数组首元素的地址。在本例中，zippo的首元素是 一个内含两个int值的数组，所以zippo是这个内含两个int值的数组的地址。 下面，我们从指针的属性进一步分析。 因为zippo是数组首元素的地址，所以zippo的值和\u0026amp;zippo[0]的值相同。 而zippo[0]本身是一个内含两个整数的数组，所以zippo[0]的值和它首元素 （一个整数）的地址（即\u0026amp;zippo[0][0]的值）相同。简而言之，zippo[0]是一 个占用一个int大小对象的地址，而zippo是一个占用两个int大小对象的地 址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以zippo 和zippo[0]的值相同。 给指针或地址加 1 ，其值会增加对应类型大小的数值。在这方面，zippo 和zippo[0]不同，因为zippo指向的对象占用了两个int大小，而zippo[0]指向的 对象只占用一个int大小。因此， zippo + 1和zippo[0] + 1的值不同。 解引用一个指针（在指针前使用运算符）或在数组名后使用带下标的 []运算符，得到引用对象代表的值。因为zippo[0]是该数组首元素（zippo[0] [0]）的地址，所以*(zippo[0])表示储存在zippo[0][0]上的值（即一个int类型 的值）。与此类似，*zippo代表该数组首元素（zippo[0]）的值，但是 zippo[0]本身是一个int类型值的地址。该值的地址是\u0026amp;zippo[0][0]，所以 *zippo就是\u0026amp;zippo[0][0]。对两个表达式应用解引用运算符表明，**zippo与 *\u0026amp;zippo[0][0]等价，这相当于zippo[0][0]，即一个int类型的值。简而言之， zippo是地址的地址，必须解引用两次才能获得原始值。地址的地址或指针\n的指针是就是双重间接（double indirection）的例子。 显然，增加数组维数会增加指针的复杂度。现在，大部分初学者都开始 意识到指针为什么是 C 语言中最难的部分。认真思考上述内容，看看是否 能用所学的知识解释程序清单10.15中的程序。该程序显示了一些地址值和 数组的内容。 程序清单 10.15 zippo1.c 程序 /* zippo1.c \u0026ndash; zippo的相关信息 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int zippo[4][2] = { { 2, 4　}, { 6, 8　}, { 1, 3　}, { 5, 7　} }; printf(\u0026rdquo; zippo = %p, zippo + 1　= %p\\n\u0026quot;,zippo, zippo\n1); printf(\u0026ldquo;zippo[0] = %p, zippo[0] + 1　= %p\\n\u0026rdquo;,zippo[0], zippo[0] + 1); printf(\u0026quot; *zippo = %p, *zippo + 1 = %p\\n\u0026quot;,*zippo, *zippo + 1); printf(\u0026ldquo;zippo[0][0] = %d\\n\u0026rdquo;, zippo[0][0]); printf(\u0026quot; *zippo[0] = %d\\n\u0026quot;, *zippo[0]); printf(\u0026quot; **zippo = %d\\n\u0026quot;, **zippo); printf(\u0026quot; zippo[2][1] = %d\\n\u0026quot;, zippo[2][1]); printf(\u0026quot;((zippo+2) + 1) = %d\\n\u0026quot;, ((zippo + 2) + 1)); return 0; } 下面是我们的系统运行该程序后的输出： zippo = 0x0064fd38, zippo + 1　= 0x0064fd40 zippo[0]= 0x0064fd38, zippo[0] + 1　= 0x0064fd3c *zippo = 0x0064fd38, *zippo + 1 = 0x0064fd3c zippo[0][0] = 2 zippo[0] = 2 **zippo = 2 zippo[2][1] = 3 ((zippo+2) + 1) = 3 其他系统显示的地址值和地址形式可能不同，但是地址之间的关系与以 上输出相同。该输出显示了二维数组zippo的地址和一维数组zippo[0]的地址 相同。它们的地址都是各自数组首元素的地址，因而与\u0026amp;zippo[0][0]的值也 相同。 尽管如此，它们也有差别。在我们的系统中，int是 4 字节。前面讨论 过，zippo[0]指向一个 4 字节的数据对象。zippo[0]加 1 ，其值加 4 （十六进制 中，38+4得3c）。数组名zippo 是一个内含 2 个int类型值的数组的地址，所以 zippo指向一个 8 字节的数据对象。因此，zippo加 1 ，它所指向的地址加 8 字节 （十六进制中，38+8得 40 ）。 该程序演示了zippo[0]和zippo完全相同，实际上确实如此。然后，对\n二维数组名解引用两次，得到储存在数组中的值。使用两个间接运算符 # （）或者使用两对方括号（[]）都能获得该值（还可以使用一个和一对 # []，但是我们暂不讨论这么多情况）。 # 要特别注意，与 zippo[2][1]等价的指针表示法是*(*(zippo+2) + 1)。看上 去比较复杂，应最好能理解。下面列出了理解该表达式的思路：\n以上分析并不是为了说明用指针表示法（((zippo+2) + 1)）代替数组 表示法（zippo[2][1]），而是提示读者，如果程序恰巧使用一个指向二维数 组的指针，而且要通过该指针获取值时，最好用简单的数组表示法，而不是 指针表示法。 图10.5以另一种视图演示了数组地址、数组内容和指针之间的关系。\n图10.5 数组的数组 10.7.1 指向多维数组的指针 # 如何声明一个指针变量pz指向一个二维数组（如，zippo）？在编写处 理类似zippo这样的二维数组时会用到这样的指针。把指针声明为指向int的 类型还不够。因为指向int只能与zippo[0]的类型匹配，说明该指针指向一个 int类型的值。但是zippo是它首元素的地址，该元素是一个内含两个int类型 值的一维数组。因此，pz必须指向一个内含两个int类型值的数组，而不是指 向一个int类型值，其声明如下： int (* pz)[2]; // pz指向一个内含两个int类型值的数组 以上代码把pz声明为指向一个数组的指针，该数组内含两个int类型值。 为什么要在声明中使用圆括号？因为[]的优先级高于*。考虑下面的声明： int * pax[2]; // pax是一个内含两个指针元素的数组，每个元素都指 向int的指针 由于[]优先级高，先与pax结合，所以pax成为一个内含两个元素的数 组。然后*表示pax数组内含两个指针。最后，int表示pax数组中的指针都指 向int类型的值。因此，这行代码声明了两个指向int的指针。而前面有圆括号 的版本，先与pz结合，因此声明的是一个指向数组（内含两个int类型的 值）的指针。程序清单10.16演示了如何使用指向二维数组的指针。 程序清单 10.16 zippo2.c 程序 / zippo2.c \u0026ndash;　通过指针获取zippo的信息 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { int zippo[4][2] = { { 2, 4　}, { 6, 8　}, { 1, 3　}, { 5, 7　} }; int(*pz)[2];\npz = zippo; printf(\u0026quot; pz = %p, pz + 1　= %p\\n\u0026quot;, pz, pz + 1); printf(\u0026ldquo;pz[0] = %p, pz[0] + 1　= %p\\n\u0026rdquo;, pz[0], pz[0] + 1); printf(\u0026quot; *pz = %p, *pz + 1 = %p\\n\u0026quot;, *pz, *pz + 1); printf(\u0026ldquo;pz[0][0] = %d\\n\u0026rdquo;, pz[0][0]); printf(\u0026quot; pz[0] = %d\\n\u0026quot;, pz[0]); printf(\u0026quot; **pz = %d\\n\u0026quot;, **pz); printf(\u0026quot; pz[2][1] = %d\\n\u0026quot;, pz[2][1]); printf(\u0026quot;((pz+2) + 1) = %d\\n\u0026quot;, ((pz + 2) + 1)); return 0; } 下面是该程序的输出： pz = 0x0064fd38, pz + 1　= 0x0064fd40 pz[0] = 0x0064fd38, pz[0] + 1　= 0x0064fd3c *pz = 0x0064fd38, *pz + 1 = 0x0064fd3c pz[0][0] = 2 *pz[0] = 2 **pz = 2 pz[2][1] = 3\n((pz+2) + 1) = 3 系统不同，输出的地址可能不同，但是地址之间的关系相同。如前所 述，虽然pz是一个指针，不是数组名，但是也可以使用 pz[2][1]这样的写 法。可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组 名，也可以使用指针名： zippo[m][n] == ((zippo + m) + n) pz[m][n] == ((pz + m) + n)\n10.7.2 指针的兼容性 # 指针之间的赋值比数值类型之间的赋值要严格。例如，不用类型转换就 # 可以把 int 类型的值赋给double类型的变量，但是两个类型的指针不能这样 做。 int n = 5; double x; int * p1 = \u0026amp;n; double * pd = \u0026amp;x; x = n; // 隐式类型转换 pd = p1; // 编译时错误 更复杂的类型也是如此。假设有如下声明： int * pt; int (*pa)[3]; int ar1[2][3];\nint ar2[3][2]; int **p2; // 一个指向指针的指针 有如下的语句： pt = \u0026amp;ar1[0][0]; // 都是指向int的指针 pt = ar1[0]; // 都是指向int的指针 pt = ar1; // 无效 pa = ar1; // 都是指向内含 3 个int类型元素数组的指针 pa = ar2; // 无效 p2 = \u0026amp;pt; // both pointer-to-int * *p2 = ar2[0]; // 都是指向int的指针 p2 = ar2; // 无效 注意，以上无效的赋值表达式语句中涉及的两个指针都是指向不同的类 型。例如，pt 指向一个 int类型值，而ar1指向一个内含 3 和int类型元素的数 组。类似地，pa指向一个内含 2 个int类型元素的数组，所以它与ar1的类型兼 容，但是ar2指向一个内含 2 个int类型元素的数组，所以pa与ar2不兼容。 上面的最后两个例子有些棘手。变量p2是指向指针的指针，它指向的指 针指向int，而ar2是指向数组的指针，该数组内含 2 个int类型的元素。所以， p2和ar2的类型不同，不能把ar2赋给p2。但是，*p2是指向int的指针，与 ar2[0]兼容。因为ar2[0]是指向该数组首元素（ar2[0][0]）的指针，所以 ar2[0]也是指向int的指针。 一般而言，多重解引用让人费解。例如，考虑下面的代码： int x = 20;\nconst int y = 23; int * p1 = \u0026amp;x; const int * p2 = \u0026amp;y; const int ** pp2; p1 = p2; // 不安全 \u0026ndash; 把const指针赋给非const指针 p2 = p1; // 有效 \u0026ndash; 把非const指针赋给const指针 pp2 = \u0026amp;p1; // 不安全 –- 嵌套指针类型赋值 前面提到过，把const指针赋给非const指针不安全，因为这样可以使用 新的指针改变const指针指向的数据。编译器在编译代码时，可能会给出警 告，执行这样的代码是未定义的。但是把非const指针赋给const指针没问 题，前提是只进行一级解引用： p2 = p1; // 有效 \u0026ndash; 把非const指针赋给const指针 但是进行两级解引用时，这样的赋值也不安全，例如，考虑下面的代 码： const int **pp2; int p1; const int n = 13; pp2 = \u0026amp;p1; // 允许，但是这导致const限定符失效（根据第 1 行代码， 不能通过pp2修改它所指向的内容） *pp2 = \u0026amp;n; // 有效，两者都声明为const，但是这将导致p1指向 n（*pp2已被修改）\n*p1 = 10;//有效，但是这将改变n的值（但是根据第 3 行代码，不能修改n 的值） 发生了什么？如前所示，标准规定了通过非const指针更改const数据是 未定义的。例如，在Terminal中（OS X对底层UNIX系统的访问）使用gcc编 译包含以上代码的小程序，导致n最终的值是 13 ，但是在相同系统下使用 clang来编译，n最终的值是 10 。两个编译器都给出指针类型不兼容的警告。 当然，可以忽略这些警告，但是最好不要相信该程序运行的结果，这些结果 都是未定义的。 C const 和 C++ const C和C++中const的用法很相似，但是并不完全相同。区别之一是， C++允许在声明数组大小时使用const整数，而C却不允许。区别之二是， C++的指针赋值检查更严格： const int y; const int * p2 = \u0026amp;y; int * p1; p1 = p2; // C++中不允许这样做，但是C可能只给出警告 C++不允许把const指针赋给非const指针。而C则允许这样做，但是如果 通过p1更改y，其行为是未定义的。\n10.7.3 函数和多维数组 # 如果要编写处理二维数组的函数，首先要能正确地理解指针才能写出声 # 明函数的形参。在函数体中，通常使用数组表示法进行相关操作。 # 下面，我们编写一个处理二维数组的函数。一种方法是，利用for循环 把处理一维数组的函数应用到二维数组的每一行。如下所示：\nint junk[3][4] = { {2,4,5,8}, {3,5,6,9}, {12,10,8,6} }; int i, j; int total = 0; for (i = 0; i \u0026lt; 3　; i++) total += sum(junk[i], 4); // junk[i]是一维数组 记住，如果 junk 是二维数组，junk[i]就是一维数组，可将其视为二维数 组的一行。这里，sum()函数计算二维数组的每行的总和，然后for循环再把 每行的总和加起来。 然而，这种方法无法记录行和列的信息。用这种方法计算总和，行和列 的信息并不重要。但如果每行代表一年，每列代表一个月，就还需要一个函 数计算某列的总和。该函数要知道行和列的信息，可以通过声明正确类型的 形参变量来完成，以便函数能正确地传递数组。在这种情况下，数组 junk 是一个内含 3 个数组元素的数组，每个元素是内含 4 个int类型值的数组（即 junk是一个 3 行 4 列的二维数组）。通过前面的讨论可知，这表明junk是一个 指向数组（内含 4 个int类型值）的指针。可以这样声明函数的形参： void somefunction( int (* pt)[4] ); 另外，如果当且仅当pt是一个函数的形式参数时，可以这样声明： void somefunction( int pt[][4] ); 注意，第 1 个方括号是空的。空的方括号表明pt是一个指针。这样的变 量稍后可以用作相同方法作为junk。下面的程序示例中就是这样做的，如程 序清单10.17所示。注意该程序清单演示了 3 种等价的原型语法。 程序清单 10.17 array2d.c 程序 // array2d.c \u0026ndash; 处理二维数组的函数\n#include \u0026lt;stdio.h\u0026gt; #define ROWS 3 #define COLS 4 void sum_rows(int ar[][COLS], int rows); void sum_cols(int [][COLS], int); // 省略形参名，没问题 int sum2d(int(*ar)[COLS], int rows); // 另一种语法 int main(void) { int junk[ROWS][COLS] = { { 2, 4, 6, 8　}, { 3, 5, 7, 9　}, { 12, 10, 8, 6　} }; sum_rows(junk, ROWS); sum_cols(junk, ROWS); printf(\u0026ldquo;Sum of all elements = %d\\n\u0026rdquo;, sum2d(junk, ROWS)); return 0; } void sum_rows(int ar[][COLS], int rows)\n{ # int r; int c; int tot; for (r = 0; r \u0026lt; rows; r++) { tot = 0; for (c = 0; c \u0026lt; COLS; c++) tot += ar[r][c]; printf(\u0026ldquo;row %d: sum = %d\\n\u0026rdquo;, r, tot); } } void sum_cols(int ar[][COLS], int rows) { int r; int c; int tot; for (c = 0; c \u0026lt; COLS; c++) {\ntot = 0; for (r = 0; r \u0026lt; rows; r++) tot += ar[r][c]; printf(\u0026ldquo;col %d: sum = %d\\n\u0026rdquo;, c, tot); } } int sum2d(int ar[][COLS], int rows) { int r; int c; int tot = 0; for (r = 0; r \u0026lt; rows; r++) for (c = 0; c \u0026lt; COLS; c++) tot += ar[r][c]; return tot; } 该程序的输出如下： row 0: sum = 20 row 1: sum = 24\nrow 2: sum = 36 col 0: sum = 17 col 1: sum = 19 col 2: sum = 21 col 3: sum = 23 Sum of all elements = 80 程序清单10.17中的程序把数组名junk（即，指向数组首元素的指针，首 元素是子数组）和符号常量ROWS（代表行数 3 ）作为参数传递给函数。每 个函数都把ar视为内含数组元素（每个元素是内含 4 个int类型值的数组）的 数组。列数内置在函数体中，但是行数靠函数传递得到。如果传入函数的行 数是 12 ，那么函数要处理的是12×4的数组。因为rows是元素的个数，然 而，因为每个元素都是数组，或者视为一行，rows也可以看成是行数。 注意，ar和main()中的junk都使用数组表示法。因为ar和junk的类型相 同，它们都是指向内含 4 个int类型值的数组的指针。 注意，下面的声明不正确： int sum2(int ar[][], int rows); // 错误的声明 前面介绍过，编译器会把数组表示法转换成指针表示法。例如，编译器 会把 ar[1]转换成 ar+1。编译器对ar+1求值，要知道ar所指向的对象大小。下 面的声明： int sum2(int ar[][4], int rows); // 有效声明 表示ar指向一个内含 4 个int类型值的数组（在我们的系统中，ar指向的 对象占 16 字节），所以ar+1的意思是“该地址加上 16 字节”。如果第 2 对方括 号是空的，编译器就不知道该怎样处理。\n也可以在第 1 对方括号中写上大小，如下所示，但是编译器会忽略该 # 值： # int sum2(int ar[3][4], int rows); // 有效声明，但是 3 将被忽略 与使用typedef（第 5 章和第 14 章中讨论）相比，这种形式方便得多： typedef int arr4[4]; // arr4是一个内含 4 个int的数组 typedef arr4 arr3x4[3]; // arr3x4 是一个内含 3 个 arr4的数 组 int sum2(arr3x4 ar, int rows); // 与下面的声明相同 int sum2(int ar[3][4], int rows); // 与下面的声明相同 int sum2(int ar[][4], int rows); // 标准形式 一般而言，声明一个指向N维数组的指针时，只能省略最左边方括号中 的值： int sum4d(int ar[][12][20][30], int rows); 因为第 1 对方括号只用于表明这是一个指针，而其他的方括号则用于描 述指针所指向数据对象的类型。下面的声明与该声明等价： int sum4d(int (*ar)[12][20][30], int rows); // ar是一个指针 这里，ar指向一个12×20×30的int数组。\n10.8 变长数组（ VLA ） # 读者在学习处理二维数组的函数中可能不太理解，为何只把数组的行数 # 作为函数的形参，而列数却内置在函数体内。例如，函数定义如下： # #define COLS 4 int sum2d(int ar[][COLS], int rows) { int r; int c; int tot = 0; for (r = 0; r \u0026lt; rows; r++) for (c = 0; c \u0026lt; COLS; c++) tot += ar[r][c]; return tot; } 假设声明了下列数组： int array1[5][4]; int array2[100][4]; int array3[2][4]; 可以用sum2d()函数分别计算这些数组的元素之和： tot = sum2d(array1, 5); // 5×4 数组的元素之和 tot = sum2d(array2, 100); // 100×4数组的元素之和 tot = sum2d(array3, 2); // 2×4数组的元素之和 sum2d()函数之所以能处理这些数组，是因为这些数组的列数固定为 4 ， 而行数被传递给形参rows， rows是一个变量。但是如果要计算6×5的数组 （即 6 行 5 列），就不能使用这个函数，必须重新创建一个CLOS为 5 的函数。 因为C规定，数组的维数必须是常量，不能用变量来代替COLS。 要创建一个能处理任意大小二维数组的函数，比较繁琐（必须把数组作 为一维数组传递，然后让函数计算每行的开始处）。而且，这种方法不好处 理FORTRAN的子例程，这些子例程都允许在函数调用中指定两个维度。虽 然 FORTRAN 是比较老的编程语言，但是在过去的几十年里，数值计算领域 的专家已经用FORTRAN开发出许多有用的计算库。C正逐渐替代 FORTRAN，如果能直接转换现有的FORTRAN库就好了。 鉴于此，C99新增了变长数组（variable-length array，VLA），允许使用 变量表示数组的维度。如下所示： int quarters = 4; int regions = 5; double sales[regions][quarters]; // 一个变长数组（VLA） 前面提到过，变长数组有一些限制。变长数组必须是自动存储类别，这 意味着无论在函数中声明还是作为函数形参声明，都不能使用static或extern 存储类别说明符（第 12 章介绍）。而且，不能在声明中初始化它们。最终， C11把变长数组作为一个可选特性，而不是必须强制实现的特性。 注意 变长数组不能改变大小 变长数组中的“变”不是指可以修改已创建数组的大小。一旦创建了变长\n数组，它的大小则保持不变。这里的“变”指的是：在创建数组时，可以使用 # 变量指定数组的维度。 # 由于变长数组是C语言的新特性，目前完全支持这一特性的编译器不 # 多。下面我们来看一个简单的例子：如何编写一个函数，计算int的二维数组 所有元素之和。 首先，要声明一个带二维变长数组参数的函数，如下所示： int sum2d(int rows, int cols, int ar[rows][cols]); // ar是一个变长数组 （VLA） 注意前两个形参（rows和cols）用作第 3 个形参二维数组ar的两个维度。 因为ar的声明要使用rows和cols，所以在形参列表中必须在声明ar之前先声 明这两个形参。因此，下面的原型是错误的： int sum2d(int ar[rows][cols], int rows, int cols); // 无效的顺序 C99/C11标准规定，可以省略原型中的形参名，但是在这种情况下，必 须用星号来代替省略的维度： int sum2d(int, int, int ar[][]); // ar是一个变长数组（VLA），省略了维度 形参名 其次，该函数的定义如下： int sum2d(int rows, int cols, int ar[rows][cols]) { int r; int c; int tot = 0;\nfor (r = 0; r \u0026lt; rows; r++) for (c = 0; c \u0026lt; cols; c++) tot += ar[r][c]; return tot; } 该函数除函数头与传统的C函数（程序清单10.17）不同外，还把符号常 量COLS替换成变量cols。这是因为在函数头中使用了变长数组。由于用变 量代表行数和列数，所以新的sum2d()现在可以处理任意大小的二维int数 组，如程序清单10.18所示。但是，该程序要求编译器支持变长数组特性。 另外，该程序还演示了以变长数组作为形参的函数既可处理传统C数组，也 可处理变长数组。 程序清单 10.18 vararr2d.c 程序 //vararr2d.c \u0026ndash; 使用变长数组的函数 #include \u0026lt;stdio.h\u0026gt; #define ROWS 3 #define COLS 4 int sum2d(int rows, int cols, int ar[rows][cols]); int main(void) { int i, j; int rs = 3;\nint cs = 10; int junk[ROWS][COLS] = { { 2, 4, 6, 8　}, { 3, 5, 7, 9　}, { 12, 10, 8, 6　} }; int morejunk[ROWS - 1][COLS + 2] = { { 20, 30, 40, 50, 60, 70　}, { 5, 6, 7, 8, 9, 10　} }; int varr[rs][cs]; // 变长数组（VLA） for (i = 0; i \u0026lt; rs; i++) for (j = 0; j \u0026lt; cs; j++) varr[i][j] = i * j + j; printf(\u0026ldquo;3x5 array\\n\u0026rdquo;); printf(\u0026ldquo;Sum of all elements = %d\\n\u0026rdquo;, sum2d(ROWS, COLS, junk)); printf(\u0026ldquo;2x6 array\\n\u0026rdquo;); printf(\u0026ldquo;Sum of all elements = %d\\n\u0026rdquo;, sum2d(ROWS - 1, COLS + 2, morejunk));\nprintf(\u0026ldquo;3x10 VLA\\n\u0026rdquo;); printf(\u0026ldquo;Sum of all elements = %d\\n\u0026rdquo;, sum2d(rs, cs, varr)); return 0; } // 带变长数组形参的函数 int sum2d(int rows, int cols, int ar[rows][cols]) { int r; int c; int tot = 0; for (r = 0; r \u0026lt; rows; r++) for (c = 0; c \u0026lt; cols; c++) tot += ar[r][c]; return tot; } 下面是该程序的输出： 3x5 array Sum of all elements = 80 2x6 array\nSum of all elements = 315 3x10 VLA Sum of all elements = 270 需要注意的是，在函数定义的形参列表中声明的变长数组并未实际创建 数组。和传统的语法类似，变长数组名实际上是一个指针。这说明带变长数 组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组。 下面的代码段指出指针和实际数组是何时声明的： int thing[10][6]; twoset(10,6,thing); \u0026hellip; } void twoset (int n, int m, int ar[n][m]) // ar是一个指向数组（内含m个int类 型的值）的指针 { int temp[n][m]; // temp是一个n×m的int数组 temp[0][0] = 2; // 设置temp的一个元素为 2 ar[0][0] = 2; // 设置thing[0][0]为 2 } 如上代码所示调用twoset()时，ar成为指向thing[0]的指针，temp被创建 为10×6的数组。因为ar和thing都是指向thing[0]的指针，ar[0][0]与thing[0][0] 访问的数据位置相同。\nconst 和数组大小 是否可以在声明数组时使用const变量？ const int SZ = 80; \u0026hellip; double ar[SZ]; // 是否允许？ C90标准不允许（也可能允许）。数组的大小必须是给定的整型常量表 达式，可以是整型常量组合，如 20 、sizeof表达式或其他不是const的内容。 由于C实现可以扩大整型常量表达式的范围，所以可能会允许使用const，但 是这种代码可能无法移植。 C99/C11 标准允许在声明变长数组时使用 const 变量。所以该数组的定 义必须是声明在块中的自动存储类别数组。 变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大 小。普通 C数组都是静态内存分配，即在编译时确定数组的大小。由于数组 大小是常量，所以编译器在编译时就知道了。第 12 章将详细介绍动态内存分 配。\n10.9 复合字面量 # 假设给带int类型形参的函数传递一个值，要传递int类型的变量，但是也 可以传递int类型常量，如 5 。在C99 标准以前，对于带数组形参的函数，情 况不同，可以传递数组，但是没有等价的数组常量。C99新增了复合字面量 （compound literal）。字面量是除符号常量外的常量。例如， 5 是int类型字 面量， 81.3是double类型的字面量，\u0026lsquo;Y\u0026rsquo;是char类型的字面量，\u0026ldquo;elephant\u0026quot;是字 符串字面量。发布C99标准的委员会认为，如果有代表数组和结构内容的复 合字面量，在编程时会更方便。 对于数组，复合字面量类似数组初始化列表，前面是用括号括起来的类 型名。例如，下面是一个普通的数组声明： int diva[2] = {10, 20}; 下面的复合字面量创建了一个和diva数组相同的匿名数组，也有两个int 类型的值： (int [2]){10, 20} // 复合字面量 注意，去掉声明中的数组名，留下的int [2]即是复合字面量的类型名。 初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大 小，编译器会自动计算数组当前的元素个数： (int []){50, 20, 90} // 内含 3 个元素的复合字面量 因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建 的同时使用它。使用指针记录地址就是一种用法。也就是说，可以这样用： int * pt1; pt1 = (int [2]) {10, 20};\n注意，该复合字面量的字面常量与上面创建的 diva 数组的字面常量完 全相同。与有数组名的数组类似，复合字面量的类型名也代表首元素的地 址，所以可以把它赋给指向int的指针。然后便可使用这个指针。例如，本例 中*pt1是 10 ，pt1[1]是 20 。 还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数： int sum(const int ar[], int n); \u0026hellip; int total3; total3 = sum((int []){4,4,4,5,5,5}, 6); 这里，第 1 个实参是内含 6 个int类型值的数组，和数组名类似，这同时也 是该数组首元素的地址。这种用法的好处是，把信息传入函数前不必先创建 数组，这是复合字面量的典型用法。 可以把这种用法应用于二维数组或多维数组。例如，下面的代码演示了 如何创建二维int数组并储存其地址： int (*pt2)[4]; // 声明一个指向二维数组的指针，该数组内含 2 个数组 元素， // 每个元素是内含 4 个int类型值的数组 pt2 = (int [2][4]) { {1,2,3,-9}, {4,5,6,-8} }; 如上所示，该复合字面量的类型是int [2][4]，即一个2×4的int数组。 程序清单10.19把上述例子放进一个完整的程序中。 程序清单 10.19 flc.c 程序 // flc.c \u0026ndash; 有趣的常量\n#include \u0026lt;stdio.h\u0026gt; #define COLS 4 int sum2d(const int ar[][COLS], int rows); int sum(const int ar[], int n); int main(void) { int total1, total2, total3; int * pt1; int(*pt2)[COLS]; pt1 = (int[2]) { 10, 20　}; pt2 = (int[2][COLS]) { {1, 2, 3, -9}, { 4, 5, 6, -8 } }; total1 = sum(pt1, 2); total2 = sum2d(pt2, 2); total3 = sum((int []){ 4, 4, 4, 5, 5, 5　}, 6); printf(\u0026ldquo;total1 = %d\\n\u0026rdquo;, total1); printf(\u0026ldquo;total2 = %d\\n\u0026rdquo;, total2); printf(\u0026ldquo;total3 = %d\\n\u0026rdquo;, total3); return 0;\n} # int sum(const int ar [], int n) { int i; int total = 0; for (i = 0; i \u0026lt; n; i++) total += ar[i]; return total; } int sum2d(const int ar [][COLS], int rows) { int r; int c; int tot = 0; for (r = 0; r \u0026lt; rows; r++) for (c = 0; c \u0026lt; COLS; c++) tot += ar[r][c]; return tot; }\n要支持C99的编译器才能正常运行该程序示例（目前并不是所有的编译 # 器都支持），其输出如下： # total1 = 30 total2 = 4 total3 = 27 记住，复合字面量是提供只临时需要的值的一种手段。复合字面量具有 块作用域（第 12 章将介绍相关内容），这意味着一旦离开定义复合字面量的 块，程序将无法保证该字面量是否存在。也就是说，复合字面量的定义在最 内层的花括号中。\n10.10 关键概念 # 数组用于储存相同类型的数据。C 把数组看作是派生类型，因为数组是 # 建立在其他类型的基础上。也就是说，无法简单地声明一个数组。在声明数 # 组时必须说明其元素的类型，如int类型的数组、float类型的数组，或其他类 型的数组。所谓的其他类型也可以是数组类型，这种情况下，创建的是数组 的数组（或称为二维数组）。 通常编写一个函数来处理数组，这样在特定的函数中解决特定的问题， 有助于实现程序的模块化。在把数组名作为实际参数时，传递给函数的不是 整个数组，而是数组的地址（因此，函数对应的形式参数是指针）。为了处 理数组，函数必须知道从何处开始读取数据和要处理多少个数组元素。数组 地址提供了“地址”，“元素个数”可以内置在函数中或作为单独的参数传递。 第 2 种方法更普遍，因为这样做可以让同一个函数处理不同大小的数组。 数组和指针的关系密切，同一个操作可以用数组表示法或指针表示法。 它们之间的关系允许你在处理数组的函数中使用数组表示法，即使函数的形 式参数是一个指针，而不是数组。 对于传统的 C 数组，必须用常量表达式指明数组的大小，所以数组大 小在编译时就已确定。C99/C11新增了变长数组，可以用变量表示数组大 小。这意味着变长数组的大小延迟到程序运行时才确定。\n10.11 本章小结 # 数组是一组数据类型相同的元素。数组元素按顺序储存在内存中，通过 # 整数下标（或索引）可以访问各元素。在C中，数组首元素的下标是 0 ，所 # 以对于内含n个元素的数组，其最后一个元素的下标是n-1。作为程序员，要 确保使用有效的数组下标，因为编译器和运行的程序都不会检查下标的有效 性。 声明一个简单的一维数组形式如下： type name [ size ]; 这里，type是数组中每个元素的数据类型，name是数组名，size是数组 元素的个数。对于传统的C数组，要求size是整型常量表达式。但是C99/C11 允许使用整型非常量表达式。这种情况下的数组被称为变长数组。 C把数组名解释为该数组首元素的地址。换言之，数组名与指向该数组 首元素的指针等价。概括地说，数组和指针的关系十分密切。如果ar是一个 数组，那么表达式ar[i]和*(ar+i)等价。 对于 C 语言而言，不能把整个数组作为参数传递给函数，但是可以传 递数组的地址。然后函数可以使用传入的地址操控原始数组。如果函数没有 修改原始数组的意图，应在声明函数的形式参数时使用关键字const。在被 调函数中可以使用数组表示法或指针表示法，无论用哪种表示法，实际上使 用的都是指针变量。 指针加上一个整数或递增指针，指针的值以所指向对象的大小为单位改 变。也就是说，如果pd指向一个数组的 8 字节double类型值，那么pd加 1 意味 着其值加 8 ，以便它指向该数组的下一个元素。 二维数组即是数组的数组。例如，下面声明了一个二维数组： double sales[5][12];\n该数组名为sales，有 5 个元素（一维数组），每个元素都是一个内含 12 个double类型值的数组。第 1 个一维数组是sales[0]，第 2 个一维数组是 sales[1]，以此类推，每个元素都是内含 12 个double类型值的数组。使用第 2 个下标可以访问这些一维数组中的特定元素。例如，sales[2][5]是slaes[2]的 第 6 个元素，而sales[2]是sales的第 3 个元素。 C 语言传递多维数组的传统方法是把数组名（即数组的地址）传递给类 型匹配的指针形参。声明这样的指针形参要指定所有的数组维度，除了第 1 个维度。传递的第 1 个维度通常作为第 2 个参数。例如，为了处理前面声明的 sales数组，函数原型和函数调用如下： void display(double ar[][12], int rows); \u0026hellip; display(sales, 5); 变长数组提供第 2 种语法，把数组维度作为参数传递。在这种情况下， 对应函数原型和函数调用如下： void display(int rows, int cols, double ar[rows][cols]); \u0026hellip; display(5, 12, sales); 虽然上述讨论中使用的是int类型的数组和double类型的数组，其他类型 的数组也是如此。然而，字符串有一些特殊的规则，这是由于其末尾的空字 符所致。有了这个空字符，不用传递数组的大小，函数通过检测字符串的末 尾也知道在何处停止。我们将在第 11 章中详细介绍。\n10.12 复习题 # 复习题的参考答案在附录A中。 # 1.下面的程序将打印什么内容？ # #include \u0026lt;stdio.h\u0026gt; int main(void) { int ref[] = { 8, 4, 0, 2　}; int *ptr; int index; for (index = 0, ptr = ref; index \u0026lt; 4; index++, ptr++) printf(\u0026quot;%d %d\\n\u0026rdquo;, ref[index], *ptr); return 0; } 2.在复习题 1 中，ref有多少个元素？ 3.在复习题 1 中，ref的地址是什么？ref + 1是什么意思？++ref指向什 么？ 4.在下面的代码中，ptr和(ptr + 2)的值分别是什么？ a. int *ptr;\nint torf[2][2] = {12, 14, 16}; ptr = torf[0]; b. int * ptr; int fort[2][2] = { {12}, {14,16} }; ptr = fort[0]; 5.在下面的代码中，ptr和(ptr + 1)的值分别是什么？ a. int (*ptr)[2]; int torf[2][2] = {12, 14, 16}; ptr = torf; b. int (*ptr)[2]; int fort[2][2] = { {12}, {14,16} }; ptr = fort; 6.假设有下面的声明： int grid[30][100]; a.用 1 种写法表示grid[22][56] b.用 2 种写法表示grid[22][0]\nc.用 3 种写法表示grid[0][0] 7.正确声明以下各变量： a.digits是一个内含 10 个int类型值的数组 b.rates是一个内含 6 个float类型值的数组 c.mat是一个内含 3 个元素的数组，每个元素都是内含 5 个整数的数组 d.psa是一个内含 20 个元素的数组，每个元素都是指向int的指针 e.pstr是一个指向数组的指针，该数组内含 20 个char类型的值 8. a.声明一个内含 6 个int类型值的数组，并初始化各元素为 1 、 2 、 4 、 8 、 16 、 32 b.用数组表示法表示a声明的数组的第 3 个元素（其值为 4 ） c.假设编译器支持C99/C11标准，声明一个内含 100 个int类型值的数组， 并初始化最后一个元素为-1，其他元素不考虑 d.假设编译器支持C99/C11标准，声明一个内含 100 个int类型值的数组， 并初始化下标为 5 、 10 、 11 、 12 、 3 的元素为 101 ，其他元素不考虑 9.内含 10 个元素的数组下标范围是什么？ 10.假设有下面的声明： float rootbeer[10], things[10][5], *pf, value = 2.2; int i = 3; 判断以下各项是否有效：\na.rootbeer[2] = value; b.scanf(\u0026quot;%f\u0026quot;, \u0026amp;rootbeer ); c.rootbeer = value; d.printf(\u0026quot;%f\u0026quot;, rootbeer); e.things[4][4] = rootbeer[3]; f.things[5] = rootbeer; g.pf = value; h.pf = rootbeer; 11.声明一个800×600的int类型数组。 12.下面声明了 3 个数组： double trots[20]; short clops[10][30]; long shots[5][10][15]; a.分别以传统方式和以变长数组为参数的方式编写处理trots数组的void 函数原型和函数调用 b.分别以传统方式和以变长数组为参数的方式编写处理clops数组的void 函数原型和函数调用 c.分别以传统方式和以变长数组为参数的方式编写处理shots数组的void 函数原型和函数调用 13.下面有两个函数原型：\nvoid show(const double ar[], int n); // n是数组元素的个数 void show2(const double ar2[][3], int n); // n是二维数组的行数 a.编写一个函数调用，把一个内含 8 、 3 、 9 和 2 的复合字面量传递给 show()函数。 b.编写一个函数调用，把一个 2 行 3 列的复合字面量（ 8 、 3 、 9 作为第 1 行， 5 、 4 、 1 作为第 2 行）传递给show2()函数。\n10.13 编程练习 # 1.修改程序清单10.7的rain.c程序，用指针进行计算（仍然要声明并初始 化数组）。 2.编写一个程序，初始化一个double类型的数组，然后把该数组的内容 拷贝至 3 个其他数组中（在main()中声明这 4 个数组）。使用带数组表示法的 函数进行第 1 份拷贝。使用带指针表示法和指针递增的函数进行第 2 份拷贝。 把目标数组名、源数组名和待拷贝的元素个数作为前两个函数的参数。第 3 个函数以目标数组名、源数组名和指向源数组最后一个元素后面的元素的指 针。也就是说，给定以下声明，则函数调用如下所示： double source[5] = {1.1, 2.2, 3.3, 4.4, 5.5}; double target1[5]; double target2[5]; double target3[5]; copy_arr(target1, source, 5); copy_ptr(target2, source, 5); copy_ptrs(target3, source, source + 5); 3.编写一个函数，返回储存在int类型数组中的最大值，并在一个简单的 程序中测试该函数。 4.编写一个函数，返回储存在double类型数组中最大值的下标，并在一 个简单的程序中测试该函数。 5.编写一个函数，返回储存在double类型数组中最大值和最小值的差 值，并在一个简单的程序中测试该函数。\n6.编写一个函数，把double类型数组中的数据倒序排列，并在一个简单 的程序中测试该函数。 7.编写一个程序，初始化一个double类型的二维数组，使用编程练习 2 中 的一个拷贝函数把该数组中的数据拷贝至另一个二维数组中（因为二维数组 是数组的数组，所以可以使用处理一维数组的拷贝函数来处理数组中的每个 子数组）。 8.使用编程练习 2 中的拷贝函数，把一个内含 7 个元素的数组中第 3 ～第 5 个元素拷贝至内含 3 个元素的数组中。该函数本身不需要修改，只需要选择 合适的实际参数（实际参数不需要是数组名和数组大小，只需要是数组元素 的地址和待处理元素的个数）。 9.编写一个程序，初始化一个double类型的3×5二维数组，使用一个处理 变长数组的函数将其拷贝至另一个二维数组中。还要编写一个以变长数组为 形参的函数以显示两个数组的内容。这两个函数应该能处理任意N×M数组 （如果编译器不支持变长数组，就使用传统C函数处理N×5的数组）。 10.编写一个函数，把两个数组中相对应的元素相加，然后把结果储存 到第 3 个数组中。也就是说，如果数组 1 中包含的值是 2 、 4 、 5 、 8 ，数组 2 中 包含的值是 1 、 0 、 4 、 6 ，那么该函数把 3 、 4 、 9 、 14 赋给第 3 个数组。函数接 受 3 个数组名和一个数组大小。在一个简单的程序中测试该函数。 11.编写一个程序，声明一个int类型的3×5二维数组，并用合适的值初始 化它。该程序打印数组中的值，然后各值翻倍（即是原值的 2 倍），并显示 出各元素的新值。编写一个函数显示数组的内容，再编写一个函数把各元素 的值翻倍。这两个函数都以函数名和行数作为参数。 12.重写程序清单10.7的rain.c程序，把main()中的主要任务都改成用函数 来完成。 13.编写一个程序，提示用户输入 3 组数，每组数包含 5 个double类型的数 （假设用户都正确地响应，不会输入非数值数据）。该程序应完成下列任\n务。 # a.把用户输入的数据储存在3×5的数组中 b.计算每组（ 5 个）数据的平均值 c.计算所有数据的平均值 d.找出这 15 个数据中的最大值 e.打印结果 每个任务都要用单独的函数来完成（使用传统C处理数组的方式）。完 成任务b，要编写一个计算并返回一维数组平均值的函数，利用循环调用该 函数 3 次。对于处理其他任务的函数，应该把整个数组作为参数，完成任务c 和d的函数应把结果返回主调函数。 14.以变长数组作为函数形参，完成编程练习 13 。\n[1].者注在最后一次while循环中执行完start++;后，start的值就是end的值。——译\n第 11 章 字符串和字符串函数 # 本章介绍以下内容： # 函数：gets()、gets_s()、fgets()、puts()、fputs()、strcat()、strncat()、 strcmp()、strncmp()、strcpy()、strncpy()、sprintf()、strchr() 创建并使用字符串 使用C库中的字符和字符串函数，并创建自定义的字符串函数 使用命令行参数 字符串是C语言中最有用、最重要的数据类型之一。虽然我们一直在使 用字符串，但是要学的东西还很多。C 库提供大量的函数用于读写字符串、 拷贝字符串、比较字符串、合并字符串、查找字符串等。通过本章的学习， 读者将进一步提高自己的编程水平。\n11.1 表示字符串和字符串 I/O # 第 4 章介绍过，字符串是以空字符（\\0）结尾的char类型数组。因此，可 以把上一章学到的数组和指针的知识应用于字符串。不过，由于字符串十分 常用，所以 C提供了许多专门用于处理字符串的函数。本章将讨论字符串的 性质、如何声明并初始化字符串、如何在程序中输入和输出字符串，以及如 何操控字符串。 程序清单11.1演示了在程序中表示字符串的几种方式。 程序清单 11.1 strings1.c 程序 // strings1.c #include \u0026lt;stdio.h\u0026gt; #define MSG \u0026ldquo;I am a symbolic string constant.\u0026rdquo; #define MAXLENGTH 81 int main(void) { char words[MAXLENGTH] = \u0026ldquo;I am a string in an array.\u0026rdquo;; const char * pt1 = \u0026ldquo;Something is pointing at me.\u0026rdquo;; puts(\u0026ldquo;Here are some strings:\u0026rdquo;); puts(MSG); puts(words); puts(pt1);\nwords[8] = \u0026lsquo;p\u0026rsquo;; puts(words); return 0; } 和printf()函数一样，puts()函数也属于stdio.h系列的输入/输出函数。但 是，与printf()不同的是，puts()函数只显示字符串，而且自动在显示的字符 串末尾加上换行符。下面是该程序的输出： Here are some strings: I am an old-fashioned symbolic string constant. I am a string in an array. Something is pointing at me. I am a spring in an array. 我们先分析一下该程序中定义字符串的几种方法，然后再讲解把字符串 读入程序涉及的一些操作，最后学习如何输出字符串。\n11.1.1 在程序中定义字符串 # 程序清单11.1中使用了多种方法（即字符串常量、char类型数组、指向 char的指针）定义字符串。程序应该确保有足够的空间储存字符串，这一点 我们稍后讨论。\n1. 字符串字面量（字符串常量） 用双引号括起来的内容称为字符串字面量（string literal），也叫作字符 串常量（string constant）。双引号中的字符和编译器自动加入末尾的\\0字 符，都作为字符串储存在内存中，所以\u0026quot;I am a symbolic stringconstant.\u0026quot;、\u0026ldquo;I\nam a string in an array.\u0026quot;、\u0026ldquo;Something is pointed at me.\u0026quot;、\u0026ldquo;Here are some strings:\u0026ldquo;都是字符串字面量。 从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符 分隔，C会将其视为串联起来的字符串字面量。例如： char greeting[50] = \u0026ldquo;Hello, and\u0026rdquo;\u0026rdquo; how are\u0026rdquo; \u0026quot; you\u0026rdquo; \u0026quot; today!\u0026rdquo;; 与下面的代码等价： char greeting[50] = \u0026ldquo;Hello, and how are you today!\u0026rdquo;; 如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠 （\\）： printf(\u0026quot;\u0026quot;Run, Spot, run!\u0026quot; exclaimed Dick.\\n\u0026quot;); 输出如下： \u0026ldquo;Run, Spot, run!\u0026rdquo; exclaimed Dick. 字符串常量属于静态存储类别（static storage class），这说明如果在函 数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存 在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串储存 位置的指针。这类似于把数组名作为指向该数组位置的指针。如果确实如 此，程序清单11.2中的程序会输出什么？ 程序清单 11.2 strptr.c 程序 /* strptr.c \u0026ndash; 把字符串看作指针 */ #include \u0026lt;stdio.h\u0026gt; int main(void)\n{ # printf(\u0026quot;%s, %p, %c\\n\u0026quot;, \u0026ldquo;We\u0026rdquo;, \u0026ldquo;are\u0026rdquo;, \u0026ldquo;space farers\u0026rdquo;); return 0; } printf()根据%s 转换说明打印 We，根据%p 转换说明打印一个地址。因 此，如果\u0026quot;are\u0026quot;代表一个地址，printf()将打印该字符串首字符的地址（如果使 用ANSI之前的实现，可能要用%u或%lu代替%p）。最后，\u0026ldquo;space farers\u0026quot;表 示该字符串所指向地址上储存的值，应该是字符串*\u0026ldquo;space farers\u0026quot;的首字 符。是否真的是这样？下面是该程序的输出： We, 0x100000f61, s\n2. 字符串数组和初始化 定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足 够空间的数组储存字符串。在下面的声明中，用指定的字符串初始化数组 m1： const char m1[40] = \u0026ldquo;Limit yourself to one line\u0026rsquo;s worth.\u0026rdquo;; const表明不会更改这个字符串。 这种形式的初始化比标准的数组初始化形式简单得多： const char m1[40] = { \u0026lsquo;L\u0026rsquo;,\u0026lsquo;i\u0026rsquo;, \u0026rsquo;m\u0026rsquo;, \u0026lsquo;i\u0026rsquo;, \u0026rsquo;t\u0026rsquo;, \u0026rsquo; \u0026lsquo;, \u0026lsquo;y\u0026rsquo;, \u0026lsquo;o\u0026rsquo;, \u0026lsquo;u\u0026rsquo;, \u0026lsquo;r\u0026rsquo;, \u0026rsquo;s\u0026rsquo;, \u0026rsquo;e\u0026rsquo;, \u0026rsquo;l\u0026rsquo;, \u0026lsquo;f\u0026rsquo;, \u0026rsquo; \u0026lsquo;, \u0026rsquo;t\u0026rsquo;, \u0026lsquo;o\u0026rsquo;, \u0026rsquo; \u0026lsquo;, \u0026lsquo;o\u0026rsquo;, \u0026rsquo;n\u0026rsquo;, \u0026rsquo;e\u0026rsquo;, \u0026rsquo; \u0026lsquo;,\u0026rsquo;l\u0026rsquo;, \u0026lsquo;i\u0026rsquo;, \u0026rsquo;n\u0026rsquo;, \u0026rsquo;e\u0026rsquo;, \u0026lsquo;\u0026quot;, \u0026rsquo;s\u0026rsquo;, \u0026rsquo; \u0026lsquo;, \u0026lsquo;w\u0026rsquo;, \u0026lsquo;o\u0026rsquo;, \u0026lsquo;r\u0026rsquo;,\u0026rsquo;t\u0026rsquo;, \u0026lsquo;h\u0026rsquo;, \u0026lsquo;.\u0026rsquo;, \u0026lsquo;\\0\u0026rsquo; };\n注意最后的空字符。没有这个空字符，这就不是一个字符串，而是一个 # 字符数组。 # 在指定数组大小时，要确保数组的元素个数至少比字符串长度多 1 （为 # 了容纳空字符）。所有未被使用的元素都被自动初始化为 0 （这里的 0 指的是 # char形式的空字符，不是数字字符 0 ），如图11.1所示。\n图11.1 初始化数组 通常，让编译器确定数组的大小很方便。回忆一下，省略数组初始化声 明中的大小，编译器会自动计算数组的大小： const char m2[] = \u0026ldquo;If you can\u0026rsquo;t think of anything, fake it.\u0026rdquo;; 让编译器确定初始化字符数组的大小很合理。因为处理字符串的函数通 常都不知道数组的大小，这些函数通过查找字符串末尾的空字符确定字符串 在何处结束。 让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再 填充的数组，就必须在声明时指定大小。声明数组时，数组大小必须是可求 值的整数。在C99新增变长数组之前，数组的大小必须是整型常量，包括由 整型常量组成的表达式。 int n = 8; char cookies[1]; // 有效 char cakes[2 + 5];// 有效，数组大小是整型常量表达式\nchar pies[2*sizeof(long double) + 1]; // 有效 char crumbs[n]; // 在C99标准之前无效，C99标准之后这种数组 是变长数组 字符数组名和其他数组名一样，是该数组首元素的地址。因此，假设有 下面的初始化： char car[10] = \u0026ldquo;Tata\u0026rdquo;; 那么，以下表达式都为真： car == \u0026amp;car[0]、car == \u0026lsquo;T\u0026rsquo;、(car+1) == car[1] == \u0026lsquo;a\u0026rsquo;。 还可以使用指针表示法创建字符串。例如，程序清单11.1中使用了下面 的声明： const char * pt1 = \u0026ldquo;Something is pointing at me.\u0026rdquo;; 该声明和下面的声明几乎相同： const char ar1[] = \u0026ldquo;Something is pointing at me.\u0026rdquo;; 以上两个声明表明，pt1和ar1都是该字符串的地址。在这两种情况下， 带双引号的字符串本身决定了预留给字符串的存储空间。尽管如此，这两种 形式并不完全相同。\n3. 数组和指针 数组形式和指针形式有何不同？以上面的声明为例，数组形式（ar1[]） 在计算机的内存中分配为一个内含 29 个元素的数组（每个元素对应一个字 符，还加上一个末尾的空字符\u0026rsquo;\\0\u0026rsquo;），每个元素被初始化为字符串字面量对 应的字符。通常，字符串都作为可执行文件的一部分储存在数据段中。当把 程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区 （static memory）中。但是，程序在开始运行时才会为该数组分配内存。此\n时，才将字符串拷贝到数组中（第 12 章将详细讲解）。注意，此时字符串 # 有两个副本。一个是在静态内存中的字符串字面量，另一个是储存在ar1数 组中的字符串。 此后，编译器便把数组名ar1识别为该数组首元素地址（\u0026amp;ar1[0]）的别 名。这里关键要理解，在数组形式中，ar1是地址常量。不能更改ar1，如果 改变了ar1，则意味着改变了数组的存储位置（即地址）。可以进行类似 ar1+1这样的操作，标识数组的下一个元素。但是不允许进行++ar1这样的操 作。递增运算符只能用于变量名前（或概括地说，只能用于可修改的左 值），不能用于常量。 指针形式（*pt1）也使得编译器为字符串在静态存储区预留 29 个元素的 空间。另外，一旦开始执行程序，它会为指针变量pt1留出一个储存位置， 并把字符串的地址储存在指针变量中。该变量最初指向该字符串的首字符， 但是它的值可以改变。因此，可以使用递增运算符。例如，++pt1将指向第 2 个字符（o）。 字符串字面量被视为const数据。由于pt1指向这个const数据，所以应该 把pt1声明为指向const数据的指针。这意味着不能用pt1改变它所指向的数 据，但是仍然可以改变pt1的值（即，pt1指向的位置）。如果把一个字符串 字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为const。 总之，初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针 只把字符串的地址拷贝给指针。程序清单11.3演示了这一点。 程序清单 11.3 addresses.c 程序 // addresses.c \u0026ndash; 字符串的地址 #define MSG \u0026ldquo;I\u0026rsquo;m special\u0026rdquo; #include \u0026lt;stdio.h\u0026gt; int main()\n{ # char ar[] = MSG; const char *pt = MSG; printf(\u0026ldquo;address of \u0026quot;I\u0026rsquo;m special\u0026quot;: %p \\n\u0026rdquo;, \u0026ldquo;I\u0026rsquo;m special\u0026rdquo;); printf(\u0026rdquo; address ar: %p\\n\u0026rdquo;, ar); printf(\u0026quot; address pt: %p\\n\u0026quot;, pt); printf(\u0026quot; address of MSG: %p\\n\u0026quot;, MSG); printf(\u0026ldquo;address of \u0026quot;I\u0026rsquo;m special\u0026quot;: %p \\n\u0026rdquo;, \u0026ldquo;I\u0026rsquo;m special\u0026rdquo;); return 0; } 下面是在我们的系统中运行该程序后的输出： address of \u0026ldquo;I\u0026rsquo;m special\u0026rdquo;: 0x100000f10 address ar: 0x7fff5fbff858 address pt: 0x100000f10 address of MSG: 0x100000f10 address of \u0026ldquo;I\u0026rsquo;m special\u0026rdquo;: 0x100000f10 该程序的输出说明了什么？第一，pt和MSG的地址相同，而ar的地址不 同，这与我们前面讨论的内容一致。第二，虽然字符串字面量\u0026quot;I\u0026rsquo;m special\u0026quot;在程序的两个 printf()函数中出现了两次，但是编译器只使用了一个 存储位置，而且与MSG的地址相同。编译器可以把多次使用的相同字面量\n储存在一处或多处。另一个编译器可能在不同的位置储存 3 个\u0026quot;I\u0026rsquo;m special\u0026quot;。 第三，静态数据使用的内存与ar使用的动态内存不同。不仅值不同，特定编 译器甚至使用不同的位数表示两种内存。 数组和指针表示字符串的区别是否很重要？通常不太重要，但是这取决 于想用程序做什么。我们来进一步讨论这个主题。\n4. 数组和指针的区别 初始化字符数组来储存字符串和初始化指针来指向字符串有何区别 （“指向字符串”的意思是指向字符串的首字符）？例如，假设有下面两个声 明： char heart[] = \u0026ldquo;I love Tillie!\u0026rdquo;; const char *head = \u0026ldquo;I love Millie!\u0026rdquo;; 两者主要的区别是：数组名heart是常量，而指针名head是变量。那么， 实际使用有什么区别？ 首先，两者都可以使用数组表示法： for (i = 0; i \u0026lt; 6; i++) putchar(heart[i]); putchar(\u0026rsquo;\\n\u0026rsquo;); for (i = 0; i \u0026lt; 6; i++) putchar(head[i]); putchar(\u0026rsquo;\\n\u0026rsquo;); 上面两段代码的输出是：\nI love I love 其次，两者都能进行指针加法操作： for (i = 0; i \u0026lt; 6; i++) putchar((heart + i)); putchar(\u0026rsquo;\\n\u0026rsquo;); for (i = 0; i \u0026lt; 6; i++) putchar((head + i)); putchar(\u0026rsquo;\\n\u0026rsquo;); 输出如下： I love I love 但是，只有指针表示法可以进行递增操作： while ((head) != \u0026lsquo;\\0\u0026rsquo;) / 在字符串末尾处停止*/ putchar((head++)); / 打印字符，指针指向下一个位置 / 这段代码的输出如下： I love Millie! 假设想让head和heart统一，可以这样做： head = heart; / head现在指向数组heart */\n这使得head指针指向heart数组的首元素。 但是，不能这样做： heart = head; /* 非法构造，不能这样写 / 这类似于x = 3;和3 = x;的情况。赋值运算符的左侧必须是变量（或概括 地说是可修改的左值），如pt_int。顺带一提，head = heart;不会导致head指 向的字符串消失，这样做只是改变了储存在head中的地址。除非已经保存 了\u0026quot;I love Millie!\u0026ldquo;的地址，否则当head指向别处时，就无法再访问该字符串。 另外，还可以改变heart数组中元素的信息： heart[7]= \u0026lsquo;M\u0026rsquo;;或者*(heart + 7) = \u0026lsquo;M\u0026rsquo;; 数组的元素是变量（除非数组被声明为const），但是数组名不是变 量。 我们来看一下未使用const限定符的指针初始化： char * word = \u0026ldquo;frame\u0026rdquo;; 是否能使用该指针修改这个字符串？ word[1] = \u0026rsquo;l\u0026rsquo;; // 是否允许？ 编译器可能允许这样做，但是对当前的C标准而言，这样的行为是未定 义的。例如，这样的语句可能导致内存访问错误。原因前面提到过，编译器 可以使用内存中的一个副本来表示所有完全相同的字符串字面量。例如，下 面的语句都引用字符串\u0026quot;Klingon\u0026quot;的一个内存位置： char * p1 = \u0026ldquo;Klingon\u0026rdquo;; p1[0] = \u0026lsquo;F\u0026rsquo;; // ok? printf(\u0026ldquo;Klingon\u0026rdquo;);\nprintf(\u0026rdquo;: Beware the %ss!\\n\u0026quot;, \u0026ldquo;Klingon\u0026rdquo;); 也就是说，编译器可以用相同的地址替换每个\u0026quot;Klingon\u0026quot;实例。如果编译 器使用这种单次副本表示法，并允许p1[0]修改\u0026rsquo;F\u0026rsquo;，那将影响所有使用该字 符串的代码。所以以上语句打印字符串字面量\u0026quot;Klingon\u0026quot;时实际上显示的 是\u0026quot;Flingon\u0026quot;： Flingon: Beware the Flingons! 实际上在过去，一些编译器由于这方面的原因，其行为难以捉摸，而另 一些编译器则导致程序异常中断。因此，建议在把指针初始化为字符串字面 量时使用const限定符： const char * pl = \u0026ldquo;Klingon\u0026rdquo;; // 推荐用法 然而，把非const数组初始化为字符串字面量却不会导致类似的问题。 因为数组获得的是原始字符串的副本。 总之，如果不修改字符串，不要用指针指向字符串字面量。\n5. 字符串数组 如果创建一个字符数组会很方便，可以通过数组下标访问多个不同的字 符串。程序清单11.4演示了两种方法：指向字符串的指针数组和char类型数 组的数组。 程序清单 11.4 arrchar.c 程序 // arrchar.c \u0026ndash; 指针数组，字符串数组 #include \u0026lt;stdio.h\u0026gt; #define SLEN 40 #define LIM 5\nint main(void) { const char *mytalents[LIM] = { \u0026ldquo;Adding numbers swiftly\u0026rdquo;, \u0026ldquo;Multiplying accurately\u0026rdquo;, \u0026ldquo;Stashing data\u0026rdquo;, \u0026ldquo;Following instructions to the letter\u0026rdquo;, \u0026ldquo;Understanding the C language\u0026rdquo; }; char yourtalents[LIM][SLEN] = { \u0026ldquo;Walking in a straight line\u0026rdquo;, \u0026ldquo;Sleeping\u0026rdquo;, \u0026ldquo;Watching television\u0026rdquo;, \u0026ldquo;Mailing letters\u0026rdquo;, \u0026ldquo;Reading email\u0026rdquo; }; int i; puts(\u0026ldquo;Let\u0026rsquo;s compare talents.\u0026rdquo;); printf(\u0026quot;%-36s %-25s\\n\u0026quot;, \u0026ldquo;My Talents\u0026rdquo;, \u0026ldquo;Your Talents\u0026rdquo;); for (i = 0; i \u0026lt; LIM; i++) printf(\u0026quot;%-36s %-25s\\n\u0026quot;, mytalents[i], yourtalents[i]); printf(\u0026quot;\\nsizeof mytalents: %zd, sizeof yourtalents: %zd\\n\u0026quot;,\nsizeof(mytalents), sizeof(yourtalents)); return 0; } 下面是该程序的输出： Let\u0026rsquo;s compare talents. My Talents Your Talents Adding numbers swiftly Walking in a straight line Multiplying accurately Sleeping Stashing data Watching television Following instructions to the letter Mailing letters Understanding the C language Reading email sizeof mytalents: 40, sizeof yourtalents: 200 从某些方面来看，mytalents和yourtalents非常相似。两者都代表 5 个字符 串。使用一个下标时都分别表示一个字符串，如mytalents[0]和 yourtalents[0]；使用两个下标时都分别表示一个字符，例如 mytalents[1][2]表 示 mytalents 数组中第 2 个指针所指向的字符串的第 3 个字符\u0026rsquo;l\u0026rsquo;， yourtalents[1][2]表示youttalentes数组的第 2 个字符串的第 3 个字符\u0026rsquo;e\u0026rsquo;。而且， 两者的初始化方式也相同。 但是，它们也有区别。mytalents数组是一个内含 5 个指针的数组，在我\n们的系统中共占用 40 字节。而yourtalents是一个内含 5 个数组的数组，每个数 组内含 40 个char类型的值，共占用 200 字节。所以，虽然mytalents[0]和 yourtalents[0]都分别表示一个字符串，但mytalents和yourtalents的类型并不相 同。mytalents中的指针指向初始化时所用的字符串字面量的位置，这些字符 串字面量被储存在静态内存中；而 yourtalents 中的数组则储存着字符串字面 量的副本，所以每个字符串都被储存了两次。此外，为字符串数组分配内存 的使用率较低。yourtalents 中的每个元素的大小必须相同，而且必须是能储 存最长字符串的大小。 我们可以把yourtalents想象成矩形二维数组，每行的长度都是 40 字节； 把mytalents想象成不规则的数组，每行的长度不同。图 11.2 演示了这两种数 组的情况（实际上，mytalents 数组的指针元素所指向的字符串不必储存在连 续的内存中，图中所示只是为了强调两种数组的不同）。\n图11.2 矩形数组和不规则数组 综上所述，如果要用数组表示一系列待显示的字符串，请使用指针数 组，因为它比二维字符数组的效率高。但是，指针数组也有自身的缺点。\nmytalents 中的指针指向的字符串字面量不能更改；而yourtalentsde 中的内容 可以更改。所以，如果要改变字符串或为字符串输入预留空间，不要使用指 向字符串字面量的指针。\n11.1.2 指针和字符串 # 读者可能已经注意到了，在讨论字符串时或多或少会涉及指针。实际 # 上，字符串的绝大多数操作都是通过指针完成的。例如，考虑程序清单11.5 # 中的程序。 # 程序清单 11.5 p_and_s.c 程序 /* p_and_s.c \u0026ndash; 指针和字符串 */ #include \u0026lt;stdio.h\u0026gt; int main(void) { const char * mesg = \u0026ldquo;Don\u0026rsquo;t be a fool!\u0026rdquo;; const char * copy; copy = mesg; printf(\u0026quot;%s\\n\u0026quot;, copy); printf(\u0026ldquo;mesg = %s; \u0026amp;mesg = %p; value = %p\\n\u0026rdquo;, mesg, \u0026amp;mesg, mesg); printf(\u0026ldquo;copy = %s; \u0026amp;copy = %p; value = %p\\n\u0026rdquo;, copy, \u0026amp;copy, copy); return 0;\n} # 注意 # 如果编译器不识别%p，用%u或%lu代替%p。 你可能认为该程序拷贝了字符串\u0026quot;Don\u0026rsquo;t be a fool!\u0026quot;，程序的输出似乎也验 证了你的猜测： Don\u0026rsquo;t be a fool! mesg = Don\u0026rsquo;t be a fool!; \u0026amp;mesg = 0x0012ff48; value = 0x0040a000 copy = Don\u0026rsquo;t be a fool!; \u0026amp;copy = 0x0012ff44; value = 0x0040a000 我们来仔细分析最后两个printf()的输出。首先第 1 项，mesg和copy都以 字符串形式输出（%s转换说明）。这里没问题，两个字符串都是\u0026quot;Don\u0026rsquo;t be a fool!\u0026quot;。 接着第 2 项，打印两个指针的地址。如上输出所示，指针mesg和copy分 别储存在地址为0x0012ff48和0x0012ff44的内存中。 注意最后一项，显示两个指针的值。所谓指针的值就是它储存的地址。 mesg 和 copy 的值都是0x0040a000，说明它们都指向的同一个位置。因此， 程序并未拷贝字符串。语句copy = mesg;把mesg的值赋给copy，即让copy也指 向mesg指向的字符串。 为什么要这样做？为何不拷贝整个字符串？假设数组有 50 个元素，考虑 一下哪种方法更效率：拷贝一个地址还是拷贝整个数组？通常，程序要完成 某项操作只需要知道地址就可以了。如果确实需要拷贝整个数组，可以使用 strcpy()或strncpy()函数，本章稍后介绍这两个函数。 我们已经讨论了如何在程序中定义字符串，接下来看看如何从键盘输入\n字符串。 # 11.2 字符串输入 # 如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然 # 后用输入函数获取该字符串。 # 11.2.1 分配空间 # 要做的第 1 件事是分配空间，以储存稍后读入的字符串。前面提到过， # 这意味着必须要为字符串分配足够的空间。不要指望计算机在读取字符串时 # 顺便计算它的长度，然后再分配空间（计算机不会这样做，除非你编写一个 # 处理这些任务的函数）。假设编写了如下代码： # char *name; scanf(\u0026quot;%s\u0026quot;, name); 虽然可能会通过编译（编译器很可能给出警告），但是在读入name 时，name可能会擦写掉程序中的数据或代码，从而导致程序异常中止。因 为scanf()要把信息拷贝至参数指定的地址上，而此时该参数是个未初始化的 指针，name可能会指向任何地方。大多数程序员都认为出现这种情况很搞 笑，但仅限于评价别人的程序时。 最简单的方法是，在声明时显式指明数组的大小： char name[81]; 现在name是一个已分配块（ 81 字节）的地址。还有一种方法是使用C库 函数来分配内存，第 12 章将详细介绍。 为字符串分配内存后，便可读入字符串。C 库提供了许多读取字符串的 函数：scanf()、gets()和fgets()。我们先讨论最常用gets()函数。\n11.2.2 不幸的 gets() 函数 # 在读取字符串时，scanf()和转换说明%s只能读取一个单词。可是在程序 中经常要读取一整行输入，而不仅仅是一个单词。许多年前，gets()函数就 用于处理这种情况。gets()函数简单易用，它读取整行输入，直至遇到换行 符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符 使其成为一个 C 字符串。它经常和 puts()函数配对使用，该函数用于显示字 符串，并在末尾添加换行符。程序清单11.6中演示了这两个函数的用法。 程序清单 11.6 getsputs.c 程序 /* getsputs.c \u0026ndash; 使用 gets() 和 puts() */ #include \u0026lt;stdio.h\u0026gt; #define STLEN 81 int main(void) { char words[STLEN]; puts(\u0026ldquo;Enter a string, please.\u0026rdquo;); gets(words); // 典型用法 printf(\u0026ldquo;Your string twice:\\n\u0026rdquo;); printf(\u0026quot;%s\\n\u0026quot;, words); puts(words); puts(\u0026ldquo;Done.\u0026rdquo;); return 0; }\n下面是该程序在某些编译器（或者至少是旧式编译器）中的运行示例： # Enter a string, please. I want to learn about string theory! Your string twice: I want to learn about string theory! I want to learn about string theory! Done. 整行输入（除了换行符）都被储存在 words 中，puts(words)和 printf(\u0026quot;%s\\n, words\u0026quot;)的效果相同。 下面是该程序在另一个编译器中的输出示例： Enter a string, please. warning: this program uses gets(), which is unsafe. Oh, no! Your string twice: Oh, no! Oh, no! Done. 编译器在输出中插入了一行警告消息。每次运行这个程序，都会显示这 行消息。但是，并非所有的编译器都会这样做。其他编译器可能在编译过程 中给出警告，但不会引起你的注意。\n这是怎么回事？问题出在 gets()唯一的参数是 words，它无法检查数组 是否装得下输入行。上一章介绍过，数组名会被转换成该数组首元素的地 址，因此，gets()函数只知道数组的开始处，并不知道数组中有多少个元 素。 如果输入的字符串过长，会导致缓冲区溢出（buffer overflow），即多 余的字符超出了指定的目标空间。如果这些多余的字符只是占用了尚未使用 的内存，就不会立即出现问题；如果它们擦写掉程序中的其他数据，会导致 程序异常中止；或者还有其他情况。为了让输入的字符串容易溢出，把程序 中的STLEN设置为 5 ，程序的输出如下： Enter a string, please. warning: this program uses gets(), which is unsafe. I think I\u0026rsquo;ll be just fine. Your string twice: I think I\u0026rsquo;ll be just fine. I think I\u0026rsquo;ll be just fine. Done. Segmentation fault: 11 “Segmentation fault”（分段错误）似乎不是个好提示，的确如此。在 UNIX系统中，这条消息说明该程序试图访问未分配的内存。 C 提供解决某些编程问题的方法可能会导致陷入另一个尴尬棘手的困 境。但是，为什么要特别提到gets()函数？因为该函数的不安全行为造成了 安全隐患。过去，有些人通过系统编程，利用gets()插入和运行一些破坏系 统安全的代码。\n不久，C 编程社区的许多人都建议在编程时摒弃 gets()。制定 C99 标准 的委员会把这些建议放入了标准，承认了gets()的问题并建议不要再使用 它。尽管如此，在标准中保留gets()也合情合理，因为现有程序中含有大量 使用该函数的代码。而且，只要使用得当，它的确是一个很方便的函数。 好景不长，C11标准委员会采取了更强硬的态度，直接从标准中废除了 gets()函数。既然标准已经发布，那么编译器就必须根据标准来调整支持什 么，不支持什么。然而在实际应用中，编译器为了能兼容以前的代码，大部 分都继续支持gets()函数。不过，我们使用的编译器，可没那么大方。\n11.2.3 gets() 的替代品 # 过去通常用fgets()来代替gets()，fgets()函数稍微复杂些，在处理输入方 面与gets()略有不同。C11标准新增的gets_s()函数也可代替gets()。该函数与 gets()函数更接近，而且可以替换现有代码中的gets()。但是，它是stdio.h输 入/输出函数系列中的可选扩展，所以支持C11的编译器也不一定支持它。 1.fgets() 函数（和 fputs() ） fgets()函数通过第 2 个参数限制读入的字符数来解决溢出的问题。该函 数专门设计用于处理文件输入，所以一般情况下可能不太好用。fgets()和 gets()的区别如下。 fgets()函数的第 2 个参数指明了读入字符的最大数量。如果该参数的值 是n，那么fgets()将读入n-1个字符，或者读到遇到的第一个换行符为止。 如果fgets()读到一个换行符，会把它储存在字符串中。这点与gets()不 同，gets()会丢弃换行符。 fgets()函数的第 3 个参数指明要读入的文件。如果读入从键盘输入的数 据，则以stdin（标准输入）作为参数，该标识符定义在stdio.h中。 因为 fgets()函数把换行符放在字符串的末尾（假设输入行不溢出），通 常要与 fputs()函数（和puts()类似）配对使用，除非该函数不在字符串末尾\n添加换行符。fputs()函数的第 2 个参数指明它要写入的文件。如果要显示在 计算机显示器上，应使用stdout（标准输出）作为该参数。程序清单11.7演 示了fgets()和fputs()函数的用法。 程序清单 11.7 fgets1.c 程序 /* fgets1.c \u0026ndash; 使用 fgets() 和 fputs() */ #include \u0026lt;stdio.h\u0026gt; #define STLEN 14 int main(void) { char words[STLEN]; puts(\u0026ldquo;Enter a string, please.\u0026rdquo;); fgets(words, STLEN, stdin); printf(\u0026ldquo;Your string twice (puts(), then fputs()):\\n\u0026rdquo;); puts(words); fputs(words, stdout); puts(\u0026ldquo;Enter another string, please.\u0026rdquo;); fgets(words, STLEN, stdin); printf(\u0026ldquo;Your string twice (puts(), then fputs()):\\n\u0026rdquo;); puts(words); fputs(words, stdout);\nputs(\u0026ldquo;Done.\u0026rdquo;); return 0; } 下面是该程序的输出示例： Enter a string, please. apple pie Your string twice (puts(), then fputs()): apple pie apple pie Enter another string, please. strawberry shortcake Your string twice (puts(), then fputs()): strawberry sh strawberry shDone. 第 1 行输入，apple pie，比fgets()读入的整行输入短，因此，apple pie\\n\\0 被储存在数组中。所以当puts()显示该字符串时又在末尾添加了换行符，因 此apple pie后面有一行空行。因为fputs()不在字符串末尾添加换行符，所以 并未打印出空行。 第 2 行输入，strawberry shortcake，超过了大小的限制，所以fgets()只读 入了 13 个字符，并把strawberry sh\\0 储存在数组中。再次提醒读者注意， puts()函数会在待输出字符串末尾添加一个换行符，而fputs()不会这样做。\nfputs()函数返回指向 char的指针。如果一切进行顺利，该函数返回的地 址与传入的第 1 个参数相同。但是，如果函数读到文件结尾，它将返回一个 特殊的指针：空指针（null pointer）。该指针保证不会指向有效的数据，所 以可用于标识这种特殊情况。在代码中，可以用数字 0 来代替，不过在C语 言中用宏NULL来代替更常见（如果在读入数据时出现某些错误，该函数也 返回NULL）。程序清单11.8演示了一个简单的循环，读入并显示用户输入 的内容，直到fgets()读到文件结尾或空行（即，首字符是换行符）。 程序清单 11.8 fgets2.c 程序 /* fgets2.c \u0026ndash; 使用 fgets() 和 fputs() */ #include \u0026lt;stdio.h\u0026gt; #define STLEN 10 int main(void) { char words[STLEN]; puts(\u0026ldquo;Enter strings (empty line to quit):\u0026rdquo;); while (fgets(words, STLEN, stdin) != NULL \u0026amp;\u0026amp; words[0] != \u0026lsquo;\\n\u0026rsquo;) fputs(words, stdout); puts(\u0026ldquo;Done.\u0026rdquo;); return 0; } 下面是该程序的输出示例：\nEnter strings (empty line to quit): By the way, the gets() function By the way, the gets() function also returns a null pointer if it also returns a null pointer if it encounters end-of-file. encounters end-of-file. Done. 有意思，虽然STLEN被设置为 10 ，但是该程序似乎在处理过长的输入时 完全没问题。程序中的fgets()一次读入 STLEN - 1 个字符（该例中为 9 个字 符）。所以，一开始它只读入了“By the wa”，并储存为By the wa\\0；接着 fputs()打印该字符串，而且并未换行。然后while循环进入下一轮迭代， fgets()继续从剩余的输入中读入数据，即读入“y, the ge”并储存为y, the ge\\0； 接着fputs()在刚才打印字符串的这一行接着打印第 2 次读入的字符串。然后 while 进入下一轮迭代，fgets()继续读取输入、fputs()打印字符串，这一过程 循环进行，直到读入最后的“tion\\n”。fgets()将其储存为tion\\n\\0， fputs()打印 该字符串，由于字符串中的\\n，光标被移至下一行开始处。 系统使用缓冲的I/O。这意味着用户在按下Return键之前，输入都被储存 在临时存储区（即，缓冲区）中。按下Return键就在输入中增加了一个换行 符，并把整行输入发送给fgets()。对于输出，fputs()把字符发送给另一个缓 冲区，当发送换行符时，缓冲区中的内容被发送至屏幕上。 fgets()储存换行符有好处也有坏处。坏处是你可能并不想把换行符储存 在字符串中，这样的换行符会带来一些麻烦。好处是对于储存的字符串而 言，检查末尾是否有换行符可以判断是否读取了一整行。如果不是一整行，\n要妥善处理一行中剩下的字符。 # 首先，如何处理掉换行符？一个方法是在已储存的字符串中查找换行 # 符，并将其替换成空字符： # while (words[i] != \u0026lsquo;\\n\u0026rsquo;) // 假设\\n在words中 i++; words[i] = \u0026lsquo;\\0\u0026rsquo;; 其次，如果仍有字符串留在输入行怎么办？一个可行的办法是，如果目 标数组装不下一整行输入，就丢弃那些多出的字符： while (getchar() != \u0026lsquo;\\n\u0026rsquo;) // 读取但不储存输入，包括\\n continue; 程序清单11.9在程序清单11.8的基础上添加了一部分测试代码。该程序 读取输入行，删除储存在字符串中的换行符，如果没有换行符，则丢弃数组 装不下的字符。 程序清单 11.9 fgets3.c 程序 /* fgets3.c \u0026ndash; 使用 fgets() */ #include \u0026lt;stdio.h\u0026gt; #define STLEN 10 int main(void) { char words[STLEN];\nint i; puts(\u0026ldquo;Enter strings (empty line to quit):\u0026rdquo;); while (fgets(words, STLEN, stdin) != NULL \u0026amp;\u0026amp; words[0] != \u0026lsquo;\\n\u0026rsquo;) { i = 0; while (words[i] != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; words[i] != \u0026lsquo;\\0\u0026rsquo;) i++; if (words[i] == \u0026lsquo;\\n\u0026rsquo;) words[i] = \u0026lsquo;\\0\u0026rsquo;; else // 如果word[i] == \u0026lsquo;\\0\u0026rsquo;则执行这部分代码 while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; puts(words); } puts(\u0026ldquo;done\u0026rdquo;); return 0; } 循环\nwhile (words[i] != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; words[i] != \u0026lsquo;\\0\u0026rsquo;) i++; 遍历字符串，直至遇到换行符或空字符。如果先遇到换行符，下面的if 语句就将其替换成空字符；如果先遇到空字符，else部分便丢弃输入行的剩 余字符。下面是该程序的输出示例： Enter strings (empty line to quit): This This program seems program s unwilling to accept long lines. unwilling But it doesn\u0026rsquo;t get stuck on long But it do lines either. lines eit done 空字符和空指针 程序清单 11.9 中出现了空字符和空指针。从概念上看，两者完全不 同。空字符（或\u0026rsquo;\\0\u0026rsquo;）是用于标记C字符串末尾的字符，其对应字符编码是\n0 。由于其他字符的编码不可能是 0 ，所以不可能是字符串的一部分。 # 空指针（或NULL）有一个值，该值不会与任何数据的有效地址对应。 # 通常，函数使用它返回一个有效地址表示某些特殊情况发生，例如遇到文件 # 结尾或未能按预期执行。 # 空字符是整数类型，而空指针是指针类型。两者有时容易混淆的原因 # 是：它们都可以用数值 0 来表示。但是，从概念上看，两者是不同类型的 0 。 # 另外，空字符是一个字符，占 1 字节；而空指针是一个地址，通常占 4 字节。 # 2.gets_s() 函数 C11新增的gets_s()函数（可选）和fgets()类似，用一个参数限制读入的 字符数。假设把程序清单11.9中的fgets()换成gets_s()，其他内容不变，那么 下面的代码将把一行输入中的前 9 个字符读入words数组中，假设末尾有换行 符： gets_s(words, STLEN); gets_s()与fgets()的区别如下。 gets_s()只从标准输入中读取数据，所以不需要第 3 个参数。 如果gets_s()读到换行符，会丢弃它而不是储存它。 如果gets_s()读到最大字符数都没有读到换行符，会执行以下几步。首 先把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直至读到换 行符或文件结尾，然后返回空指针。接着，调用依赖实现的“处理函数”（或 你选择的其他函数），可能会中止或退出程序。 第 2 个特性说明，只要输入行未超过最大字符数，gets_s()和gets()几乎一 样，完全可以用gets_s()替换gets()。第 3 个特性说明，要使用这个函数还需要 进一步学习。 我们来比较一下 gets()、fgets()和 gets_s()的适用性。如果目标存储区装\n得下输入行， 3 个函数都没问题。但是fgets()会保留输入末尾的换行符作为 字符串的一部分，要编写额外的代码将其替换成空字符。 如果输入行太长会怎样？使用gets()不安全，它会擦写现有数据，存在 安全隐患。gets_s()函数很安全，但是，如果并不希望程序中止或退出，就 要知道如何编写特殊的“处理函数”。另外，如果打算让程序继续运行， gets_s()会丢弃该输入行的其余字符，无论你是否需要。由此可见，当输入 太长，超过数组可容纳的字符数时，fgets()函数最容易使用，而且可以选择 不同的处理方式。如果要让程序继续使用输入行中超出的字符，可以参考程 序清单11.8中的处理方法。如果想丢弃输入行的超出字符，可以参考程序清 单11.9中的处理方法。 所以，当输入与预期不符时，gets_s()完全没有fgets()函数方便、灵活。 也许这也是gets_s()只作为C库的可选扩展的原因之一。鉴于此，fgets()通常 是处理类似情况的最佳选择。 3.s_gets() 函数 程序清单11.9演示了fgets()函数的一种用法：读取整行输入并用空字符 代替换行符，或者读取一部分输入，并丢弃其余部分。既然没有处理这种情 况的标准函数，我们就创建一个，在后面的程序中会用得上。程序清单 11.10提供了一个这样的函数。 程序清单 11.10 s_gets() 函数 char * s_gets(char * st, int n) { char * ret_val; int i = 0; ret_val = fgets(st, n, stdin);\nif (ret_val) // 即，ret_val != NULL { while (st[i] != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; st[i] != \u0026lsquo;\\0\u0026rsquo;) i++; if (st[i] == \u0026lsquo;\\n\u0026rsquo;) st[i] = \u0026lsquo;\\0\u0026rsquo;; else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } return ret_val; } 如果 fgets()返回 NULL，说明读到文件结尾或出现读取错误，s_gets()函 数跳过了这个过程。它模仿程序清单11.9的处理方法，如果字符串中出现换 行符，就用空字符替换它；如果字符串中出现空字符，就丢弃该输入行的其 余字符，然后返回与fgets()相同的值。我们在后面的示例中将讨论fgets()函 数。 也许读者想了解为什么要丢弃过长输入行中的余下字符。这是因为，输 入行中多出来的字符会被留在缓冲区中，成为下一次读取语句的输入。例 如，如果下一条读取语句要读取的是 double 类型的值，就可能导致程序崩 溃。丢弃输入行余下的字符保证了读取语句与键盘输入同步。 我们设计的 s_gets()函数并不完美，它最严重的缺陷是遇到不合适的输\n入时毫无反应。它丢弃多余的字符时，既不通知程序也不告知用户。但是， # 用来替换前面程序示例中的gets()足够了。\n11.2.4 scanf() 函数 # 我们再来研究一下scanf()。前面的程序中用scanf()和%s转换说明读取字 符串。scanf()和gets()或fgets()的区别在于它们如何确定字符串的末尾： scanf()更像是“获取单词”函数，而不是“获取字符串”函数；如果预留的存储 区装得下输入行，gets()和fgets()会读取第 1 个换行符之前所有的字符。 scanf()函数有两种方法确定输入结束。无论哪种方法，都从第 1 个非空白字 符作为字符串的开始。如果使用%s转换说明，以下一个空白字符（空行、 空格、制表符或换行符）作为字符串的结束（字符串不包括空白字符）。如 果指定了字段宽度，如%10s，那么scanf()将读取 10 个字符或读到第 1 个空白 字符停止（先满足的条件即是结束输入的条件），见图11.3。\n图11.3 字段宽度和scanf() 前面介绍过，scanf()函数返回一个整数值，该值等于scanf()成功读取的 项数或EOF（读到文件结尾时返回EOF）。 程序清单11.11演示了在scanf()函数中指定字段宽度的用法。 程序清单 11.11 scan_str.c 程序 /* scan_str.c \u0026ndash; 使用 scanf() */ #include \u0026lt;stdio.h\u0026gt;\nint main(void) { char name1[11], name2[11]; int count; printf(\u0026ldquo;Please enter 2　names.\\n\u0026rdquo;); count = scanf(\u0026quot;%5s %10s\u0026quot;, name1, name2); printf(\u0026ldquo;I read the %d names %s and %s.\\n\u0026rdquo;, count, name1, name2); return 0; } 下面是该程序的 3 个输出示例： Please enter 2 names. Jesse Jukes I read the 2 names Jesse and Jukes. Please enter 2 names. Liza Applebottham I read the 2 names Liza and Applebotth. Please enter 2 names. Portensia Callowit\nI read the 2 names Porte and nsia. 第 1 个输出示例，两个名字的字符个数都未超过字段宽度。第 2 个输出示 例，只读入了Applebottham的前 10 个字符Applebotth（因为使用了%10s转换 说明）。第 3 个输出示例，Portensia的后 4 个字符nsia被写入name2中，因为第 2 次调用scanf()时，从上一次调用结束的地方继续读取数据。在该例中，读 取的仍是Portensia中的字母。 根据输入数据的性质，用fgets()读取从键盘输入的数据更合适。例如， scanf()无法完整读取书名或歌曲名，除非这些名称是一个单词。scanf()的典 型用法是读取并转换混合数据类型为某种标准形式。例如，如果输入行包含 一种工具名、库存量和单价，就可以使用scanf()。否则可能要自己拼凑一个 函数处理一些输入检查。如果一次只输入一个单词，用scanf()也没问题。 scanf()和gets()类似，也存在一些潜在的缺点。如果输入行的内容过长， scanf()也会导致数据溢出。不过，在%s转换说明中使用字段宽度可防止溢 出。\n11.3 字符串输出 # 讨论完字符串输入，接下来我们讨论字符串输出。C有 3 个标准库函数 # 用于打印字符串：put()、fputs()和printf()。\n11.3.1 puts() 函数 # puts()函数很容易使用，只需把字符串的地址作为参数传递给它即可。 程序清单11.12演示了puts()的一些用法。 程序清单 11.12 put_out.c 程序 /* put_out.c \u0026ndash; 使用 puts() */ #include \u0026lt;stdio.h\u0026gt; #define DEF \u0026ldquo;I am a #defined string.\u0026rdquo; int main(void) { char str1[80] = \u0026ldquo;An array was initialized to me.\u0026rdquo;; const char * str2 = \u0026ldquo;A pointer was initialized to me.\u0026rdquo;; puts(\u0026ldquo;I\u0026rsquo;m an argument to puts().\u0026rdquo;); puts(DEF); puts(str1); puts(str2); puts(\u0026amp;str1[5]);\nputs(str2 + 4); return 0; } 该程序的输出如下： I\u0026rsquo;m an argument to puts(). I am a #defined string. An array was initialized to me. A pointer was initialized to me. ray was initialized to me. inter was initialized to me. 如上所示，每个字符串独占一行，因为puts()在显示字符串时会自动在 其末尾添加一个换行符。 该程序示例再次说明，用双引号括起来的内容是字符串常量，且被视为 该字符串的地址。另外，储存字符串的数组名也被看作是地址。在第 5 个 puts()调用中，表达式\u0026amp;str1[5]是str1数组的第 6 个元素（r），puts()从该元素 开始输出。与此类似，第 6 个puts()调用中，str2+4指向储存\u0026quot;pointer\u0026quot;中i的存 储单元，puts()从这里开始输出。 puts()如何知道在何处停止？该函数在遇到空字符时就停止输出，所以 必须确保有空字符。不要模仿程序清单11.13中的程序！ 程序清单 11.13 nono.c 程序 /* nono.c \u0026ndash; 千万不要模仿！ */\n#include \u0026lt;stdio.h\u0026gt; int main(void) { char side_a[] = \u0026ldquo;Side A\u0026rdquo;; char dont[] = { \u0026lsquo;W\u0026rsquo;, \u0026lsquo;O\u0026rsquo;, \u0026lsquo;W\u0026rsquo;, \u0026lsquo;!\u0026rsquo; }; char side_b[] = \u0026ldquo;Side B\u0026rdquo;; puts(dont); /* dont 不是一个字符串 */ return 0; } 由于dont缺少一个表示结束的空字符，所以它不是一个字符串，因此 puts()不知道在何处停止。它会一直打印dont后面内存中的内容，直到发现一 个空字符为止。为了让puts()能尽快读到空字符，我们把dont放在side_a和 side_b之间。下面是该程序的一个运行示例： WOW!Side A 我们使用的编译器把side_a数组储存在dont数组之后，所以puts()一直输 出至遇到side_a中的空字符。你所使用的编译器输出的内容可能不同，这取 决于编译器如何在内存中储存数据。如果删除程序中的side_a和side_b数组 会怎样？通常内存中有许多空字符，如果幸运的话，puts()很快就会发现一 个。但是，这样做很不靠谱。\n11.3.2 fputs() 函数 # fputs()函数是puts()针对文件定制的版本。它们的区别如下。 fputs()函数的第 2 个参数指明要写入数据的文件。如果要打印在显示器 上，可以用定义在stdio.h中的stdout（标准输出）作为该参数。 与puts()不同，fputs()不会在输出的末尾添加换行符。 注意，gets()丢弃输入中的换行符，但是puts()在输出中添加换行符。另 一方面，fgets()保留输入中的换行符，fputs()不在输出中添加换行符。假设 要编写一个循环，读取一行输入，另起一行打印出该输入。可以这样写： char line[81]; while (gets(line))// 与while (gets(line) != NULL)相同 puts(line); 如果gets()读到文件结尾会返回空指针。对空指针求值为 0 （即为假）， 这样便可结束循环。或者，可以这样写： char line[81]; while (fgets(line, 81, stdin)) fputs(line, stdout); 第 1 个循环（使用gets()和puts()的while循环），line数组中的字符串显示 在下一行，因为puts()在字符串末尾添加了一个换行符。第 2 个循环（使用 fgets()和fputs()的while循环），line数组中的字符串也显示在下一行，因为 fgets()把换行符储存在字符串末尾。注意，如果混合使用 fgets()输入和puts() 输出，每个待显示的字符串末尾就会有两个换行符。这里关键要注意： puts()应与gets()配对使用，fputs()应与fgets()配对使用。 我们在这里提到已被废弃的 gets()，并不是鼓励使用它，而是为了让读 者了解它的用法。如果今后遇到包含该函数的代码，不至于看不懂。\n11.3.3 printf() 函数 # 在第 4 章中，我们详细讨论过printf()函数的用法。和puts()一样，printf() 也把字符串的地址作为参数。printf()函数用起来没有puts()函数那么方便， 但是它更加多才多艺，因为它可以格式化不同的数据类型。 与puts()不同的是，printf()不会自动在每个字符串末尾加上一个换行 符。因此，必须在参数中指明应该在哪里使用换行符。例如： printf(\u0026quot;%s\\n\u0026quot;, string); 和下面的语句效果相同： puts(string); 如上所示，printf()的形式更复杂些，需要输入更多代码，而且计算机执 行的时间也更长（但是你觉察不到）。然而，使用 printf()打印多个字符串 更加简单。例如，下面的语句把 Well、用户名和一个#define定义的字符串 打印在一行： printf(\u0026ldquo;Well, %s, %s\\n\u0026rdquo;, name, MSG);\n11.4 自定义输入 / 输出函数 # 不一定非要使用C库中的标准函数，如果无法使用这些函数或者不想用 # 它们，完全可以在getchar()和putchar()的基础上自定义所需的函数。假设你 需要一个类似puts()但是不会自动添加换行符的函数。程序清单11.14给出了 一个这样的函数。 程序清单 11.14 put1() 函数 /* put1.c \u0026ndash; 打印字符串，不添加\\n / #include \u0026lt;stdio.h\u0026gt; void put1(const char * string)/ 不会改变字符串 */ { while (*string != \u0026lsquo;\\0\u0026rsquo;) putchar(string++); } 指向char的指针string最初指向传入参数的首元素。因为该函数不会改变 传入的字符串，所以形参使用了const限定符。打印了首元素的内容后，指 针递增 1 ，指向下一个元素。while循环重复这一过程，直到指针指向包含空 字符的元素。记住，++的优先级高于，因此putchar(*string++)打印string指 向的值，递增的是string本身，而不是递增它所指向的字符。 可以把 put1.c 程序作为编写字符串处理函数的模型。因为每个字符串都 以空字符结尾，所以不用给函数传递字符串的大小。函数依次处理每个字 符，直至遇到空字符。 用数组表示法编写这个函数稍微复杂些：\nint i = 0; while (string[i]!= \u0026lsquo;\\0\u0026rsquo;) putchar(string[i++]); 要为数组索引创建一个额外的变量。 许多C程序员会在while循环中使用下面的测试条件： while (*string) 当string指向空字符时，*string的值是 0 ，即测试条件为假，while循环结 束。这种方法比上面两种方法简洁。但是，如果不熟悉C语言，可能觉察不 出来。这种处理方法很普遍，作为C程序员应该熟悉这种写法。 注意 为什么程序清单11.14中的形式参数是const char * string，而不是const char sting[]？从技术方面看，两者等价且都有效。使用带方括号的写法是为 了提醒用户：该函数处理的是数组。然而，如果要处理字符串，实际参数可 以是数组名、用双引号括起来的字符串，或声明为 char 类型的变量。用 const char * string可以提醒用户：实际参数不一定是数组。 假设要设计一个类似puts()的函数，而且该函数还给出待打印字符的个 数。如程序清单11.15所示，添加一个功能很简单。 程序清单 11.15 put2.c 程序 / put2.c \u0026ndash; 打印一个字符串，并统计打印的字符数 */ #include \u0026lt;stdio.h\u0026gt; int put2(const char * string) {\nint count = 0; while (string) / 常规用法 */ { putchar(string++); count++; } putchar(\u0026rsquo;\\n\u0026rsquo;); / 不统计换行符 */ return(count); } 下面的函数调用将打印字符串pizza： put1(\u0026ldquo;pizza\u0026rdquo;); 下面的调用将返回统计的字符数，并将其赋给num（该例中，num的值 是 5 ）： num = put2(\u0026ldquo;pizza\u0026rdquo;); 程序清单11.16使用一个简单的驱动程序测试put1()和put2()，并演示了嵌 套函数的调用。 程序清单 11.16 .c 程序 //put_put.c \u0026ndash; 用户自定义输出函数 #include \u0026lt;stdio.h\u0026gt; void put1(const char *);\nint put2(const char *); int main(void) { put1(\u0026ldquo;If I\u0026rsquo;d as much money\u0026rdquo;); put1(\u0026quot; as I could spend,\\n\u0026quot;); printf(\u0026ldquo;I count %d characters.\\n\u0026rdquo;, put2(\u0026ldquo;I never would cry old chairs to mend.\u0026rdquo;)); return 0; } void put1(const char * string) { while (string) / 与 *string != \u0026lsquo;\\0\u0026rsquo; 相同 */ putchar(*string++); } int put2(const char * string) { int count = 0; while (*string) {\nputchar(*string++); count++; } putchar(\u0026rsquo;\\n\u0026rsquo;); return(count); } 程序中使用 printf()打印 put2()的值，但是为了获得 put2()的返回值，计 算机必须先执行put2()，因此在打印字符数之前先打印了传递给该函数的字 符串。下面是该程序的输出： If I\u0026rsquo;d as much money as I could spend, I never would cry old chairs to mend. I count 37　characters.\n11.5 字符串函数 # C库提供了多个处理字符串的函数，ANSI C把这些函数的原型放在 # string.h头文件中。其中最常用的函数有 strlen()、strcat()、strcmp()、 strncmp()、strcpy()和 strncpy()。另外，还有sprintf()函数，其原型在stdio.h头 文件中。欲了解string.h系列函数的完整列表，请查阅附录B中的参考资料 V“新增C99和C11的标准ANSI C库”。\n11.5.1 strlen() 函数 # strlen()函数用于统计字符串的长度。下面的函数可以缩短字符串的长 度，其中用到了strlen()： void fit(char string, unsigned int size) { if (strlen(string) \u0026gt; size) string[size] = \u0026lsquo;\\0\u0026rsquo;; } 该函数要改变字符串，所以函数头在声明形式参数string时没有使用 const限定符。 程序清单11.17中的程序测试了fit()函数。注意代码中使用了C字符串常 量的串联特性。 程序清单 11.17 test_fit.c 程序 / test_fit.c \u0026ndash; 使用缩短字符串长度的函数 */ #include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt; /* 内含字符串函数原型 */ void fit(char *, unsigned int); int main(void) { char mesg [] = \u0026ldquo;Things should be as simple as possible,\u0026rdquo; \u0026quot; but not simpler.\u0026quot;; puts(mesg); fit(mesg, 38); puts(mesg); puts(\u0026ldquo;Let\u0026rsquo;s look at some more of the string.\u0026rdquo;); puts(mesg + 39); return 0; } void fit(char *string, unsigned int size) { if (strlen(string) \u0026gt; size) string[size] = \u0026lsquo;\\0\u0026rsquo;; } 下面是该程序的输出：\nThings should be as simple as possible, but not simpler. Things should be as simple as possible Let\u0026rsquo;s look at some more of the string. but not simpler. fit()函数把第 39 个元素的逗号替换成\u0026rsquo;\\0\u0026rsquo;字符。puts()函数在空字符处停止 输出，并忽略其余字符。然而，这些字符还在缓冲区中，下面的函数调用把 这些字符打印了出来： puts(mesg + 8); 表达式mesg + 39是mesg[39]的地址，该地址上储存的是空格字符。所以 put()显示该字符并继续输出直至遇到原来字符串中的空字符。图11.4演示了 这一过程。\n图11.4 puts()函数和空字符 注意 一些ANSI之前的系统使用strings.h头文件，而有些系统可能根本没有字 符串头文件。 # string.h头文件中包含了C字符串函数系列的原型，因此程序清单11.17要 包含该头文件。\n11.5.2 strcat() 函数 # strcat()（用于拼接字符串）函数接受两个字符串作为参数。该函数把第 2 个字符串的备份附加在第 1 个字符串末尾，并把拼接后形成的新字符串作为 第 1 个字符串，第 2 个字符串不变。strcat()函数的类型是char （即，指向char 的指针）。strcat()函数返回第 1 个参数，即拼接第 2 个字符串后的第 1 个字符 串的地址。 程序清单11.18演示了strcat()的用法。该程序还使用了程序清单11.10的 s_gets()函数。回忆一下，该函数使用fgets()读取一整行，如果有换行符，将 其替换成空字符。 程序清单 11.18 str_cat.c 程序 / str_cat.c \u0026ndash; 拼接两个字符串 / #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; / strcat()函数的原型在该头文件中 */ #define SIZE 80 char * s_gets(char * st, int n); int main(void) { char flower[SIZE]; char addon [] = \u0026ldquo;s smell like old shoes.\u0026rdquo;;\nputs(\u0026ldquo;What is your favorite flower?\u0026rdquo;); if (s_gets(flower, SIZE)) { strcat(flower, addon); puts(flower); puts(addon); } else puts(\u0026ldquo;End of file encountered!\u0026rdquo;); puts(\u0026ldquo;bye\u0026rdquo;); return 0; } char * s_gets(char * st, int n) { char * ret_val; int i = 0; ret_val = fgets(st, n, stdin); if (ret_val) {\nwhile (st[i] != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; st[i] != \u0026lsquo;\\0\u0026rsquo;) i++; if (st[i] == \u0026lsquo;\\n\u0026rsquo;) st[i] = \u0026lsquo;\\0\u0026rsquo;; else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } return ret_val; } 该程序的输出示例如下： What is your favorite flower? wonderflower wonderflowers smell like old shoes. s smell like old shoes. bye 从以上输出可以看出，flower改变了，而addon保持不变。\n11.5.3 strncat() 函数 # strcat()函数无法检查第 1 个数组是否能容纳第 2 个字符串。如果分配给第\n1 个数组的空间不够大，多出来的字符溢出到相邻存储单元时就会出问题。 # 当然，可以像程序清单11.15那样，用strlen()查看第 1 个数组的长度。注意， 要给拼接后的字符串长度加 1 才够空间存放末尾的空字符。或者，用 strncat()，该函数的第 3 个参数指定了最大添加字符数。例如，strncat(bugs, addon, 13)将把 addon字符串的内容附加给bugs，在加到第 13 个字符或遇到空 字符时停止。因此，算上空字符（无论哪种情况都要添加空字符），bugs数 组应该足够大，以容纳原始字符串（不包含空字符）、添加原始字符串在后 面的 13 个字符和末尾的空字符。程序清单11.19使用这种方法，计算avaiable 变量的值，用于表示允许添加的最大字符数。 程序清单 11.19 join_chk.c 程序 /* join_chk.c \u0026ndash; 拼接两个字符串，检查第 1 个数组的大小 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define SIZE 30 #define BUGSIZE 13 char * s_gets(char * st, int n); int main(void) { char flower[SIZE]; char addon [] = \u0026ldquo;s smell like old shoes.\u0026rdquo;; char bug[BUGSIZE]; int available;\nputs(\u0026ldquo;What is your favorite flower?\u0026rdquo;); s_gets(flower, SIZE); if ((strlen(addon) + strlen(flower) + 1) \u0026lt;= SIZE) strcat(flower, addon); puts(flower); puts(\u0026ldquo;What is your favorite bug?\u0026rdquo;); s_gets(bug, BUGSIZE); available = BUGSIZE - strlen(bug) - 1; strncat(bug, addon, available); puts(bug); return 0; } char * s_gets(char * st, int n) { char * ret_val; int i = 0; ret_val = fgets(st, n, stdin); if (ret_val) {\nwhile (st[i] != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; st[i] != \u0026lsquo;\\0\u0026rsquo;) i++; if (st[i] == \u0026lsquo;\\n\u0026rsquo;) st[i] = \u0026lsquo;\\0\u0026rsquo;; else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } return ret_val; } 下面是该程序的运行示例： What is your favorite flower? Rose Roses smell like old shoes. What is your favorite bug? Aphid Aphids smell 读者可能已经注意到，strcat()和 gets()类似，也会导致缓冲区溢出。为 什么 C11 标准不废弃strcat()，只留下strncat()？为何对gets()那么残忍？这也 许是因为gets()造成的安全隐患来自于使用该程序的人，而strcat()暴露的问\n题是那些粗心的程序员造成的。无法控制用户会进行什么操作，但是，可以 # 控制你的程序做什么。C语言相信程序员，因此程序员有责任确保strcat()的 使用安全。\n11.5.4 strcmp() 函数 # 假设要把用户的响应与已储存的字符串作比较，如程序清单11.20所 # 示。 # 程序清单 11.20 nogo.c 程序 /* nogo.c -- 该程序是否能正常运行？ */ #include \u0026lt;stdio.h\u0026gt; #define ANSWER \u0026#34;Grant\u0026#34; #define SIZE 40 char * s_gets(char * st, int n); int main(void) { char try[SIZE]; puts(\u0026#34;Who is buried in Grant\u0026#39;s tomb?\u0026#34;); s_gets(try, SIZE); while (try != ANSWER) { puts(\u0026#34;No, that\u0026#39;s wrong. Try again.\u0026#34;); s_gets(try, SIZE); } puts(\u0026ldquo;That\u0026rsquo;s right!\u0026rdquo;); return 0; } char * s_gets(char * st, int n) { char * ret_val; int i = 0; ret_val = fgets(st, n, stdin); if (ret_val) { while (st[i] != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; st[i] != \u0026lsquo;\\0\u0026rsquo;) i++; if (st[i] == \u0026lsquo;\\n\u0026rsquo;) st[i] = \u0026lsquo;\\0\u0026rsquo;; else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue;\n} # return ret_val; } 这个程序看上去没问题，但是运行后却不对劲。ANSWER和try都是指 针，所以try != ANSWER检查的不是两个字符串是否相等，而是这两个字符 串的地址是否相同。因为ANSWE和try储存在不同的位置，所以这两个地址 不可能相同，因此，无论用户输入什么，程序都提示输入不正确。这真让人 沮丧。 该函数要比较的是字符串的内容，不是字符串的地址。读者可以自己设 计一个函数，也可以使用C标准库中的strcmp()函数（用于字符串比较）。该 函数通过比较运算符来比较字符串，就像比较数字一样。如果两个字符串参 数相同，该函数就返回 0 ，否则返回非零值。修改后的版本如程序清单11.21 所示。 程序清单 11.21 compare.c 程序 /* compare.c \u0026ndash; 该程序可以正常运行 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; // strcmp()函数的原型在该头文件中 #define ANSWER \u0026ldquo;Grant\u0026rdquo; #define SIZE 40 char * s_gets(char * st, int n); int main(void) {\nchar try[SIZE]; puts(\u0026ldquo;Who is buried in Grant\u0026rsquo;s tomb?\u0026rdquo;); s_gets(try, SIZE); while (strcmp(try, ANSWER) != 0) { puts(\u0026ldquo;No, that\u0026rsquo;s wrong. Try again.\u0026rdquo;); s_gets(try, SIZE); } puts(\u0026ldquo;That\u0026rsquo;s right!\u0026rdquo;); return 0; } char * s_gets(char * st, int n) { char * ret_val; int i = 0; ret_val = fgets(st, n, stdin); if (ret_val) { while (st[i] != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; st[i] != \u0026lsquo;\\0\u0026rsquo;)\ni++; if (st[i] == \u0026lsquo;\\n\u0026rsquo;) st[i] = \u0026lsquo;\\0\u0026rsquo;; else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } return ret_val; } 注意 由于非零值都为“真”，所以许多经验丰富的C程序员会把该例main()中 的while循环头写成：while (strcmp(try, ANSWER)) strcmp()函数比较的是字符串，不是整个数组，这是非常好的功能。虽 然数组try占用了 40 字节，而储存在其中的\u0026quot;Grant\u0026quot;只占用了 6 字节（还有一个 用来放空字符），strcmp()函数只会比较try中第 1 个空字符前面的部分。所 以，可以用strcmp()比较储存在不同大小数组中的字符串。 如果用户输入GRANT、grant或Ulysses S.Grant会怎样？程序会告知用户 输入错误。希望程序更友好，必须把所有正确答案的可能性包含其中。这里 可以使用一些小技巧。例如，可以使用#define定义类似GRANT这样的答 案，并编写一个函数把输入的内容都转换成小写，就解决了大小写的问题。 但是，还要考虑一些其他错误的形式，这些留给读者完成。 1.strcmp() 的返回值\n如果strcmp()比较的字符串不同，它会返回什么值？请看程序清单11.22 的程序示例。 程序清单 11.22 compback.c 程序 /* compback.c \u0026ndash; strcmp()的返回值 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { printf(\u0026ldquo;strcmp(\u0026quot;A\u0026quot;, \u0026quot;A\u0026quot;) is \u0026ldquo;); printf(\u0026quot;%d\\n\u0026rdquo;, strcmp(\u0026ldquo;A\u0026rdquo;, \u0026ldquo;A\u0026rdquo;)); printf(\u0026ldquo;strcmp(\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;) is \u0026ldquo;); printf(\u0026quot;%d\\n\u0026rdquo;, strcmp(\u0026ldquo;A\u0026rdquo;, \u0026ldquo;B\u0026rdquo;)); printf(\u0026ldquo;strcmp(\u0026quot;B\u0026quot;, \u0026quot;A\u0026quot;) is \u0026ldquo;); printf(\u0026quot;%d\\n\u0026rdquo;, strcmp(\u0026ldquo;B\u0026rdquo;, \u0026ldquo;A\u0026rdquo;)); printf(\u0026ldquo;strcmp(\u0026quot;C\u0026quot;, \u0026quot;A\u0026quot;) is \u0026ldquo;); printf(\u0026quot;%d\\n\u0026rdquo;, strcmp(\u0026ldquo;C\u0026rdquo;, \u0026ldquo;A\u0026rdquo;)); printf(\u0026ldquo;strcmp(\u0026quot;Z\u0026quot;, \u0026quot;a\u0026quot;) is \u0026ldquo;); printf(\u0026quot;%d\\n\u0026rdquo;, strcmp(\u0026ldquo;Z\u0026rdquo;, \u0026ldquo;a\u0026rdquo;)); printf(\u0026ldquo;strcmp(\u0026quot;apples\u0026quot;, \u0026quot;apple\u0026quot;) is \u0026ldquo;);\nprintf(\u0026quot;%d\\n\u0026rdquo;, strcmp(\u0026ldquo;apples\u0026rdquo;, \u0026ldquo;apple\u0026rdquo;)); return 0; } 在我们的系统中运行该程序，输出如下： strcmp(\u0026ldquo;A\u0026rdquo;, \u0026ldquo;A\u0026rdquo;) is 0 strcmp(\u0026ldquo;A\u0026rdquo;, \u0026ldquo;B\u0026rdquo;) is -1 strcmp(\u0026ldquo;B\u0026rdquo;, \u0026ldquo;A\u0026rdquo;) is 1 strcmp(\u0026ldquo;C\u0026rdquo;, \u0026ldquo;A\u0026rdquo;) is 1 strcmp(\u0026ldquo;Z\u0026rdquo;, \u0026ldquo;a\u0026rdquo;) is -1 strcmp(\u0026ldquo;apples\u0026rdquo;, \u0026ldquo;apple\u0026rdquo;) is 1 strcmp()比较\u0026quot;A\u0026quot;和本身，返回 0 ；比较\u0026quot;A\u0026quot;和\u0026quot;B\u0026rdquo;，返回-1；比 较\u0026quot;B\u0026quot;和\u0026quot;A\u0026rdquo;，返回 1 。这说明，如果在字母表中第 1 个字符串位于第 2 个字符 串前面，strcmp()中就返回负数；反之，strcmp()则返回正数。所以， strcmp()比较\u0026quot;C\u0026quot;和\u0026quot;A\u0026rdquo;，返回 1 。其他系统可能返回 2 ，即两者的ASCII码之 差。ASCII标准规定，在字母表中，如果第 1 个字符串在第 2 个字符串前面， strcmp()返回一个负数；如果两个字符串相同，strcmp()返回 0 ；如果第 1 个字 符串在第 2 个字符串后面，strcmp()返回正数。然而，返回的具体值取决于实 现。例如，下面给出在不同实现中的输出，该实现返回两个字符的差值： strcmp(\u0026ldquo;A\u0026rdquo;, \u0026ldquo;A\u0026rdquo;) is 0 strcmp(\u0026ldquo;A\u0026rdquo;, \u0026ldquo;B\u0026rdquo;) is -1 strcmp(\u0026ldquo;B\u0026rdquo;, \u0026ldquo;A\u0026rdquo;) is 1 strcmp(\u0026ldquo;C\u0026rdquo;, \u0026ldquo;A\u0026rdquo;) is 2\nstrcmp(\u0026ldquo;Z\u0026rdquo;, \u0026ldquo;a\u0026rdquo;) is -7 strcmp(\u0026ldquo;apples\u0026rdquo;, \u0026ldquo;apple\u0026rdquo;) is 115 如果两个字符串开始的几个字符都相同会怎样？一般而言，strcmp()会 依次比较每个字符，直到发现第 1 对不同的字符为止。然后，返回相应的 值。例如，在上面的最后一个例子中，\u0026ldquo;apples\u0026quot;和\u0026quot;apple\u0026quot;只有最后一对字符 不同（\u0026ldquo;apples\u0026quot;的s和\u0026quot;apple\u0026quot;的空字符）。由于空字符在ASCII中排第 1 。字符 s一定在它后面，所以strcmp()返回一个正数。 最后一个例子表明，strcmp()比较所有的字符，不只是字母。所以，与 其说该函数按字母顺序进行比较，不如说是按机器排序序列（machine collating sequence）进行比较，即根据字符的数值进行比较（通常都使用 ASCII值）。在ASCII中，大写字母在小写字母前面，所以strcmp(\u0026ldquo;Z\u0026rdquo;, \u0026ldquo;a\u0026rdquo;)返 回的是负值。 大多数情况下，strcmp()返回的具体值并不重要，我们只在意该值是 0 还 是非 0 （即，比较的两个字符串是否相等）。或者按字母排序字符串，在这 种情况下，需要知道比较的结果是为正、为负还是为 0 。 注意 strcmp()函数比较的是字符串，不是字符，所以其参数应该是字符串 （如\u0026quot;apples\u0026quot;和\u0026quot;A\u0026rdquo;），而不是字符（如\u0026rsquo;A\u0026rsquo;）。但是，char 类型实际上是整数 类型，所以可以使用关系运算符来比较字符。假设word是储存在char类型数 组中的字符串，ch是char类型的变量，下面的语句都有效： if (strcmp(word, \u0026ldquo;quit\u0026rdquo;) == 0) // 使用strcmp()比较字符串 puts(\u0026ldquo;Bye!\u0026rdquo;); if (ch == \u0026lsquo;q\u0026rsquo;) // 使用 == 比较字符 puts(\u0026ldquo;Bye!\u0026rdquo;);\n尽管如此，不要使用ch或\u0026rsquo;q\u0026rsquo;作为strcmp()的参数。 程序清单11.23用strcmp()函数检查程序是否要停止读取输入。 程序清单 11.23 quit_chk.c 程序 /* quit_chk.c \u0026ndash; 某程序的开始部分 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define SIZE 80 #define LIM 10 #define STOP \u0026ldquo;quit\u0026rdquo; char * s_gets(char * st, int n); int main(void) { char input[LIM][SIZE]; int ct = 0; printf(\u0026ldquo;Enter up to %d lines (type quit to quit):\\n\u0026rdquo;, LIM); while (ct \u0026lt; LIM \u0026amp;\u0026amp; s_gets(input[ct], SIZE) != NULL \u0026amp;\u0026amp; strcmp(input[ct], STOP) != 0) { ct++;\n} # printf(\u0026quot;%d strings entered\\n\u0026rdquo;, ct); return 0; } char * s_gets(char * st, int n) { char * ret_val; int i = 0; ret_val = fgets(st, n, stdin); if (ret_val) { while (st[i] != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; st[i] != \u0026lsquo;\\0\u0026rsquo;) i++; if (st[i] == \u0026lsquo;\\n\u0026rsquo;) st[i] = \u0026lsquo;\\0\u0026rsquo;; else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; }\nreturn ret_val; } 该程序在读到EOF字符（这种情况下s_gets()返回NULL）、用户输入quit 或输入项达到LIM时退出。 顺带一提，有时输入空行（即，只按下Enter键或Return键）表示结束输 入更方便。为实现这一功能，只需修改一下while循环的条件即可： while (ct \u0026lt; LIM \u0026amp;\u0026amp; s_gets(input[ct], SIZE) != NULL\u0026amp;\u0026amp; input[ct][0] != \u0026lsquo;\\0\u0026rsquo;) 这里，input[ct]是刚输入的字符串，input[ct][0]是该字符串的第 1 个字 符。如果用户输入空行， s_gets()便会把该行第 1 个字符（换行符）替换成空 字符。所以，下面的表达式用于检测空行： input[ct][0] != \u0026lsquo;\\0\u0026rsquo; 2.strncmp() 函数 strcmp()函数比较字符串中的字符，直到发现不同的字符为止，这一过 程可能会持续到字符串的末尾。而strncmp()函数在比较两个字符串时，可以 比较到字符不同的地方，也可以只比较第 3 个参数指定的字符数。例如，要 查找以\u0026quot;astro\u0026quot;开头的字符串，可以限定函数只查找这 5 个字符。程序清单 11.24 演示了该函数的用法。 程序清单 11.24 starsrch.c 程序 /* starsrch.c \u0026ndash; 使用 strncmp() */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define LISTSIZE 6\nint main() { const char * list[LISTSIZE] = { \u0026ldquo;astronomy\u0026rdquo;, \u0026ldquo;astounding\u0026rdquo;, \u0026ldquo;astrophysics\u0026rdquo;, \u0026ldquo;ostracize\u0026rdquo;, \u0026ldquo;asterism\u0026rdquo;, \u0026ldquo;astrophobia\u0026rdquo; }; int count = 0; int i; for (i = 0; i \u0026lt; LISTSIZE; i++) if (strncmp(list[i], \u0026ldquo;astro\u0026rdquo;, 5) == 0) { printf(\u0026ldquo;Found: %s\\n\u0026rdquo;, list[i]); count++; } printf(\u0026ldquo;The list contained %d words beginning\u0026rdquo; \u0026quot; with astro.\\n\u0026rdquo;, count); return 0;\n} # 下面是该程序的输出： # Found: astronomy Found: astrophysics Found: astrophobia The list contained 3 words beginning with astro. 11.5.5 strcpy() 和 strncpy() 函数 # 前面提到过，如果pts1和pts2都是指向字符串的指针，那么下面语句拷 贝的是字符串的地址而不是字符串本身： pts2 = pts1; 如果希望拷贝整个字符串，要使用strcpy()函数。程序清单11.25要求用 户输入以q开头的单词。该程序把输入拷贝至一个临时数组中，如果第 1 个 字母是q，程序调用strcpy()把整个字符串从临时数组拷贝至目标数组中。 strcpy()函数相当于字符串赋值运算符。 程序清单 11.25 copy1.c 程序 /* copy1.c \u0026ndash; 演示 strcpy() */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; // strcpy()的原型在该头文件中 #define SIZE 40 #define LIM 5\nchar * s_gets(char * st, int n); int main(void) { char qwords[LIM][SIZE]; char temp[SIZE]; int i = 0; printf(\u0026ldquo;Enter %d words beginning with q:\\n\u0026rdquo;, LIM); while (i \u0026lt; LIM \u0026amp;\u0026amp; s_gets(temp, SIZE)) { if (temp[0] != \u0026lsquo;q\u0026rsquo;) printf(\u0026quot;%s doesn\u0026rsquo;t begin with q!\\n\u0026rdquo;, temp); else { strcpy(qwords[i], temp); i++; } } puts(\u0026ldquo;Here are the words accepted:\u0026rdquo;); for (i = 0; i \u0026lt; LIM; i++)\nputs(qwords[i]); return 0; } char * s_gets(char * st, int n) { char * ret_val; int i = 0; ret_val = fgets(st, n, stdin); if (ret_val) { while (st[i] != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; st[i] != \u0026lsquo;\\0\u0026rsquo;) i++; if (st[i] == \u0026lsquo;\\n\u0026rsquo;) st[i] = \u0026lsquo;\\0\u0026rsquo;; else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } return ret_val;\n} # 下面是该程序的运行示例： # Enter 5　words beginning with q: quackery quasar quilt quotient no more no more doesn\u0026rsquo;t begin with q! quiz Here are the words accepted: quackery quasar quilt quotient quiz 注意，只有在输入以q开头的单词后才会递增计数器i，而且该程序通过 比较字符进行判断： if (temp[0] != \u0026lsquo;q\u0026rsquo;)\n这行代码的意思是：temp中的第 1 个字符是否是q？当然，也可以通过比 较字符串进行判断： if (strncmp(temp, \u0026ldquo;q\u0026rdquo;, 1) != 0) 这行代码的意思是：temp字符串和\u0026quot;q\u0026quot;的第 1 个元素是否相等？ 请注意，strcpy()第 2 个参数（temp）指向的字符串被拷贝至第 1 个参数 （qword[i]）指向的数组中。拷贝出来的字符串被称为目标字符串，最初的 字符串被称为源字符串。参考赋值表达式语句，很容易记住strcpy()参数的 顺序，即第 1 个是目标字符串，第 2 个是源字符串。 char target[20]; int x; x = 50; /* 数字赋值*/ strcpy(target, \u0026ldquo;Hi ho!\u0026rdquo;); /* 字符串赋值*/ target = \u0026ldquo;So long\u0026rdquo;; /* 语法错误 */程序员有责任确保目标数组有 足够的空间容纳源字符串的副本。下面的代码有点问题： char * str; strcpy(str, \u0026ldquo;The C of Tranquility\u0026rdquo;); // 有问题 strcpy()把\u0026quot;The C of Tranquility\u0026quot;拷贝至str指向的地址上，但是str未被初始 化，所以该字符串可能被拷贝到任意的地方！ 总之，strcpy()接受两个字符串指针作为参数，可以把指向源字符串的 第 2 个指针声明为指针、数组名或字符串常量；而指向源字符串副本的第 1 个 指针应指向一个数据对象（如，数组），且该对象有足够的空间储存源字符 串的副本。记住，声明数组将分配储存数据的空间，而声明指针只分配储存 一个地址的空间。\n1.strcpy() 的其他属性 strcpy()函数还有两个有用的属性。第一，strcpy()的返回类型是 char ， 该函数返回的是第 1 个参数的值，即一个字符的地址。第二，第 1 个参数不 必指向数组的开始。这个属性可用于拷贝数组的一部分。程序清单11.26演 示了该函数的这两个属性。 程序清单 11.26 copy2.c 程序 / copy2.c \u0026ndash; 使用 strcpy() */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; // 提供strcpy()的函数原型 #define WORDS \u0026ldquo;beast\u0026rdquo; #define SIZE 40 int main(void) { const char * orig = WORDS; char copy[SIZE] = \u0026ldquo;Be the best that you can be.\u0026rdquo;; char * ps; puts(orig); puts(copy); ps = strcpy(copy + 7, orig); puts(copy);\nputs(ps); return 0; } 下面是该程序的输出： beast Be the best that you can be. Be the beast beast 注意，strcpy()把源字符串中的空字符也拷贝在内。在该例中，空字符 覆盖了copy数组中that的第 1 个t（见图11.5）。注意，由于第 1 个参数是copy + 7 ，所以ps指向copy中的第 8 个元素（下标为 7 ）。因此puts(ps)从该处开始打 印字符串。\n图11.5 使用指针strcpy()函数 2. 更谨慎的选择： strncpy() strcpy()和 strcat()都有同样的问题，它们都不能检查目标空间是否能容 纳源字符串的副本。拷贝字符串用 strncpy()更安全，该函数的第 3 个参数指 明可拷贝的最大字符数。程序清单 11.27 用strncpy()代替程序清单11.25中的 strcpy()。为了演示目标空间装不下源字符串的副本会发生什么情况，该程 序使用了一个相当小的目标字符串（共 7 个元素，包含 6 个字符）。 程序清单 11.27 copy3.c 程序 /* copy3.c \u0026ndash; 使用strncpy() / #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; / 提供strncpy()的函数原型*/ #define SIZE 40 #define TARGSIZE 7 #define LIM 5 char * s_gets(char * st, int n); int main(void) { char qwords[LIM][TARGSIZE]; char temp[SIZE]; int i = 0; printf(\u0026ldquo;Enter %d words beginning with q:\\n\u0026rdquo;, LIM);\nwhile (i \u0026lt; LIM \u0026amp;\u0026amp; s_gets(temp, SIZE)) { if (temp[0] != \u0026lsquo;q\u0026rsquo;) printf(\u0026quot;%s doesn\u0026rsquo;t begin with q!\\n\u0026rdquo;, temp); else { strncpy(qwords[i], temp, TARGSIZE - 1); qwords[i][TARGSIZE - 1] = \u0026lsquo;\\0\u0026rsquo;; i++; } } puts(\u0026ldquo;Here are the words accepted:\u0026rdquo;); for (i = 0; i \u0026lt; LIM; i++) puts(qwords[i]); return 0; } char * s_gets(char * st, int n) { char * ret_val;\nint i = 0; ret_val = fgets(st, n, stdin); if (ret_val) { while (st[i] != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; st[i] != \u0026lsquo;\\0\u0026rsquo;) i++; if (st[i] == \u0026lsquo;\\n\u0026rsquo;) st[i] = \u0026lsquo;\\0\u0026rsquo;; else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } return ret_val; } 下面是该程序的运行示例： Enter 5　words beginning with q: quack quadratic quisling\nquota quagga Here are the words accepted: quack quadra quisli quota quagga strncpy(target, source, n)把source中的n个字符或空字符之前的字符（先满 足哪个条件就拷贝到何处）拷贝至target中。因此，如果source中的字符数小 于n，则拷贝整个字符串，包括空字符。但是，strncpy()拷贝字符串的长度不 会超过n，如果拷贝到第n个字符时还未拷贝完整个源字符串，就不会拷贝空 字符。所以，拷贝的副本中不一定有空字符。鉴于此，该程序把 n 设置为比 目标数组大小少 1 （TARGSIZE-1），然后把数组最后一个元素设置为空字 符： strncpy(qwords[i], temp, TARGSIZE - 1); qwords[i][TARGSIZE - 1] = \u0026lsquo;\\0\u0026rsquo;; 这样做确保储存的是一个字符串。如果目标空间能容纳源字符串的副 本，那么从源字符串拷贝的空字符便是该副本的结尾；如果目标空间装不下 副本，则把副本最后一个元素设置为空字符。\n11.5.6 sprintf() 函数 # sprintf()函数声明在stdio.h中，而不是在string.h中。该函数和printf()类 似，但是它是把数据写入字符串，而不是打印在显示器上。因此，该函数可 # 以把多个元素组合成一个字符串。sprintf()的第 1 个参数是目标字符串的地 址。其余参数和printf()相同，即格式字符串和待写入项的列表。 程序清单11.28中的程序用printf()把 3 个项（两个字符串和一个数字）组 合成一个字符串。注意， sprintf()的用法和printf()相同，只不过sprintf()把组 合后的字符串储存在数组formal中而不是显示在屏幕上。 程序清单 11.28 format.c 程序 /* format.c \u0026ndash; 格式化字符串 */ #include \u0026lt;stdio.h\u0026gt; #define MAX 20 char * s_gets(char * st, int n); int main(void) { char first[MAX]; char last[MAX]; char formal[2 * MAX + 10]; double prize; puts(\u0026ldquo;Enter your first name:\u0026rdquo;); s_gets(first, MAX); puts(\u0026ldquo;Enter your last name:\u0026rdquo;);\ns_gets(last, MAX); puts(\u0026ldquo;Enter your prize money:\u0026rdquo;); scanf(\u0026quot;%lf\u0026quot;, \u0026amp;prize); sprintf(formal, \u0026ldquo;%s, %-19s: $%6.2f\\n\u0026rdquo;, last, first, prize); puts(formal); return 0; } char * s_gets(char * st, int n) { char * ret_val; int i = 0; ret_val = fgets(st, n, stdin); if (ret_val) { while (st[i] != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; st[i] != \u0026lsquo;\\0\u0026rsquo;) i++; if (st[i] == \u0026lsquo;\\n\u0026rsquo;) st[i] = \u0026lsquo;\\0\u0026rsquo;; else\nwhile (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } return ret_val; } 下面是该程序的运行示例： Enter your first name: Annie Enter your last name: von Wurstkasse Enter your prize money: 25000 von Wurstkasse, Annie : $25000.00 sprintf()函数获取输入，并将其格式化为标准形式，然后把格式化后的 字符串储存在formal中。\n11.5.7 其他字符串函数 # ANSI C库有 20 多个用于处理字符串的函数，下面总结了一些常用的函 # 数。 # char *strcpy(char * restrict s1, const char * restrict s2); 该函数把s2指向的字符串（包括空字符）拷贝至s1指向的位置，返回值 是s1。 char *strncpy(char * restrict s1, const char * restrict s2, size_t n); 该函数把s2指向的字符串拷贝至s1指向的位置，拷贝的字符数不超过 n，其返回值是s1。该函数不会拷贝空字符后面的字符，如果源字符串的字 符少于n个，目标字符串就以拷贝的空字符结尾；如果源字符串有n个或超过 n个字符，就不拷贝空字符。 char *strcat(char * restrict s1, const char * restrict s2); 该函数把s2指向的字符串拷贝至s1指向的字符串末尾。s2字符串的第 1 个字符将覆盖s1字符串末尾的空字符。该函数返回s1。 char *strncat(char * restrict s1, const char * restrict s2, size_t n); 该函数把s2字符串中的n个字符拷贝至s1字符串末尾。s2字符串的第 1 个 字符将覆盖s1字符串末尾的空字符。不会拷贝s2字符串中空字符和其后的字 符，并在拷贝字符的末尾添加一个空字符。该函数返回s1。 int strcmp(const char * s1, const char * s2); 如果s1字符串在机器排序序列中位于s2字符串的后面，该函数返回一个 正数；如果两个字符串相等，则返回 0 ；如果s1字符串在机器排序序列中位 于s2字符串的前面，则返回一个负数。 int strncmp(const char * s1, const char * s2, size_t n); 该函数的作用和strcmp()类似，不同的是，该函数在比较n个字符后或遇 到第 1 个空字符时停止比较。 char *strchr(const char * s, int c); 如果s字符串中包含c字符，该函数返回指向s字符串首位置的指针（末 尾的空字符也是字符串的一部分，所以在查找范围内）；如果在字符串s中\n未找到c字符，该函数则返回空指针。 char *strpbrk(const char * s1, const char * s2);如果 s1 字符中包含 s2 字符 串中的任意字符，该函数返回指向 s1 字符串首位置的指针；如果在s1字符 串中未找到任何s2字符串中的字符，则返回空字符。 char *strrchr(const char * s, int c);该函数返回s字符串中c字符的最后一次 出现的位置（末尾的空字符也是字符串的一部分，所以在查找范围内）。如 果未找到c字符，则返回空指针。 char *strstr(const char * s1, const char * s2); 该函数返回指向s1字符串中s2字符串出现的首位置。如果在s1中没有找 到s2，则返回空指针。 size_t strlen(const char * s); 该函数返回s字符串中的字符数，不包括末尾的空字符。 请注意，那些使用const关键字的函数原型表明，函数不会更改字符 串。例如，下面的函数原型： char *strcpy(char * restrict s1, const char * restrict s2); 表明不能更改s2指向的字符串，至少不能在strcpy()函数中更改。但是可 以更改s1指向的字符串。这样做很合理，因为s1是目标字符串，要改变，而 s2是源字符串，不能更改。 关键字restrict将在第 12 章中介绍，该关键字限制了函数参数的用法。例 如，不能把字符串拷贝给本身。 第 5 章中讨论过，size_t类型是sizeof运算符返回的类型。C规定sizeof运 算符返回一个整数类型，但是并未指定是哪种整数类型，所以size_t在一个 系统中可以是unsigned int，而在另一个系统中可以是 unsigned long。string.h 头文件针对特定系统定义了 size_t，或者参考其他有 size_t定义的头文件。\n前面提到过，参考资料V中列出了string.h系列的所有函数。除提供ANSI 标准要求的函数外，许多实现还提供一些其他函数。应查看你所使用的C实 现文档，了解可以使用哪些函数。 我们来看一下其中一个函数的简单用法。前面学过的fgets()读入一行输 入时，在目标字符串的末尾添加换行符。我们自定义的s_gets()函数通过 while循环检测换行符。其实，这里可以用strchr()代替s_gets()。首先，使用 strchr()查找换行符（如果有的话）。如果该函数发现了换行符，将返回该换 行符的地址，然后便可用空字符替换该位置上的换行符： char line[80]; char * find; fgets(line, 80, stdin); find = strchr(line, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果没找到换行符，返回NULL *find = \u0026lsquo;\\0\u0026rsquo;; // 把该处的字符替换为空字符 如果strchr()未找到换行符，fgets()在达到行末尾之前就达到了它能读取 的最大字符数。可以像在s_gets()中那样，给if添加一个else来处理这种情 况。 接下来，我们看一个处理字符串的完整程序。\n11.6 字符串示例：字符串排序 # 我们来处理一个按字母表顺序排序字符串的实际问题。准备名单表、创 # 建索引和许多其他情况下都会用到字符串排序。该程序主要是用 strcmp()函 数来确定两个字符串的顺序。一般的做法是读取字符串函数、排序字符串并 打印出来。之前，我们设计了一个读取字符串的方案，该程序就用到这个方 案。打印字符串没问题。程序使用标准的排序算法，稍后解释。我们使用了 一个小技巧，看看读者是否能明白。程序清单11.29演示了这个程序。 程序清单 11.29 sort_str.c 程序 /* sort_str.c \u0026ndash; 读入字符串，并排序字符串 / #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define SIZE 81 / 限制字符串长度，包括 \\0 / #define LIM 20 / 可读入的最多行数 / #define HALT \u0026quot;\u0026quot; / 空字符串停止输入 */ void stsrt(char strings [], int num); / 字符串排序函数 / char * s_gets(char * st, int n); int main(void) { char input[LIM][SIZE]; / 储存输入的数组　*/ char ptstr[LIM]; / 内含指针变量的数组　/ int ct = 0; / 输入计数　*/\nint k; /* 输出计数　/ printf(\u0026ldquo;Input up to %d lines, and I will sort them.\\n\u0026rdquo;, LIM); printf(\u0026ldquo;To stop, press the Enter key at a line\u0026rsquo;s start.\\n\u0026rdquo;); while (ct \u0026lt; LIM \u0026amp;\u0026amp; s_gets(input[ct], SIZE) != NULL \u0026amp;\u0026amp; input[ct][0] != \u0026lsquo;\\0\u0026rsquo;) { ptstr[ct] = input[ct]; / 设置指针指向字符串　/ ct++; } stsrt(ptstr, ct); / 字符串排序函数　/ puts(\u0026quot;\\nHere\u0026rsquo;s the sorted list:\\n\u0026quot;); for (k = 0; k \u0026lt; ct; k++) puts(ptstr[k]); / 排序后的指针　/ return 0; } / 字符串-指针-排序函数 */ void stsrt(char *strings [], int num) { char *temp;\nint top, seek; for (top = 0; top \u0026lt; num - 1; top++) for (seek = top + 1; seek \u0026lt; num; seek++) if (strcmp(strings[top], strings[seek]) \u0026gt; 0) { temp = strings[top]; strings[top] = strings[seek]; strings[seek] = temp; } } char * s_gets(char * st, int n) { char * ret_val; int i = 0; ret_val = fgets(st, n, stdin); if (ret_val) { while (st[i] != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; st[i] != \u0026lsquo;\\0\u0026rsquo;) i++;\nif (st[i] == \u0026lsquo;\\n\u0026rsquo;) st[i] = \u0026lsquo;\\0\u0026rsquo;; else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } return ret_val; } 我们用一首童谣来测试该程序： Input up to 20　lines, and I will sort them. To stop, press the Enter key at a line\u0026rsquo;s start. O that I was where I would be, Then would I be where I am not; But where I am I must be, And where I would be I can not. Here\u0026rsquo;s the sorted list: And where I would be I can not. But where I am I must be, O that I was where I would be,\nThen would I be where I am not; 看来经过排序后，这首童谣的内容未受影响。 11.6.1 排序指针而非字符串 # 该程序的巧妙之处在于排序的是指向字符串的指针，而不是字符串本 # 身。我们来分析一下具体怎么做。最初，ptrst[0]被设置为input[0]，ptrst[1] 被设置为input[1]，以此类推。这意味着指针ptrst[i]指向数组input[i]的首字 符。每个input[i]都是一个内含 81 个元素的数组，每个ptrst[i]都是一个单独的 变量。排序过程把ptrst重新排列，并未改变input。例如，如果按字母顺序 input[1]在intput[0]前面，程序便交换指向它们的指针（即ptrst[0]指向input[1] 的开始，而ptrst[1]指向input[0]的开始）。这样做比用strcpy()交换两个input 字符串的内容简单得多，而且还保留了input数组中的原始顺序。图11.6从另 一个视角演示了这一过程。\n图11.6 排序字符串指针 11.6.2 选择排序算法 # 我们采用选择排序算法（selection sort algorithm）来排序指针。具体做 法是，利用for循环依次把每个元素与首元素比较。如果待比较的元素在当 前首元素的前面，则交换两者。循环结束时，首元素包含的指针指向机器排 序序列最靠前的字符串。然后外层for循环重复这一过程，这次从input的第 2 个元素开始。当内层循环执行完毕时，ptrst中的第 2 个元素指向排在第 2 的字 符串。这一过程持续到所有元素都已排序完毕。\n现在来进一步分析选择排序的过程。下面是排序过程的伪代码： # for n = 首元素至 n = 倒数第 2 个元素, 找出剩余元素中的最大值，并将其放在第n个元素中 具体过程如下。首先，从n = 0开始，遍历整个数组找出最大值元素，那 该元素与第 1 个元素交换；然后设置n = 1，遍历除第 1 个元素以外的其他元 素，在其余元素中找出最大值元素，把该元素与第 2 个元素交换；重复这一 过程直至倒数第 2 个元素为止。现在只剩下两个元素。比较这两个元素，把 较大者放在倒数第 2 的位置。这样，数组中的最小元素就在最后的位置上。 这看起来用for循环就能完成任务，但是我们还要更详细地分析“查找和 放置”的过程。在剩余项中查找最大值的方法是，比较数组剩余元素的第 1 个 元素和第 2 个元素。如果第 2 个元素比第 1 个元素大，交换两者。现在比较数 组剩余元素的第 1 个元素和第 3 个元素，如果第 3 个元素比较大，交换两者。 每次交换都把较大的元素移至顶部。继续这一过程直到比较第 1 个元素和最 后一个元素。比较完毕后，最大值元素现在是剩余数组的首元素。已经排出 了该数组的首元素，但是其他元素还是一团糟。下面是排序过程的伪代码： for n - 第 2 个元素至最后一个元素, 比较第n个元素与第 1 个元素，如果第n个元素更大，交换这两个元素的 值 看上去用一个for循环也能搞定。只不过要把它嵌套在刚才的for循环 中。外层循环指明正在处理数组的哪一个元素，内层循环找出应储存在该元 素的值。把这两部分伪代码结合起来，翻译成 C代码，就得到了程序清单 11.29中的stsrt()函数。顺带一提，C库中有一个更高级的排序函数：qsort()。 该函数使用一个指向函数的指针进行排序比较。第 16 章将给出该函数的用法 示例。\n11.7 ctype.h 字符函数和字符串 # 第 7 章中介绍了ctype.h系列与字符相关的函数。虽然这些函数不能处理 整个字符串，但是可以处理字符串中的字符。例如，程序清单11.30中定义 的ToUpper()函数，利用toupper()函数处理字符串中的每个字符，把整个字符 串转换成大写；定义的 PunctCount()函数，利用 ispunct()统计字符串中的标 点符号个数。另外，该程序使用strchr()处理fgets()读入字符串的换行符（如 果有的话）。 程序清单 11.30 mod_str.c 程序 /* mod_str.c \u0026ndash; 修改字符串 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #define LIMIT 81 void ToUpper(char *); int PunctCount(const char *); int main(void) { char line[LIMIT]; char * find; puts(\u0026ldquo;Please enter a line:\u0026rdquo;); fgets(line, LIMIT, stdin);\nfind = strchr(line, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是 NULL， *find = \u0026lsquo;\\0\u0026rsquo;; // 用空字符替换 ToUpper(line); puts(line); printf(\u0026ldquo;That line has %d punctuation characters.\\n\u0026rdquo;, PunctCount(line)); return 0; } void ToUpper(char * str) { while (*str) { *str = toupper(*str); str++; } } int PunctCount(const char * str) {\nint ct = 0; while (*str) { if (ispunct(*str)) ct++; str++; } return ct; } while (str)循环处理str指向的字符串中的每个字符，直至遇到空字符。 此时str的值为 0 （空字符的编码值为 0 ），即循环条件为假，循环结束。下 面是该程序的运行示例： Please enter a line: Me? You talkin\u0026rsquo; to me? Get outta here! ME? YOU TALKIN\u0026rsquo; TO ME? GET OUTTA HERE! That line has 4　punctuation characters. ToUpper()函数利用toupper()处理字符串中的每个字符（由于C区分大小 写，所以这是两个不同的函数名）。根据ANSI C中的定义，toupper()函数只 改变小写字符。但是一些很旧的C实现不会自动检查大小写，所以以前的代 码通常会这样写： if (islower(str)) / ANSI C之前的做法 \u0026ndash; 在转换大小写之前先检查 */\n*str = toupper(*str); 顺带一提，ctype.h中的函数通常作为宏（macro）来实现。这些C预处理 器宏的作用很像函数，但是两者有一些重要的区别。我们在第 16 章再讨论关 于宏的内容。 该程序使用 fgets()和 strchr()组合，读取一行输入并把换行符替换成空字 符。这种方法与使用s_gets()的区别是：s_gets()会处理输入行剩余字符（如 果有的话），为下一次输入做好准备。而本例只有一条输入语句，就没必要 进行多余的步骤。\n11.8 命令行参数 # 在图形界面普及之前都使用命令行界面。DOS和UNIX就是例子。Linux 终端提供类UNIX命令行环境。命令行（command line）是在命令行环境中， 用户为运行程序输入命令的行。假设一个文件中有一个名为fuss的程序。在 UNIX环境中运行该程序的命令行是： $ fuss 或者在Windows命令提示模式下是： C\u0026gt; fuss 命令行参数（command-line argument）是同一行的附加项。如下例： $ fuss -r Ginger 一个C程序可以读取并使用这些附加项（见图11.7）。 程序清单11.27是一个典型的例子，该程序通过main()的参数读取这些附 加项。\n图11.7 命令行参数 程序清单 11.31 repeat.c 程序 /* repeat.c \u0026ndash; 带参数的 main() */ #include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv []) { int count; printf(\u0026ldquo;The command line has %d arguments:\\n\u0026rdquo;, argc - 1); for (count = 1; count \u0026lt; argc; count++) printf(\u0026quot;%d: %s\\n\u0026quot;, count, argv[count]);\nprintf(\u0026quot;\\n\u0026quot;); return 0; } 把该程序编译为可执行文件repeat。下面是通过命令行运行该程序后的 输出： C\u0026gt;repeat Resistance is futile The command line has 3　arguments: 1: Resistance 2: is 3: futile 由此可见该程序为何名为repeat。下面我们解释一下它的运行原理。 C编译器允许main()没有参数或者有两个参数（一些实现允许main()有更 多参数，属于对标准的扩展）。main()有两个参数时，第 1 个参数是命令行 中的字符串数量。过去，这个int类型的参数被称为argc （表示参数计数 (argument count)）。系统用空格表示一个字符串的结束和下一个字符串的开 始。因此，上面的repeat示例中包括命令名共有 4 个字符串，其中后 3 个供 repeat使用。该程序把命令行字符串储存在内存中，并把每个字符串的地址 储存在指针数组中。而该数组的地址则被储存在 main()的第 2 个参数中。按 照惯例，这个指向指针的指针称为argv（表示参数值[argument value]）。如 果系统允许（一些操作系统不允许这样），就把程序本身的名称赋给 argv[0]，然后把随后的第 1 个字符串赋给argv[1]，以此类推。在我们的例子 中，有下面的关系： argv[0] 指向 repeat （对大部分系统而言）\nargv[1] 指向Resistance argv[2] 指向is argv[3] 指向futile 程序清单11.31的程序通过一个for循环依次打印每个字符串。printf()中 的%s转换说明表明，要提供一个字符串的地址作为参数，而指针数组中的 每个元素（argv[0]、argv[1]等）都是这样的地址。 main()中的形参形式与其他带形参的函数相同。许多程序员用不同的形 式声明argv： int main(int argc, char **argv) char **argv与char *argv[]等价。也就是说，argv是一个指向指针的指 针，它所指向的指针指向 char。因此，即使在原始定义中，argv 也是指向指 针（该指针指向 char）的指针。两种形式都可以使用，但我们认为第 1 种形 式更清楚地表明argv表示一系列字符串。 顺带一提，许多环境（包括UNIX和DOS）都允许用双引号把多个单词 括起来形成一个参数。例如： repeat \u0026ldquo;I am hungry\u0026rdquo; now 这行命令把字符串\u0026quot;I am hungry\u0026quot;赋给argv[1]，把\u0026quot;now\u0026quot;赋给argv[2]。\n11.8.1 集成环境中的命令行参数 # Windows集成环境（如Xcode、Microsoft Visual C++和Embarcadero C++ Builder）都不用命令行运行程序。有些环境中有项目对话框，为特定项目指 定命令行参数。其他环境中，可以在IDE中编译程序，然后打开MS-DOS窗 口在命令行模式中运行程序。但是，如果你的系统有一个运行命令行的编译 器（如GCC）会更简单。\n11.8.2 Macintosh 中的命令行参数 # 如果使用Xcode 4.6（或类似的版本），可以在Product菜单中选择 Scheme选项来提供命令行参数，编辑Scheme，运行。然后选择Argument标 签，在Launch的Arguments Pass中输入参数。 或者进入Mac的Terminal模式和UNIX的命令行环境。然后，可以找到程 序可执行代码的目录（UNIX的文件夹），或者下载命令行工具，使用gcc或 clang编译程序。\n11.9 把字符串转换为数字 # 数字既能以字符串形式储存，也能以数值形式储存。把数字储存为字符 # 串就是储存数字字符。例如，数字 213 以'2\u0026rsquo;、\u0026lsquo;1\u0026rsquo;、\u0026lsquo;3\u0026rsquo;、\u0026rsquo;\\0\u0026rsquo;的形式被储存在字 # 符串数组中。以数值形式储存 213 ，储存的是int类型的值。 C要求用数值形式进行数值运算（如，加法和比较）。但是在屏幕上显 示数字则要求字符串形式，因为屏幕显示的是字符。printf()和 sprintf()函 数，通过%d 和其他转换说明，把数字从数值形式转换为字符串形式， scanf()可以把输入字符串转换为数值形式。C 还有一些函数专门用于把字符 串形式转换成数值形式。 假设你编写的程序需要使用数值命令形参，但是命令形参数被读取为字 符串。因此，要使用数值必须先把字符串转换为数字。如果需要整数，可以 使用atoi()函数（用于把字母数字转换成整数），该函数接受一个字符串作 为参数，返回相应的整数值。程序清单11.32中的程序示例演示了该函数的 用法。 程序清单 11.32 hello.c 程序 /* hello.c \u0026ndash; 把命令行参数转换为数字 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(int argc, char *argv []) { int i, times; if (argc \u0026lt; 2　|| (times = atoi(argv[1])) \u0026lt; 1)\nprintf(\u0026ldquo;Usage: %s positive-number\\n\u0026rdquo;, argv[0]); else for (i = 0; i \u0026lt; times; i++) puts(\u0026ldquo;Hello, good looking!\u0026rdquo;); return 0; } 该程序的运行示例： $ hello 3 Hello, good looking! Hello, good looking! Hello, good looking! $是UNIX和Linux的提示符（一些UNIX系统使用%）。命令行参数 3 被储 存为字符串3\\0。atoi()函数把该字符串转换为整数值 3 ，然后该值被赋给 times。该值确定了执行for循环的次数。 如果运行该程序时没有提供命令行参数，那么argc \u0026lt; 2为真，程序给出 一条提示信息后结束。如果times 为 0 或负数，情况也是如此。C 语言逻辑 运算符的求值顺序保证了如果 argc \u0026lt; 2，就不会对atoi(argv[1])求值。 如果字符串仅以整数开头，atio()函数也能处理，它只把开头的整数转 换为字符。例如， atoi(\u0026ldquo;42regular\u0026rdquo;)将返回整数 42 。如果在命令行输入hello what会怎样？在我们所用的C实现中，如果命令行参数不是数字，atoi()函数 返回 0 。然而C标准规定，这种情况下的行为是未定义的。因此，使用有错 误检测功能的strtol()函数（马上介绍）会更安全。\n该程序中包含了stdlib.h头文件，因为从ANSI C开始，该头文件中包含 了atoi()函数的原型。除此之外，还包含了 atof()和 atol()函数的原型。atof() 函数把字符串转换成 double 类型的值， atol()函数把字符串转换成long类型 的值。atof()和atol()的工作原理和atoi()类似，因此它们分别返回double类型 和long类型。 ANSI C还提供一套更智能的函数：strtol()把字符串转换成long类型的 值，strtoul()把字符串转换成unsigned long类型的值，strtod()把字符串转换成 double类型的值。这些函数的智能之处在于识别和报告字符串中的首字符是 否是数字。而且，strtol()和strtoul()还可以指定数字的进制。 下面的程序示例中涉及strtol()函数，其原型如下： long strtol(const char * restrict nptr, char ** restrict endptr, int base); 这里，nptr是指向待转换字符串的指针，endptr是一个指针的地址，该 指针被设置为标识输入数字结束字符的地址，base表示以什么进制写入数 字。程序清单11.33演示了该函数的用法。 程序清单 11.33 strcnvt.c 程序 /* strcnvt.c \u0026ndash; 使用 strtol() */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define LIM 30 char * s_gets(char * st, int n); int main() {\nchar number[LIM]; char * end; long value; puts(\u0026ldquo;Enter a number (empty line to quit):\u0026rdquo;); while (s_gets(number, LIM) \u0026amp;\u0026amp; number[0] != \u0026lsquo;\\0\u0026rsquo;) { value = strtol(number, \u0026amp;end, 10); /* 十进制 */ printf(\u0026ldquo;base 10　input, base 10　output: %ld, stopped at %s (%d)\\n\u0026rdquo;, value, end, end); value = strtol(number, \u0026amp;end, 16); / 十六进制 */ printf(\u0026ldquo;base 16　input, base 10　output: %ld, stopped at %s (%d)\\n\u0026rdquo;, value, end, *end); puts(\u0026ldquo;Next number:\u0026rdquo;); } puts(\u0026ldquo;Bye!\\n\u0026rdquo;); return 0; } char * s_gets(char * st, int n)\n{ # char * ret_val; int i = 0; ret_val = fgets(st, n, stdin); if (ret_val) { while (st[i] != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; st[i] != \u0026lsquo;\\0\u0026rsquo;) i++; if (st[i] == \u0026lsquo;\\n\u0026rsquo;) st[i] = \u0026lsquo;\\0\u0026rsquo;; else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } return ret_val; } 下面是该程序的输出示例： Enter a number (empty line to quit): 10\nbase 10　input, base 10　output: 10, stopped at (0) base 16　input, base 10　output: 16, stopped at (0) Next number: 10atom base 10　input, base 10　output: 10, stopped at atom (97) base 16 input, base 10 output: 266, stopped at tom (116) Next number: Bye! 首先注意，当base分别为 10 和 16 时，字符串\u0026quot;10\u0026quot;分别被转换成数字 10 和 16 。还要注意，如果end指向一个字符，end就是一个字符。因此，第 1 次转 换在读到空字符时结束，此时end指向空字符。打印end会显示一个空字符 串，以%d转换说明输出end显示的是空字符的ASCII码。 对于第 2 个输入的字符串，当base为 10 时，end的值是\u0026rsquo;a\u0026rsquo;字符的地址。所 以打印end显示的是字符串\u0026quot;atom\u0026quot;，打印*end显示的是\u0026rsquo;a\u0026rsquo;字符的ASCII码。然 而，当base为 16 时，\u0026lsquo;a\u0026rsquo;字符被识别为一个有效的十六进制数，strtol()函数把 十六进制数10a转换成十进制数 266 。 strtol()函数最多可以转换三十六进制，\u0026lsquo;a\u0026rsquo;~\u0026lsquo;z\u0026rsquo;字符都可用作数字。 strtoul()函数与该函数类似，但是它把字符串转换成无符号值。strtod()函数 只以十进制转换，因此它值需要两个参数。 许多实现使用 itoa()和 ftoa()函数分别把整数和浮点数转换成字符串。但 是这两个函数并不是 C标准库的成员，可以用sprintf()函数代替它们，因为 sprintf()的兼容性更好。\n11.10 关键概念 # 许多程序都要处理文本数据。一个程序可能要求用户输入姓名、公司列 # 表、地址、一种蕨类植物的学名、音乐剧的演员等。毕竟，我们用言语与现 # 实世界互动，使用文本的例子不计其数。C 程序通过字符串的方式来处理它 # 们。 # 字符串，无论是由字符数组、指针还是字符串常量标识，都储存为包含 # 字符编码的一系列字节，并以空字符串结尾。C 提供库函数处理字符串，查 # 找字符串并分析它们。尤其要牢记，应该使用 strcmp()来代替关系运算符， 当比较字符串时，应该使用strcpy()或strncpy()代替赋值运算符把字符串赋给 字符数组。\n11.11 本章小结 # C字符串是一系列char类型的字符，以空字符（\u0026rsquo;\\0\u0026rsquo;）结尾。字符串可以 储存在字符数组中。字符串还可以用字符串常量来表示，里面都是字符，括 在双引号中（空字符除外）。编译器提供空字符。因此，\u0026ldquo;joy\u0026quot;被储存为 4 个 字符j、o、y和\\0。strlen()函数可以统计字符串的长度，空字符不计算在内。 字符串常量也叫作字符串——字面量，可用于初始化字符数组。为了容 纳末尾的空字符，数组大小应该至少比容纳的数组长度多 1 。也可以用字符 串常量初始化指向char的指针。 函数使用指向字符串首字符的指针来表示待处理的字符串。通常，对应 的实际参数是数组名、指针变量或用双引号括起来的字符串。无论是哪种情 况，传递的都是首字符的地址。一般而言，没必要传递字符串的长度，因为 函数可以通过末尾的空字符确定字符串的结束。 fgets()函数获取一行输入，puts()和 fputs()函数显示一行输出。它们都是 stdio.h 头文件中的函数，用于代替已被弃用的gets()。 C库中有多个字符串处理函数。在ANSI C中，这些函数都声明在string.h 文件中。C库中还有许多字符处理函数，声明在ctype.h文件中。 给main()函数提供两个合适的形式参数，可以让程序访问命令行参数。 第 1 个参数通常是int类型的argc，其值是命令行的单词数量。第 2 个参数通常 是一个指向数组的指针argv，数组内含指向char的指针。每个指向char的指 针都指向一个命令行参数字符串，argv[0]指向命令名称，argv[1]指向第 1 个 命令行参数，以此类推。 atoi()、atol()和atof()函数把字符串形式的数字分别转换成int、long 和 double类型的数字。strtol()、strtoul()和strtod()函数把字符串形式的数字分别 转换成long、unsigned long和double类型的数字。\n11.12 复习题 # 复习题的参考答案在附录A中。 # 1.下面字符串的声明有什么问题？ # int main(void) { char name[] = {\u0026lsquo;F\u0026rsquo;, \u0026rsquo;e\u0026rsquo;, \u0026rsquo;s\u0026rsquo;, \u0026rsquo;s\u0026rsquo; }; \u0026hellip; } 2.下面的程序会打印什么？ #include \u0026lt;stdio.h\u0026gt; int main(void) { char note[] = \u0026ldquo;See you at the snack bar.\u0026rdquo;; char *ptr; ptr = note; puts(ptr); puts(++ptr); note[7] = \u0026lsquo;\\0\u0026rsquo;; puts(note);\nputs(++ptr); return 0; } 3.下面的程序会打印什么？ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { char food [] = \u0026ldquo;Yummy\u0026rdquo;; char *ptr; ptr = food + strlen(food); while (\u0026ndash;ptr \u0026gt;= food) puts(ptr); return 0; } 4.下面的程序会打印什么？ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void)\n{ # char goldwyn[40] = \u0026ldquo;art of it all \u0026ldquo;; char samuel[40] = \u0026ldquo;I read p\u0026rdquo;; const char * quote = \u0026ldquo;the way through.\u0026rdquo;; strcat(goldwyn, quote); strcat(samuel, goldwyn); puts(samuel); return 0; } 5.下面的练习涉及字符串、循环、指针和递增指针。首先，假设定义了 下面的函数： #include \u0026lt;stdio.h\u0026gt; char *pr(char *str) { char *pc; pc = str; while (*pc) putchar(*pc++); do {\nputchar(\u0026ndash;pc); } while (pc - str); return (pc); } 考虑下面的函数调用： x = pr(\u0026ldquo;Ho Ho Ho!\u0026rdquo;); a.将打印什么？ b.x是什么类型？ c.x的值是什么？ d.表达式\u0026ndash;pc是什么意思？与\u0026ndash;pc有何不同？ e.如果用\u0026ndash;pc替换\u0026ndash;*pc，会打印什么？ f.两个while循环用来测试什么？ g.如果pr()函数的参数是空字符串，会怎样？ h.必须在主调函数中做什么，才能让pr()函数正常运行？ 6.假设有如下声明： char sign = \u0026lsquo;$\u0026rsquo;; sign占用多少字节的内存？\u0026rsquo;$\u0026lsquo;占用多少字节的内存？\u0026quot;$\u0026ldquo;占用多少字节的 内存？ 7.下面的程序会打印出什么？\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define M1 \u0026ldquo;How are ya, sweetie? \u0026quot; char M2[40] = \u0026ldquo;Beat the clock.\u0026rdquo;; char * M3 = \u0026ldquo;chat\u0026rdquo;; int main(void) { char words[80]; printf(M1); puts(M1); puts(M2); puts(M2 + 1); strcpy(words, M2); strcat(words, \u0026quot; Win a toy.\u0026rdquo;); puts(words); words[4] = \u0026lsquo;\\0\u0026rsquo;; puts(words); while (*M3) puts(M3++);\nputs(\u0026ndash;M3); puts(\u0026ndash;M3); M3 = M1; puts(M3); return 0; } 8.下面的程序会打印出什么？ #include \u0026lt;stdio.h\u0026gt; int main(void) { char str1 [] = \u0026ldquo;gawsie\u0026rdquo;; char str2 [] = \u0026ldquo;bletonism\u0026rdquo;; char *ps; int i = 0; for (ps = str1; *ps != \u0026lsquo;\\0\u0026rsquo;; ps++) { if (*ps == \u0026lsquo;a\u0026rsquo; || *ps == \u0026rsquo;e\u0026rsquo;) putchar(*ps); else (*ps)\u0026ndash;;\nputchar(ps); } putchar(\u0026rsquo;\\n\u0026rsquo;); while (str2[i] != \u0026lsquo;\\0\u0026rsquo;) { printf(\u0026quot;%c\u0026rdquo;, i % 3? str2[i] : \u0026lsquo;\u0026rsquo;); ++i; } return 0; } 9.本章定义的s_gets()函数，用指针表示法代替数组表示法便可减少一个 变量i。请改写该函数。 10.strlen()函数接受一个指向字符串的指针作为参数，并返回该字符串 的长度。请编写一个这样的函数。 11.本章定义的s_gets()函数，可以用strchr()函数代替其中的while循环来 查找换行符。请改写该函数。 12.设计一个函数，接受一个指向字符串的指针，返回指向该字符串第 1 个空格字符的指针，或如果未找到空格字符，则返回空指针。 13.重写程序清单11.21，使用ctype.h头文件中的函数，以便无论用户选 择大写还是小写，该程序都能正确识别答案。\n11.13 编程练习 # 1.设计并测试一个函数，从输入中获取下n个字符（包括空白、制表 符、换行符），把结果储存在一个数组里，它的地址被传递作为一个参数。 2.修改并编程练习 1 的函数，在n个字符后停止，或在读到第 1 个空白、 制表符或换行符时停止，哪个先遇到哪个停止。不能只使用scanf()。 3.设计并测试一个函数，从一行输入中把一个单词读入一个数组中，并 丢弃输入行中的其余字符。该函数应该跳过第 1 个非空白字符前面的所有空 白。将一个单词定义为没有空白、制表符或换行符的字符序列。 4.设计并测试一个函数，它类似编程练习 3 的描述，只不过它接受第 2 个 参数指明可读取的最大字符数。 5.设计并测试一个函数，搜索第 1 个函数形参指定的字符串，在其中查 找第 2 个函数形参指定的字符首次出现的位置。如果成功，该函数返指向该 字符的指针，如果在字符串中未找到指定字符，则返回空指针（该函数的功 能与 strchr()函数相同）。在一个完整的程序中测试该函数，使用一个循环 给函数提供输入值。 6.编写一个名为is_within()的函数，接受一个字符和一个指向字符串的 指针作为两个函数形参。如果指定字符在字符串中，该函数返回一个非零值 （即为真）。否则，返回 0 （即为假）。在一个完整的程序中测试该函数， 使用一个循环给函数提供输入值。 7.strncpy(s1, s2, n)函数把s2中的n个字符拷贝至s1中，截断s2，或者有必 要的话在末尾添加空字符。如果s2的长度是n或多于n，目标字符串不能以空 字符结尾。该函数返回s1。自己编写一个这样的函数，名为mystrncpy()。在 一个完整的程序中测试该函数，使用一个循环给函数提供输入值。 8.编写一个名为string_in()的函数，接受两个指向字符串的指针作为参 数。如果第 2 个字符串中包含第 1 个字符串，该函数将返回第 1 个字符串开始\n的地址。例如，string_in(\u0026ldquo;hats\u0026rdquo;, \u0026ldquo;at\u0026rdquo;)将返回hats中a的地址。否则，该函数返 回空指针。在一个完整的程序中测试该函数，使用一个循环给函数提供输入 值。 9.编写一个函数，把字符串中的内容用其反序字符串代替。在一个完整 的程序中测试该函数，使用一个循环给函数提供输入值。 10.编写一个函数接受一个字符串作为参数，并删除字符串中的空格。 在一个程序中测试该函数，使用循环读取输入行，直到用户输入一行空行。 该程序应该应用该函数只每个输入的字符串，并显示处理后的字符串。 11.编写一个函数，读入 10 个字符串或者读到EOF时停止。该程序为用 户提供一个有 5 个选项的菜单：打印源字符串列表、以ASCII中的顺序打印字 符串、按长度递增顺序打印字符串、按字符串中第 1 个单词的长度打印字符 串、退出。菜单可以循环显示，除非用户选择退出选项。当然，该程序要能 真正完成菜单中各选项的功能。 12.编写一个程序，读取输入，直至读到 EOF，报告读入的单词数、大 写字母数、小写字母数、标点符号数和数字字符数。使用ctype.h头文件中的 函数。 13.编写一个程序，反序显示命令行参数的单词。例如，命令行参数是 see you later，该程序应打印later you see。 14.编写一个通过命令行运行的程序计算幂。第 1 个命令行参数是double 类型的数，作为幂的底数，第 2 个参数是整数，作为幂的指数。 15.使用字符分类函数实现atoi()函数。如果输入的字符串不是纯数字， 该函数返回 0 。 16.编写一个程序读取输入，直至读到文件结尾，然后把字符串打印出 来。该程序识别和实现下面的命令行参数： -p 按原样打印\n-u 把输入全部转换成大写 -l 把输入全部转换成小写 如果没有命令行参数，则让程序像是使用了-p参数那样运行。\n第 12 章 存储类别、链接和内存管理 # 本章介绍以下内容： # 关键字：auto、extern、static、register、const、volatile、restricted、 _Thread_local、_Atomic 函数：rand()、srand()、time()、malloc()、calloc()、free() 如何确定变量的作用域（可见的范围）和生命期（它存在多长时间） 设计更复杂的程序 C语言能让程序员恰到好处地控制程序，这是它的优势之一。程序员通 过 C的内存管理系统指定变量的作用域和生命期，实现对程序的控制。合理 使用内存储存数据是设计程序的一个要点。\n12.1 存储类别 # C提供了多种不同的模型或存储类别（storage class）在内存中储存数 据。要理解这些存储类别，先要复习一些概念和术语。 本书目前所有编程示例中使用的数据都储存在内存中。从硬件方面来 看，被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为 对象（object）。对象可以储存一个或多个值。一个对象可能并未储存实际 的值，但是它在储存适当的值时一定具有相应的大小（面向对象编程中的对 象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对 象编程语言）。 从软件方面来看，程序需要一种方法访问对象。这可以通过声明变量来 完成： int entity = 3; 该声明创建了一个名为entity的标识符（identifier）。标识符是一个名 称，在这种情况下，标识符可以用来指定（designate）特定对象的内容。标 识符遵循变量的命名规则（第 2 章介绍过）。在该例中，标识符entity即是软 件（即C程序）指定硬件内存中的对象的方式。该声明还提供了储存在对象 中的值。 变量名不是指定对象的唯一途径。考虑下面的声明： int * pt = \u0026amp;entity; int ranks[10]; 第 1 行声明中，pt是一个标识符，它指定了一个储存地址的对象。但 是，表达式*pt不是标识符，因为它不是一个名称。然而，它确实指定了一 个对象，在这种情况下，它与 entity 指定的对象相同。一般而言，那些指定 对象的表达式被称为左值（第 5 章介绍过）。所以，entity既是标识符也是左\n值；pt既是表达式也是左值。按照这个思路，ranks + 2 * entity既不是标识符 （不是名称），也不是左值（它不指定内存位置上的内容）。但是表达式 (ranks + 2 * entity)是一个左值，因为它的确指定了特定内存位置的值，即 ranks数组的第 7 个元素。顺带一提，ranks的声明创建了一个可容纳 10 个int类 型元素的对象，该数组的每个元素也是一个对象。 所有这些示例中，如果可以使用左值改变对象中的值，该左值就是一个 可修改的左值（modifiable lvalue）。现在，考虑下面的声明： const char * pc = \u0026ldquo;Behold a string literal!\u0026rdquo;; 程序根据该声明把相应的字符串字面量储存在内存中，内含这些字符值 的数组就是一个对象。由于数组中的每个字符都能被单独访问，所以每个字 符也是一个对象。该声明还创建了一个标识符为pc的对象，储存着字符串的 地址。由于可以设置pc重新指向其他字符串，所以标识符pc是一个可修改的 左值。const只能保证被pc指向的字符串内容不被修改，但是无法保证pc不指 向别的字符串。由于pc指定了储存\u0026rsquo;B\u0026rsquo;字符的数据对象，所以pc 是一个左 值，但不是一个可修改的左值。与此类似，因为字符串字面量本身指定了储 存字符串的对象，所以它也是一个左值，但不是可修改的左值。 可以用存储期（storage duration）描述对象，所谓存储期是指对象在内 存中保留了多长时间。标识符用于访问对象，可以用作用域（scope）和链 接（linkage）描述标识符，标识符的作用域和链接表明了程序的哪些部分可 以使用它。不同的存储类别具有不同的存储期、作用域和链接。标识符可以 在源代码的多文件中共享、可用于特定文件的任意函数中、可仅限于特定函 数中使用，甚至只在函数中的某部分使用。对象可存在于程序的执行期，也 可以仅存在于它所在函数的执行期。对于并发编程，对象可以在特定线程的 执行期存在。可以通过函数调用的方式显式分配和释放内存。 我们先学习作用域、链接和存储期的含义，再介绍具体的存储类别。\n12.1.1 作用域 # 作用域描述程序中可访问标识符的区域。一个C变量的作用域可以是块 # 作用域、函数作用域、函数原型作用域或文件作用域。到目前为止，本书程 # 序示例中使用的变量几乎都具有块作用域。块是用一对花括号括起来的代码 # 区域。例如，整个函数体是一个块，函数中的任意复合语句也是一个块。定 # 义在块中的变量具有块作用域（block scope），块作用域变量的可见范围是 从定义处到包含该定义的块的末尾。另外，虽然函数的形式参数声明在函数 的左花括号之前，但是它们也具有块作用域，属于函数体这个块。所以到目 前为止，我们使用的局部变量（包括函数的形式参数）都具有块作用域。因 此，下面代码中的变量 cleo和patrick都具有块作用域： double blocky(double cleo) { double patrick = 0.0; \u0026hellip; return patrick; } 声明在内层块中的变量，其作用域仅局限于该声明所在的块： double blocky(double cleo) { double patrick = 0.0; int i; for (i = 0; i \u0026lt; 10; i++) {\ndouble q = cleo * i; // q的作用域开始 \u0026hellip; patrick *= q; } // q的作用域结束 \u0026hellip; return patrick; } 在该例中，q的作用域仅限于内层块，只有内层块中的代码才能访问q。 以前，具有块作用域的变量都必须声明在块的开头。C99 标准放宽了这 一限制，允许在块中的任意位置声明变量。因此，对于for的循环头，现在 可以这样写： for (int i = 0; i \u0026lt; 10; i++) printf(\u0026ldquo;A C99 feature: i = %d\u0026rdquo;, i); 为适应这个新特性，C99把块的概念扩展到包括for循环、while循环、 do while循环和if语句所控制的代码，即使这些代码没有用花括号括起来， 也算是块的一部分。所以，上面for循环中的变量i被视为for循环块的一部 分，它的作用域仅限于for循环。一旦程序离开for循环，就不能再访问i。 函数作用域（function scope）仅用于goto语句的标签。这意味着即使一 个标签首次出现在函数的内层块中，它的作用域也延伸至整个函数。如果在 两个块中使用相同的标签会很混乱，标签的函数作用域防止了这样的事情发 生。 函数原型作用域（function prototype scope）用于函数原型中的形参名\n（变量名），如下所示： # int mighty(int mouse, double large); 函数原型作用域的范围是从形参定义处到原型声明结束。这意味着，编 译器在处理函数原型中的形参时只关心它的类型，而形参名（如果有的话） 通常无关紧要。而且，即使有形参名，也不必与函数定义中的形参名相匹 配。只有在变长数组中，形参名才有用： void use_a_VLA(int n, int m, ar[n][m]); 方括号中必须使用在函数原型中已声明的名称。 变量的定义在函数的外面，具有文件作用域（file scope）。具有文件作 用域的变量，从它的定义处到该定义所在文件的末尾均可见。考虑下面的例 子： #include \u0026lt;stdio.h\u0026gt; int units = 0; /* 该变量具有文件作用域 */ void critic(void); int main(void) { \u0026hellip; } void critic(void) { \u0026hellip;\n} # 这里，变量units具有文件作用域，main()和critic()函数都可以使用它 （更准确地说，units具有外部链接文件作用域，稍后讲解）。由于这样的变 量可用于多个函数，所以文件作用域变量也称为全局变量（global variable）。 注意 翻译单元和文件 你认为的多个文件在编译器中可能以一个文件出现。例如，通常在源代 码（.c扩展名）中包含一个或多个头文件（.h 扩展名）。头文件会依次包含 其他头文件，所以会包含多个单独的物理文件。但是，C预处理实际上是用 包含的头文件内容替换#include指令。所以，编译器源代码文件和所有的头 文件都看成是一个包含信息的单独文件。这个文件被称为翻译单元 （translation unit）。描述一个具有文件作用域的变量时，它的实际可见范围 是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个 翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。\n12.1.2 链接 # 接下来，我们介绍链接。C 变量有 3 种链接属性：外部链接、内部链接 # 或无链接。具有块作用域、函数作用域或函数原型作用域的变量都是无链接 # 变量。这意味着这些变量属于定义它们的块、函数或原型私有。具有文件作 # 用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中 # 使用，内部链接变量只能在一个翻译单元中使用。 # 注意 正式和非正式术语 # C 标准用“内部链接的文件作用域”描述仅限于一个翻译单元（即一个源 # 代码文件和它所包含的头文件）的作用域，用“外部链接的文件作用域”描述 # 可延伸至其他翻译单元的作用域。但是，对程序员而言这些术语太长了。一 # 些程序员把“内部链接的文件作用域”简称为“文件作用域”，把“外部链接的 # 文件作用域”简称为“全局作用域”或“程序作用域”。 # 如何知道文件作用域变量是内部链接还是外部链接？可以查看外部定义 # 中是否使用了存储类别说明符static： int giants = 5; // 文件作用域，外部链接 static int dodgers = 3; // 文件作用域，内部链接 int main() { \u0026hellip; } \u0026hellip; 该文件和同一程序的其他文件都可以使用变量giants。而变量dodgers属 文件私有，该文件中的任意函数都可使用它。\n12.1.3 存储期 # 作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访 # 问的对象的生存期。C对象有 4 种存储期：静态存储期、线程存储期、自动 # 存储期、动态分配存储期。 # 如果对象具有静态存储期，那么它在程序的执行期间一直存在。文件作 # 用域变量具有静态存储期。注意，对于文件作用域变量，关键字 static表明 了其链接属性，而非存储期。以 static声明的文件作用域变量具有内部链 接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态 存储期。 线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程 存储期的对象，从被声明时到线程结束一直存在。以关键字_Thread_local声 明一个对象时，每个线程都获得该变量的私有备份。\n块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块 # 时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。 # 这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存 # 区。例如，一个函数调用结束后，其变量占用的内存可用于储存下一个被调 # 用函数的变量。 # 变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的 # 开始处到块的末尾。 # 我们到目前为止使用的局部变量都是自动类别。例如，在下面的代码 # 中，变量number和index在每次调用bore()函数时被创建，在离开函数时被销 毁： void bore(int number) { int index; for (index = 0; index \u0026lt; number; index++) puts(\u0026ldquo;They don\u0026rsquo;t make them the way they used to.\\n\u0026rdquo;); return 0; } 然而，块作用域变量也能具有静态存储期。为了创建这样的变量，要把 变量声明在块中，且在声明前面加上关键字static： void more(int number) { int index;\nstatic int ct = 0; \u0026hellip; return 0; } 这里，变量ct储存在静态内存中，它从程序被载入到程序结束期间都存 在。但是，它的作用域定义在more()函数块中。只有在执行该函数时，程序 才能使用ct访问它所指定的对象（但是，该函数可以给其他函数提供该存储 区的地址以便间接访问该对象，例如通过指针形参或返回值）。 C 使用作用域、链接和存储期为变量定义了多种存储方案。本书不涉及 并发程序设计，所以不再赘述这方面的内容。已分配存储期在本章后面介 绍。因此，剩下 5 种存储类别：自动、寄存器、静态块作用域、静态外部链 接、静态内部链接，如表12.1所列。现在，我们已经介绍了作用域、链接和 存储期，接下来将详细讨论这些存储类别。 表12.1 5种存储类别\n12.1.4 自动变量 # 属于自动存储类别的变量具有自动存储期、块作用域且无链接。默认情 # 况下，声明在块或函数头中的任何变量都属于自动存储类别。为了更清楚地 # 表达你的意图（例如，为了表明有意覆盖一个外部变量定义，或者强调不要 # 把该变量改为其他存储类别），可以显式使用关键字auto，如下所示： int main(void)\n{ # auto int plox; 关键字auto是存储类别说明符（storage-class specifier）。auto关键字在 C++中的用法完全不同，如果编写C/C++兼容的程序，最好不要使用auto作 为存储类别说明符。 块作用域和无链接意味着只有在变量定义所在的块中才能通过变量名访 问该变量（当然，参数用于传递变量的值和地址给另一个函数，但是这是间 接的方法）。另一个函数可以使用同名变量，但是该变量是储存在不同内存 位置上的另一个变量。 变量具有自动存储期意味着，程序在进入该变量声明所在的块时变量存 在，程序在退出该块时变量消失。原来该变量占用的内存位置现在可做他 用。 接下来分析一下嵌套块的情况。块中声明的变量仅限于该块及其包含的 块使用。 int loop(int n) { int m; // m 的作用域 scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;m); { int i; // m 和 i 的作用域 for (i = m; i \u0026lt; n; i++) puts(\u0026ldquo;i is local to a sub-block\\n\u0026rdquo;);\n} # return m; // m 的作用域，i 已经消失 } 在上面的代码中，i仅在内层块中可见。如果在内层块的前面或后面使 用i，编译器会报错。通常，在设计程序时用不到这个特性。然而，如果这 个变量仅供该块使用，那么在块中就近定义该变量也很方便。这样，可以在 靠近使用变量的地方记录其含义。另外，这样的变量只有在使用时才占用内 存。变量n和 m 分别定义在函数头和外层块中，它们的作用域是整个函数， 而且在调用函数到函数结束期间都一直存在。 如果内层块中声明的变量与外层块中的变量同名会怎样？内层块会隐藏 外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作 用域。程序清单12.1演示了这一过程。 程序清单 12.1 hiding.c 程序 // hiding.c \u0026ndash; 块中的变量 #include \u0026lt;stdio.h\u0026gt; int main() { int x = 30; // 原始的 x printf(\u0026ldquo;x in outer block: %d at %p\\n\u0026rdquo;, x, \u0026amp;x); { int x = 77; // 新的 x，隐藏了原始的 x printf(\u0026ldquo;x in inner block: %d at %p\\n\u0026rdquo;, x, \u0026amp;x);\n} # printf(\u0026ldquo;x in outer block: %d at %p\\n\u0026rdquo;, x, \u0026amp;x); while (x++ \u0026lt; 33) // 原始的 x { int x = 100; // 新的 x，隐藏了原始的 x x++; printf(\u0026ldquo;x in while loop: %d at %p\\n\u0026rdquo;, x, \u0026amp;x); } printf(\u0026ldquo;x in outer block: %d at %p\\n\u0026rdquo;, x, \u0026amp;x); return 0; } 下面是该程序的输出： x in outer block: 30　at 0x7fff5fbff8c8 x in inner block: 77　at 0x7fff5fbff8c4 x in outer block: 30　at 0x7fff5fbff8c8 x in while loop: 101　at 0x7fff5fbff8c0 x in while loop: 101　at 0x7fff5fbff8c0 x in while loop: 101　at 0x7fff5fbff8c0 x in outer block: 34　at 0x7fff5fbff8c8\n首先，程序创建了变量x并初始化为 30 ，如第 1 条printf()语句所示。然 后，定义了一个新的变量x，并设置为 77 ，如第 2 条printf()语句所示。根据显 示的地址可知，新变量隐藏了原始的x。第 3 条printf()语句位于第 1 个内层块 后面，显示的是原始的x的值，这说明原始的x既没有消失也不曾改变。 也许该程序最难懂的是while循环。while循环的测试条件中使用的是原 始的x： while(x++ \u0026lt; 33) 在该循环中，程序创建了第 3 个x变量，该变量只定义在while循环中。 所以，当执行到循环体中的x++时，递增为 101 的是新的x，然后printf()语句 显示了该值。每轮迭代结束，新的x变量就消失。然后循环的测试条件使用 并递增原始的x，再次进入循环体，再次创建新的x。在该例中，这个x被创 建和销毁了 3 次。注意，该循环必须在测试条件中递增x，因为如果在循环体 中递增x，那么递增的是循环体中创建的x，而非测试条件中使用的原始x。 我们使用的编译器在创建while循环体中的x时，并未复用内层块中x占 用的内存，但是有些编译器会这样做。 该程序示例的用意不是鼓励读者要编写类似的代码（根据C的命名规 则，要想出别的变量名并不难），而是为了解释在内层块中定义变量的具体 情况。\n1. 没有花括号的块 前面提到一个C99特性：作为循环或if语句的一部分，即使不使用花括 号（{}），也是一个块。更完整地说，整个循环是它所在块的子块（sub- block），循环体是整个循环块的子块。与此类似，if 语句是一个块，与其 相关联的子语句是if语句的子块。这些规则会影响到声明的变量和这些变量 的作用域。程序清单12.2演示了for循环中该特性的用法。 程序清单 12.2 forc99.c 程序\n// forc99.c \u0026ndash; 新的 C99 块规则 #include \u0026lt;stdio.h\u0026gt; int main() { int n = 8; printf(\u0026rdquo; Initially, n = %d at %p\\n\u0026rdquo;, n, \u0026amp;n); for (int n = 1; n \u0026lt; 3; n++) printf(\u0026quot; loop 1: n = %d at %p\\n\u0026quot;, n, \u0026amp;n); printf(\u0026ldquo;After loop 1, n = %d at %p\\n\u0026rdquo;, n, \u0026amp;n); for (int n = 1; n \u0026lt; 3; n++) { printf(\u0026quot; loop 2　index n = %d at %p\\n\u0026quot;, n, \u0026amp;n); int n = 6; printf(\u0026quot; loop 2: n = %d at %p\\n\u0026quot;, n, \u0026amp;n); n++; } printf(\u0026ldquo;After loop 2, n = %d at %p\\n\u0026rdquo;, n, \u0026amp;n); return 0; }\n假设编译器支持C语言的这个新特性，该程序的输出如下： # Initially, n = 8 at 0x7fff5fbff8c8 loop 1: n = 1 at 0x7fff5fbff8c4 loop 1: n = 2 at 0x7fff5fbff8c4 After loop 1, n = 8 at 0x7fff5fbff8c8 loop 2 index n = 1 at 0x7fff5fbff8c0 loop 2: n = 6 at 0x7fff5fbff8bc loop 2 index n = 2 at 0x7fff5fbff8c0 loop 2: n = 6 at 0x7fff5fbff8bc After loop 2, n = 8 at 0x7fff5fbff8c8 第 1 个for循环头中声明的n，其作用域作用至循环末尾，而且隐藏了原 始的n。但是，离开循环后，原始的n又起作用了。 第 2 个for循环头中声明的n作为循环的索引，隐藏了原始的n。然后，在 循环体中又声明了一个n，隐藏了索引n。结束一轮迭代后，声明在循环体中 的n消失，循环头使用索引n进行测试。当整个循环结束时，原始的 n 又起作 用了。再次提醒读者注意，没必要在程序中使用相同的变量名。如果用了， 各变量的情况如上所述。 注意 支持 C99 和 C11 有些编译器并不支持C99/C11的这些作用域规则（Microsoft Visual Studio 2012 就是其中之一）。有些编译会提供激活这些规则的选项。例如，撰写本 书时，gcc默认支持了C99的许多特性，但是要用 选项激活程序 清单12.2中使用的特性：\ngcc –std=c99 forc99.c 与此类似，gcc或clang都要使用 或 选项，才支持 C11特性。\n2. 自动变量的初始化 自动变量不会初始化，除非显式初始化它。考虑下面的声明： int main(void) { int repid; int tents = 5; tents变量被初始化为 5 ，但是repid变量的值是之前占用分配给repid的空 间中的任意值（如果有的话），别指望这个值是 0 。可以用非常量表达式 （non-constant expression）初始化自动变量，前提是所用的变量已在前面定 义过： int main(void) { int ruth = 1; int rance = 5 * ruth; // 使用之前定义的变量\n12.1.5 寄存器变量 # 变量通常储存在计算机内存中。如果幸运的话，寄存器变量储存在CPU # 的寄存器中，或者概括地说，储存在最快的可用内存中。与普通变量相比， # 访问和处理这些变量的速度更快。由于寄存器变量储存在寄存器而非内存 # 中，所以无法获取寄存器变量的地址。绝大多数方面，寄存器变量和自动变 # 量都一样。也就是说，它们都是块作用域、无链接和自动存储期。使用存储 # 类别说明符register便可声明寄存器变量： int main(void) { register int quick; 我们刚才说“如果幸运的话”，是因为声明变量为register类别与直接命令 相比更像是一种请求。编译器必须根据寄存器或最快可用内存的数量衡量你 的请求，或者直接忽略你的请求，所以可能不会如你所愿。在这种情况下， 寄存器变量就变成普通的自动变量。即使是这样，仍然不能对该变量使用地 址运算符。 在函数头中使用关键字register，便可请求形参是寄存器变量： void macho(register int n) 可声明为register的数据类型有限。例如，处理器中的寄存器可能没有足 够大的空间来储存double类型的值。\n12.1.6 块作用域的静态变量 # 静态变量（static variable）听起来自相矛盾，像是一个不可变的变量。 实际上，静态的意思是该变量在内存中原地不动，并不是说它的值不变。具 有文件作用域的变量自动具有（也必须是）静态存储期。前面提到过，可以 创建具有静态存储期、块作用域的局部变量。这些变量和自动变量一样，具 有相同的作用域，但是程序离开它们所在的函数后，这些变量不会消失。也 就是说，这种变量具有块作用域、无链接，但是具有静态存储期。计算机在 多次函数调用之间会记录它们的值。在块中（提供块作用域和无链接）以存 储类别说明符static（提供静态存储期）声明这种变量。程序清单12.3演示了 一个这样的例子。\n程序清单 12.3 loc_stat.c 程序 /* loc_stat.c \u0026ndash; 使用局部静态变量 */ #include \u0026lt;stdio.h\u0026gt; void trystat(void); int main(void) { int count; for (count = 1; count \u0026lt;= 3; count++) { printf(\u0026ldquo;Here comes iteration %d:\\n\u0026rdquo;, count); trystat(); } return 0; } void trystat(void) { int fade = 1; static int stay = 1; printf(\u0026ldquo;fade = %d and stay = %d\\n\u0026rdquo;, fade++, stay++);\n} # 注意，trystat()函数先打印再递增变量的值。该程序的输出如下： Here comes iteration 1: fade = 1　and stay = 1 Here comes iteration 2: fade = 1　and stay = 2 Here comes iteration 3: fade = 1　and stay = 3 静态变量stay保存了它被递增 1 后的值，但是fade变量每次都是 1 。这表 明了初始化的不同：每次调用trystat()都会初始化fade，但是stay只在编译 strstat()时被初始化一次。如果未显式初始化静态变量，它们会被初始化为 0 。 下面两个声明很相似： int fade = 1; static int stay = 1; 第 1 条声明确实是trystat()函数的一部分，每次调用该函数时都会执行这 条声明。这是运行时行为。第 2 条声明实际上并不是trystat()函数的一部分。 如果逐步调试该程序会发现，程序似乎跳过了这条声明。这是因为静态变量 和外部变量在程序被载入内存时已执行完毕。把这条声明放在trystat()函数 中是为了告诉编译器只有trystat()函数才能看到该变量。这条声明并未在运 行时执行。 不能在函数的形参中使用static：\nint wontwork(static int flu); // 不允许 “局部静态变量”是描述具有块作用域的静态变量的另一个术语。阅读一 些老的 C文献时会发现，这种存储类别被称为内部静态存储类别（internal static storage class）。这里的内部指的是函数内部，而非内部链接。\n12.1.7 外部链接的静态变量 # 外部链接的静态变量具有文件作用域、外部链接和静态存储期。该类别 # 有时称为外部存储类别（external storage class），属于该类别的变量称为外 部变量（external variable）。把变量的定义性声明（defining declaration）放 在在所有函数的外面便创建了外部变量。当然，为了指出该函数使用了外部 变量，可以在函数中用关键字extern再次声明。如果一个源代码文件使用的 外部变量定义在另一个源代码文件中，则必须用extern在该文件中声明该变 量。如下所示： int Errupt; /* 外部定义的变量 / double Up[100]; / 外部定义的数组 / extern char Coal; / 如果Coal被定义在另一个文件， / /则必须这样声明/ void next(void); int main(void) { extern int Errupt; / 可选的声明*/ extern double Up[]; /* 可选的声明*/ \u0026hellip;\n} # void next(void) { \u0026hellip; } 注意，在main()中声明Up数组时（这是可选的声明）不用指明数组大 小，因为第 1 次声明已经提供了数组大小信息。main()中的两条 extern 声明完 全可以省略，因为外部变量具有文件作用域，所以Errupt和Up从声明处到文 件结尾都可见。它们出现在那里，仅为了说明main()函数要使用这两个变 量。 如果省略掉函数中的extern关键字，相当于创建了一个自动变量。去掉 下面声明中的extern： extern int Errupt; 便成为： int Errupt; 这使得编译器在 main()中创建了一个名为 Errupt 的自动变量。它是一个 独立的局部变量，与原来的外部变量Errupt不同。该局部变量仅main()中可 见，但是外部变量Errupt对于该文件的其他函数（如 next()）也可见。简而 言之，在执行块中的语句时，块作用域中的变量将“隐藏”文件作用域中的同 名变量。如果不得已要使用与外部变量同名的局部变量，可以在局部变量的 声明中使用 auto 存储类别说明符明确表达这种意图。 外部变量具有静态存储期。因此，无论程序执行到main()、next()还是其 他函数，数组Up及其值都一直存在。\n下面 3 个示例演示了外部和自动变量的一些使用情况。示例 1 中有一个 # 外部变量 Hocus。该变量对main()和magic()均可见。 /* 示例1 */ int Hocus; int magic(); int main(void) { extern int Hocus; // Hocus 之前已声明为外部变量 \u0026hellip; } int magic() { extern int Hocus; // 与上面的Hocus 是同一个变量 \u0026hellip; } 示例 2 中有一个外部变量Hocus，对两个函数均可见。这次，在默认情况 下对magic()可见。 /*示例 2　*/ int Hocus; int magic();\nint main(void) { extern int Hocus; // Hocus之前已声明为外部变量 \u0026hellip; } int magic() { //并未在该函数中声明Hocus，但是仍可使用该变量 \u0026hellip; } 在示例 3 中，创建了 4 个独立的变量。main()中的Hocus变量默认是自动 变量，属于main()私有。magic()中的Hocus变量被显式声明为自动，只有 magic()可用。外部变量Houcus对main()和magic()均不可见，但是对该文件中 未创建局部Hocus变量的其他函数可见。最后，Pocus是外部变量，magic()可 见，但是main()不可见，因为Pocus被声明在main()后面。 /* 示例 3 */ int Hocus; int magic(); int main(void) {\nint Hocus; // 声明Hocus，默认是自动变量 \u0026hellip; } int Pocus; int magic() { auto int Hocus; //把局部变量Hocus显式声明为自动变量 \u0026hellip; } 这 3 个示例演示了外部变量的作用域是：从声明处到文件结尾。除此之 外，还说明了外部变量的生命期。外部变量Hocus和Pocus在程序运行中一直 存在，因为它们不受限于任何函数，不会在某个函数返回后就消失。\n1. 初始化外部变量 外部变量和自动变量类似，也可以被显式初始化。与自动变量不同的 是，如果未初始化外部变量，它们会被自动初始化为 0 。这一原则也适用于 外部定义的数组元素。与自动变量的情况不同，只能使用常量表达式初始化 文件作用域变量： int x = 10; // 没问题， 10 是常量 int y = 3 + 20; // 没问题，用于初始化的是常量表达式 size_t z = sizeof(int); //没问题，用于初始化的是常量表达式 int x2 = 2 * x; // 不行，x是变量\n（只要不是变长数组，sizeof表达式可被视为常量表达式。） 2. 使用外部变量 下面来看一个使用外部变量的示例。假设有两个函数main()和critic()， 它们都要访问变量units。可以把units声明在这两个函数的上面，如程序清单 12.4所示（注意：该例的目的是演示外部变量的工作原理，并非它的典型用 法）。 程序清单 12.4 global.c 程序 /* global.c \u0026ndash; 使用外部变量 / #include \u0026lt;stdio.h\u0026gt; int units = 0; / 外部变量　/ void critic(void); int main(void) { extern int units; / 可选的重复声明 */ printf(\u0026ldquo;How many pounds to a firkin of butter?\\n\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;units); while (units != 56) critic(); printf(\u0026ldquo;You must have looked it up!\\n\u0026rdquo;); return 0;\n} # void critic(void) { /* 删除了可选的重复声明 */ printf(\u0026ldquo;No luck, my friend. Try again.\\n\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;units); } 下面是该程序的输出示例： How many pounds to a firkin of butter? 14 No luck, my friend. Try again. 56 You must have looked it up! 注意，critic()是如何读取 units的第 2 个值的。当while循环结束时， main()也知道units的新值。所以main()函数和critic()都可以通过标识符units访 问相同的变量。用C的术语来描述是， units具有文件作用域、外部链接和静 态存储期。 把units定义在所有函数定义外面（即外部），units便是一个外部变量， 对units定义下面的所有函数均可见。因此，critics()可以直接使用units变量。 类似地，main()也可直接访问units。但是，main()中确实有如下声明：\nextern int units; 本例中，以上声明主要是为了指出该函数要使用这个外部变量。存储类 别说明符extern告诉编译器，该函数中任何使用units的地方都引用同一个定 义在函数外部的变量。再次强调，main()和critic()使用的都是外部定义的 units。\n3. 外部名称 C99和C11标准都要求编译器识别局部标识符的前 63 个字符和外部标识 符的前 31 个字符。这修订了以前的标准，即编译器识别局部标识符前 31 个字 符和外部标识符前 6 个字符。你所用的编译器可能还执行以前的规则。外部 变量名比局部变量名的规则严格，是因为外部变量名还要遵循局部环境规 则，所受的限制更多。 4. 定义和声明 下面进一步介绍定义变量和声明变量的区别。考虑下面的例子： int tern = 1; /* tern被定义 / main() { extern int tern; / 使用在别处定义的tern */ 这里，tern被声明了两次。第 1 次声明为变量预留了存储空间，该声明构 成了变量的定义。第 2 次声明只告诉编译器使用之前已创建的tern变量，所以 这不是定义。第 1 次声明被称为定义式声明（defining declaration），第 2 次声 明被称为引用式声明（referencing declaration）。关键字extern表明该声明不 是定义，因为它指示编译器去别处查询其定义。 假设这样写：\nextern int tern; int main(void) { 编译器会假设 tern 实际的定义在该程序的别处，也许在别的文件中。该 声明并不会引起分配存储空间。因此，不要用关键字extern创建外部定义， 只用它来引用现有的外部定义。 外部变量只能初始化一次，且必须在定义该变量时进行。假设有下面的 代码： // file_one.c char permis = \u0026lsquo;N\u0026rsquo;; \u0026hellip; // file_two.c extern char permis = \u0026lsquo;Y\u0026rsquo;; /* 错误 */ file_two中的声明是错误的，因为file_one.c中的定义式声明已经创建并 初始化了permis。\n12.1.8 内部链接的静态变量 # 该存储类别的变量具有静态存储期、文件作用域和内部链接。在所有函 # 数外部（这点与外部变量相同），用存储类别说明符static定义的变量具有 这种存储类别： static int svil = 1; // 静态变量，内部链接 int main(void)\n{ # 这种变量过去称为外部静态变量（external static variable），但是这个 术语有点自相矛盾（这些变量具有内部链接）。但是，没有合适的新简称， 所以只能用内部链接的静态变量（static variable with internal linkage）。普通 的外部变量可用于同一程序中任意文件中的函数，但是内部链接的静态变量 只能用于同一个文件中的函数。可以使用存储类别说明符 extern，在函数中 重复声明任何具有文件作用域的变量。这样的声明并不会改变其链接属性。 考虑下面的代码： int traveler = 1; // 外部链接 static int stayhome = 1; // 内部链接 int main() { extern int traveler; // 使用定义在别处的 traveler extern int stayhome; // 使用定义在别处的 stayhome \u0026hellip; 对于该程序所在的翻译单元，trveler和stayhome都具有文件作用域，但 是只有traveler可用于其他翻译单元（因为它具有外部链接）。这两个声明 都使用了extern关键字，指明了main()中使用的这两个变量的定义都在别处， 但是这并未改变stayhome的内部链接属性。\n12.1.9 多文件 # 只有当程序由多个翻译单元组成时，才体现区别内部链接和外部链接的 # 重要性。接下来简要介绍一下。 # 复杂的C程序通常由多个单独的源代码文件组成。有时，这些文件可能 # 要共享一个外部变量。C通过在一个文件中进行定义式声明，然后在其他文 # 件中进行引用式声明来实现共享。也就是说，除了一个定义式声明外，其他 # 声明都要使用extern关键字。而且，只有定义式声明才能初始化变量。 注意，如果外部变量定义在一个文件中，那么其他文件在使用该变量之 前必须先声明它（用 extern关键字）。也就是说，在某文件中对外部变量进 行定义式声明只是单方面允许其他文件使用该变量，其他文件在用extern声 明之前不能直接使用它。 过去，不同的编译器遵循不同的规则。例如，许多 UNIX系统允许在多 个文件中不使用 extern 关键字声明变量，前提是只有一个带初始化的声明。 编译器会把文件中一个带初始化的声明视为该变量的定义。\n12.1.10 存储类别说明符 # 读者可能已经注意到了，关键字static和extern的含义取决于上下文。C 语言有 6 个关键字作为存储类别说明符：auto、register、static、extern、 _Thread_local和typedef。typedef关键字与任何内存存储无关，把它归于此类 有一些语法上的原因。尤其是，在绝大多数情况下，不能在声明中使用多个 存储类别说明符，所以这意味着不能使用多个存储类别说明符作为typedef的 一部分。唯一例外的是_Thread_local，它可以和static或extern一起使用。 auto说明符表明变量是自动存储期，只能用于块作用域的变量声明中。 由于在块中声明的变量本身就具有自动存储期，所以使用auto主要是为了明 确表达要使用与外部变量同名的局部变量的意图。 register 说明符也只用于块作用域的变量，它把变量归为寄存器存储类 别，请求最快速度访问该变量。同时，还保护了该变量的地址不被获取。 用 static 说明符创建的对象具有静态存储期，载入程序时创建对象，当 程序结束时对象消失。如果static 用于文件作用域声明，作用域受限于该文 件。如果 static 用于块作用域声明，作用域则受限于该块。因此，只要程序 在运行对象就存在并保留其值，但是只有在执行块内的代码时，才能通过标\n识符访问。块作用域的静态变量无链接。文件作用域的静态变量具有内部链 # 接。 # extern 说明符表明声明的变量定义在别处。如果包含 extern 的声明具有 文件作用域，则引用的变量必须具有外部链接。如果包含 extern 的声明具有 块作用域，则引用的变量可能具有外部链接或内部链接，这接取决于该变量 的定义式声明。 小结：存储类别 自动变量具有块作用域、无链接、自动存储期。它们是局部变量，属于 其定义所在块（通常指函数）私有。寄存器变量的属性和自动变量相同，但 是编译器会使用更快的内存或寄存器储存它们。不能获取寄存器变量的地 址。 具有静态存储期的变量可以具有外部链接、内部链接或无链接。在同一 个文件所有函数的外部声明的变量是外部变量，具有文件作用域、外部链接 和静态存储期。如果在这种声明前面加上关键字static，那么其声明的变量 具有文件作用域、内部链接和静态存储期。如果在函数中用 static 声明一个 变量，则该变量具有块作用域、无链接、静态存储期。 具有自动存储期的变量，程序在进入该变量的声明所在块时才为其分配 内存，在退出该块时释放之前分配的内存。如果未初始化，自动变量中是垃 圾值。程序在编译时为具有静态存储期的变量分配内存，并在程序的运行过 程中一直保留这块内存。如果未初始化，这样的变量会被设置为 0 。 具有块作用域的变量是局部的，属于包含该声明的块私有。具有文件作 用域的变量对文件（或翻译单元）中位于其声明后面的所有函数可见。具有 外部链接的文件作用域变量，可用于该程序的其他翻译单元。具有内部链接 的文件作用域变量，只能用于其声明所在的文件内。 下面用一个简短的程序使用了 5 种存储类别。该程序包含两个文件（程 序清单12.5和程序清单12.6），所以必须使用多文件编译（参见第 9 章或参看\n编译器的指导手册）。该示例仅为了让读者熟悉 5 种存储类别的用法，并不 # 是提供设计模型，好的设计可以不需要使用文件作用域变量。 # 程序清单 12.5 parta.c 程序 // parta.c --- 不同的存储类别 // 与 partb.c 一起编译 #include \u0026lt;stdio.h\u0026gt; void report_count(); void accumulate(int k); int count = 0; // 文件作用域，外部链接 int main(void) { int value; // 自动变量 register int i; // 寄存器变量 printf(\u0026#34;Enter a positive integer (0 to quit): \u0026#34;); while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;value) == 1　\u0026amp;\u0026amp; value \u0026gt; 0) { ++count; // 使用文件作用域变量 for (i = value; i \u0026gt;= 0; i--) accumulate(i); printf(\u0026ldquo;Enter a positive integer (0 to quit): \u0026ldquo;); } report_count(); return 0; } void report_count() { printf(\u0026ldquo;Loop executed %d times\\n\u0026rdquo;, count); } 程序清单 12.6 partb.c 程序 // partb.c \u0026ndash; 程序的其余部分 // 与 parta.c 一起编译 #include \u0026lt;stdio.h\u0026gt; extern int count; // 引用式声明，外部链接 static int total = 0; // 静态定义，内部链接 void accumulate(int k); // 函数原型 void accumulate(int k)// k 具有块作用域，无链接 { static int subtotal = 0; // 静态，无链接\nif (k \u0026lt;= 0) { printf(\u0026ldquo;loop cycle: %d\\n\u0026rdquo;, count); printf(\u0026ldquo;subtotal: %d; total: %d\\n\u0026rdquo;, subtotal, total); subtotal = 0; } else { subtotal += k; total += k; } } 在该程序中，块作用域的静态变量subtotal统计每次while循环传入 accumulate()函数的总数，具有文件作用域、内部链接的变量 total 统计所有 传入 accumulate()函数的总数。当传入负值时， accumulate()函数报告total和 subtotal的值，并在报告后重置subtotal为 0 。由于parta.c调用了 accumulate()函 数，所以必须包含 accumulate()函数的原型。而 partb.c 只包含了accumulate() 函数的定义，并未在文件中调用该函数，所以其原型为可选（即省略原型也 不影响使用）。该函数使用了外部变量count 统计main()中的while循环迭代 的次数（顺带一提，对于该程序，没必要使用外部变量把 parta.c 和 partb.c 的代码弄得这么复杂）。在 parta.c 中，main()和report_count()共享count。 下面是程序的运行示例：\nEnter a positive integer (0 to quit): 5 loop cycle: 1 subtotal: 15; total: 15 Enter a positive integer (0 to quit): 10 loop cycle: 2 subtotal: 55; total: 70 Enter a positive integer (0 to quit): 2 loop cycle: 3 subtotal: 3; total: 73 Enter a positive integer (0 to quit): 0 Loop executed 3　times 12.1.11 存储类别和函数 # 函数也有存储类别，可以是外部函数（默认）或静态函数。C99 新增了 # 第 3 种类别——内联函数，将在第 16 章中介绍。外部函数可以被其他文件的 # 函数访问，但是静态函数只能用于其定义所在的文件。假设一个文件中包含 # 了以下函数原型： # double gamma(double); /* 该函数默认为外部函数 */ static double beta(int, int); extern double delta(double, int); 在同一个程序中，其他文件中的函数可以调用gamma()和delta()，但是 不能调用beta()，因为以static存储类别说明符创建的函数属于特定模块私 有。这样做避免了名称冲突的问题，由于beta()受限于它所在的文件，所以 在其他文件中可以使用与之同名的函数。 通常的做法是：用 extern 关键字声明定义在其他文件中的函数。这样做 是为了表明当前文件中使用的函数被定义在别处。除非使用static关键字， 否则一般函数声明都默认为extern。\n12.1.12 存储类别的选择 # 对于“使用哪种存储类别”的回答绝大多数是“自动存储类别”，要知道默 # 认类别就是自动存储类别。初学者会认为外部存储类别很不错，为何不把所 # 有的变量都设置成外部变量，这样就不必使用参数和指针在函数间传递信息 # 了。然而，这背后隐藏着一个陷阱。如果这样做，A()函数可能违背你的意 # 图，私下修改B()函数使用的变量。多年来，无数程序员的经验表明，随意 # 使用外部存储类别的变量导致的后果远远超过了它所带来的便利。 # 唯一例外的是const数据。因为它们在初始化后就不会被修改，所以不 用担心它们被意外篡改： const int DAYS = 7; const char * MSGS[3] = {\u0026ldquo;Yes\u0026rdquo;, \u0026ldquo;No\u0026rdquo;, Maybe\u0026rdquo;}; 保护性程序设计的黄金法则是：“按需知道”原则。尽量在函数内部解决 该函数的任务，只共享那些需要共享的变量。除自动存储类别外，其他存储 类别也很有用。不过，在使用某类别之前先要考虑一下是否有必要这样做。\n12.2 随机数函数和静态变量 # 学习了不同存储类别的概念后，我们来看几个相关的程序。首先，来看 # 一个使用内部链接的静态变量的函数：随机数函数。ANSI C库提供了rand() 函数生成随机数。生成随机数有多种算法，ANSI C允许C实现针对特定机器 使用最佳算法。然而，ANSI C标准还提供了一个可移植的标准算法，在不 同系统中生成相同的随机数。实际上，rand()是“伪随机数生成器”，意思是 可预测生成数字的实际序列。但是，数字在其取值范围内均匀分布。 为了看清楚程序内部的情况，我们使用可移植的ANSI版本，而不是编 译器内置的rand()函数。可移植版本的方案开始于一个“种子”数字。该函数 使用该种子生成新的数，这个新数又成为新的种子。然后，新种子可用于生 成更新的种子，以此类推。该方案要行之有效，随机数函数必须记录它上一 次被调用时所使用的种子。这里需要一个静态变量。程序清单12.7演示了版 本 0 （稍后给出版本 1 ）。 程序清单 12.7 rand0.c 函数文件 /* rand0.c \u0026ndash;生成随机数*/ /* 使用 ANSI C 可移植算法 / static unsigned long int next = 1; / 种子　/ unsigned int rand0(void) { / 生成伪随机数的魔术公式 */ next = next * 1103515245 + 12345; return (unsigned int) (next / 65536) % 32768;\n} # 在程序清单12.7中，静态变量next的初始值是 1 ，其值在每次调用rand0() 函数时都会被修改（通过魔术公式）。该函数是用于返回一个 0 ～ 32767 之间 的值。注意，next是具有内部链接的静态变量（并非无链接）。这是为了方 便稍后扩展本例，供同一个文件中的其他函数共享。 程序清单12.8是测试rand0()函数的一个简单的驱动程序。 程序清单 12.8 r_drive0.c 驱动程序 /* r_drive0.c \u0026ndash; 测试 rand0()函数 / / 与 rand0.c 一起编译*/ #include \u0026lt;stdio.h\u0026gt; extern unsigned int rand0(void); int main(void) { int count; for (count = 0; count \u0026lt; 5; count++) printf(\u0026quot;%d\\n\u0026rdquo;, rand0()); return 0; } 该程序也需要多文件编译。程序清单 12.7 和程序清单 12.8 分别使用一 个文件。程序清单 12.8 中的extern关键字提醒读者rand0()被定义在其他文件 中，在这个文件中不要求写出该函数原型。输出如下：\n16838 # 5758 # 10113 # 17515 # 31051 # 程序输出的数字看上去是随机的，再次运行程序后，输出如下： # 16838 # 5758 # 10113 # 17515 # 31051 # 看来，这两次的输出完全相同，这体现了“伪随机”的一个方面。每次主 # 程序运行，都开始于相同的种子 1 。可以引入另一个函数srand1()重置种子来 解决这个问题。关键是要让next成为只供rand1()和srand1()访问的内部链接静 态变量（srand1()相当于C库中的srand()函数）。把srand1()加入rand1()所在 的文件中。程序清单12.9给出了修改后的文件。 程序清单 12.9 s_and_r.c 文件程序 /* s_and_r.c \u0026ndash; 包含 rand1() 和 srand1() 的文件　/ / 使用 ANSI C 可移植算法　/ static unsigned long int next = 1; / 种子 */\nint rand1(void) { /生成伪随机数的魔术公式/ next = next * 1103515245 + 12345; return (unsigned int) (next / 65536) % 32768; } void srand1(unsigned int seed) { next = seed; } 注意，next是具有内部链接的文件作用域静态变量。这意味着rand1()和 srand1()都可以使用它，但是其他文件中的函数无法访问它。使用程序清单 12.10的驱动程序测试这两个函数。 程序清单 12.10 r_drive1.c 驱动程序 /* r_drive1.c \u0026ndash; 测试 rand1() 和 srand1() / / 与 s_and_r.c 一起编译 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; extern void srand1(unsigned int x); extern int rand1(void);\nint main(void) { int count; unsigned seed; printf(\u0026ldquo;Please enter your choice for seed.\\n\u0026rdquo;); while (scanf(\u0026quot;%u\u0026quot;, \u0026amp;seed) == 1) { srand1(seed); /* 重置种子 */ for (count = 0; count \u0026lt; 5; count++) printf(\u0026quot;%d\\n\u0026quot;, rand1()); printf(\u0026ldquo;Please enter next seed (q to quit):\\n\u0026rdquo;); } printf(\u0026ldquo;Done\\n\u0026rdquo;); return 0; } 编译两个文件，运行该程序后，其输出如下： 1 16838 5758\n10113 # 17515 # 31051 # Please enter next seed (q to quit): 513 20067 23475 8955 20841 15324 Please enter next seed (q to quit): q Done 设置seed的值为 1 ，输出的结果与前面程序相同。但是设置seed的值为 513 后就得到了新的结果。 注意 自动重置种子 如果 C 实现允许访问一些可变的量（如，时钟系统），可以用这些值 （可能会被截断）初始化种子值。例如，ANSI C有一个time()函数返回系统 时间。虽然时间单元因系统而异，但是重点是该返回值是一个可进行运算的 类型，而且其值随着时间变化而变化。time()返回值的类型名是time_t，具体 类型与系统有关。这没关系，我们可以使用强制类型转换：\n#include \u0026lt;time.h\u0026gt; /* 提供time()的ANSI原型*/ srand1((unsigned int) time(0)); /* 初始化种子 */ 一般而言，time()接受的参数是一个 time_t 类型对象的地址，而时间值 就储存在传入的地址上。当然，也可以传入空指针（ 0 ）作为参数，这种情 况下，只能通过返回值机制来提供值。 可以把这个技巧应用于标准的ANSI C函数srand()和rand()中。如果使用 这些函数，要在文件中包含stdlib.c头文件。实际上，既然已经明白了 srand1()和rand1()如何使用内部链接的静态变量，你也可以使用编译器提供 的版本。我们将在下一个示例中这样做。\n12.3 掷骰子 # 我们将要模拟一个非常流行的游戏——掷骰子。骰子的形式多种多样， # 最普遍的是使用两个 6 面骰子。在一些冒险游戏中，会使用 5 种骰子： 4 面、 6 # 面、 8 面、 12 面和 20 面。聪明的古希腊人证明了只有 5 种正多面体，它们的所 # 有面都具有相同的形状和大小。各种不同类型的骰子就是根据这些正多面体 # 发展而来。也可以做成其他面数的，但是其所有的面不会都相等，因此各个 # 面朝上的几率就不同。 # 计算机计算不用考虑几何的限制，所以可以设计任意面数的电子骰子。 # 我们先从 6 面开始。 # 我们想获得 1 ～ 6 的随机数。然而，rand()生成的随机数在 0 ～ RAND_MAX之间。RAND_MAX被定义在stdlib.h中，其值通常是 INT_MAX。因此，需要进行一些调整，方法如下。 1.把随机数求模 6 ，获得的整数在 0 ～ 5 之间。 2.结果加 1 ，新值在 1 ～ 6 之间。 3.为方便以后扩展，把第 1 步中的数字 6 替换成骰子面数。 下面的代码实现了这 3 个步骤： #include \u0026lt;stdlib.h\u0026gt; /* 提供rand()的原型 */ int rollem(int sides) { int roll; roll = rand() % sides + 1; return roll;\n} # 我们还想用一个函数提示用户选择任意面数的骰子，并返回点数总和。 # 如程序清单12.11所示。 # 程序清单 12.11 diceroll.c 程序 /* diceroll.c -- 掷骰子模拟程序 */ /* 与 mandydice.c 一起编译 */ #include \u0026#34;diceroll.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; /* 提供库函数 rand()的原型 */ int roll_count = 0; /* 外部链接 */ static int rollem(int sides) /* 该函数属于该文件私有 */ { int roll; roll = rand() % sides + 1; ++roll_count; /* 计算函数调用次数 */ return roll; } int roll_n_dice(int dice, int sides) { int d; int total = 0; if (sides \u0026lt; 2) { printf(\u0026ldquo;Need at least 2　sides.\\n\u0026rdquo;); return -2; } if (dice \u0026lt; 1) { printf(\u0026ldquo;Need at least 1　die.\\n\u0026rdquo;); return -1; } for (d = 0; d \u0026lt; dice; d++) total += rollem(sides); return total; } 该文件加入了新元素。第一，rollem()函数属于该文件私有，它是 roll_n_dice()的辅助函数。第二，为了演示外部链接的特性，该文件声明了 一个外部变量roll_count。该变量统计调用rollem()函数的次数。这样设计有 点蹩脚，仅为了演示外部变量的特性。第三，该文件包含以下预处理指令：\n#include \u0026ldquo;diceroll.h\u0026rdquo; 如果使用标准库函数，如 rand()，要在当前文件中包含标准头文件（对 rand()而言要包含stdlib.h），而不是声明该函数。因为头文件中已经包含了 正确的函数原型。我们效仿这一做法，把roll_n_dice()函数的原型放在 diceroll.h头文件中。把文件名放在双引号中而不是尖括号中，指示编译器在 本地查找文件，而不是到编译器存放标准头文件的位置去查找文件。“本地 查找”的含义取决于具体的实现。一些常见的实现把头文件与源代码文件或 工程文件（如果编译器使用它们的话）放在相同的目录或文件夹中。程序清 单12.12是头文件中的内容。 程序清单 12.12 diceroll.h 文件 //diceroll.h extern int roll_count; int roll_n_dice(int dice, int sides); 该头文件中包含一个函数原型和一个 extern 声明。由于 direroll.c 文件 包含了该文件， direroll.c实际上包含了roll_count的两个声明： extern int roll_count; // 头文件中的声明（引用式声明） int roll_count = 0; // 源代码文件中的声明（定义式声明） 这样做没问题。一个变量只能有一个定义式声明，但是带 extern 的声明 是引用式声明，可以有多个引用式声明。 使用 roll_n_dice()函数的程序都要包含 diceroll.c 头文件。包含该头文件 后，程序便可使用roll_n_dice()函数和roll_count变量。如程序清单12.13所 示。 程序清单 12.13 manydice.c 文件\n/* manydice.c \u0026ndash; 多次掷骰子的模拟程序 / / 与 diceroll.c 一起编译*/ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; /* 为库函数 srand() 提供原型　/ #include \u0026lt;time.h\u0026gt; / 为 time() 提供原型　/ #include \u0026ldquo;diceroll.h\u0026rdquo; / 为roll_n_dice()提供原型，为roll_count变量 提供声明 / int main(void) { int dice, roll; int sides; int status; srand((unsigned int) time(0)); / 随机种子 */ printf(\u0026ldquo;Enter the number of sides per die, 0　to stop.\\n\u0026rdquo;); while (scanf(\u0026quot;%d\u0026quot;, \u0026amp;sides) == 1　\u0026amp;\u0026amp; sides \u0026gt; 0) { printf(\u0026ldquo;How many dice?\\n\u0026rdquo;); if ((status = scanf(\u0026quot;%d\u0026quot;, \u0026amp;dice)) != 1) {\nif (status == EOF) break; /* 退出循环 / else { printf(\u0026ldquo;You should have entered an integer.\u0026rdquo;); printf(\u0026quot; Let\u0026rsquo;s begin again.\\n\u0026quot;); while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; / 处理错误的输入 / printf(\u0026ldquo;How many sides? Enter 0　to stop.\\n\u0026rdquo;); continue; / 进入循环的下一轮迭代 / } } roll = roll_n_dice(dice, sides); printf(\u0026ldquo;You have rolled a %d using %d %d-sided dice.\\n\u0026rdquo;, roll, dice, sides); printf(\u0026ldquo;How many sides? Enter 0　to stop.\\n\u0026rdquo;); } printf(\u0026ldquo;The rollem() function was called %d times.\\n\u0026rdquo;, roll_count); / 使用外部变量 */\nprintf(\u0026ldquo;GOOD FORTUNE TO YOU!\\n\u0026rdquo;); return 0; } 要与包含程序清单12.11的文件一起编译该文件。可以把程序清单 12.11、12.12和12.13都放在同一文件夹或目录中。运行该程序，下面是一个 输出示例： Enter the number of sides per die, 0　to stop. 6 How many dice? 2 You have rolled a 12　using 2　6-sided dice. How many sides? Enter 0　to stop. 6 How many dice? 2 You have rolled a 4　using 2　6-sided dice. How many sides? Enter 0　to stop. 6 How many dice? 2\nYou have rolled a 5　using 2　6-sided dice. How many sides? Enter 0　to stop. 0 The rollem() function was called 6　times. GOOD FORTUNE TO YOU! 因为该程序使用了srand()随机生成随机数种子，所以大多数情况下，即 使输入相同也很难得到相同的输出。注意，manydice.c中的main()访问了定 义在diceroll.c中的roll_count变量。 有 3 种情况可以导致外层while循环结束：side小于 1 、输入类型不匹配 （此时scanf()返回 0 ）、遇到文件结尾（返回值是EOF）。为了读取骰子的 点数，该程序处理文件结尾的方式（退出while循环）与处理类型不匹配 （进入循环的下一轮迭代）的情况不同。 可以通过多种方式使用roll_n_dice()。sides等于 2 时，程序模仿掷硬 币，“正面朝上”为 2 ，“反面朝上”为 1 （或者反过来表示也行）。很容易修改 该程序单独显示点数的结果，或者构建一个骰子模拟器。如果要掷多次骰子 （如在一些角色扮演类游戏中），可以很容易地修改程序以输出类似的结 果： Enter the number of sets; enter q to stop. 18 How many sides and how many dice? 6 3 Here are 18　sets of 3　6-sided throws.\n12　10　6　9　8　14　8　15　9　14　12　17　11　7　10 # 13　8　14 # How many sets? Enter q to stop. q rand1()或 rand()（不是 rollem()）还可以用来创建一个猜数字程序，让 计算机选定一个数字，你来猜。读者感兴趣的话可以自己编写这个程序。\n12.4 分配内存： malloc() 和 free() # 我们前面讨论的存储类别有一个共同之处：在确定用哪种存储类别后， # 根据已制定好的内存管理规则，将自动选择其作用域和存储期。然而，还有 # 更灵活地选择，即用库函数分配和管理内存。 # 首先，回顾一下内存分配。所有程序都必须预留足够的内存来储存程序 # 使用的数据。这些内存中有些是自动分配的。例如，以下声明： # float x; char place[] = \u0026ldquo;Dancing Oxen Creek\u0026rdquo;; 为一个float类型的值和一个字符串预留了足够的内存，或者可以显式指 定分配一定数量的内存： int plates[100]; 该声明预留了 100 个内存位置，每个位置都用于储存int类型的值。声明 还为内存提供了一个标识符。因此，可以使用x或place识别数据。回忆一 下，静态数据在程序载入内存时分配，而自动数据在程序执行块时分配，并 在程序离开该块时销毁。 C 能做的不止这些。可以在程序运行时分配更多的内存。主要的工具是 malloc()函数，该函数接受一个参数：所需的内存字节数。malloc()函数会找 到合适的空闲内存块，这样的内存是匿名的。也就是说， malloc()分配内 存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。 因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。因为 char表示 1 字节，malloc()的返回类型通常被定义为指向char的指针。然而， 从ANSI C标准开始，C使用一个新的类型：指向void的指针。该类型相当于 一个“通用指针”。malloc()函数可用于返回指向数组的指针、指向结构的指 针等，所以通常该函数的返回值会被强制转换为匹配的类型。在ANSI C 中，应该坚持使用强制类型转换，提高代码的可读性。然而，把指向 void\n的指针赋给任意类型的指针完全不用考虑类型匹配的问题。如果 malloc()分 配内存失败，将返回空指针。 我们试着用 malloc()创建一个数组。除了用 malloc()在程序运行时请求 一块内存，还需要一个指针记录这块内存的位置。例如，考虑下面的代码： double * ptd; ptd = (double ) malloc(30 * sizeof(double)); 以上代码为 30 个double类型的值请求内存空间，并设置ptd指向该位置。 注意，指针ptd被声明为指向一个double类型，而不是指向内含 30 个double类 型值的块。回忆一下，数组名是该数组首元素的地址。因此，如果让ptd指 向这个块的首元素，便可像使用数组名一样使用它。也就是说，可以使用表 达式ptd[0]访问该块的首元素，ptd[1]访问第 2 个元素，以此类推。根据前面 所学的知识，可以使用数组名来表示指针，也可以用指针来表示数组。 现在，我们有 3 种创建数组的方法。 声明数组时，用常量表达式表示数组的维度，用数组名访问数组的元 素。可以用静态内存或自动内存创建这种数组。 声明变长数组（C99新增的特性）时，用变量表达式表示数组的维度， 用数组名访问数组的元素。具有这种特性的数组只能在自动内存中创建。 声明一个指针，调用malloc()，将其返回值赋给指针，使用指针访问数 组的元素。该指针可以是静态的或自动的。 使用第 2 种和第 3 种方法可以创建动态数组（dynamic array）。这种数组 和普通数组不同，可以在程序运行时选择数组的大小和分配内存。例如，假 设n是一个整型变量。在C99之前，不能这样做： double item[n]; / C99之前：n不允许是变量 */ 但是，可以这样做：\nptd = (double ) malloc(n * sizeof(double)); / 可以 / 如你所见，这比变长数组更灵活。 通常，malloc()要与free()配套使用。free()函数的参数是之前malloc()返 回的地址，该函数释放之前malloc()分配的内存。因此，动态分配内存的存 储期从调用malloc()分配内存到调用free()释放内存为止。设想malloc()和 free()管理着一个内存池。每次调用malloc()分配内存给程序使用，每次调用 free()把内存归还内存池中，这样便可重复使用这些内存。free()的参数应该 是一个指针，指向由 malloc()分配的一块内存。不能用 free()释放通过其他 方式（如，声明一个数组）分配的内存。malloc()和free()的原型都在stdlib.h 头文件中。 使用malloc()，程序可以在运行时才确定数组大小。如程序清单12.14所 示，它把内存块的地址赋给指针 ptd，然后便可以使用数组名的方式使用 ptd。另外，如果内存分配失败，可以调用 exit()函数结束程序，其原型在 stdlib.h中。EXIT_FAILURE的值也被定义在stdlib.h中。标准提供了两个返回 值以保证在所有操作系统中都能正常工作：EXIT_SUCCESS（或者，相当于 0 ）表示普通的程序结束， EXIT_FAILURE 表示程序异常中止。一些操作系 统（包括 UNIX、Linux 和 Windows）还接受一些表示其他运行错误的整数 值。 程序清单 12.14 dyn_arr.c 程序 / dyn_arr.c \u0026ndash; 动态分配数组 / #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; / 为 malloc()、free()提供原型 */ int main(void) {\ndouble * ptd; int max; int number; int i = 0; puts(\u0026ldquo;What is the maximum number of type double entries?\u0026rdquo;); if (scanf(\u0026quot;%d\u0026quot;, \u0026amp;max) != 1) { puts(\u0026ldquo;Number not correctly entered \u0026ndash; bye.\u0026rdquo;); exit(EXIT_FAILURE); } ptd = (double ) malloc(max * sizeof(double)); if (ptd == NULL) { puts(\u0026ldquo;Memory allocation failed. Goodbye.\u0026rdquo;); exit(EXIT_FAILURE); } / ptd 现在指向有max个元素的数组 */ puts(\u0026ldquo;Enter the values (q to quit):\u0026rdquo;); while (i \u0026lt; max \u0026amp;\u0026amp; scanf(\u0026quot;%lf\u0026quot;, \u0026amp;ptd[i]) == 1)\n++i; printf(\u0026ldquo;Here are your %d entries:\\n\u0026rdquo;, number = i); for (i = 0; i \u0026lt; number; i++) { printf(\u0026quot;%7.2f \u0026ldquo;, ptd[i]); if (i % 7　== 6) putchar(\u0026rsquo;\\n\u0026rsquo;); } if (i % 7　!= 0) putchar(\u0026rsquo;\\n\u0026rsquo;); puts(\u0026ldquo;Done.\u0026rdquo;); free(ptd); return 0; } 下面是该程序的运行示例。程序通过交互的方式让用户先确定数组的大 小，我们设置数组大小为 5 。虽然我们后来输入了 6 个数，但程序也只处理 前 5 个数。 What is the maximum number of entries? 5 Enter the values (q to quit):\n20 30 35 25 40 80 # Here are your 5　entries: 20.00 30.00 35.00 25.00 40.00 Done. 该程序通过以下代码获取数组的大小： if (scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;max) != 1) { puts(\u0026ldquo;Number not correctly entered \u0026ndash; bye.\u0026rdquo;); exit(EXIT_FAILURE); } 接下来，分配足够的内存空间以储存用户要存入的所有数，然后把动态 分配的内存地址赋给指针ptd： ptd = (double *) malloc(max * sizeof (double)); 在C中，不一定要使用强制类型转换(double *)，但是在C++中必须使 用。所以，使用强制类型转换更容易把C程序转换为C++程序。 malloc()可能分配不到所需的内存。在这种情况下，该函数返回空指 针，程序结束： if (ptd == NULL) { puts(\u0026ldquo;Memory allocation failed. Goodbye.\u0026rdquo;);\nexit(EXIT_FAILURE); } 如果程序成功分配内存，便可把ptd视为一个有max个元素的数组名。 注意，free()函数位于程序的末尾，它释放了malloc()函数分配的内存。 free()函数只释放其参数指向的内存块。一些操作系统在程序结束时会自动 释放动态分配的内存，但是有些系统不会。为保险起见，请使用free()，不 要依赖操作系统来清理。 使用动态数组有什么好处？从本例来看，使用动态数组给程序带来了更 多灵活性。假设你已经知道，在大多数情况下程序所用的数组都不会超过 100 个元素，但是有时程序确实需要 10000 个元素。要是按照平时的做法，你 不得不为这种情况声明一个内含 10000 个元素的数组。基本上这样做是在浪 费内存。如果需要 10001 个元素，该程序就会出错。这种情况下，可以使用 一个动态数组调整程序以适应不同的情况。\n12.4.1 free() 的重要性 # 静态内存的数量在编译时是固定的，在程序运行期间也不会改变。自动 # 变量使用的内存数量在程序执行期间自动增加或减少。但是动态分配的内存 # 数量只会增加，除非用 free()进行释放。例如，假设有一个创建数组临时副 本的函数，其代码框架如下： \u0026hellip; int main() { double glad[2000]; int i;\n\u0026hellip; # for (i = 0; i \u0026lt; 1000; i++) gobble(glad, 2000); \u0026hellip; } void gobble(double ar[], int n) { double * temp = (double ) malloc( n * sizeof(double)); \u0026hellip;/ free(temp); // 假设忘记使用free() */ } 第 1 次调用gobble()时，它创建了指针temp，并调用malloc()分配了 16000 字节的内存（假设double为 8 字节）。假设如代码注释所示，遗漏了free()。 当函数结束时，作为自动变量的指针temp也会消失。但是它所指向的 16000 字节的内存却仍然存在。由于temp指针已被销毁，所以无法访问这块内存， 它也不能被重复使用，因为代码中没有调用free()释放这块内存。 第 2 次调用gobble()时，它又创建了指针temp，并调用malloc()分配了 16000 字节的内存。第 1 次分配的 16000 字节内存已不可用，所以malloc()分配 了另外一块 16000 字节的内存。当函数结束时，该内存块也无法被再访问和 再使用。 循环要执行 1000 次，所以在循环结束时，内存池中有 1600 万字节被占 用。实际上，也许在循环结束之前就已耗尽所有的内存。这类问题被称为内 存泄漏（memory leak）。在函数末尾处调用free()函数可避免这类问题发 生。\n12.4.2 calloc() 函数 # 分配内存还可以使用calloc()，典型的用法如下： long * newmem; newmem = (long *)calloc(100, sizeof (long)); 和malloc()类似，在ANSI之前，calloc()也返回指向char的指针；在ANSI 之后，返回指向void的指针。如果要储存不同的类型，应使用强制类型转换 运算符。calloc()函数接受两个无符号整数作为参数（ANSI规定是size_t类 型）。第 1 个参数是所需的存储单元数量，第 2 个参数是存储单元的大小（以 字节为单位）。在该例中，long为 4 字节，所以，前面的代码创建了 100 个 4 字节的存储单元，总共 400 字节。 用sizeof(long)而不是 4 ，提高了代码的可移植性。这样，在其他long不是 4 字节的系统中也能正常工作。 calloc()函数还有一个特性：它把块中的所有位都设置为 0 （注意，在某 些硬件系统中，不是把所有位都设置为 0 来表示浮点值 0 ）。 free()函数也可用于释放calloc()分配的内存。 动态内存分配是许多高级程序设计技巧的关键。我们将在第 17 章中详细 讲解。有些编译器可能还提供其他内存管理函数，有些可以移植，有些不可 以。读者可以抽时间看一下。\n12.4.3 动态内存分配和变长数组 # 变长数组（VLA）和调用 malloc()在功能上有些重合。例如，两者都可 用于创建在运行时确定大小的数组： int vlamal() {\nint n; int * pi; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); pi = (int ) malloc (n * sizeof(int)); int ar[n];// 变长数组 pi[2] = ar[2] = -5; \u0026hellip; } 不同的是，变长数组是自动存储类型。因此，程序在离开变长数组定义 所在的块时（该例中，即vlamal()函数结束时），变长数组占用的内存空间 会被自动释放，不必使用 free()。另一方面，用malloc()创建的数组不必局限 在一个函数内访问。例如，可以这样做：被调函数创建一个数组并返回指 针，供主调函数访问，然后主调函数在末尾调用free()释放之前被调函数分 配的内存。另外，free()所用的指针变量可以与 malloc()的指针变量不同，但 是两个指针必须储存相同的地址。但是，不能释放同一块内存两次。 对多维数组而言，使用变长数组更方便。当然，也可以用 malloc()创建 二维数组，但是语法比较繁琐。如果编译器不支持变长数组特性，就只能固 定二维数组的维度，如下所示： int n = 5; int m = 6; int ar2[n][m]; // n×m的变长数组（VLA） int ( p2)[6]; // C99之前的写法\nint (* p3)[m]; // 要求支持变长数组 p2 = (int ()[6]) malloc(n * 6 * sizeof(int)); // n×6 数组 p3 = (int ()[m]) malloc(n * m * sizeof(int)); // n×m 数组（要求支持变长数 组） ar2[1][2] = p2[1][2] = 12; 先复习一下指针声明。由于malloc()函数返回一个指针，所以p2必须是 一个指向合适类型的指针。第 1 个指针声明： int (* p2)[6]; // C99之前的写法 表明p2指向一个内含 6 个int类型值的数组。因此，p2[i]代表一个由 6 个整 数构成的元素，p2[i][j]代表一个整数。 第 2 个指针声明用一个变量指定p3所指向数组的大小。因此，p3代表一 个指向变长数组的指针，这行代码不能在C90标准中运行。\n12.4.4 存储类别和动态内存分配 # 存储类别和动态内存分配有何联系？我们来看一个理想化模型。可以认 # 为程序把它可用的内存分为 3 部分：一部分供具有外部链接、内部链接和无 # 链接的静态变量使用；一部分供自动变量使用；一部分供动态内存分配。 # 静态存储类别所用的内存数量在编译时确定，只要程序还在运行，就可 # 访问储存在该部分的数据。该类别的变量在程序开始执行时被创建，在程序 # 结束时被销毁。 # 然而，自动存储类别的变量在程序进入变量定义所在块时存在，在程序 # 离开块时消失。因此，随着程序调用函数和函数结束，自动变量所用的内存 # 数量也相应地增加和减少。这部分的内存通常作为栈来处理，这意味着新创 # 建的变量按顺序加入内存，然后以相反的顺序销毁。 # 动态分配的内存在调用 malloc()或相关函数时存在，在调用 free()后释 放。这部分的内存由程序员管理，而不是一套规则。所以内存块可以在一个 函数中创建，在另一个函数中销毁。正是因为这样，这部分的内存用于动态 内存分配会支离破碎。也就是说，未使用的内存块分散在已使用的内存块之 间。另外，使用动态内存通常比使用栈内存慢。 总而言之，程序把静态对象、自动对象和动态分配的对象储存在不同的 区域。 程序清单 12.15 where.c 程序 // where.c \u0026ndash; 数据被储存在何处？ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int static_store = 30; const char * pcg = \u0026ldquo;String Literal\u0026rdquo;; int main() { int auto_store = 40; char auto_string [] = \u0026ldquo;Auto char Array\u0026rdquo;; int * pi; char * pcl; pi = (int *) malloc(sizeof(int));\n*pi = 35; pcl = (char *) malloc(strlen(\u0026ldquo;Dynamic String\u0026rdquo;) + 1); strcpy(pcl, \u0026ldquo;Dynamic String\u0026rdquo;); printf(\u0026ldquo;static_store: %d at %p\\n\u0026rdquo;, static_store, \u0026amp;static_store); printf(\u0026quot; auto_store: %d at %p\\n\u0026quot;, auto_store, \u0026amp;auto_store); printf(\u0026quot; *pi: %d at %p\\n\u0026quot;, *pi, pi); printf(\u0026quot; %s at %p\\n\u0026quot;, pcg, pcg); printf(\u0026quot; %s at %p\\n\u0026quot;, auto_string, auto_string); printf(\u0026quot; %s at %p\\n\u0026quot;, pcl, pcl); printf(\u0026quot; %s at %p\\n\u0026quot;, \u0026ldquo;Quoted String\u0026rdquo;, \u0026ldquo;Quoted String\u0026rdquo;); free(pi); free(pcl); return 0; } 在我们的系统中，该程序的输入如下： static_store: 30　at 00378000 auto_store: 40　at 0049FB8C *pi: 35 at 008E9BA0 String Literal at 00375858\nAuto char Array at 0049FB74 Dynamic String at 008E9BD0 Quoted String at 00375908 如上所示，静态数据（包括字符串字面量）占用一个区域，自动数据占 用另一个区域，动态分配的数据占用第 3 个区域（通常被称为内存堆或自由 内存）。\n12.5 ANSI C 类型限定符 # 我们通常用类型和存储类别来描述一个变量。C90 还新增了两个属性： # 恒常性（constancy）和易变性（volatility）。这两个属性可以分别用关键字 const 和 volatile 来声明，以这两个关键字创建的类型是限定类型（qualified type）。C99标准新增了第 3 个限定符：restrict，用于提高编译器优化。C11 标准新增了第 4 个限定符：_Atomic。C11提供一个可选库，由stdatomic.h管 理，以支持并发程序设计，而且_Atomic是可选支持项。 C99 为类型限定符增加了一个新属性：它们现在是幂等的 （idempotent）！这个属性听起来很强大，其实意思是可以在一条声明中多 次使用同一个限定符，多余的限定符将被忽略： const const const int n = 6; // 与 const int n = 6;相同 有了这个新属性，就可以编写类似下面的代码： typedef const int zip; const zip q = 8;\n12.5.1 const 类型限定符 # 第 4 章和第 10 章中介绍过const。以const关键字声明的对象，其值不能通 过赋值或递增、递减来修改。在ANSI兼容的编译器中，以下代码： const int nochange; /* 限定nochange的值不能被修改 / nochange = 12; / 不允许 / 编译器会报错。但是，可以初始化const变量。因此，下面的代码没问 题： const int nochange = 12; / 没问题 */\n该声明让nochange成为只读变量。初始化后，就不能再改变它的值。 可以用const关键字创建不允许修改的数组： const int days1[12] = {31,28,31,30,31,30,31,31,30,31,30,31}; 1. 在指针和形参声明中使用 const 声明普通变量和数组时使用 const 关键字很简单。指针则复杂一些，因 为要区分是限定指针本身为const还是限定指针指向的值为const。下面的声 明： const float * pf; /* pf 指向一个float类型的const值 / 创建了 pf 指向的值不能被改变，而 pt 本身的值可以改变。例如，可以 设置该指针指向其他 const值。相比之下，下面的声明： float * const pt; / pt 是一个const指针 / 创建的指针pt本身的值不能更改。pt必须指向同一个地址，但是它所指 向的值可以改变。下面的声明： const float * const ptr; 表明ptr既不能指向别处，它所指向的值也不能改变。 还可以把const放在第 3 个位置： float const * pfc; // 与const float * pfc;相同 如注释所示，把const放在类型名之后、之前，说明该指针不能用于改 变它所指向的值。简而言之， const放在左侧任意位置，限定了指针指向的 数据不能改变；const放在的右侧，限定了指针本身不能改变。 const 关键字的常见用法是声明为函数形参的指针。例如，假设有一个 函数要调用 display()显示一个数组的内容。要把数组名作为实际参数传递给\n该函数，但是数组名是一个地址。该函数可能会更改主调函数中的数据，但 # 是下面的原型保证了数据不会被更改： # void display(const int array[], int limit); 在函数原型和函数头，形参声明const int array[]与const int * array相同， 所以该声明表明不能更改array指向的数据。 ANSI C库遵循这种做法。如果一个指针仅用于给函数访问值，应将其 声明为一个指向const限定类型的指针。如果要用指针更改主调函数中的数 据，就不使用const关键字。例如，ANSI C中的strcat()原型如下： char *strcat(char * restrict s1, const char * restrict s2); 回忆一下，strcat()函数在第 1 个字符串的末尾添加第 2 个字符串的副本。 这更改了第 1 个字符串，但是未更改第 1 个字符串。上面的声明体现了这一 点。\n2. 对全局数据使用 const 前面讲过，使用全局变量是一种冒险的方法，因为这样做暴露了数据， 程序的任何部分都能更改数据。如果把数据设置为 const，就可避免这样的 危险，因此用 const 限定符声明全局数据很合理。可以创建const变量、const 数组和const结构（结构是一种复合数据类型，将在下一章介绍）。 然而，在文件间共享const数据要小心。可以采用两个策略。第一，遵 循外部变量的常用规则，即在一个文件中使用定义式声明，在其他文件中使 用引用式声明（用extern关键字）： /* file1.c \u0026ndash; 定义了一些外部const变量 */ const double PI = 3.14159; const char * MONTHS[12] = { \u0026ldquo;January\u0026rdquo;, \u0026ldquo;February\u0026rdquo;, \u0026ldquo;March\u0026rdquo;, \u0026ldquo;April\u0026rdquo;, \u0026ldquo;May\u0026rdquo;,\n\u0026ldquo;June\u0026rdquo;, \u0026ldquo;July\u0026rdquo;,\u0026ldquo;August\u0026rdquo;, \u0026ldquo;September\u0026rdquo;, \u0026ldquo;October\u0026rdquo;, \u0026ldquo;November\u0026rdquo;, \u0026ldquo;December\u0026rdquo; }; /* file2.c \u0026ndash; 使用定义在别处的外部const变量 / extern const double PI; extern const * MONTHS []; 另一种方案是，把const变量放在一个头文件中，然后在其他文件中包 含该头文件： / constant.h \u0026ndash;定义了一些外部const变量*/ static const double PI = 3.14159; static const char * MONTHS[12] ={\u0026ldquo;January\u0026rdquo;, \u0026ldquo;February\u0026rdquo;, \u0026ldquo;March\u0026rdquo;, \u0026ldquo;April\u0026rdquo;, \u0026ldquo;May\u0026rdquo;, \u0026ldquo;June\u0026rdquo;, \u0026ldquo;July\u0026rdquo;,\u0026ldquo;August\u0026rdquo;, \u0026ldquo;September\u0026rdquo;, \u0026ldquo;October\u0026rdquo;, \u0026ldquo;November\u0026rdquo;, \u0026ldquo;December\u0026rdquo;}; /* file1.c \u0026ndash;使用定义在别处的外部const变量*/ #include \u0026ldquo;constant.h\u0026rdquo; /* file2.c \u0026ndash;使用定义在别处的外部const变量*/ #include \u0026ldquo;constant.h\u0026rdquo; 这种方案必须在头文件中用关键字static声明全局const变量。如果去掉 static，那么在file1.c和file2.c中包含constant.h将导致每个文件中都有一个相 同标识符的定义式声明，C标准不允许这样做（然而，有些编译器允许）。 实际上，这种方案相当于给每个文件提供了一个单独的数据副本[1]。由于\n每个副本只对该文件可见，所以无法用这些数据和其他文件通信。不过没关 # 系，它们都是完全相同（每个文件都包含相同的头文件）的const数据（声 明时使用了const关键字），这不是问题。 头文件方案的好处是，方便你偷懒，不用惦记着在一个文件中使用定义 式声明，在其他文件中使用引用式声明。所有的文件都只需包含同一个头文 件即可。但它的缺点是，数据是重复的。对于前面的例子而言，这不算什么 问题，但是如果const数据包含庞大的数组，就不能视而不见了。\n12.5.2 volatile 类型限定符 # volatile 限定符告知计算机，代理（而不是变量所在的程序）可以改变 该变量的值。通常，它被用于硬件地址以及在其他程序或同时运行的线程中 共享数据。例如，一个地址上可能储存着当前的时钟时间，无论程序做什 么，地址上的值都随时间的变化而改变。或者一个地址用于接受另一台计算 机传入的信息。 volatile的语法和const一样： olatile int loc1;/* loc1 是一个易变的位置 / volatile int * ploc; / ploc 是一个指向易变的位置的指针 / 以上代码把loc1声明为volatile变量，把ploc声明为指向volatile变量的指 针。 读者可能认为volatile是个可有可无的概念，为何ANSI委员把volatile关 键字放入标准？原因是它涉及编译器的优化。例如，假设有下面的代码： vall =x; / 一些不使用 x 的代码*/ val2 = x\n智能的（进行优化的）编译器会注意到以上代码使用了两次 x，但并未 改变它的值。于是编译器把 x的值临时储存在寄存器中，然后在val2需要使 用x时，才从寄存器中（而不是从原始内存位置上）读取x的值，以节约时 间。这个过程被称为高速缓存（caching）。通常，高速缓存是个不错的优化 方案，但是如果一些其他代理在以上两条语句之间改变了x的值，就不能这 样优化了。如果没有volatile关键字，编译器就不知道这种事情是否会发 生。因此，为安全起见，编译器不会进行高速缓存。这是在 ANSI 之前的情 况。现在，如果声明中没有volatile关键字，编译器会假定变量的值在使用 过程中不变，然后再尝试优化代码。 可以同时用const和volatile限定一个值。例如，通常用const把硬件时钟 设置为程序不能更改的变量，但是可以通过代理改变，这时用 volatile。只 能在声明中同时使用这两个限定符，它们的顺序不重要，如下所示： volatile const int loc; const volatile int * ploc;\n12.5.3 restrict 类型限定符 # restrict 关键字允许编译器优化某部分代码以更好地支持计算。它只能 用于指针，表明该指针是访问数据对象的唯一且初始的方式。要弄明白为什 么这样做有用，先看几个例子。考虑下面的代码： int ar[10]; int * restrict restar = (int *) malloc(10 * sizeof(int)); int * par = ar; 这里，指针restar是访问由malloc()所分配内存的唯一且初始的方式。因 此，可以用restrict关键字限定它。而指针par既不是访问ar数组中数据的初始 方式，也不是唯一方式。所以不用把它设置为restrict。\n现在考虑下面稍复杂的例子，其中n是int类型： for (n = 0; n \u0026lt; 10; n++) { par[n] += 5; restar[n] += 5; ar[n] = 2; par[n] += 3; restar[n] += 3; } 由于之前声明了 restar 是访问它所指向的数据块的唯一且初始的方式， 编译器可以把涉及 restar的两条语句替换成下面这条语句，效果相同： restar[n] += 8; / 可以进行替换 */ 但是，如果把与par相关的两条语句替换成下面的语句，将导致计算错 误： par[n] += 8; / * 给出错误的结果 */ 这是因为for循环在par两次访问相同的数据之间，用ar改变了该数据的 值。 在本例中，如果未使用restrict关键字，编译器就必须假设最坏的情况 （即，在两次使用指针之间，其他的标识符可能已经改变了数据）。如果用 了restrict关键字，编译器就可以选择捷径优化计算。 restrict 限定符还可用于函数形参中的指针。这意味着编译器可以假定\n在函数体内其他标识符不会修改该指针指向的数据，而且编译器可以尝试对 # 其优化，使其不做别的用途。例如，C 库有两个函数用于把一个位置上的字 # 节拷贝到另一个位置。在C99中，这两个函数的原型是： # void * memcpy(void * restrict s1, const void * restrict s2, size_t n); void * memmove(void * s1, const void * s2, size_t n); 这两个函数都从位置s2把n字节拷贝到位置s1。memcpy()函数要求两个 位置不重叠，但是memove()没有这样的要求。声明s1和s2为restrict说明这两 个指针都是访问相应数据的唯一方式，所以它们不能访问相同块的数据。这 满足了memcpy()无重叠的要求。memmove()函数允许重叠，它在拷贝数据时 不得不更小心，以防在使用数据之前就先覆盖了数据。 restrict 关键字有两个读者。一个是编译器，该关键字告知编译器可以 自由假定一些优化方案。另一个读者是用户，该关键字告知用户要使用满足 restrict要求的参数。总而言之，编译器不会检查用户是否遵循这一限制，但 是无视它后果自负。\n12.5.4 _Atomic 类型限定符（ C11 ） # 并发程序设计把程序执行分成可以同时执行的多个线程。这给程序设计 # 带来了新的挑战，包括如何管理访问相同数据的不同线程。C11通过包含可 # 选的头文件stdatomic.h和threads.h，提供了一些可选的（不是必须实现的） 管理方法。值得注意的是，要通过各种宏函数来访问原子类型。当一个线程 对一个原子类型的对象执行原子操作时，其他线程不能访问该对象。例如， 下面的代码： int hogs;// 普通声明 hogs = 12; // 普通赋值 可以替换成：\n_Atomic int hogs; // hogs 是一个原子类型的变量 atomic_store(\u0026amp;hogs, 12); // stdatomic.h中的宏 这里，在hogs中储存 12 是一个原子过程，其他线程不能访问hogs。 编写这种代码的前提是，编译器要支持这一新特性。 12.5.5 旧关键字的新位置 # C99允许把类型限定符和存储类别说明符static放在函数原型和函数头的 形式参数的初始方括号中。对于类型限定符而言，这样做为现有功能提供了 一个替代的语法。例如，下面是旧式语法的声明： void ofmouth(int * const a1, int * restrict a2, int n); // 以前的风格 该声明表明a1是一个指向int的const指针，这意味着不能更改指针本身， 可以更改指针指向的数据。除此之外，还表明a2是一个restrict指针，如上一 节所述。新的等价语法如下： void ofmouth(int a1[const], int a2[restrict], int n); // C99允许 根据新标准，在声明函数形参时，指针表示法和数组表示法都可以使用 这两个限定符。 static的情况不同，因为新标准为static引入了一种与以前用法不相关的 新用法。现在，static除了表明静态存储类别变量的作用域或链接外，新的 用法告知编译器如何使用形式参数。例如，考虑下面的原型： double stick(double ar[static 20]); static 的这种用法表明，函数调用中的实际参数应该是一个指向数组首 元素的指针，且该数组至少有 20 个元素。这种用法的目的是让编译器使用这 些信息优化函数的编码。为何给static新增一个完全不同的用法？C 标准委员 会不愿意创建新的关键字，因为这样会让以前用新关键字作为标识符的程序\n无效。所以，他们会尽量利用现有的关键字，尽量不添加新的关键字。 # restrict 关键字有两个读者。一个是编译器，该关键字告知编译器可以 自由假定一些优化方案。另一个读者是用户，该关键字告知用户要使用满足 restrict要求的参数。\n12.6 关键概念 # C 提供多种管理内存的模型。除了熟悉这些模型外，还要学会如何选择 # 不同的类别。大多数情况下，最好选择自动变量。如果要使用其他类别，应 # 该有充分的理由。通常，使用自动变量、函数形参和返回值进行函数间的通 # 信比使用全局变量安全。但是，保持不变的数据适合用全局变量。 # 应该尽量理解静态内存、自动内存和动态分配内存的属性。尤其要注 # 意：静态内存的数量在编译时确定；静态数据在载入程序时被载入内存。在 # 程序运行时，自动变量被分配或释放，所以自动变量占用的内存数量随着程 # 序的运行会不断变化。可以把自动内存看作是可重复利用的工作区。动态分 # 配的内存也会增加和减少，但是这个过程由函数调用控制，不是自动进行 # 的。 # 12.7 本章小结 # 内存用于存储程序中的数据，由存储期、作用域和链接表征。存储期可 # 以是静态的、自动的或动态分配的。如果是静态存储期，在程序开始执行时 # 分配内存，并在程序运行时都存在。如果是自动存储期，在程序进入变量定 # 义所在块时分配变量的内存，在程序离开块时释放内存。如果是动态分配存 # 储期，在调用malloc()（或相关函数）时分配内存，在调用free()函数时释放 内存。 作用域决定程序的哪些部分可以访问某数据。定义在所有函数之外的变 量具有文件作用域，对位于该变量声明之后的所有函数可见。定义在块或作 为函数形参内的变量具有块作用域，只对该块以及它包含的嵌套块可见。 链接描述定义在程序某翻译单元中的变量可被链接的程度。具有块作用 域的变量是局部变量，无链接。具有文件作用域的变量可以是内部链接或外 部链接。内部链接意味着只有其定义所在的文件才能使用该变量。外部链接 意味着其他文件使用也可以使用该变量。 下面是C的 5 种存储类别（不包括线程的概念）。 自动——在块中不带存储类别说明符或带 auto 存储类别说明符声明的 变量（或作为函数头中的形参）属于自动存储类别，具有自动存储期、块作 用域、无链接。如果未初始化自动变量，它的值是未定义的。 寄存器——在块中带 register 存储类别说明符声明的变量（或作为函数 头中的形参）属于寄存器存储类别，具有自动存储期、块作用域、无链接， 且无法获取其地址。把一个变量声明为寄存器变量即请求编译器将其储存到 访问速度最快的区域。如果未初始化寄存器变量，它的值是未定义的。 静态、无链接——在块中带static存储类别说明符声明的变量属于“静 态、无链接”存储类别，具有静态存储期、块作用域、无链接。只在编译时 被初始化一次。如果未显式初始化，它的字节都被设置为 0 。\n静态、外部链接——在所有函数外部且没有使用 static 存储类别说明符 声明的变量属于“静态、外部链接”存储类别，具有静态存储期、文件作用 域、外部链接。只能在编译器被初始化一次。如果未显式初始化，它的字节 都被设置为 0 。 静态、内部链接——在所有函数外部且使用了 static 存储类别说明符声 明的变量属于“静态、内部链接”存储类别，具有静态存储期、文件作用域、 内部链接。只能在编译器被初始化一次。如果未显式初始化，它的字节都被 设置为 0 。 动态分配的内存由 malloc()（或相关）函数分配，该函数返回一个指向 指定字节数内存块的指针。这块内存被free()函数释放后便可重复使用， free()函数以该内存块的地址作为参数。 类型限定符const、volatile、restrict和_Atomic。const限定符限定数据在 程序运行时不能改变。对指针使用const时，可限定指针本身不能改变或指 针指向的数据不能改变，这取决于const在指针声明中的位置。volatile 限定 符表明，限定的数据除了被当前程序修改外还可以被其他进程修改。该限定 符的目的是警告编译器不要进行假定的优化。restrict限定符也是为了方便编 译器设置优化方案。restrict限定的指针是访问它所指向数据的唯一途径。\n12.8 复习题 # 复习题的参考答案在附录A中。 # 1.哪些类别的变量可以成为它所在函数的局部变量？ # 2.哪些类别的变量在它所在程序的运行期一直存在？ # 3.哪些类别的变量可以被多个文件使用？哪些类别的变量仅限于在一个 # 文件中使用？ # 4.块作用域变量具有什么链接属性？ # 5.extern关键字有什么用途？ 6.考虑下面两行代码，就输出的结果而言有何异同： int * p1 = (int *)malloc(100 * sizeof(int)); int * p1 = (int *)calloc(100, sizeof(int)); 7.下面的变量对哪些函数可见？程序是否有误？ /* 文件 1 */ int daisy; int main(void) { int lily; ...; } int petal() { extern int daisy, lily; \u0026hellip;; } /* 文件 2 */ extern int daisy; static int lily; int rose; int stem() { int rose; \u0026hellip;; } void root() { \u0026hellip;; } 8.下面程序会打印什么？\n#include \u0026lt;stdio.h\u0026gt; char color = \u0026lsquo;B\u0026rsquo;; void first(void); void second(void); int main(void) { extern char color; printf(\u0026ldquo;color in main() is %c\\n\u0026rdquo;, color); first(); printf(\u0026ldquo;color in main() is %c\\n\u0026rdquo;, color); second(); printf(\u0026ldquo;color in main() is %c\\n\u0026rdquo;, color); return 0; } void first(void) { char color; color = \u0026lsquo;R\u0026rsquo;; printf(\u0026ldquo;color in first() is %c\\n\u0026rdquo;, color);\n} # void second(void) { color = \u0026lsquo;G\u0026rsquo;; printf(\u0026ldquo;color in second() is %c\\n\u0026rdquo;, color); } 9.假设文件的开始处有如下声明： static int plink; int value_ct(const int arr[], int value, int n); a.以上声明表明了程序员的什么意图？ b.用const int value和const int n分别替换int value和int n，是否对主调程序 的值加强保护。\n12.9 编程练习 # 1.不使用全局变量，重写程序清单12.4。 # 2.在美国，通常以英里/加仑来计算油耗；在欧洲，以升/100 公里来计 # 算。下面是程序的一部分，提示用户选择计算模式（美制或公制），然后接 # 收数据并计算油耗。 # // pe12-2b.c // 与 pe12-2a.c 一起编译 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;pe12-2a.h\u0026#34; int main(void) { int mode; printf(\u0026#34;Enter 0　for metric mode, 1　for US mode: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;mode); while (mode \u0026gt;= 0) { set_mode(mode); get_info(); show_info(); printf(\u0026ldquo;Enter 0　for metric mode, 1　for US mode\u0026rdquo;); printf(\u0026quot; (-1 to quit): \u0026ldquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;mode); } printf(\u0026ldquo;Done.\\n\u0026rdquo;); return 0; } 下面是是一些输出示例： Enter 0　for metric mode, 1　for US mode: 0 Enter distance traveled in kilometers: 600 Enter fuel consumed in liters: 78.8 Fuel consumption is 13.13 liters per 100　km. Enter 0　for metric mode, 1　for US mode (-1 to quit): 1 Enter distance traveled in miles: 434 Enter fuel consumed in gallons: 12.7 Fuel consumption is 34.2 miles per gallon. Enter 0　for metric mode, 1　for US mode (-1 to quit): 3 Invalid mode specified. Mode 1(US) used. Enter distance traveled in miles: 388\nEnter fuel consumed in gallons: 15.3 Fuel consumption is 25.4 miles per gallon. Enter 0　for metric mode, 1　for US mode (-1 to quit): -1 Done. 如果用户输入了不正确的模式，程序向用户给出提示消息并使用上一次 输入的正确模式。请提供pe12-2a.h头文件和pe12-2a.c源文件。源代码文件应 定义 3 个具有文件作用域、内部链接的变量。一个表示模式、一个表示距 离、一个表示消耗的燃料。get_info()函数根据用户输入的模式提示用户输入 相应数据，并将其储存到文件作用域变量中。show_info()函数根据设置的模 式计算并显示油耗。可以假设用户输入的都是数值数据。 3.重新设计编程练习 2 ，要求只使用自动变量。该程序提供的用户界面 不变，即提示用户输入模式等。但是，函数调用要作相应变化。 4.在一个循环中编写并测试一个函数，该函数返回它被调用的次数。 5.编写一个程序，生成 100 个 1 ～ 10 范围内的随机数，并以降序排列（可 以把第 11 章的排序算法稍加改动，便可用于整数排序，这里仅对整数排 序）。 6.编写一个程序，生成 1000 个 1 ～ 10 范围内的随机数。不用保存或打印 这些数字，仅打印每个数出现的次数。用 10 个不同的种子值运行，生成的 数字出现的次数是否相同？可以使用本章自定义的函数或ANSI C的rand()和 srand()函数，它们的格式相同。这是一个测试特定随机数生成器随机性的方 法。 7.编写一个程序，按照程序清单12.13输出示例后面讨论的内容，修改该 程序。使其输出类似： Enter the number of sets; enter q to stop : 18\nHow many sides and how many dice? 6　3 Here are 18　sets of 3　6-sided throws. 12　10　6　9　8　14　8　15　9　14　12　17　11　7　10 13　8　14 How many sets? Enter q to stop: q 8.下面是程序的一部分： // pe12-8.c #include \u0026lt;stdio.h\u0026gt; int * make_array(int elem, int val); void show_array(const int ar [], int n); int main(void) { int * pa; int size; int value; printf(\u0026ldquo;Enter the number of elements: \u0026ldquo;); while (scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;size) == 1　\u0026amp;\u0026amp; size \u0026gt; 0) { printf(\u0026ldquo;Enter the initialization value: \u0026ldquo;);\nscanf(\u0026quot;%d\u0026rdquo;, \u0026amp;value); pa = make_array(size, value); if (pa) { show_array(pa, size); free(pa); } printf(\u0026ldquo;Enter the number of elements (\u0026lt;1 to quit): \u0026ldquo;); } printf(\u0026ldquo;Done.\\n\u0026rdquo;); return 0; } 提供make_array()和show_array()函数的定义，完成该程序。make_array() 函数接受两个参数，第 1 个参数是int类型数组的元素个数，第 2 个参数是要赋 给每个元素的值。该函数调用malloc()创建一个大小合适的数组，将其每个 元素设置为指定的值，并返回一个指向该数组的指针。show_array()函数显 示数组的内容，一行显示 8 个数。 9.编写一个符合以下描述的函数。首先，询问用户需要输入多少个单 词。然后，接收用户输入的单词，并显示出来，使用malloc()并回答第 1 个问 题（即要输入多少个单词），创建一个动态数组，该数组内含相应的指向 char的指针（注意，由于数组的每个元素都是指向char的指针，所以用于储 存malloc()返回值的指针应该是一个指向指针的指针，且它所指向的指针指\n向char）。在读取字符串时，该程序应该把单词读入一个临时的char数组， 使用malloc()分配足够的存储空间来储存单词，并把地址存入该指针数组 （该数组中每个元素都是指向 char 的指针）。然后，从临时数组中把单词 拷贝到动态分配的存储空间中。因此，有一个字符指针数组，每个指针都指 向一个对象，该对象的大小正好能容纳被储存的特定单词。下面是该程序的 一个运行示例： How many words do you wish to enter? 5 Enter 5　words now: I enjoyed doing this exerise Here are your words: I enjoyed doing this exercise\n[1].注意，以static声明的文件作用域变量具有内部链接属性。——译者注\n第 13 章 文件输入 / 输出 # 本章介绍以下内容： # 函数：fopen()、getc()、putc()、exit()、fclose() fprintf()、fscanf()、fgets()、fputs() rewind()、fseek()、ftell()、fflush() fgetpos()、fsetpos()、feof()、ferror() ungetc()、setvbuf()、fread()、fwrite() 如何使用C标准I/O系列的函数处理文件 文件模式和二进制模式、文本和二进制格式、缓冲和无缓冲I/O 使用既可以顺序访问文件也可以随机访问文件的函数 文件是当今计算机系统不可或缺的部分。文件用于储存程序、文档、数 据、书信、表格、图形、照片、视频和许多其他种类的信息。作为程序员， 必须会编写创建文件和从文件读写数据的程序。本章将介绍相关的内容。\n13.1 与文件进行通信 # 有时，需要程序从文件中读取信息或把信息写入文件。这种程序与文件 # 交互的形式就是文件重定向（第 8 章介绍过）。这种方法很简单，但是有一 # 定限制。例如，假设要编写一个交互程序，询问用户书名并把完整的书名列 # 表保存在文件中。如果使用重定向，应该类似于： # books \u0026gt; bklist 用户的输入被重定向到 bklist 中。这样做不仅会把不符合要求的文本写 入 bklist，而且用户也看不到要回答什么问题。 C提供了更强大的文件通信方法，可以在程序中打开文件，然后使用特 殊的I/O函数读取文件中的信息或把信息写入文件。在研究这些方法之前， 先简要介绍一下文件的性质。\n13.1.1 文件是什么 # 文件（file）通常是在磁盘或固态硬盘上的一段已命名的存储区。对我 们而言，stdio.h就是一个文件的名称，该文件中包含一些有用的信息。然 而，对操作系统而言，文件更复杂一些。例如，大型文件会被分开储存，或 者包含一些额外的数据，方便操作系统确定文件的种类。然而，这都是操作 系统所关心的，程序员关心的是C程序如何处理文件（除非你正在编写操作 系统）。 C把文件看作是一系列连续的字节，每个字节都能被单独读取。这与 UNIX环境中（C的发源地）的文件结构相对应。由于其他环境中可能无法完 全对应这个模型，C提供两种文件模式：文本模式和二进制模式。\n13.1.2 文本模式和二进制模式 # 首先，要区分文本内容和二进制内容、文本文件格式和二进制文件格 # 式，以及文件的文本模式和二进制模式。 # 所有文件的内容都以二进制形式（ 0 或 1 ）储存。但是，如果文件最初使 # 用二进制编码的字符（例如， ASCII或Unicode）表示文本（就像C字符串那 样），该文件就是文本文件，其中包含文本内容。如果文件中的二进制值代 表机器语言代码或数值数据（使用相同的内部表示，假设，用于long或 double类型的值）或图片或音乐编码，该文件就是二进制文件，其中包含二 进制内容。 UNIX用同一种文件格式处理文本文件和二进制文件的内容。不奇怪， 鉴于C是作为开发UNIX的工具而创建的，C和UNIX在文本中都使用\\n（换行 符）表示换行。UNIX目录中有一个统计文件大小的计数，程序可使用该计 数确定是否读到文件结尾。然而，其他系统在此之前已经有其他方法处理文 件，专门用于保存文本。也就是说，其他系统已经有一种与UNIX模型不同 的格式处理文本文件。例如，以前的OS X Macintosh文件用\\r （回车符）表 示新的一行。早期的MS-DOS文件用\\r\\n组合表示新的一行，用嵌入的Ctrl+Z 字符表示文件结尾，即使实际文件用添加空字符的方法使其总大小是 256 的 倍数（在Windows中，Notepad仍然生成MS-DOS格式的文本文件，但是新的 编辑器可能使用类UNIX格式居多）。其他系统可能保持文本文件中的每一 行长度相同，如有必要，用空字符填充每一行，使其长度保持一致。或者， 系统可能在每行的开始标出每行的长度。 为了规范文本文件的处理，C 提供两种访问文件的途径：二进制模式和 文本模式。在二进制模式中，程序可以访问文件的每个字节。而在文本模式 中，程序所见的内容和文件的实际内容不同。程序以文本模式读取文件时， 把本地环境表示的行末尾或文件结尾映射为C模式。例如，C程序在旧式 Macintosh中以文本模式读取文件时，把文件中的\\r转换成\\n；以文本模式写 入文件时，把\\n转换成\\r。或者，C文本模式程序在MS-DOS平台读取文件 时，把\\r\\n转换成\\n；写入文件时，把\\n转换成\\r\\n。在其他环境中编写的文本 模式程序也会做类似的转换。 除了以文本模式读写文本文件，还能以二进制模式读写文本文件。如果 读写一个旧式MS-DOS文本文件，程序会看到文件中的\\r 和\\n 字符，不会发 生映射（图 13.1 演示了一些文本）。如果要编写旧式 Mac格式、MS-DOS格\n式或UNIX/Linux格式的文件模式程序，应该使用二进制模式，这样程序才能 确定实际的文件内容并执行相应的动作。\n图13.1 二进制模式和文本模式 虽然C提供了二进制模式和文本模式，但是这两种模式的实现可以相 同。前面提到过，因为UNIX使用一种文件格式，这两种模式对于UNIX实现 而言完全相同。Linux也是如此。\n13.1.3 I/O 的级别 # 除了选择文件的模式，大多数情况下，还可以选择I/O的两个级别（即 # 处理文件访问的两个级别）。底层I/O（low-level I/O）使用操作系统提供的 基本I/O服务。标准高级I/O（standard high-level I/O）使用C库的标准包和 stdio.h头文件定义。因为无法保证所有的操作系统都使用相同的底层I/O模\n型，C标准只支持标准I/O包。有些实现会提供底层库，但是C标准建立了可 # 移植的I/O模型，我们主要讨论这些I/O。 # 13.1.4 标准文件 # C程序会自动打开 3 个文件，它们被称为标准输入（standard input）、标 准输出（standard output）和标准错误输出（standard error output）。在默认 情况下，标准输入是系统的普通输入设备，通常为键盘；标准输出和标准错 误输出是系统的普通输出设备，通常为显示屏。 通常，标准输入为程序提供输入，它是 getchar()和 scanf()使用的文件。 程序通常输出到标准输出，它是putchar()、puts()和printf()使用的文件。第 8 章提到的重定向把其他文件视为标准输入或标准输出。标准错误输出提供了 一个逻辑上不同的地方来发送错误消息。例如，如果使用重定向把输出发送 给文件而不是屏幕，那么发送至标准错误输出的内容仍然会被发送到屏幕 上。这样很好，因为如果把错误消息发送至文件，就只能打开文件才能看 到。\n13.2 标准 I/O # 与底层I/O相比，标准I/O包除了可移植以外还有两个好处。第一，标准 # I/O有许多专门的函数简化了处理不同I/O的问题。例如，printf()把不同形式 的数据转换成与终端相适应的字符串输出。第二，输入和输出都是缓冲的。 也就是说，一次转移一大块信息而不是一字节信息（通常至少 512 字节）。 例如，当程序读取文件时，一块数据被拷贝到缓冲区（一块中介存储区 域）。这种缓冲极大地提高了数据传输速率。程序可以检查缓冲区中的字 节。缓冲在后台处理，所以让人有逐字符访问的错觉（如果使用底层I/O， 要自己完成大部分工作）。程序清单13.1演示了如何用标准I/O读取文件和 统计文件中的字符数。我们将在后面几节讨论程序清单 13.1 中的一些特 性。该程序使用命令行参数，如果你是Windows用户，在编译后必须在命令 提示窗口运行该程序；如果你是Macintosh用户，最简单的方法是使用 Terminal在命令行形式中编译并运行该程序。或者，如第 11 章所述，如果在 IDE中运行该程序，可以使用Xcode的Product菜单提供命令行参数。或者也 可以用puts()和fgets()函数替换命令行参数来获得文件名。 程序清单 13.1 count.c 程序 /* count.c \u0026ndash; 使用标准 I/O */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 提供 exit()的原型 int main(int argc, char *argv []) { int ch; // 读取文件时，储存每个字符的地方 FILE *fp; // “文件指针” unsigned long count = 0;\nif (argc != 2) { printf(\u0026ldquo;Usage: %s filename\\n\u0026rdquo;, argv[0]); exit(EXIT_FAILURE); } if ((fp = fopen(argv[1], \u0026ldquo;r\u0026rdquo;)) == NULL) { printf(\u0026ldquo;Can\u0026rsquo;t open %s\\n\u0026rdquo;, argv[1]); exit(EXIT_FAILURE); } while ((ch = getc(fp)) != EOF) { putc(ch, stdout); // 与 putchar(ch); 相同 count++; } fclose(fp); printf(\u0026ldquo;File %s has %lu characters\\n\u0026rdquo;, argv[1], count); return 0; }\n13.2.1 检查命令行参数 # 首先，程序清单13.1中的程序检查argc的值，查看是否有命令行参数。 如果没有，程序将打印一条消息并退出程序。字符串 argv[0]是该程序的名 称。显式使用 argv[0]而不是程序名，错误消息的描述会随可执行文件名的 改变而自动改变。这一特性在像 UNIX 这种允许单个文件具有多个文件名的 环境中也很方便。但是，一些操作系统可能不识别argv[0]，所以这种用法并 非完全可移植。 exit()函数关闭所有打开的文件并结束程序。exit()的参数被传递给一些 操作系统，包括 UNIX、Linux、Windows和MS-DOS，以供其他程序使用。 通常的惯例是：正常结束的程序传递 0 ，异常结束的程序传递非零值。不同 的退出值可用于区分程序失败的不同原因，这也是UNIX和DOS编程的通常 做法。但是，并不是所有的操作系统都能识别相同范围内的返回值。因此， C 标准规定了一个最小的限制范围。尤其是，标准要求 0 或宏 EXIT_SUCCESS用于表明成功结束程序，宏EXIT_FAILURE用于表明结束程 序失败。这些宏和exit()原型都位于stdlib.h头文件中。 根据ANSI C的规定，在最初调用的main()中使用return与调用exit()的效 果相同。因此，在main()，下面的语句： return 0; 和下面这条语句的作用相同： exit(0); 但是要注意，我们说的是“最初的调用”。如果main()在一个递归程序 中，exit()仍然会终止程序，但是return只会把控制权交给上一级递归，直至 最初的一级。然后return结束程序。return和exit()的另一个区别是，即使在其 他函数中（除main()以外）调用exit()也能结束整个程序。\n13.2.2 fopen() 函数 # 继续分析程序清单13.1，该程序使用fopen()函数打开文件。该函数声明 在stdio.h中。它的第 1 个参数是待打开文件的名称，更确切地说是一个包含 改文件名的字符串地址。第 2 个参数是一个字符串，指定待打开文件的模 式。表13.1列出了C库提供的一些模式。 表13.1 fopen()的模式字符串\n像UNIX和Linux这样只有一种文件类型的系统，带b字母的模式和不带b 字母的模式相同。 新的C11新增了带x字母的写模式，与以前的写模式相比具有更多特 性。第一，如果以传统的一种写模式打开一个现有文件，fopen()会把该文件 的长度截为 0 ，这样就丢失了该文件的内容。但是使用带 x字母的写模式， 即使fopen()操作失败，原文件的内容也不会被删除。第二，如果环境允许， x模式的独占特性使得其他程序或线程无法访问正在被打开的文件。 警告 如果使用任何一种\u0026quot;w\u0026quot;模式（不带x字母）打开一个现有文件，该文件的 内容会被删除，以便程序在一个空白文件中开始操作。然而，如果使用带x 字母的任何一种模式，将无法打开一个现有文件。 程序成功打开文件后，fopen()将返回文件指针（file pointer），其他I/O\n函数可以使用这个指针指定该文件。文件指针（该例中是fp）的类型是指向 FILE的指针，FILE是一个定义在stdio.h中的派生类型。文件指针fp并不指向 实际的文件，它指向一个包含文件信息的数据对象，其中包含操作文件的 I/O函数所用的缓冲区信息。因为标准库中的I/O函数使用缓冲区，所以它们 不仅要知道缓冲区的位置，还要知道缓冲区被填充的程度以及操作哪一个文 件。标准I/O函数根据这些信息在必要时决定再次填充或清空缓冲区。fp指 向的数据对象包含了这些信息（该数据对象是一个 C结构，将在第 14 章中 介绍）。\n13.2.3 getc() 和 putc() 函数 # getc()和putc()函数与getchar()和putchar()函数类似。所不同的是，要告诉 getc()和putc()函数使用哪一个文件。下面这条语句的意思是“从标准输入中 获取一个字符”： ch = getchar(); 然而，下面这条语句的意思是“从fp指定的文件中获取一个字符”： ch = getc(fp); 与此类似，下面语句的意思是“把字符ch放入FILE指针fpout指定的文件 中”： putc(ch, fpout); 在putc()函数的参数列表中，第 1 个参数是待写入的字符，第 2 个参数是 文件指针。 程序清单13.1把stdout作为putc()的第 2 个参数。stdout作为与标准输出相 关联的文件指针，定义在stdio.h中，所以putc(ch, stdout)与putchar(ch)的作用 相同。实际上，putchar()函数一般通过putc()来定义。与此类似，getchar()也 通过使用标准输入的getc()来定义。\n为何该示例不用 putchar()而要用 putc()？原因之一是为了介绍 putc()函 数；原因之二是，把stdout替换成别的参数，很容易将这段程序改写成文件 输出。\n13.2.4 文件结尾 # 从文件中读取数据的程序在读到文件结尾时要停止。如何告诉程序已经 # 读到文件结尾？如果 getc()函数在读取一个字符时发现是文件结尾，它将返 回一个特殊值EOF。所以C程序只有在读到超过文件末尾时才会发现文件的 结尾（一些其他语言用一个特殊的函数在读取之前测试文件结尾，C语言不 同）。 为了避免读到空文件，应该使用入口条件循环（不是do while循环）进 行文件输入。鉴于getc() （和其他C输入函数）的设计，程序应该在进入循 环体之前先尝试读取。如下面设计所示： // 设计范例 #1 int ch; // 用int类型的变量储存EOF FILE * fp; fp = fopen(\u0026ldquo;wacky.txt\u0026rdquo;, \u0026ldquo;r\u0026rdquo;); ch = getc(fp); // 获取初始输入 while (ch != EOF) { putchar(ch); // 处理输入 ch = getc(fp); // 获取下一个输入 }\n以上代码可简化为： # // 设计范例 #2 # int ch; FILE * fp; fp = fopen(\u0026ldquo;wacky.txt\u0026rdquo;, \u0026ldquo;r\u0026rdquo;); while (( ch = getc(fp)) != EOF) { putchar(ch); //处理输入 } 由于ch = getc(fp)是while测试条件的一部分，所以程序在进入循环体之 前就读取了文件。不要设计成下面这样： // 糟糕的设计（存在两个问题） int ch; FILE * fp; fp = fopen(\u0026ldquo;wacky.txt\u0026rdquo;, \u0026ldquo;r\u0026rdquo;); while (ch != EOF) // 首次使用ch时，它的值尚未确定 { ch = getc(fp); // 获取输入 putchar(ch); // 处理输入\n} # 第 1 个问题是，ch首次与EOF比较时，其值尚未确定。第 2 个问题是，如 果getc()返回EOF，该循环会把EOF作为一个有效字符处理。这些问题都可以 解决。例如，把ch初始化为一个哑值（dummy value），再把一个if语句加入 到循环中。但是，何必多此一举，直接使用上面的设计范例即可。 其他输入函数也会用到这种处理方案，它们在读到文件结尾时也会返回 一个错误信号（EOF 或 NULL指针）。\n13.2.5 fclose() 函数 # fclose(fp)函数关闭fp指定的文件，必要时刷新缓冲区。对于较正式的程 序，应该检查是否成功关闭文件。如果成功关闭，fclose()函数返回 0 ，否则 返回EOF： if (fclose(fp) != 0) printf(\u0026ldquo;Error in closing file %s\\n\u0026rdquo;, argv[1]); 如果磁盘已满、移动硬盘被移除或出现I/O错误，都会导致调用fclose() 函数失败。\n13.2.6 指向标准文件的指针 # stdio.h头文件把 3 个文件指针与 3 个标准文件相关联，C程序会自动打开 这 3 个标准文件。如表13.2所示： 表13.2 标准文件和相关联的文件指针\n这些文件指针都是指向FILE的指针，所以它们可用作标准I/O函数的参 # 数，如fclose(fp)中的fp。接下来，我们用一个程序示例创建一个新文件，并 写入内容。\n13.3 一个简单的文件压缩程序 # 下面的程序示例把一个文件中选定的数据拷贝到另一个文件中。该程序 # 同时打开了两个文件，以\u0026quot;r\u0026quot;模式打开一个，以\u0026quot;w\u0026quot;模式打开另一个。该程序 （程序清单13.2）以保留每 3 个字符中的第 1 个字符的方式压缩第 1 个文件的 内容。最后，把压缩后的文本存入第 2 个文件。第 2 个文件的名称是第 1 个文 件名加上.red后缀（此处的red代表reduced）。使用命令行参数，同时打开多 个文件，以及在原文件名后面加上后缀，都是相当有用的技巧。这种压缩方 式有限，但是也有它的用途（很容易把该程序改成用标准 I/O 而不是命令行 参数提供文件名）。 程序清单 13.2 reducto.c 程序 // reducto.c –把文件压缩成原来的1/3！ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 提供 exit()的原型 #include \u0026lt;string.h\u0026gt; // 提供 strcpy()、strcat()的原型 #define LEN 40 int main(int argc, char *argv []) { FILE *in, *out; // 声明两个指向 FILE 的指针 int ch; char name[LEN]; // 储存输出文件名 int count = 0;\n// 检查命令行参数 # if (argc \u0026lt; 2) { fprintf(stderr, \u0026ldquo;Usage: %s filename\\n\u0026rdquo;, argv[0]); exit(EXIT_FAILURE); } // 设置输入 if ((in = fopen(argv[1], \u0026ldquo;r\u0026rdquo;)) == NULL) { fprintf(stderr, \u0026ldquo;I couldn\u0026rsquo;t open the file \u0026quot;%s\u0026quot;\\n\u0026rdquo;, argv[1]); exit(EXIT_FAILURE); } // 设置输出 strncpy(name, argv[1], LEN - 5); // 拷贝文件名 name[LEN - 5] = \u0026lsquo;\\0\u0026rsquo;; strcat(name, \u0026ldquo;.red\u0026rdquo;); // 在文件名后添加.red if ((out = fopen(name, \u0026ldquo;w\u0026rdquo;)) == NULL) { // 以写模式打开文件\nfprintf(stderr, \u0026ldquo;Can\u0026rsquo;t create output file.\\n\u0026rdquo;); exit(3); } // 拷贝数据 while ((ch = getc(in)) != EOF) if (count++ % 3 == 0) putc(ch, out);// 打印 3 个字符中的第 1 个字符 // 收尾工作 if (fclose(in) != 0 || fclose(out) != 0) fprintf(stderr, \u0026ldquo;Error in closing files\\n\u0026rdquo;); return 0; } 假设可执行文件名是reducto，待读取的文件名为eddy，该文件中包含下 面一行内容： So even Eddy came oven ready. 命令如下： reducto eddy 待写入的文件名为eddy.red。该程序把输出显示在eddy.red中，而不是屏 幕上。打开eddy.red，内容如下： Send money\n该程序示例演示了几个编程技巧。我们来仔细研究一下。 # fprintf()和 printf()类似，但是 fprintf()的第 1 个参数必须是一个文件指 针。程序中使用stderr指针把错误消息发送至标准错误，C标准通常都这么 做。 为了构造新的输出文件名，该程序使用strncpy()把名称eddy拷贝到数组 name中。参数LEN-5为.red后缀和末尾的空字符预留了空间。如果argv[2]字 符串比LEN-5长，就拷贝不了空字符。出现这种情况时，程序会添加空字 符。调用strncpy()后，name中的第 1 个空字符在调用strcat()函数时，被.red的. 覆盖，生成了eddy.red。程序中还检查了是否成功打开名为eddy.red的文件。 这个步骤在一些环境中相当重要，因为像strange.c.red这样的文件名可能是 无效的。例如，在传统的DOS环境中，不能在后缀名后面添加后缀名（MS- DOS使用的方法是用.red替换现有后缀名，所以strange.c将变成strange.red。 例如，可以用strchr()函数定位（如果有的话），然后只拷贝点前面的部分即 可）。 该程序同时打开了两个文件，所以我们要声明两个 FIFL 指针。注意， 程序都是单独打开和关闭每个文件。同时打开的文件数量是有限的，这个限 制取决于系统和实现，范围一般是 10 ～ 20 。相同的文件指针可以处理不同的 文件，前提是这些文件不需要同时打开。\n13.4 文件 I/O ： fprintf() 、 fscanf() 、 fgets() 和 fputs() # 前面章节介绍的I/O函数都类似于文件I/O函数。它们的主要区别是，文 # 件I/O函数要用FILE指针指定待处理的文件。与 getc()、putc()类似，这些函 数都要求用指向 FILE 的指针（如，stdout）指定一个文件，或者使用fopen() 的返回值。\n13.4.1 fprintf() 和 fscanf() 函数 # 文件I/O函数fprintf()和fscanf()函数的工作方式与printf()和scanf()类似， 区别在于前者需要用第 1 个参数指定待处理的文件。我们在前面用过 fprintf()。程序清单13.3演示了这两个文件I/O函数和rewind()函数的用法。 程序清单 13.3 addaword.c 程序 /* addaword.c \u0026ndash; 使用 fprintf()、fscanf() 和 rewind() */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAX 41 int main(void) { FILE *fp; char words[MAX]; if ((fp = fopen(\u0026ldquo;wordy\u0026rdquo;, \u0026ldquo;a+\u0026rdquo;)) == NULL)\n{ # fprintf(stdout, \u0026ldquo;Can\u0026rsquo;t open \u0026quot;wordy\u0026quot; file.\\n\u0026rdquo;); exit(EXIT_FAILURE); } puts(\u0026ldquo;Enter words to add to the file; press the #\u0026rdquo;); puts(\u0026ldquo;key at the beginning of a line to terminate.\u0026rdquo;); while ((fscanf(stdin, \u0026ldquo;%40s\u0026rdquo;, words) == 1) \u0026amp;\u0026amp; (words[0] != \u0026lsquo;#\u0026rsquo;)) fprintf(fp, \u0026ldquo;%s\\n\u0026rdquo;, words); puts(\u0026ldquo;File contents:\u0026rdquo;); rewind(fp); /* 返回到文件开始处 */ while (fscanf(fp, \u0026ldquo;%s\u0026rdquo;, words) == 1) puts(words); puts(\u0026ldquo;Done!\u0026rdquo;); if (fclose(fp) != 0) fprintf(stderr, \u0026ldquo;Error closing file\\n\u0026rdquo;); return 0; } 该程序可以在文件中添加单词。使用\u0026quot;a+\u0026ldquo;模式，程序可以对文件进行读 写操作。首次使用该程序，它将创建wordy文件，以便把单词存入其中。随 后再使用该程序，可以在wordy文件后面添加单词。虽然\u0026quot;a+\u0026ldquo;模式只允许在\n文件末尾添加内容，但是该模式下可以读整个文件。rewind()函数让程序回 到文件开始处，方便while循环打印整个文件的内容。注意，rewind()接受一 个文件指针作为参数。 下面是该程序在UNIX环境中的一个运行示例（可执行程序已重命名为 addword）： $ addaword Enter words to add to the file; press the Enter key at the beginning of a line to terminate. The fabulous programmer # File contents: The fabulous programmer Done! $ addaword Enter words to add to the file; press the Enter key at the beginning of a line to terminate. enchanted the large\n# File contents: The fabulous programmer enchanted the large Done! 如你所见，fprintf()和 fscanf()的工作方式与 printf()和 scanf()类似。但 是，与 putc()不同的是，fprintf()和fscanf()函数都把FILE指针作为第 1 个参 数，而不是最后一个参数。\n13.4.2 fgets() 和 fputs() 函数 # 第 11 章时介绍过fgets()函数。它的第 1 个参数和gets()函数一样，也是表 示储存输入位置的地址（char * 类型）；第 2 个参数是一个整数，表示待输 入字符串的大小 [1]；最后一个参数是文件指针，指定待读取的文件。下面 是一个调用该函数的例子： fgets(buf, STLEN, fp); 这里，buf是char类型数组的名称，STLEN是字符串的大小，fp是指向 FILE的指针。 fgets()函数读取输入直到第 1 个换行符的后面，或读到文件结尾，或者 读取STLEN-1 个字符（以上面的 fgets()为例）。然后，fgets()在末尾添加一\n个空字符使之成为一个字符串。字符串的大小是其字符数加上一个空字符。 # 如果fgets()在读到字符上限之前已读完一整行，它会把表示行结尾的换行符 放在空字符前面。fgets()函数在遇到EOF时将返回NULL值，可以利用这一机 制检查是否到达文件结尾；如果未遇到EOF则之前返回传给它的地址。 fputs()函数接受两个参数：第 1 个是字符串的地址；第 2 个是文件指针。 该函数根据传入地址找到的字符串写入指定的文件中。和 puts()函数不同， fputs()在打印字符串时不会在其末尾添加换行符。下面是一个调用该函数的 例子： fputs(buf, fp); 这里，buf是字符串的地址，fp用于指定目标文件。 由于fgets()保留了换行符，fputs()就不会再添加换行符，它们配合得非 常好。如第 11 章的程序清单11.8所示，即使输入行比STLEN长，这两个函数 依然处理得很好。\n13.5 随机访问： fseek() 和 ftell() # 有了 fseek()函数，便可把文件看作是数组，在 fopen()打开的文件中直 接移动到任意字节处。我们创建一个程序（程序清单13.4）演示fseek()和 ftell()的用法。注意，fseek()有 3 个参数，返回int类型的值；ftell()函数返回一 个long类型的值，表示文件中的当前位置。 程序清单 13.4 reverse.c 程序 /* reverse.c \u0026ndash; 倒序显示文件的内容 / #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define CNTL_Z \u0026lsquo;\\032\u0026rsquo; / DOS文本文件中的文件结尾标记 */ #define SLEN 81 int main(void) { char file[SLEN]; char ch; FILE *fp; long count, last; puts(\u0026ldquo;Enter the name of the file to be processed:\u0026rdquo;); scanf(\u0026quot;%80s\u0026rdquo;, file); if ((fp = fopen(file, \u0026ldquo;rb\u0026rdquo;)) == NULL)\n{ /* 只读模式　*/ # printf(\u0026ldquo;reverse can\u0026rsquo;t open %s\\n\u0026rdquo;, file); exit(EXIT_FAILURE); } fseek(fp, 0L, SEEK_END); /* 定位到文件末尾 / last = ftell(fp); for (count = 1L; count \u0026lt;= last; count++) { fseek(fp, -count, SEEK_END); / 回退　/ ch = getc(fp); if (ch != CNTL_Z \u0026amp;\u0026amp; ch != \u0026lsquo;\\r\u0026rsquo;) / MS-DOS 文件 */ putchar(ch); } putchar(\u0026rsquo;\\n\u0026rsquo;); fclose(fp); return 0; } 下面是对一个文件的输出： Enter the name of the file to be processed:\nCluv .C ni eno naht ylevol erom margorp a ees reven llahs I taht kniht I 该程序使用二进制模式，以便处理MS-DOS文本和UNIX文件。但是， 在使用其他格式文本文件的环境中可能无法正常工作。 注意 如果通过命令行环境运行该程序，待处理文件要和可执行文件在同一个 目录（或文件夹）中。如果在IDE中运行该程序，具体查找方案序因实现而 异。例如，默认情况下，Microsoft Visual Studio 2012在源代码所在的目录中 查找，而Xcode 4.6则在可执行文件所在的目录中查找。 接下来，我们要讨论 3 个问题：fseek()和ftell()函数的工作原理、如何使 用二进制流、如何让程序可移植。\n13.5.1 fseek() 和 ftell() 的工作原理 # fseek()的第 1 个参数是FILE指针，指向待查找的文件，fopen()应该已打 开该文件。 fseek()的第 2 个参数是偏移量（offset）。该参数表示从起始点开始要移 动的距离（参见表13.3列出的起始点模式）。该参数必须是一个long类型的 值，可以为正（前移）、负（后移）或 0 （保持不动）。 fseek()的第 3 个参数是模式，该参数确定起始点。根据ANSI标准，在 stdio.h头文件中规定了几个表示模式的明示常量（manifest constant），如表 13.3所示。 表13.3 文件的起始点模式\n旧的实现可能缺少这些定义，可以使用数值0L、1L、2L分别表示这 3 种 # 模式。L后缀表明其值是long类型。或者，实现可能把这些明示常量定义在 别的头文件中。如果不确定，请查阅实现的使用手册或在线帮助。 下面是调用fseek()函数的一些示例，fp是一个文件指针： fseek(fp, 0L, SEEK_SET); // 定位至文件开始处 fseek(fp, 10L, SEEK_SET); // 定位至文件中的第 10 个字节 fseek(fp, 2L, SEEK_CUR); // 从文件当前位置前移 2 个字节 fseek(fp, 0L, SEEK_END); // 定位至文件结尾 fseek(fp, -10L, SEEK_END); // 从文件结尾处回退 10 个字节 对于这些调用还有一些限制，我们稍后再讨论。 如果一切正常，fseek()的返回值为 0 ；如果出现错误（如试图移动的距 离超出文件的范围），其返回值为-1。 ftell()函数的返回类型是long，它返回的是当前的位置。ANSI C把它定 义在stdio.h中。在最初实现的UNIX中，ftell()通过返回距文件开始处的字节 数来确定文件的位置。文件的第 1 个字节到文件开始处的距离是 0 ，以此类 推。ANSI C规定，该定义适用于以二进制模式打开的文件，以文件模式打 开文件的情况不同。这也是程序清单13.4以二进制模式打开文件的原因。 下面，我们来分析程序清单13.4中的基本要素。首先，下面的语句： fseek(fp, 0L, SEEK_END);\n把当前位置设置为距文件末尾 0 字节偏移量。也就是说，该语句把当前 # 位置设置在文件结尾。下一条语句： # last = ftell(fp); 把从文件开始处到文件结尾的字节数赋给last。 然后是一个for循环： for (count = 1L; count \u0026lt;= last; count++) { fseek(fp, -count, SEEK_END); /* go backward */ ch = getc(fp); } 第 1 轮迭代，把程序定位到文件结尾的第 1 个字符（即，文件的最后一个 字符）。然后，程序打印该字符。下一轮迭代把程序定位到前一个字符，并 打印该字符。重复这一过程直至到达文件的第 1 个字符，并打印。\n13.5.2 二进制模式和文本模式 # 我们设计的程序清单13.4在UNIX和MS-DOS环境下都可以运行。UNIX # 只有一种文件格式，所以不需要进行特殊的转换。然而MS-DOS要格外注 # 意。许多MS-DOS编辑器都用Ctrl+Z标记文本文件的结尾。以文本模式打开 这样的文件时，C 能识别这个作为文件结尾标记的字符。但是，以二进制模 式打开相同的文件时，Ctrl+Z字符被看作是文件中的一个字符，而实际的文 件结尾符在该字符的后面。文件结尾符可能紧跟在Ctrl+Z字符后面，或者文 件中可能用空字符填充，使该文件的大小是 256 的倍数。在DOS环境下不会 打印空字符，程序清单13.4中就包含了防止打印Ctrl+Z字符的代码。 二进制模式和文本模式的另一个不同之处是：MS-DOS用\\r\\n组合表示文\n本文件换行。以文本模式打开相同的文件时，C程序把\\r\\n“看成”\\n。但是， 以二进制模式打开该文件时，程序能看见这两个字符。因此，程序清单13.4 中还包含了不打印\\r的代码。通常，UNIX文本文件既没有Ctrl+Z，也没有 \\r，所以这部分代码不会影响大部分UNIX文本文件。 ftell()函数在文本模式和二进制模式中的工作方式不同。许多系统的文 本文件格式与UNIX的模型有很大不同，导致从文件开始处统计的字节数成 为一个毫无意义的值。ANSI C规定，对于文本模式，ftell()返回的值可以作 为fseek()的第 2 个参数。对于MS-DOS，ftell()返回的值把\\r\\n当作一个字节计 数。\n13.5.3 可移植性 # 理论上，fseek()和ftell()应该符合UNIX模型。但是，不同系统存在着差 异，有时确实无法做到与UNIX模型一致。因此，ANSI对这些函数降低了要 求。下面是一些限制。 在二进制模式中，实现不必支持SEEK_END模式。因此无法保证程序清 单13.4的可移植性。移植性更高的方法是逐字节读取整个文件直到文件末 尾。C 预处理器的条件编译指令（第 16 章介绍）提供了一种系统方法来处 理这种情况。 在文本模式中，只有以下调用能保证其相应的行为。\n不过，许多常见的环境都支持更多的行为。 # 13.5.4 fgetpos() 和 fsetpos() 函数 # fseek()和 ftell()潜在的问题是，它们都把文件大小限制在 long 类型能表 示的范围内。也许 20 亿字节看起来相当大，但是随着存储设备的容量迅猛 增长，文件也越来越大。鉴于此，ANSI C新增了两个处理较大文件的新定 位函数：fgetpos()和 fsetpos()。这两个函数不使用 long 类型的值表示位置， 它们使用一种新类型：fpos_t（代表file position type，文件定位类型）。 fpos_t类型不是基本类型，它根据其他类型来定义。fpos_t 类型的变量或数 据对象可以在文件中指定一个位置，它不能是数组类型，除此之外，没有其 他限制。实现可以提供一个满足特殊平台要求的类型，例如，fpos_t可以实 现为结构。 ANSI C定义了如何使用fpos_t类型。fgetpos()函数的原型如下： int fgetpos(FILE * restrict stream, fpos_t * restrict pos); 调用该函数时，它把fpos_t类型的值放在pos指向的位置上，该值描述了 文件中的一个位置。如果成功，fgetpos()函数返回 0 ；如果失败，返回非 0 。 fsetpos()函数的原型如下： int fsetpos(FILE *stream, const fpos_t *pos); 调用该函数时，使用pos指向位置上的fpos_t类型值来设置文件指针指向 该值指定的位置。如果成功，fsetpos()函数返回 0 ；如果失败，则返回非 0 。 fpos_t类型的值应通过之前调用fgetpos()获得。\n13.6 标准 I/O 的机理 # 我们在前面学习了标准I/O包的特性，本节研究一个典型的概念模型， # 分析标准I/O的工作原理。 # 通常，使用标准I/O的第 1 步是调用fopen()打开文件（前面介绍过，C程 序会自动打开 3 种标准文件）。fopen()函数不仅打开一个文件，还创建了一 个缓冲区（在读写模式下会创建两个缓冲区）以及一个包含文件和缓冲区数 据的结构。另外，fopen()返回一个指向该结构的指针，以便其他函数知道如 何找到该结构。假设把该指针赋给一个指针变量fp，我们说fopen()函数“打 开一个流”。如果以文本模式打开该文件，就获得一个文本流；如果以二进 制模式打开该文件，就获得一个二进制流。 这个结构通常包含一个指定流中当前位置的文件位置指示器。除此之 外，它还包含错误和文件结尾的指示器、一个指向缓冲区开始处的指针、一 个文件标识符和一个计数（统计实际拷贝进缓冲区的字节数）。 我们主要考虑文件输入。通常，使用标准I/O的第 2 步是调用一个定义在 stdio.h中的输入函数，如fscanf()、getc()或 fgets()。一调用这些函数，文件中 的数据块就被拷贝到缓冲区中。缓冲区的大小因实现而异，一般是 512 字节 或是它的倍数，如 4096 或 16384 （随着计算机硬盘容量越来越大，缓冲区的 大小也越来越大）。最初调用函数，除了填充缓冲区外，还要设置fp所指向 的结构中的值。尤其要设置流中的当前位置和拷贝进缓冲区的字节数。通 常，当前位置从字节 0 开始。 在初始化结构和缓冲区后，输入函数按要求从缓冲区中读取数据。在它 读取数据时，文件位置指示器被设置为指向刚读取字符的下一个字符。由于 stdio.h系列的所有输入函数都使用相同的缓冲区，所以调用任何一个函数都 将从上一次函数停止调用的位置开始。 当输入函数发现已读完缓冲区中的所有字符时，会请求把下一个缓冲大 小的数据块从文件拷贝到该缓冲区中。以这种方式，输入函数可以读取文件\n中的所有内容，直到文件结尾。函数在读取缓冲区中的最后一个字符后，把 # 结尾指示器设置为真。于是，下一次被调用的输入函数将返回EOF。 # 输出函数以类似的方式把数据写入缓冲区。当缓冲区被填满时，数据将 # 被拷贝至文件中。 # 13.7 其他标准 I/O 函数 # ANSI标准库的标准I/O系列有几十个函数。虽然在这里无法一一列举， # 但是我们会简要地介绍一些，让读者对它们有一个大概的了解。这里列出函 # 数的原型，表明函数的参数和返回类型。我们要讨论的这些函数，除了 # setvbuf()，其他函数均可在ANSI之前的实现中使用。参考资料V的“新增C99 和C11的标准ANSI C库”中列出了全部的ANSI C标准I/O包。\n13.7.1 int ungetc(int c, FILE *fp) 函数 # int ungetc()函数把c指定的字符放回输入流中。如果把一个字符放回输入 流，下次调用标准输入函数时将读取该字符（见图13.2）。例如，假设要读 取下一个冒号之前的所有字符，但是不包括冒号本身，可以使用 getchar()或 getc()函数读取字符到冒号，然后使用 ungetc()函数把冒号放回输入流中。 ANSI C标准保证每次只会放回一个字符。如果实现允许把一行中的多个字 符放回输入流，那么下一次输入函数读入的字符顺序与放回时的顺序相反。\n图13.2 ungets()函数 13.7.2 int fflush() 函数 # fflush()函数的原型如下： int fflush(FILE *fp); 调用fflush()函数引起输出缓冲区中所有的未写入数据被发送到fp指定的 输出文件。这个过程称为刷新缓冲区。如果 fp是空指针，所有输出缓冲区 都被刷新。在输入流中使用fflush()函数的效果是未定义的。只要最近一次操 作不是输入操作，就可以用该函数来更新流（任何读写模式）。\n13.7.3 int setvbuf() 函数 # setvbuf()函数的原型是： int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size); setvbuf()函数创建了一个供标准I/O函数替换使用的缓冲区。在打开文件 后且未对流进行其他操作之前，调用该函数。指针fp识别待处理的流，buf 指向待使用的存储区。如果buf的值不是NULL，则必须创建一个缓冲区。例 如，声明一个内含 1024 个字符的数组，并传递该数组的地址。然而，如果把 NULL作为buf的值，该函数会为自己分配一个缓冲区。变量size告诉setvbuf() 数组的大小（size_t是一种派生的整数类型，第 5 章介绍过）。mode的选择如 下：_IOFBF表示完全缓冲（在缓冲区满时刷新）；_IOLBF表示行缓冲（在 缓冲区满时或写入一个换行符时）；_IONBF表示无缓冲。如果操作成功， 函数返回 0 ，否则返回一个非零值。 假设一个程序要储存一种数据对象，每个数据对象的大小是 3000 字节。 可以使用setvbuf()函数创建一个缓冲区，其大小是该数据对象大小的倍数。\n13.7.4 二进制 I/O ： fread() 和 fwrite() # 介绍fread()和fwrite()函数之前，先要了解一些背景知识。之前用到的标 准I/O函数都是面向文本的，用于处理字符和字符串。如何要在文件中保存 数值数据？用 fprintf()函数和%f转换说明只是把数值保存为字符串。例如， 下面的代码：\ndouble num = 1./3.; fprintf(fp,\u0026quot;%f\u0026rdquo;, num); 把num储存为 8 个字符：0.333333。使用%.2f转换说明将其储存为 4 个字 符：0.33，用%.12f转换说明则将其储存为 14 个字符：0.333333333333。改 变转换说明将改变储存该值所需的空间数量，也会导致储存不同的值。把 num 储存为 0.33 后，读取文件时就无法将其恢复为更高的精度。一般而 言， fprintf()把数值转换为字符数据，这种转换可能会改变值。 为保证数值在储存前后一致，最精确的做法是使用与计算机相同的位组 合来储存。因此，double 类型的值应该储存在一个 double 大小的单元中。 如果以程序所用的表示法把数据储存在文件中，则称以二进制形式储存数 据。不存在从数值形式到字符串的转换过程。对于标准 I/O，fread()和 fwrite 函数用于以二进制形式处理数据（见图13.3）。 实际上，所有的数据都是以二进制形式储存的，甚至连字符都以字符码 的二进制表示来储存。如果文件中的所有数据都被解释成字符码，则称该文 件包含文本数据。如果部分或所有的数据都被解释成二进制形式的数值数 据，则称该文件包含二进制数据（另外，用数据表示机器语言指令的文件都 是二进制文件）。\n图13.3 二进制输出和文本输出 二进制和文本的用法很容易混淆。ANSI C和许多操作系统都识别两种 文件格式：二进制和文本。能以二进制数据或文本数据形式存储或读取信\n息。可以用二进制模式打开文本格式的文件，可以把文本储存在二进制形式 # 的文件中。可以调用 getc()拷贝包含二进制数据的文件。然而，一般而言， 用二进制模式在二进制格式文件中储存二进制数据。类似地，最常用的还是 以文本格式打开文本文件中的文本数据（通常文字处理器生成的文件都是二 进制文件，因为这些文件中包含了大量非文本信息，如字体和格式等）。\n13.7.5 size_t fwrite() 函数 # fwrite()函数的原型如下： size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb,FILE * restrict fp); fwrite()函数把二进制数据写入文件。size_t是根据标准C类型定义的类 型，它是sizeof运算符返回的类型，通常是unsigned int，但是实现可以选择 使用其他类型。指针ptr是待写入数据块的地址。size表示待写入数据块的大 小（以字节为单位），nmemb表示待写入数据块的数量。和其他函数一样， fp指定待写入的文件。例如，要保存一个大小为 256 字节的数据对象（如数 组），可以这样做： char buffer[256]; fwrite(buffer, 256, 1, fp); 以上调用把一块 256 字节的数据从buffer写入文件。另举一例，要保存一 个内含 10 个double类型值的数组，可以这样做： double earnings[10]; fwrite(earnings, sizeof(double), 10, fp); 以上调用把earnings数组中的数据写入文件，数据被分成 10 块，每块都 是double的大小。\n注意fwrite()原型中的const void * restrict ptr声明。fwrite()的一个问题 是，它的第 1 个参数不是固定的类型。例如，第 1 个例子中使用buffer，其类 型是指向char的指针；而第 2 个例子中使用earnings，其类型是指向double的 指针。在ANSI C函数原型中，这些实际参数都被转换成指向void的指针类 型，这种指针可作为一种通用类型指针（在ANSI C之前，这些参数使用char *类型，需要把实参强制转换成char *类型）。 fwrite()函数返回成功写入项的数量。正常情况下，该返回值就是 nmemb，但如果出现写入错误，返回值会比nmemb小。\n13.7.6 size_t fread() 函数 # size_t fread()函数的原型如下： size_t fread(void * restrict ptr, size_t size, size_t nmemb,FILE * restrict fp); fread()函数接受的参数和fwrite()函数相同。在fread()函数中，ptr是待读 取文件数据在内存中的地址，fp指定待读取的文件。该函数用于读取被 fwrite()写入文件的数据。例如，要恢复上例中保存的内含 10 个double类型值 的数组，可以这样做： double earnings[10]; fread(earnings, sizeof (double), 10, fp); 该调用把 10 个double大小的值拷贝进earnings数组中。 fread()函数返回成功读取项的数量。正常情况下，该返回值就是 nmemb，但如果出现读取错误或读到文件结尾，该返回值就会比nmemb小。\n13.7.7 int feof(FILE *fp) 和 int ferror(FILE *fp) 函数 # 如果标准输入函数返回 EOF，则通常表明函数已到达文件结尾。然 # 而，出现读取错误时，函数也会返回EOF。feof()和ferror()函数用于区分这\n两种情况。当上一次输入调用检测到文件结尾时，feof()函数返回一个非零 值，否则返回 0 。当读或写出现错误，ferror()函数返回一个非零值，否则返 回 0 。\n13.7.8 一个程序示例 # 接下来，我们用一个程序示例说明这些函数的用法。该程序把一系列文 # 件中的内容附加在另一个文件的末尾。该程序存在一个问题：如何给文件传 # 递信息。可以通过交互或使用命令行参数来完成，我们先采用交互式的方 # 法。下面列出了程序的设计方案。 # 询问目标文件的名称并打开它。 # 使用一个循环询问源文件。 # 以读模式依次打开每个源文件，并将其添加到目标文件的末尾。 # 为演示setvbuf()函数的用法，该程序将使用它指定一个不同的缓冲区大 小。下一步是细化程序打开目标文件的步骤： 1.以附加模式打开目标文件； 2.如果打开失败，则退出程序； 3.为该文件创建一个 4096 字节的缓冲区； 4.如果创建失败，则退出程序。 与此类似，通过以下具体步骤细化拷贝部分： 1.如果该文件与目标文件相同，则跳至下一个文件； 2.如果以读模式无法打开文件，则跳至下一个文件； 3.把文件内容添加至目标文件末尾。\n最后，程序回到目标文件的开始处，显示当前整个文件的内容。 # 作为练习，我们使用fread()和fwrite()函数进行拷贝。程序清单13.5给出 了这个程序。 程序清单 13.5 append.c 程序 /* append.c \u0026ndash; 把文件附加到另一个文件末尾 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define BUFSIZE 4096 #define SLEN 81 void append(FILE *source, FILE *dest); char * s_gets(char * st, int n); int main(void) { FILE *fa, *fs; // fa 指向目标文件，fs 指向源文件 int files = 0; // 附加的文件数量 char file_app[SLEN]; // 目标文件名 char file_src[SLEN]; // 源文件名 int ch;\nputs(\u0026ldquo;Enter name of destination file:\u0026rdquo;); s_gets(file_app, SLEN); if ((fa = fopen(file_app, \u0026ldquo;a+\u0026rdquo;)) == NULL) { fprintf(stderr, \u0026ldquo;Can\u0026rsquo;t open %s\\n\u0026rdquo;, file_app); exit(EXIT_FAILURE); } if (setvbuf(fa, NULL, _IOFBF, BUFSIZE) != 0) { fputs(\u0026ldquo;Can\u0026rsquo;t create output buffer\\n\u0026rdquo;, stderr); exit(EXIT_FAILURE); } puts(\u0026ldquo;Enter name of first source file (empty line to quit):\u0026rdquo;); while (s_gets(file_src, SLEN) \u0026amp;\u0026amp; file_src[0] != \u0026lsquo;\\0\u0026rsquo;) { if (strcmp(file_src, file_app) == 0) fputs(\u0026ldquo;Can\u0026rsquo;t append file to itself\\n\u0026rdquo;, stderr); else if ((fs = fopen(file_src, \u0026ldquo;r\u0026rdquo;)) == NULL) fprintf(stderr, \u0026ldquo;Can\u0026rsquo;t open %s\\n\u0026rdquo;, file_src);\nelse { if (setvbuf(fs, NULL, _IOFBF, BUFSIZE) != 0) { fputs(\u0026ldquo;Can\u0026rsquo;t create input buffer\\n\u0026rdquo;, stderr); continue; } append(fs, fa); if (ferror(fs) != 0) fprintf(stderr, \u0026ldquo;Error in reading file %s.\\n\u0026rdquo;, file_src); if (ferror(fa) != 0) fprintf(stderr, \u0026ldquo;Error in writing file %s.\\n\u0026rdquo;, file_app); fclose(fs); files++; printf(\u0026ldquo;File %s appended.\\n\u0026rdquo;, file_src); puts(\u0026ldquo;Next file (empty line to quit):\u0026rdquo;); }\n} # printf(\u0026ldquo;Done appending.%d files appended.\\n\u0026rdquo;, files); rewind(fa); printf(\u0026quot;%s contents:\\n\u0026rdquo;, file_app); while ((ch = getc(fa)) != EOF) putchar(ch); puts(\u0026ldquo;Done displaying.\u0026rdquo;); fclose(fa); return 0; } void append(FILE *source, FILE *dest) { size_t bytes; static char temp[BUFSIZE]; // 只分配一次 while ((bytes = fread(temp, sizeof(char), BUFSIZE, source)) \u0026gt; 0) fwrite(temp, sizeof(char), bytes, dest); } char * s_gets(char * st, int n) {\nchar * ret_val; char * find; ret_val = fgets(st, n, stdin); if (ret_val) { find = strchr(st, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是NULL， *find = \u0026lsquo;\\0\u0026rsquo;; // 在此处放置一个空字符 else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } return ret_val; } 如果setvbuf()无法创建缓冲区，则返回一个非零值，然后终止程序。可 以用类似的代码为正在拷贝的文件创建一块 4096 字节的缓冲区。把NULL作 为setvbuf()的第 2 个参数，便可让函数分配缓冲区的存储空间。 该程序获取文件名所用的函数是 s_gets()，而不是 scanf()，因为 scanf() 会跳过空白，因此无法检测到空行。该程序还用s_gets()代替fgets()，因为后 者在字符串中保留换行符。\n以下代码防止程序把文件附加在自身末尾： # if (strcmp(file_src, file_app) == 0) fputs(\u0026ldquo;Can\u0026rsquo;t append file to itself\\n\u0026rdquo;,stderr); 参数file_app表示目标文件名，file_src表示正在处理的文件名。 append()函数完成拷贝任务。该函数使用fread()和fwrite()一次拷贝 4096 字节，而不是一次拷贝 1 字节： void append(FILE *source, FILE *dest) { size_t bytes; static char temp[BUFSIZE]; // 只分配一次 while ((bytes = fread(temp, sizeof(char), BUFSIZE, source)) \u0026gt; 0) fwrite(temp, sizeof(char), bytes, dest); } 因为是以附加模式打开由 dest 指定的文件，所以所有的源文件都被依 次添加至目标文件的末尾。注意，temp数组具有静态存储期（意思是在编译 时分配该数组，不是在每次调用append()函数时分配）和块作用域（意思是 该数组属于它所在的函数私有）。 该程序示例使用文本模式的文件。使用\u0026quot;ab+\u0026ldquo;和\u0026quot;rb\u0026quot;模式可以处理二进制 文件。\n13.7.9 用二进制 I/O 进行随机访问 # 随机访问是用二进制I/O写入二进制文件最常用的方式，我们来看一个 # 简短的例子。程序清单13.6中的程序创建了一个储存double类型数字的文 件，然后让用户访问这些内容。 程序清单 13.6 randbin.c 程序 /* randbin.c \u0026ndash; 用二进制I/O进行随机访问 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define ARSIZE 1000 int main() { double numbers[ARSIZE]; double value; const char * file = \u0026ldquo;numbers.dat\u0026rdquo;; int i; long pos; FILE *iofile; // 创建一组 double类型的值 for (i = 0; i \u0026lt; ARSIZE; i++) numbers[i] = 100.0 * i + 1.0 / (i + 1); // 尝试打开文件\nif ((iofile = fopen(file, \u0026ldquo;wb\u0026rdquo;)) == NULL) { fprintf(stderr, \u0026ldquo;Could not open %s for output.\\n\u0026rdquo;, file); exit(EXIT_FAILURE); } // 以二进制格式把数组写入文件 fwrite(numbers, sizeof(double), ARSIZE, iofile); fclose(iofile); if ((iofile = fopen(file, \u0026ldquo;rb\u0026rdquo;)) == NULL) { fprintf(stderr, \u0026ldquo;Could not open %s for random access.\\n\u0026rdquo;, file); exit(EXIT_FAILURE); } // 从文件中读取选定的内容 printf(\u0026ldquo;Enter an index in the range 0-%d.\\n\u0026rdquo;, ARSIZE - 1); while (scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;i) == 1 \u0026amp;\u0026amp; i \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; ARSIZE) { pos = (long) i * sizeof(double); // 计算偏移量\nfseek(iofile, pos, SEEK_SET); // 定位到此处 fread(\u0026amp;value, sizeof(double), 1, iofile); printf(\u0026ldquo;The value there is %f.\\n\u0026rdquo;, value); printf(\u0026ldquo;Next index (out of range to quit):\\n\u0026rdquo;); } // 完成 fclose(iofile); puts(\u0026ldquo;Bye!\u0026rdquo;); return 0; } 首先，该程序创建了一个数组，并在该数组中存放了一些值。然后，程 序以二进制模式创建了一个名为numbers.dat的文件，并使用fwrite()把数组中 的内容拷贝到文件中。内存中数组的所有double类型值的位组合（每个位组 合都是 64 位）都被拷贝至文件中。不能用文本编辑器读取最后的二进制文 件，因为无法把文件中的值转换成字符串。然而，储存在文件中的每个值都 与储存在内存中的值完全相同，没有损失任何精确度。此外，每个值在文件 中也同样占用 64 位存储空间，所以可以很容易地计算出每个值的位置。 程序的第 2 部分用于打开待读取的文件，提示用户输入一个值的索引。 程序通过把索引值和 double类型值占用的字节相乘，即可得出文件中的一个 位置。然后，程序调用fseek()定位到该位置，用fread()读取该位置上的数据 值。注意，这里并未使用转换说明。fread()从已定位的位置开始，拷贝 8 字 节到内存中地址为\u0026amp;value的位置。然后，使用printf()显示value。下面是该程 序的一个运行示例：\nEnter an index in the range 0-999. 500 The value there is 50000.001996. Next index (out of range to quit): 900 The value there is 90000.001110. Next index (out of range to quit): 0 The value there is 1.000000. Next index (out of range to quit): -1 Bye!\n13.8 关键概念 # C程序把输入看作是字节流，输入流来源于文件、输入设备（如键 # 盘），或者甚至是另一个程序的输出。类似地，C程序把输出也看作是字节 # 流，输出流的目的地可以是文件、视频显示等。 # C 如何解释输入流或输出流取决于所使用的输入/输出函数。程序可以 # 不做任何改动地读取和存储字节，或者把字节依次解释成字符，随后可以把 # 这些字符解释成普通文本以用文本表示数字。类似地，对于输出，所使用的 # 函数决定了二进制值是被原样转移，还是被转换成文本或以文本表示数字。 # 如果要在不损失精度的前提下保存或恢复数值数据，请使用二进制模式以及 # fread()和fwrite()函数。如果打算保存文本信息并创建能在普通文本编辑器查 看的文本，请使用文本模式和函数（如getc()和fprintf()）。 要访问文件，必须创建文件指针（类型是FILE *）并把指针与特定文件 名相关联。随后的代码就可以使用这个指针（而不是文件名）来处理该文 件。 要重点理解C如何处理文件结尾。通常，用于读取文件的程序使用一个 循环读取输入，直至到达文件结尾。C 输入函数在读过文件结尾后才会检测 到文件结尾，这意味着应该在尝试读取之后立即判断是否是文件结尾。可以 使用13.2.4节中“设计范例”中的双文件输入模式。\n13.9 本章小结 # 对于大多数C程序而言，写入文件和读取文件必不可少。为此，绝大对 # 数C实现都提供底层I/O和标准高级I/O。因为ANSI C库考虑到可移植性，包 # 含了标准I/O包，但是未提供底层I/O。 # 标准 I/O 包自动创建输入和输出缓冲区以加快数据传输。fopen()函数为 标准 I/O 打开一个文件，并创建一个用于存储文件和缓冲区信息的结构。 fopen()函数返回指向该结构的指针，其他函数可以使用该指针指定待处理的 文件。feof()和ferror()函数报告I/O操作失败的原因。 C把输入视为字节流。如果使用fread()函数，C把输入看作是二进制值 并将其储存在指定存储位置。如果使用fscanf()、getc()、fgets()或其他相关函 数，C则将每个字节看作是字符码。然后fscanf()和scanf()函数尝试把字符码 翻译成转换说明指定的其他类型。例如，输入一个值 23 ，%f转换说明会把 23 翻译成一个浮点值，%d转换说明会把 23 翻译成一个整数值，%s转换说明 则会把 23 储存为字符串。getc()和 fgetc()系列函数把输入作为字符码储存， 将其作为单独的字符保存在字符变量中或作为字符串储存在字符数组中。类 似地，fwrite()将二进制数据直接放入输出流，而其他输出函数把非字符数 据转换成用字符表示后才将其放入输出流。 ANSI C提供两种文件打开模式：二进制和文本。以二进制模式打开文 件时，可以逐字节读取文件；以文本模式打开文件时，会把文件内容从文本 的系统表示法映射为C表示法。对于UNIX和Linux系统，这两种模式完全相 同。 通常，输入函数getc()、fgets()、fscanf()和fread()都从文件开始处按顺序 读取文件。然而， fseek()和ftell()函数让程序可以随机访问文件中的任意位 置。fgetpos()和fsetpos()把类似的功能扩展至更大的文件。与文本模式相 比，二进制模式更容易进行随机访问。\n13.10 复习题 # 复习题的参考答案在附录A中。 # 1.下面的程序有什么问题？ # int main(void) { int * fp; int k; fp = fopen(\u0026ldquo;gelatin\u0026rdquo;); for (k = 0; k \u0026lt; 30; k++) fputs(fp, \u0026ldquo;Nanette eats gelatin.\u0026rdquo;); fclose(\u0026ldquo;gelatin\u0026rdquo;); return 0; } 2.下面的程序完成什么任务？（假设在命令行环境中运行） #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; int main(int argc, char *argv []) {\nint ch; FILE fp; if (argc \u0026lt; 2) exit(EXIT_FAILURE); if ((fp = fopen(argv[1], \u0026ldquo;r\u0026rdquo;)) == NULL) exit(EXIT_FAILURE); while ((ch = getc(fp)) != EOF) if (isdigit(ch)) putchar(ch); fclose(fp); return 0; } 3.假设程序中有下列语句： #include \u0026lt;stdio.h\u0026gt; FILE * fp1, fp2; char ch; fp1 = fopen(\u0026ldquo;terky\u0026rdquo;, \u0026ldquo;r\u0026rdquo;); fp2 = fopen(\u0026ldquo;jerky\u0026rdquo;, \u0026ldquo;w\u0026rdquo;); 另外，假设成功打开了两个文件。补全下面函数调用中缺少的参数：\na.ch = getc(); b.fprintf( ,\u0026quot;%c\\n\u0026rdquo;, ); c.putc( , ); d.fclose(); /* 关闭terky文件 */ 4.编写一个程序，不接受任何命令行参数或接受一个命令行参数。如果 有一个参数，将其解释为文件名；如果没有参数，使用标准输入（stdin）作 为输入。假设输入完全是浮点数。该程序要计算和报告输入数字的算术平均 值。 5.编写一个程序，接受两个命令行参数。第 1 个参数是字符，第 2 个参数 是文件名。要求该程序只打印文件中包含给定字符的那些行。 注意 C程序根据\u0026rsquo;\\n\u0026rsquo;识别文件中的行。假设所有行都不超过 256 个字符，你可 能会想到用fgets()。 6.二进制文件和文本文件有何区别？二进制流和文本流有何区别？ 7. a.分别用fprintf()和fwrite()储存 8238201 有何区别？ b.分别用putc()和fwrite()储存字符S有何区别？ 8.下面语句的区别是什么？ printf(\u0026ldquo;Hello, %s\\n\u0026rdquo;, name); fprintf(stdout, \u0026ldquo;Hello, %s\\n\u0026rdquo;, name); fprintf(stderr, \u0026ldquo;Hello, %s\\n\u0026rdquo;, name);\n9.\u0026ldquo;a+\u0026quot;、\u0026ldquo;r+\u0026ldquo;和\u0026quot;w+\u0026ldquo;模式打开的文件都是可读写的。哪种模式更适合用 来更改文件中已有的内容？\n13.11 编程练习 # 1.修改程序清单13.1中的程序，要求提示用户输入文件名，并读取用户 # 输入的信息，不使用命令行参数。 # 2.编写一个文件拷贝程序，该程序通过命令行获取原始文件名和拷贝文 # 件名。尽量使用标准I/O和二进制模式。 # 3.编写一个文件拷贝程序，提示用户输入文本文件名，并以该文件名作 # 为原始文件名和输出文件名。该程序要使用 ctype.h 中的 toupper()函数，在 写入到输出文件时把所有文本转换成大写。使用标准I/O和文本模式。 4.编写一个程序，按顺序在屏幕上显示命令行中列出的所有文件。使用 argc控制循环。 5.修改程序清单13.5中的程序，用命令行界面代替交互式界面。 6.使用命令行参数的程序依赖于用户的内存如何正确地使用它们。重写 程序清单 13.2 中的程序，不使用命令行参数，而是提示用户输入所需信 息。 7.编写一个程序打开两个文件。可以使用命令行参数或提示用户输入文 件名。 a.该程序以这样的顺序打印：打印第 1 个文件的第 1 行，第 2 个文件的第 1 行，第 1 个文件的第 2 行，第 2 个文件的第 2 行，以此类推，打印到行数较多文 件的最后一行。 b.修改该程序，把行号相同的行打印成一行。 8.编写一个程序，以一个字符和任意文件名作为命令行参数。如果字符 后面没有参数，该程序读取标准输入；否则，程序依次打开每个文件并报告 每个文件中该字符出现的次数。文件名和字符本身也要一同报告。程序应包 含错误检查，以确定参数数量是否正确和是否能打开文件。如果无法打开文\n件，程序应报告这一情况，然后继续处理下一个文件。 # 9.修改程序清单 13.3 中的程序，从 1 开始，根据加入列表的顺序为每个 # 单词编号。当程序下次运行时，确保新的单词编号接着上次的编号开始。 # 10.编写一个程序打开一个文本文件，通过交互方式获得文件名。通过 # 一个循环，提示用户输入一个文件位置。然后该程序打印从该位置开始到下 # 一个换行符之前的内容。用户输入负数或非数值字符可以结束输入循环。 # 11.编写一个程序，接受两个命令行参数。第 1 个参数是一个字符串，第 # 2 个参数是一个文件名。然后该程序查找该文件，打印文件中包含该字符串 # 的所有行。因为该任务是面向行而不是面向字符的，所以要使用fgets()而不 是getc()。使用标准C库函数strstr()（11.5.7节简要介绍过）在每一行中查找 指定字符串。假设文件中的所有行都不超过 255 个字符。 12.创建一个文本文件，内含 20 行，每行 30 个整数。这些整数都在 0 ～ 9 之间，用空格分开。该文件是用数字表示一张图片， 0 ～ 9 表示逐渐增加的灰 度。编写一个程序，把文件中的内容读入一个20×30的int数组中。一种把这 些数字转换为图片的粗略方法是：该程序使用数组中的值初始化一个20×31 的字符数组，用值 0 对应空格字符， 1 对应点字符，以此类推。数字越大表 示字符所占的空间越大。例如，用#表示 9 。每行的最后一个字符（第 31 个） 是空字符，这样该数组包含了 20 个字符串。最后，程序显示最终的图片 （即，打印所有的字符串），并将结果储存在文本文件中。例如，下面是开 始的数据： 0 0 9 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 0 0 0 0 0 0 0 5 8 9 9 8 5 5 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 8 1 9 8 5 4 5 2 0 0 0 0 0 0 0 0 0 0 0 0 0 9 0 0 0 0 0 0 0 5 8 9 9 8 5 0 4 5 2 0 0 0 0 0 0 0 0 0 0 9 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 4 5 2 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 1 8 5 0 0 0 4 5 2 0 0 0 0 0 0 # 0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 4 5 2 0 0 0 0 0 # 5 5 5 5 5 5 5 5 5 5 5 5 5 8 9 9 8 5 5 5 5 5 5 5 5 5 5 5 5 5 # 8 8 8 8 8 8 8 8 8 8 8 8 5 8 9 9 8 5 8 8 8 8 8 8 8 8 8 8 8 8 # 9 9 9 9 0 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 3 9 9 9 9 9 9 9 # 8 8 8 8 8 8 8 8 8 8 8 8 5 8 9 9 8 5 8 8 8 8 8 8 8 8 8 8 8 8 # 5 5 5 5 5 5 5 5 5 5 5 5 5 8 9 9 8 5 5 5 5 5 5 5 5 5 5 5 5 5 # 0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 0 0 0 0 0 0 0 0 # 0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 6 6 0 0 0 0 0 0 # 0 0 0 0 2 2 0 0 0 0 0 0 5 8 9 9 8 5 0 0 5 6 0 0 6 5 0 0 0 0 # 0 0 0 0 3 3 0 0 0 0 0 0 5 8 9 9 8 5 0 5 6 1 1 1 1 6 5 0 0 0 # 0 0 0 0 4 4 0 0 0 0 0 0 5 8 9 9 8 5 0 0 5 6 0 0 6 5 0 0 0 0 # 0 0 0 0 5 5 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 6 6 0 0 0 0 0 0 # 0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 0 0 0 0 0 0 0 0 # 0 0 0 0 0 0 0 0 0 0 0 0 5 8 9 9 8 5 0 0 0 0 0 0 0 0 0 0 0 0 # 根据以上描述选择特定的输出字符，最终输出如下： # 13.用变长数组（VLA）代替标准数组，完成编程练习 12 。 # 14.数字图像，尤其是从宇宙飞船发回的数字图像，可能会包含一些失 # 真。为编程练习 12 添加消除失真的函数。该函数把每个值与它上下左右相邻 # 的值作比较，如果该值与其周围相邻值的差都大于 1 ，则用所有相邻值的平 # 均值（四舍五入为整数）代替该值。注意，与边界上的点相邻的点少于 4 # 个，所以做特殊处理。 # [1].后者指该字符串的字符个数。注意，字符串大小和字符串长度不同。前者指该字符串占用多少空间，——译者注 # 第 14 章 结构和其他数据形式 # 本章介绍以下内容： # 关键字：struct、union、typedef 运算符：.、-\u0026gt; 什么是C结构，如何创建结构模板和结构变量 如何访问结构的成员，如何编写处理结构的函数 联合和指向函数的指针 设计程序时，最重要的步骤之一是选择表示数据的方法。在许多情况 下，简单变量甚至是数组还不够。为此，C提供了结构变量（structure variable）提高你表示数据的能力，它能让你创造新的形式。如果熟悉Pascal 的记录（record），应该很容易理解结构。如果不懂Pascal也没关系，本章 将详细介绍C结构。我们先通过一个示例来分析为何需要C结构，学习如何 创建和使用结构。\n14.1 示例问题：创建图书目录 # Gwen Glenn要打印一份图书目录。她想打印每本书的各种信息：书名、 作者、出版社、版权日期、页数、册数和价格。其中的一些项目（如，书 名)可以储存在字符数组中，其他项目需要一个int数组或float数组。用 7 个 不同的数组分别记录每一项比较繁琐，尤其是 Gwen 还想创建多份列表：一 份按书名排序、一份按作者排序、一份按价格排序等。如果能把图书目录的 信息都包含在一个数组里更好，其中每个元素包含一本书的相关信息。 因此，Gwen需要一种即能包含字符串又能包含数字的数据形式，而且 还要保持各信息的独立。C结构就满足这种情况下的需求。我们通过一个示 例演示如何创建和使用数组。但是，示例进行了一些限制。第一，该程序示 例演示的书目只包含书名、作者和价格。第二，只有一本书的数目。当然， 别忘了这只是进行了限制，我们在后面将扩展该程序。请看程序清单14.1及 其输出，然后阅读后面的一些要点。 程序清单 14.1 book.c 程序 //* book.c \u0026ndash; 一本书的图书目录 / #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; char * s_gets(char * st, int n); #define MAXTITL 41 / 书名的最大长度 + 1 / #define MAXAUTL 31 / 作者姓名的最大长度 + 1*/ struct book { /* 结构模版：标记是 book */ char title[MAXTITL];\nchar author[MAXAUTL]; float value; }; /* 结构模版结束　/ int main(void) { struct book library; / 把 library 声明为一个 book 类型的变量 / printf(\u0026ldquo;Please enter the book title.\\n\u0026rdquo;); s_gets(library.title, MAXTITL); / 访问title部分*/ printf(\u0026ldquo;Now enter the author.\\n\u0026rdquo;); s_gets(library.author, MAXAUTL); printf(\u0026ldquo;Now enter the value.\\n\u0026rdquo;); scanf(\u0026quot;%f\u0026rdquo;, \u0026amp;library.value); printf(\u0026quot;%s by %s: $%.2f\\n\u0026rdquo;, library.title, library.author, library.value); printf(\u0026quot;%s: \u0026quot;%s\u0026quot; ($%.2f)\\n\u0026rdquo;, library.author, library.title, library.value); printf(\u0026ldquo;Done.\\n\u0026rdquo;); return 0; }\nchar * s_gets(char * st, int n) { char * ret_val; char * find; ret_val = fgets(st, n, stdin); if (ret_val) { find = strchr(st, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是 NULL, *find = \u0026lsquo;\\0\u0026rsquo;; // 在此处放置一个空字符 else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; //处理输入行中剩余的字符 } return ret_val; } 我们使用前面章节中介绍的s_gets()函数去掉fgets()储存在字符串中的换 行符。下面是该例的一个运行示例： Please enter the book title.\nChicken of the Andes Now enter the author. Disma Lapoult Now enter the value. 29.99 Chicken of the Andes by Disma Lapoult: $29.99 Disma Lapoult: \u0026ldquo;Chicken of the Andes\u0026rdquo; ($29.99) Done. 程序清单14.1中创建的结构有 3 部分，每个部分都称为成员（member） 或字段（field）。这 3 部分中，一部分储存书名，一部分储存作者名，一部 分储存价格。下面是必须掌握的 3 个技巧： 为结构建立一个格式或样式； 声明一个适合该样式的变量； 访问结构变量的各个部分。\n14.2 建立结构声明 # 结构声明（structure declaration）描述了一个结构的组织布局。声明类 似下面这样： struct book { char title[MAXTITL]; char author[MAXAUTL]; float value; }; 该声明描述了一个由两个字符数组和一个float类型变量组成的结构。该 声明并未创建实际的数据对象，只描述了该对象由什么组成。〔有时，我们 把结构声明称为模板，因为它勾勒出结构是如何储存数据的。如果读者知道 C++的模板，此模板非彼模板，C++中的模板更为强大。〕我们来分析一些 细节。首先是关键字 struct，它表明跟在其后的是一个结构，后面是一个可 选的标记（该例中是 book），稍后程序中可以使用该标记引用该结构。所 以，我们在后面的程序中可以这样声明： struct book library; 这把library声明为一个使用book结构布局的结构变量。 在结构声明中，用一对花括号括起来的是结构成员列表。每个成员都用 自己的声明来描述。例如，title部分是一个内含MAXTITL个元素的char类型 数组。成员可以是任意一种C的数据类型，甚至可以是其他结构！右花括号 后面的分号是声明所必需的，表示结构布局定义结束。可以把这个声明放在 所有函数的外部（如本例所示），也可以放在一个函数定义的内部。如果把 结构声明置于一个函数的内部，它的标记就只限于该函数内部使用。如果把 结构声明置于函数的外部，那么该声明之后的所有函数都能使用它的标记。\n例如，在程序的另一个函数中，可以这样声明： # struct book dickens; 这样，该函数便创建了一个结构变量dickens，该变量的结构布局是 book。 结构的标记名是可选的。但是以程序示例中的方式建立结构时（在一处 定义结构布局，在另一处定义实际的结构变量），必须使用标记。我们学完 如何定义结构变量后，再来看这一点。\n14.3 定义结构变量 # 结构有两层含义。一层含义是“结构布局”，刚才已经讨论过了。结构布 # 局告诉编译器如何表示数据，但是它并未让编译器为数据分配空间。下一步 # 是创建一个结构变量，即是结构的另一层含义。程序中创建结构变量的一行 # 是: # struct book library; 编译器执行这行代码便创建了一个结构变量library。编译器使用book模 板为该变量分配空间：一个内含MAXTITL个元素的char数组、一个内含 MAXAUTL个元素的char数组和一个float类型的变量。这些存储空间都与一 个名称library结合在一起（见图14.1）。 在结构变量的声明中，struct book所起的作用相当于一般声明中的int或 float。例如，可以定义两个struct book类型的变量，或者甚至是指向struct book类型结构的指针： struct book doyle, panshin, * ptbook;\n图14.1 一个结构的内存分配 结构变量doyle和panshin中都包含title、author和value部分。指针ptbook 可以指向doyle、panshin或任何其他book类型的结构变量。从本质上看， book结构声明创建了一个名为struct book的新类型。 就计算机而言，下面的声明： struct book library; 是以下声明的简化： struct book { char title[MAXTITL]; char author[AXAUTL]; float value; } library; /* 声明的右右花括号后跟变量名*/ 换言之，声明结构的过程和定义结构变量的过程可以组合成一个步骤。 如下所示，组合后的结构声明和结构变量定义不需要使用结构标记： struct { /* 无结构标记 */ char title[MAXTITL]; char author[MAXAUTL]; float value; } library; 然而，如果打算多次使用结构模板，就要使用带标记的形式；或者，使 用本章后面介绍的typedef。 这是定义结构变量的一个方面，在这个例子中，并未初始化结构变量。\n14.3.1 初始化结构 # 初始化变量和数组如下： # int count = 0; int fibo[7] = {0,1,1,2,3,5,8}; 结构变量是否也可以这样初始化？是的，可以。初始化一个结构变量 （ANSI之前，不能用自动变量初始化结构；ANSI之后可以用任意存储类 别）与初始化数组的语法类似： struct book library = { \u0026ldquo;The Pious Pirate and the Devious Damsel\u0026rdquo;, \u0026ldquo;Renee Vivotte\u0026rdquo;, 1.95 }; 简而言之，我们使用在一对花括号中括起来的初始化列表进行初始化， 各初始化项用逗号分隔。因此， title成员可以被初始化为一个字符串，value 成员可以被初始化为一个数字。为了让初始化项与结构中各成员的关联更加 明显，我们让每个成员的初始化项独占一行。这样做只是为了提高代码的可 读性，对编译器而言，只需要用逗号分隔各成员的初始化项即可。 注意 初始化结构和类别储存期 第 12 章中提到过，如果初始化静态存储期的变量（如，静态外部链接、 静态内部链接或静态无链接），必须使用常量值。这同样适用于结构。如果 初始化一个静态存储期的结构，初始化列表中的值必须是常量表达式。如果 是自动存储期，初始化列表中的值可以不是常量。\n14.3.2 访问结构成员 # 结构类似于一个“超级数组”，这个超级数组中，可以是一个元素为char 类型，下一个元素为forat类型，下一个元素为int数组。可以通过数组下标单 独访问数组中的各元素，那么，如何访问结构中的成员？使用结构成员运算 符——点（.）访问结构中的成员。例如，library.value即访问library的value 部分。可以像使用任何float类型变量那样使用library.value。与此类似，可以 像使用字符数组那样使用 library.title。因此，程序清单 14.1 中的程序中有 s_gets(library.title, MAXTITL);和scanf(\u0026quot;%f\u0026rdquo;, \u0026amp;library.value);这样的代码。 本质上，.title、.author和.value的作用相当于book结构的下标。 注意，虽然library是一个结构，但是library.value是一个float类型的变 量，可以像使用其他 float 类型变量那样使用它。例如，scanf(\u0026quot;%f\u0026rdquo;,\u0026hellip;)需要一 个 float 类型变量的地址，而\u0026amp;library.float正好符合要求。.比\u0026amp;的优先级高， 因此这个表达式和\u0026amp;(library.float)一样。 如果还有一个相同类型的结构变量，可以用相同的方法： struct book bill, newt; s_gets(bill.title, MAXTITL); s_gets(newt.title, MAXTITL); .title 引用 book 结构的第 1 个成员。注意，程序清单 14.1 中的程序以两 种不同的格式打印了library结构变量中的内容。这说明可以自行决定如何使 用结构成员。\n14.3.3 结构的初始化器 # C99和C11为结构提供了指定初始化器（designated initializer）[1]，其语 法与数组的指定初始化器类似。但是，结构的指定初始化器使用点运算符和 成员名（而不是方括号和下标）标识特定的元素。例如，只初始化book结构\n的value成员，可以这样做： struct book surprise = { .value = 10.99}; 可以按照任意顺序使用指定初始化器： struct book gift = { .value = 25.99, .author = \u0026ldquo;James Broadfool\u0026rdquo;, .title = \u0026ldquo;Rue for the Toad\u0026rdquo;}; 与数组类似，在指定初始化器后面的普通初始化器，为指定成员后面的 成员提供初始值。另外，对特定成员的最后一次赋值才是它实际获得的值。 例如，考虑下面的代码： struct book gift= {.value = 18.90, .author = \u0026ldquo;Philionna Pestle\u0026rdquo;, 0.25}; 赋给value的值是0.25，因为它在结构声明中紧跟在author成员之后。新 值0.25取代了之前的18.9。在学习了结构的基本知识后，可以进一步了解结 构的一些相关类型。\n14.4 结构数组 # 接下来，我们要把程序清单14.1的程序扩展成可以处理多本书。显然， # 每本书的基本信息都可以用一个 book 类型的结构变量来表示。为描述两本 书，需要使用两个变量，以此类推。可以使用这一类型的结构数组来处理多 本书。在下一个程序中（程序清单 14.2）就创建了一个这样的数组。如果你 使用 Borland C/C++，请参阅本节后面的“Borland C和浮点数”。 结构和内存 manybook.c程序创建了一个内含 100 个结构变量的数组。由于该数组是 自动存储类别的对象，其中的信息被储存在栈（stack）中。如此大的数组需 要很大一块内存，这可能会导致一些问题。如果在运行时出现错误，可能抱 怨栈大小或栈溢出，你的编译器可能使用了一个默认大小的栈，这个栈对于 该例而言太小。要修正这个问题，可以使用编译器选项设置栈大小为 10000 ，以容纳这个结构数组；或者可以创建静态或外部数组（这样，编译 器就不会把数组放在栈中）；或者可以减小数组大小为 16 。为何不一开始就 使用较小的数组？这是为了让读者意识到栈大小的潜在问题，以便今后再遇 到类似的问题，可以自己处理好。 程序清单 14.2 manybook.c 程序 /* manybook.c \u0026ndash; 包含多本书的图书目录 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; char * s_gets(char * st, int n); #define MAXTITL 40 #define MAXAUTL 40\n#define MAXBKS 100　/* 书籍的最大数量 / struct book { / 简历 book 模板　/ char title[MAXTITL]; char author[MAXAUTL]; float value; }; int main(void) { struct book library[MAXBKS]; / book 类型结构的数组 */ int count = 0; int index; printf(\u0026ldquo;Please enter the book title.\\n\u0026rdquo;); printf(\u0026ldquo;Press [enter] at the start of a line to stop.\\n\u0026rdquo;); while (count \u0026lt; MAXBKS \u0026amp;\u0026amp; s_gets(library[count].title, MAXTITL) != NULL \u0026amp;\u0026amp; library[count].title[0] != \u0026lsquo;\\0\u0026rsquo;) { printf(\u0026ldquo;Now enter the author.\\n\u0026rdquo;); s_gets(library[count].author, MAXAUTL);\nprintf(\u0026ldquo;Now enter the value.\\n\u0026rdquo;); scanf(\u0026quot;%f\u0026rdquo;, \u0026amp;library[count++].value); while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; /* 清理输入行*/ if (count \u0026lt; MAXBKS) printf(\u0026ldquo;Enter the next title.\\n\u0026rdquo;); } if (count \u0026gt; 0) { printf(\u0026ldquo;Here is the list of your books:\\n\u0026rdquo;); for (index = 0; index \u0026lt; count; index++) printf(\u0026quot;%s by %s: $%.2f\\n\u0026quot;, library[index].title, library[index].author, library[index].value); } else printf(\u0026ldquo;No books? Too bad.\\n\u0026rdquo;); return 0; } char * s_gets(char * st, int n)\n{ # char * ret_val; char * find; ret_val = fgets(st, n, stdin); if (ret_val) { find = strchr(st, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是 NULL， *find = \u0026lsquo;\\0\u0026rsquo;; // 在此处放置一个空字符 else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; // 处理输入行中剩余的字符 } return ret_val; } 下面是该程序的一个输出示例： Please enter the book title. Press [enter] at the start of a line to stop. My Life as a Budgie\nNow enter the author. Mack Zackles Now enter the value. 12.95 Enter the next title. \u0026hellip;（此处省略了许多内容）\u0026hellip; Here is the list of your books: My Life as a Budgie by Mack Zackles: $12.95 Thought and Unthought Rethought by Kindra Schlagmeyer: $43.50 Concerto for Financial Instruments by Filmore Walletz: $49.99 The CEO Power Diet by Buster Downsize: $19.25 C++ Primer Plus by Stephen Prata: $59.99 Fact Avoidance: Perception as Reality by Polly Bull: $19.97 Coping with Coping by Dr.Rubin Thonkwacker: $0.02 Diaphanous Frivolity by Neda McFey: $29.99 Murder Wore a Bikini by Mickey Splats: $18.95 A History of Buvania, Volume 8, by Prince Nikoli Buvan: $50.04 Mastering Your Digital Watch, 5nd Edition, by Miklos Mysz: $28.95 A Foregone Confusion by Phalty Reasoner: $5.99\nOutsourcing Government: Selection vs.Election by Ima Pundit: $33.33 Borland C 和浮点数 如果程序不使用浮点数，旧式的Borland C编译器会尝试使用小版本的 scanf()来压缩程序。然而，如果在一个结构数组中只有一个浮点值（如程序 清单14.2中那样），那么这种编译器（DOS的Borland C/C++ 3.1之前的版 本，不是Borland C/C++ 4.0）就无法发现它存在。结果，编译器会生成如下 消息： scanf : floating point formats not linked Abnormal program termination 一种解决方案是，在程序中添加下面的代码： #include \u0026lt;math.h\u0026gt; double dummy = sin(0.0); 这段代码强制编译器载入浮点版本的scanf()。 首先，我们学习如何声明结构数组和如何访问数组中的结构成员。然 后，着重分析该程序的两个方面。\n14.4.1 声明结构数组 # 声明结构数组和声明其他类型的数组类似。下面是一个声明结构数组的 # 例子： # struct book library[MAXBKS]; 以上代码把library声明为一个内含MAXBKS个元素的数组。数组的每个 元素都是一个book类型的数组。因此，library[0]是第 1 个book类型的结构变 量，library[1]是第 2 个book类型的结构变量，以此类推。参看图14.2 可以帮\n助读者理解。数组名library本身不是结构名，它是一个数组名，该数组中的 每个元素都是struct book类型的结构变量。\n图14.2 一个结构数组library[MAXBKS] 14.4.2 标识结构数组的成员 # 为了标识结构数组中的成员，可以采用访问单独结构的规则：在结构名 # 后面加一个点运算符，再在点运算符后面写上成员名。如下所示： # library[0].value /* 第 1 个数组元素与value 相关联 */ library[4].title /* 第 5 个数组元素与title 相关联 */ 注意，数组下标紧跟在library后面，不是成员名后面： library.value[2] // 错误 library[2].value // 正确 使用library[2].value的原因是：library[2]是结构变量名，正如library[1] 是另一个变量名。 顺带一提，下面的表达式代表什么？ library[2].title[4] 这是library数组第 3 个结构变量（library[2]部分）中书名的第 5 个字符 （title[4]部分）。以程序清单14.2的输出为例，这个字符是e。该例指出，点 运算符右侧的下标作用于各个成员，点运算符左侧的下标作用与结构数组。 最后，总结一下： library // 一个book 结构的数组 library[2] // 一个数组元素，该元素是book结构 library[2].title // 一个char数组（library[2]的title成员） library[2].title[4] // 数组中library[2]元素的title 成员的一个字符 下面，我们来讨论一下这个程序。\n14.4.3 程序讨论 # 较之程序清单14.1，该程序主要的改动之处是：插入一个while循环读取 多个项。该循环的条件测试是： while (count \u0026lt; MAXBKS \u0026amp;\u0026amp; s_gets(library[count].title, MAXTITL) != NULL \u0026amp;\u0026amp; library[count].title[0] != \u0026lsquo;\\0\u0026rsquo;) 表达式 s_gets(library[count].title, MAXTITL)读取一个字符串作为书名， 如果 s_gets()尝试读到文件结尾后面，该表达式则返回NULL。表达式 library[count].title[0] != \u0026lsquo;\\0\u0026rsquo;判断字符串中的首字符是否是空字符（即，该字符\n串是否是空字符串）。如果在一行开始处用户按下 Enter 键，相当于输入了 一个空字符串，循环将结束。程序中还检查了图书的数量，以免超出数组的 大小。 然后，该程序中有如下几行： while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; /* 清理输入行 */ 前面章节介绍过，这段代码弥补了scanf()函数遇到空格和换行符就结束 读取的问题。当用户输入书的价格时，可能输入如下信息： 12.50[Enter] 其传送的字符序列如下： 12.50\\n scanf()函数接受 1 、 2 、.、 5 和 0 ，但是把\\n留在输入序列中。如果没有上 面两行清理输入行的代码，就会把留在输入序列中的换行符当作空行读入， 程序以为用户发送了停止输入的信号。我们插入的这两行代码只会在输入序 列中查找并删除\\n，不会处理其他字符。这样s_gets()就可以重新开始下一次 输入。\n14.5 嵌套结构 # 有时，在一个结构中包含另一个结构（即嵌套结构）很方便。例如， # Shalala Pirosky创建了一个有关她朋友信息的结构。显然，结构中需要一个 成员表示朋友的姓名。然而，名字可以用一个数组来表示，其中包含名和姓 这两个成员。程序清单14.3是一个简单的示例。 程序清单 14.3 friend.c 程序 // friend.c \u0026ndash; 嵌套结构示例 #include \u0026lt;stdio.h\u0026gt; #define LEN 20 const char * msgs[5] = { \u0026quot; Thank you for the wonderful evening, \u0026ldquo;, \u0026ldquo;You certainly prove that a \u0026ldquo;, \u0026ldquo;is a special kind of guy.We must get together\u0026rdquo;, \u0026ldquo;over a delicious \u0026ldquo;, \u0026quot; and have a few laughs\u0026rdquo; }; struct names { // 第 1 个结构 char first[LEN]; char last[LEN];\n}; # struct guy { // 第 2 个结构 struct names handle; // 嵌套结构 char favfood[LEN]; char job[LEN]; float income; }; int main(void) { struct guy fellow = { // 初始化一个结构变量 { \u0026ldquo;Ewen\u0026rdquo;, \u0026ldquo;Villard\u0026rdquo; }, \u0026ldquo;grilled salmon\u0026rdquo;, \u0026ldquo;personality coach\u0026rdquo;, 68112.00 }; printf(\u0026ldquo;Dear %s, \\n\\n\u0026rdquo;, fellow.handle.first); printf(\u0026quot;%s%s.\\n\u0026rdquo;, msgs[0], fellow.handle.first); printf(\u0026quot;%s%s\\n\u0026rdquo;, msgs[1], fellow.job); printf(\u0026quot;%s\\n\u0026rdquo;, msgs[2]);\nprintf(\u0026quot;%s%s%s\u0026rdquo;, msgs[3], fellow.favfood, msgs[4]); if (fellow.income \u0026gt; 150000.0) puts(\u0026quot;!!\u0026quot;); else if (fellow.income \u0026gt; 75000.0) puts(\u0026quot;!\u0026quot;); else puts(\u0026quot;.\u0026quot;); printf(\u0026quot;\\n%40s%s\\n\u0026quot;, \u0026quot; \u0026ldquo;, \u0026ldquo;See you soon,\u0026rdquo;); printf(\u0026quot;%40s%s\\n\u0026rdquo;, \u0026quot; \u0026ldquo;, \u0026ldquo;Shalala\u0026rdquo;); return 0; } 下面是该程序的输出： Dear Ewen, Thank you for the wonderful evening, Ewen. You certainly prove that a personality coach is a special kind of guy.We must get together over a delicious grilled salmon and have a few laughs. See you soon, Shalala\n首先，注意如何在结构声明中创建嵌套结构。和声明int类型变量一样， 进行简单的声明： struct names handle; 该声明表明handle是一个struct name类型的变量。当然，文件中也应包 含结构names的声明。 其次，注意如何访问嵌套结构的成员，这需要使用两次点运算符： printf(\u0026ldquo;Hello, %s!\\n\u0026rdquo;, fellow.handle.first); 从左往右解释fellow.handle.first： (fellow.handle).first 也就是说，找到fellow，然后找到fellow的handle的成员，再找到handle 的first成员。\n14.6 指向结构的指针 # 喜欢使用指针的人一定很高兴能使用指向结构的指针。至少有 4 个理由 # 可以解释为何要使用指向结构的指针。第一，就像指向数组的指针比数组本 # 身更容易操控（如，排序问题）一样，指向结构的指针通常比结构本身更容 # 易操控。第二，在一些早期的C实现中，结构不能作为参数传递给函数，但 # 是可以传递指向结构的指针。第三，即使能传递一个结构，传递指针通常更 # 有效率。第四，一些用于表示数据的结构中包含指向其他结构的指针。 # 下面的程序（程序清单14.4）演示了如何定义指向结构的指针和如何用 # 这样的指针访问结构的成员。 # 程序清单 14.4 friends.c 程序 /* friends.c -- 使用指向结构的指针 */ #include \u0026lt;stdio.h\u0026gt; #define LEN 20 struct names { char first[LEN]; char last[LEN]; }; struct guy { struct names handle; char favfood[LEN]; char job[LEN]; float income; }; int main(void) { struct guy fellow[2] = { { { \u0026ldquo;Ewen\u0026rdquo;, \u0026ldquo;Villard\u0026rdquo; }, \u0026ldquo;grilled salmon\u0026rdquo;, \u0026ldquo;personality coach\u0026rdquo;, 68112.00 }, { { \u0026ldquo;Rodney\u0026rdquo;, \u0026ldquo;Swillbelly\u0026rdquo; }, \u0026ldquo;tripe\u0026rdquo;, \u0026ldquo;tabloid editor\u0026rdquo;, 432400.00 } }; struct guy * him; /* 这是一个指向结构的指针 / printf(\u0026ldquo;address #1: %p #2: %p\\n\u0026rdquo;, \u0026amp;fellow[0], \u0026amp;fellow[1]); him = \u0026amp;fellow[0]; / 告诉编译器该指针指向何处 */\nprintf(\u0026ldquo;pointer #1: %p #2: %p\\n\u0026rdquo;, him, him + 1); printf(\u0026ldquo;him-\u0026gt;income is $%.2f: (*him).income is $%.2f\\n\u0026rdquo;, him-\u0026gt;income, (him).income); him++; / 指向下一个结构　*/ printf(\u0026ldquo;him-\u0026gt;favfood is %s: him-\u0026gt;handle.last is %s\\n\u0026rdquo;, him-\u0026gt;favfood, him-\u0026gt;handle.last); return 0; } 该程序的输出如下： address #1: 0x7fff5fbff820 #2: 0x7fff5fbff874 pointer #1: 0x7fff5fbff820 #2: 0x7fff5fbff874 him-\u0026gt;income is $68112.00: (*him).income is $68112.00 him-\u0026gt;favfood is tripe: him-\u0026gt;handle.last is Swillbelly 我们先来看如何创建指向guy类型结构的指针，然后再分析如何通过该 指针指定结构的成员。\n14.6.1 声明和初始化结构指针 # 声明结构指针很简单： # struct guy * him; 首先是关键字 struct，其次是结构标记 guy，然后是一个星号（*），其 后跟着指针名。这个语法和其他指针声明一样。\n该声明并未创建一个新的结构，但是指针him现在可以指向任意现有的 guy类型的结构。例如，如果barney是一个guy类型的结构，可以这样写： him = \u0026amp;barney; 和数组不同的是，结构名并不是结构的地址，因此要在结构名前面加上 \u0026amp;运算符。 在本例中，fellow 是一个结构数组，这意味着 fellow[0]是一个结构。所 以，要让 him 指向fellow[0]，可以这样写： him = \u0026amp;fellow[0]; 输出的前两行说明赋值成功。比较这两行发现，him指向fellow[0]，him\n1指向fellow[1]。注意，him加 1 相当于him指向的地址加 84 。在十六进制 中，874 - 820 = 54（十六进制）= 84（十进制），因为每个guy结构都占用 84 字节的内存：names.first占用 20 字节，names.last占用 20 字节，favfood占用 20 字节，job占用 20 字节，income占用 4 字节（假设系统中float占用 4 字节）。 顺带一提，在有些系统中，一个结构的大小可能大于它各成员大小之和。这 是因为系统对数据进行校准的过程中产生了一些“缝隙”。例如，有些系统必 须把每个成员都放在偶数地址上，或 4 的倍数的地址上。在这种系统中，结 构的内部就存在未使用的“缝隙”。 14.6.2 用指针访问成员 # 指针him指向结构变量fellow[0]，如何通过him获得fellow[0]的成员的 值？程序清单14.4中的第 3 行输出演示了两种方法。 第 1 种方法也是最常用的方法：使用-\u0026gt;运算符。该运算符由一个连接号 （-）后跟一个大于号（\u0026gt;）组成。我们有下面的关系： 如果him == \u0026amp;barney，那么him-\u0026gt;income 即是 barney.income 如果him == \u0026amp;fellow[0]，那么him-\u0026gt;income 即是 fellow[0].income\n换句话说，-\u0026gt;运算符后面的结构指针和.运算符后面的结构名工作方式 # 相同（不能写成him.incone，因为him不是结构名）。 这里要着重理解him是一个指针，但是hime-\u0026gt;income是该指针所指向结 构的一个成员。所以在该例中，him-\u0026gt;income是一个float类型的变量。 第 2 种方法是，以这样的顺序指定结构成员的值：如果him == \u0026amp;fellow[0]，那么him == fellow[0]，因为\u0026amp;和是一对互逆运算符。因此， 可以做以下替代： fellow[0].income == (him).income 必须要使用圆括号，因为.运算符比运算符的优先级高。 总之，如果him是指向guy类型结构barney的指针，下面的关系恒成立： barney.income == (*him).income == him-\u0026gt;income // 假设 him == \u0026amp;barney 接下来，我们来学习结构和函数的交互。\n14.7 向函数传递结构的信息 # 函数的参数把值传递给函数。每个值都是一个数字——可能是int类型、 float类型，可能是ASCII字符码，或者是一个地址。然而，一个结构比一个 单独的值复杂，所以难怪以前的C实现不允许把结构作为参数传递给函数。 当前的实现已经移除了这个限制，ANSI C允许把结构作为参数使用。所以 程序员可以选择是传递结构本身，还是传递指向结构的指针。如果你只关心 结构中的某一部分，也可以把结构的成员作为参数。我们接下来将分析这 3 种传递方式，首先介绍以结构成员作为参数的情况。\n14.7.1 传递结构成员 # 只要结构成员是一个具有单个值的数据类型（即，int及其相关类型、 char、float、double或指针），便可把它作为参数传递给接受该特定类型的 函数。程序清单14.5中的财务分析程序（初级版本）演示了这一点，该程序 把客户的银行账户添加到他/她的储蓄和贷款账户中。 程序清单 14.5 funds1.c 程序 /* funds1.c \u0026ndash; 把结构成员作为参数传递 */ #include \u0026lt;stdio.h\u0026gt; #define FUNDLEN 50 struct funds { char bank[FUNDLEN]; double bankfund; char save[FUNDLEN]; double savefund;\n}; # double sum(double, double); int main(void) { struct funds stan = { \u0026ldquo;Garlic-Melon Bank\u0026rdquo;, 4032.27, \u0026ldquo;Lucky\u0026rsquo;s Savings and Loan\u0026rdquo;, 8543.94 }; printf(\u0026ldquo;Stan has a total of $%.2f.\\n\u0026rdquo;, sum(stan.bankfund, stan.savefund)); return 0; } /* 两个double类型的数相加 */ double sum(double x, double y) { return(x + y); }\n运行该程序后输出如下： # Stan has a total of $12576.21. 看来，这样传递参数没问题。注意，sum()函数既不知道也不关心实际 的参数是否是结构的成员，它只要求传入的数据是double类型。 当然，如果需要在被调函数中修改主调函数中成员的值，就要传递成员 的地址： modify(\u0026amp;stan.bankfund); 这是一个更改银行账户的函数。 把结构的信息告诉函数的第 2 种方法是，让被调函数知道自己正在处理 一个结构。\n14.7.2 传递结构的地址 # 我们继续解决前面的问题，但是这次把结构的地址作为参数。由于函数 # 要处理funds结构，所以必须声明funds结构。如程序清单14.6所示。 程序清单 14.6 funds2.c 程序 /* funds2.c \u0026ndash; 传递指向结构的指针 */ #include \u0026lt;stdio.h\u0026gt; #define FUNDLEN 50 struct funds { char bank[FUNDLEN]; double bankfund;\nchar save[FUNDLEN]; double savefund; }; double sum(const struct funds ); / 参数是一个指针 */ int main(void) { struct funds stan = { \u0026ldquo;Garlic-Melon Bank\u0026rdquo;, 4032.27, \u0026ldquo;Lucky\u0026rsquo;s Savings and Loan\u0026rdquo;, 8543.94 }; printf(\u0026ldquo;Stan has a total of $%.2f.\\n\u0026rdquo;, sum(\u0026amp;stan)); return 0; } double sum(const struct funds * money) { return(money-\u0026gt;bankfund + money-\u0026gt;savefund); }\n运行该程序后输出如下： # Stan has a total of $12576.21. sum()函数使用指向funds结构的指针（money）作为它的参数。把地址 \u0026amp;stan传递给该函数，使得指针money指向结构stan。然后通过-\u0026gt;运算符获取 stan.bankfund和stan.savefund的值。由于该函数不能改变指针所指向值的内 容，所以把money声明为一个指向const的指针。 虽然该函数并未使用其他成员，但是也可以访问它们。注意，必须使用 \u0026amp;运算符来获取结构的地址。和数组名不同，结构名只是其地址的别名。\n14.7.3 传递结构 # 对于允许把结构作为参数的编译器，可以把程序清单14.6重写为程序清 # 单14.7。 # 程序清单 14.7 funds3.c 程序 /* funds3.c -- 传递一个结构 */ #include \u0026lt;stdio.h\u0026gt; #define FUNDLEN 50 struct funds { char bank[FUNDLEN]; double bankfund; char save[FUNDLEN]; double savefund; }; double sum(struct funds moolah); /* 参数是一个结构 */ int main(void) { struct funds stan = { \u0026ldquo;Garlic-Melon Bank\u0026rdquo;, 4032.27, \u0026ldquo;Lucky\u0026rsquo;s Savings and Loan\u0026rdquo;, 8543.94 }; printf(\u0026ldquo;Stan has a total of $%.2f.\\n\u0026rdquo;, sum(stan)); return 0; } double sum(struct funds moolah) { return(moolah.bankfund + moolah.savefund); } 下面是运行该程序后的输出： Stan has a total of $12576.21. 该程序把程序清单14.6中指向struct funds类型的结构指针money替换成\nstruct funds类型的结构变量moolah。调用sum()时，编译器根据funds模板创建 了一个名为moolah的自动结构变量。然后，该结构的各成员被初始化为 stan 结构变量相应成员的值的副本。因此，程序使用原来结构的副本进行计算， 然而，传递指针的程序清单14.6使用的是原始的结构进行计算。由于moolah 是一个结构，所以该程序使用moolah.bankfund，而不是moolah-\u0026gt;bankfund。 另一方面，由于money是指针，不是结构，所以程序清单14.6使用的是monet-\nbankfund。\n14.7.4 其他结构特性 # 现在的C允许把一个结构赋值给另一个结构，但是数组不能这样做。也 # 就是说，如果n_data和o_data都是相同类型的结构，可以这样做： o_data = n_data; // 把一个结构赋值给另一个结构 这条语句把n_data的每个成员的值都赋给o_data的相应成员。即使成员 是数组，也能完成赋值。另外，还可以把一个结构初始化为相同类型的另一 个结构： struct names right_field = {\u0026ldquo;Ruthie\u0026rdquo;, \u0026ldquo;George\u0026rdquo;}; struct names captain = right_field; // 把一个结构初始化为另一个结构 现在的C（包括ANSI C），函数不仅能把结构本身作为参数传递，还能 把结构作为返回值返回。把结构作为函数参数可以把结构的信息传送给函 数；把结构作为返回值的函数能把结构的信息从被调函数传回主调函数。结 构指针也允许这种双向通信，因此可以选择任一种方法来解决编程问题。我 们通过另一组程序示例来演示这两种方法。 为了对比这两种方法，我们先编写一个程序以传递指针的方式处理结 构，然后以传递结构和返回结构的方式重写该程序。 程序清单 14.8 names1.c 程序\n/* names1.c \u0026ndash; 使用指向结构的指针 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define NLEN 30 struct namect { char fname[NLEN]; char lname[NLEN]; int letters; }; void getinfo(struct namect *); void makeinfo(struct namect *); void showinfo(const struct namect *); char * s_gets(char * st, int n); int main(void) { struct namect person; getinfo(\u0026amp;person); makeinfo(\u0026amp;person); showinfo(\u0026amp;person);\nreturn 0; } void getinfo(struct namect * pst) { printf(\u0026ldquo;Please enter your first name.\\n\u0026rdquo;); s_gets(pst-\u0026gt;fname, NLEN); printf(\u0026ldquo;Please enter your last name.\\n\u0026rdquo;); s_gets(pst-\u0026gt;lname, NLEN); } void makeinfo(struct namect * pst) { pst-\u0026gt;letters = strlen(pst-\u0026gt;fname) +strlen(pst-\u0026gt;lname); } void showinfo(const struct namect * pst) { printf(\u0026quot;%s %s, your name contains %d letters.\\n\u0026rdquo;, pst-\u0026gt;fname, pst-\u0026gt;lname, pst-\u0026gt;letters); } char * s_gets(char * st, int n)\n{ # char * ret_val; char * find; ret_val = fgets(st, n, stdin); if (ret_val) { find = strchr(st, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是 NULL, *find = \u0026lsquo;\\0\u0026rsquo;; // 在此处放置一个空字符 else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; // 处理输入行的剩余字符 } return ret_val; } 下面是编译并运行该程序后的一个输出示例： Please enter your first name. Viola Please enter your last name.\nPlunderfest Viola Plunderfest, your name contains 16 letters. 该程序把任务分配给 3 个函数来完成，都在main()中调用。每调用一个 函数就把person结构的地址传递给它。 getinfo()函数把结构的信息从自身传递给main()。该函数通过与用户交互 获得姓名，并通过pst指针定位，将其放入 person 结构中。由于 pst-\u0026gt;lname 意味着 pst 指向结构的 lname 成员，这使得pst-\u0026gt;lname等价于char数组的名 称，因此做s_gets()的参数很合适。注意，虽然getinfo()给main()提供了信 息，但是它并未使用返回机制，所以其返回类型是void。 makeinfo()函数使用双向传输方式传送信息。通过使用指向 person 的指 针，该指针定位了储存在该结构中的名和姓。该函数使用C库函数strlen()分 别计算名和姓中的字母总数，然后使用person的地址储存两数之和。同样， makeinfo()函数的返回类型也是void。 showinfo()函数使用一个指针定位待打印的信息。因为该函数不改变数 组的内容，所以将其声明为const。 所有这些操作中，只有一个结构变量 person，每个函数都使用该结构变 量的地址来访问它。一个函数把信息从自身传回主调函数，一个函数把信息 从主调函数传给自身，一个函数通过双向传输来传递信息。 现在，我们来看如何使用结构参数和返回值来完成相同的任务。第一， 为了传递结构本身，函数的参数必须是person，而不是\u0026amp;person。那么，相 应的形式参数应声明为struct namect，而不是指向该类型的指针。第二，可 以通过返回一个结构，把结构的信息返回给main()。程序清单14.9演示了不 使用指针的版本。 程序清单 14.9 names2.c 程序 /* names2.c \u0026ndash; 传递并返回结构 */\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define NLEN 30 struct namect { char fname[NLEN]; char lname[NLEN]; int letters; }; struct namect getinfo(void); struct namect makeinfo(struct namect); void showinfo(struct namect); char * s_gets(char * st, int n); int main(void) { struct namect person; person = getinfo(); person = makeinfo(person); showinfo(person); return 0;\n} # struct namect getinfo(void) { struct namect temp; printf(\u0026ldquo;Please enter your first name.\\n\u0026rdquo;); s_gets(temp.fname, NLEN); printf(\u0026ldquo;Please enter your last name.\\n\u0026rdquo;); s_gets(temp.lname, NLEN); return temp; } struct namect makeinfo(struct namect info) { info.letters = strlen(info.fname) + strlen(info.lname); return info; } void showinfo(struct namect info) { printf(\u0026quot;%s %s, your name contains %d letters.\\n\u0026quot;, info.fname, info.lname, info.letters);\n} # char * s_gets(char * st, int n) { char * ret_val; char * find; ret_val = fgets(st, n, stdin); if (ret_val) { find = strchr(st, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是 NULL， *find = \u0026lsquo;\\0\u0026rsquo;; // 在此处放置一个空字符 else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; // 处理输入行的剩余部分 } return ret_val; } 该版本最终的输出和前面版本相同，但是它使用了不同的方式。程序中 的每个函数都创建了自己的person备份，所以该程序使用了 4 个不同的结 构，不像前面的版本只使用一个结构。\n例如，考虑makeinfo()函数。在第 1 个程序中，传递的是person的地址， 该函数实际上处理的是person的值。在第 2 个版本的程序中，创建了一个新 的结构info。储存在person中的值被拷贝到info中，函数处理的是这个副本。 因此，统计完字母个数后，计算结果储存在info中，而不是person中。然 而，返回机制弥补了这一点。makeinfo()中的这行代码： return info; 与main()中的这行结合： person = makeinfo(person); 把储存在info中的值拷贝到person中。注意，必须把makeinfo()函数声明 为struct namect类型，所以该函数要返回一个结构。\n14.7.5 结构和结构指针的选择 # 假设要编写一个与结构相关的函数，是用结构指针作为参数，还是用结 # 构作为参数和返回值？两者各有优缺点。 # 把指针作为参数有两个优点：无论是以前还是现在的C实现都能使用这 # 种方法，而且执行起来很快，只需要传递一个地址。缺点是无法保护数据。 # 被调函数中的某些操作可能会意外影响原来结构中的数据。不过，ANSI C # 新增的const限定符解决了这个问题。例如，如果在程序清单14.8中， showinfo()函数中的代码改变了结构的任意成员，编译器会捕获这个错误。 把结构作为参数传递的优点是，函数处理的是原始数据的副本，这保护 了原始数据。另外，代码风格也更清楚。假设定义了下面的结构类型： struct vector {double x; double y;}; 如果用vector类型的结构ans储存相同类型结构a和b的和，就要把结构作 为参数和返回值：\nstruct vector ans, a, b; struct vector sum_vect(struct vector, struct vector); \u0026hellip; ans = sum_vect(a,b); 对程序员而言，上面的版本比用指针传递的版本更自然。指针版本如 下： struct vector ans, a, b; void sum_vect(const struct vector *, const struct vector *, struct vector *); \u0026hellip; sum_vect(\u0026amp;a, \u0026amp;b, \u0026amp;ans); 另外，如果使用指针版本，程序员必须记住总和的地址应该是第 1 个参 数还是第 2 个参数的地址。 传递结构的两个缺点是：较老版本的实现可能无法处理这样的代码，而 且传递结构浪费时间和存储空间。尤其是把大型结构传递给函数，而它只使 用结构中的一两个成员时特别浪费。这种情况下传递指针或只传递函数所需 的成员更合理。 通常，程序员为了追求效率会使用结构指针作为函数参数，如需防止原 始数据被意外修改，使用const限定符。按值传递结构是处理小型结构最常 用的方法。\n14.7.6 结构中的字符数组和字符指针 # 到目前为止，我们在结构中都使用字符数组来储存字符串。是否可以使 # 用指向 char 的指针来代替字符数组？例如，程序清单14.3中有如下声明：\n#define LEN 20 struct names { char first[LEN]; char last[LEN]; }; 其中的结构声明是否可以这样写： struct pnames { char * first; char * last; }; 当然可以，但是如果不理解这样做的含义，可能会有麻烦。考虑下面的 代码： struct names veep = {\u0026ldquo;Talia\u0026rdquo;, \u0026ldquo;Summers\u0026rdquo;}; struct pnames treas = {\u0026ldquo;Brad\u0026rdquo;, \u0026ldquo;Fallingjaw\u0026rdquo;}; printf(\u0026quot;%s and %s\\n\u0026quot;, veep.first, treas.first); 以上代码都没问题，也能正常运行，但是思考一下字符串被储存在何 处。对于struct names类型的结构变量veep，以上字符串都储存在结构内部， 结构总共要分配 40 字节储存姓名。然而，对于struct pnames类型的结构变量 treas，以上字符串储存在编译器储存常量的地方。结构本身只储存了两个地 址，在我们的系统中共占 16 字节。尤其是，struct pnames结构不用为字符串 分配任何存储空间。它使用的是储存在别处的字符串（如，字符串常量或数 组中的字符串）。简而言之，在pnames结构变量中的指针应该只用来在程序\n中管理那些已分配和在别处分配的字符串。 # 我们看看这种限制在什么情况下出问题。考虑下面的代码： # struct names accountant; struct pnames attorney; puts(\u0026ldquo;Enter the last name of your accountant:\u0026rdquo;); scanf(\u0026quot;%s\u0026quot;, accountant.last); puts(\u0026ldquo;Enter the last name of your attorney:\u0026rdquo;); scanf(\u0026quot;%s\u0026quot;, attorney.last); /* 这里有一个潜在的危险 */ 就语法而言，这段代码没问题。但是，用户的输入储存到哪里去了？对 于会计师（accountant），他的名储存在accountant结构变量的last成员中，该 结构中有一个储存字符串的数组。对于律师（attorney），scanf()把字符串放 到attorney.last表示的地址上。由于这是未经初始化的变量，地址可以是任何 值，因此程序可以把名放在任何地方。如果走运的话，程序不会出问题，至 少暂时不会出问题，否则这一操作会导致程序崩溃。实际上，如果程序能正 常运行并不是好事，因为这意味着一个未被觉察的危险潜伏在程序中。 因此，如果要用结构储存字符串，用字符数组作为成员比较简单。用指 向 char 的指针也行，但是误用会导致严重的问题。\n14.7.7 结构、指针和 malloc() # 如果使用malloc()分配内存并使用指针储存该地址，那么在结构中使用 指针处理字符串就比较合理。这种方法的优点是，可以请求malloc()为字符 串分配合适的存储空间。可以要求用 4 字节储存\u0026quot;Joe\u0026quot;和用 18 字节储 存\u0026quot;Rasolofomasoandro\u0026quot;。用这种方法改写程序清单14.9并不费劲。主要是更 改结构声明（用指针代替数组）和提供一个新版本的getinfo()函数。新的结\n构声明如下： # struct namect { char * fname; // 用指针代替数组 char * lname; int letters; }; 新版本的getinfo()把用户的输入读入临时数组中，调用malloc()函数分配 存储空间，并把字符串拷贝到新分配的存储空间中。对名和姓都要这样做： void getinfo (struct namect * pst) { char temp[SLEN]; printf(\u0026ldquo;Please enter your first name.\\n\u0026rdquo;); s_gets(temp, SLEN); // 分配内存储存名 pst-\u0026gt;fname = (char *) malloc(strlen(temp) + 1); // 把名拷贝到已分配的内存 strcpy(pst-\u0026gt;fname, temp); printf(\u0026ldquo;Please enter your last name.\\n\u0026rdquo;); s_gets(temp, SLEN);\npst-\u0026gt;lname = (char *) malloc(strlen(temp) + 1); strcpy(pst-\u0026gt;lname, temp); } 要理解这两个字符串都未储存在结构中，它们储存在 malloc()分配的内 存块中。然而，结构中储存着这两个字符串的地址，处理字符串的函数通常 都要使用字符串的地址。因此，不用修改程序中的其他函数。 第 12 章建议，应该成对使用malloc()和free()。因此，还要在程序中添加 一个新的函数cleanup()，用于释放程序动态分配的内存。如程序清单14.10所 示。 程序清单 14.10 names3.c 程序 // names3.c \u0026ndash; 使用指针和 malloc() #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; // 提供 strcpy()、strlen() 的原型 #include \u0026lt;stdlib.h\u0026gt; // 提供 malloc()、free() 的原型 #define SLEN 81 struct namect { char * fname; // 使用指针 char * lname; int letters; };\nvoid getinfo(struct namect *); // 分配内存 void makeinfo(struct namect *); void showinfo(const struct namect *); void cleanup(struct namect *); // 调用该函数时释放内存 char * s_gets(char * st, int n); int main(void) { struct namect person; getinfo(\u0026amp;person); makeinfo(\u0026amp;person); showinfo(\u0026amp;person); cleanup(\u0026amp;person); return 0; } void getinfo(struct namect * pst) { char temp[SLEN]; printf(\u0026ldquo;Please enter your first name.\\n\u0026rdquo;); s_gets(temp, SLEN);\n// 分配内存以储存名 # pst-\u0026gt;fname = (char *) malloc(strlen(temp) + 1); // 把名拷贝到动态分配的内存中 strcpy(pst-\u0026gt;fname, temp); printf(\u0026ldquo;Please enter your last name.\\n\u0026rdquo;); s_gets(temp, SLEN); pst-\u0026gt;lname = (char *) malloc(strlen(temp) + 1); strcpy(pst-\u0026gt;lname, temp); } void makeinfo(struct namect * pst) { pst-\u0026gt;letters = strlen(pst-\u0026gt;fname) + strlen(pst-\u0026gt;lname); } void showinfo(const struct namect * pst) { printf(\u0026quot;%s %s, your name contains %d letters.\\n\u0026quot;, pst-\u0026gt;fname, pst-\u0026gt;lname, pst-\u0026gt;letters); }\nvoid cleanup(struct namect * pst) { free(pst-\u0026gt;fname); free(pst-\u0026gt;lname); } char * s_gets(char * st, int n) { char * ret_val; char * find; ret_val = fgets(st, n, stdin); if (ret_val) { find = strchr(st, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是 NULL， *find = \u0026lsquo;\\0\u0026rsquo;; // 在此处放置一个空字符 else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; // 处理输入行的剩余部分 }\nreturn ret_val; } 下面是该程序的输出： Please enter your first name. Floresiensis Please enter your last name. Mann Floresiensis Mann, your name contains 16 letters. 14.7.8 复合字面量和结构（ C99 ） # C99 的复合字面量特性可用于结构和数组。如果只需要一个临时结构 # 值，复合字面量很好用。例如，可以使用复合字面量创建一个数组作为函数 # 的参数或赋给另一个结构。语法是把类型名放在圆括号中，后面紧跟一个用 # 花括号括起来的初始化列表。例如，下面是struct book类型的复合字面量： (struct book) {\u0026ldquo;The Idiot\u0026rdquo;, \u0026ldquo;Fyodor Dostoyevsky\u0026rdquo;, 6.99} 程序清单14.11中的程序示例，使用复合字面量为一个结构变量提供两 个可替换的值（在撰写本书时，并不是所有的编译器都支持这个特性，不过 这是时间的问题）。 程序清单 14.11 complit.c 程序 /* complit.c \u0026ndash; 复合字面量 */ #include \u0026lt;stdio.h\u0026gt; #define MAXTITL 41\n#define MAXAUTL 31 struct book { // 结构模版：标记是 book char title[MAXTITL]; char author[MAXAUTL]; float value; }; int main(void) { struct book readfirst; int score; printf(\u0026ldquo;Enter test score: \u0026ldquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;score); if (score \u0026gt;= 84) readfirst = (struct book) {\u0026ldquo;Crime and Punishment\u0026rdquo;, \u0026ldquo;Fyodor Dostoyevsky\u0026rdquo;, 11.25}; else readfirst = (struct book) {\u0026ldquo;Mr.Bouncy\u0026rsquo;s Nice Hat\u0026rdquo;, \u0026ldquo;Fred Winsome\u0026rdquo;,\n5.99}; # printf(\u0026ldquo;Your assigned reading:\\n\u0026rdquo;); printf(\u0026quot;%s by %s: $%.2f\\n\u0026rdquo;, readfirst.title, readfirst.author, readfirst.value); return 0; } 还可以把复合字面量作为函数的参数。如果函数接受一个结构，可以把 复合字面量作为实际参数传递： struct rect {double x; double y;}; double rect_area(struct rect r){return r.x * r.y;} \u0026hellip; double area; area = rect_area( (struct rect) {10.5, 20.0}); 值 210 被赋给area。 如果函数接受一个地址，可以传递复合字面量的地址： struct rect {double x; double y;}; double rect_areap(struct rect * rp){return rp-\u0026gt;x * rp-\u0026gt;y;} \u0026hellip; double area;\narea = rect_areap( \u0026amp;(struct rect) {10.5, 20.0}); 值 210 被赋给area。 复合字面量在所有函数的外部，具有静态存储期；如果复合字面量在块 中，则具有自动存储期。复合字面量和普通初始化列表的语法规则相同。这 意味着，可以在复合字面量中使用指定初始化器。\n14.7.9 伸缩型数组成员（ C99 ） # C99新增了一个特性：伸缩型数组成员（flexible array member），利用 这项特性声明的结构，其最后一个数组成员具有一些特性。第 1 个特性是， 该数组不会立即存在。第 2 个特性是，使用这个伸缩型数组成员可以编写合 适的代码，就好像它确实存在并具有所需数目的元素一样。这可能听起来很 奇怪，所以我们来一步步地创建和使用一个带伸缩型数组成员的结构。 首先，声明一个伸缩型数组成员有如下规则： 伸缩型数组成员必须是结构的最后一个成员； 结构中必须至少有一个成员； 伸缩数组的声明类似于普通数组，只是它的方括号中是空的。 下面用一个示例来解释以上几点： struct flex { int count; double average; double scores[]; // 伸缩型数组成员\n}; # 声明一个struct flex类型的结构变量时，不能用scores做任何事，因为没 有给这个数组预留存储空间。实际上，C99的意图并不是让你声明struct flex 类型的变量，而是希望你声明一个指向struct flex类型的指针，然后用 malloc()来分配足够的空间，以储存struct flex类型结构的常规内容和伸缩型 数组成员所需的额外空间。例如，假设用scores表示一个内含 5 个double类型 值的数组，可以这样做： struct flex * pf; // 声明一个指针 // 请求为一个结构和一个数组分配存储空间 pf = malloc(sizeof(struct flex) + 5 * sizeof(double)); 现在有足够的存储空间储存count、average和一个内含 5 个double类型值 的数组。可以用指针pf访问这些成员： pf-\u0026gt;count = 5; // 设置 count 成员 pf-\u0026gt;scores[2] = 18.5; // 访问数组成员的一个元素 程序清单14.13进一步扩展了这个例子，让伸缩型数组成员在第 1 种情况 下表示 5 个值，在第 2 种情况下代表 9 个值。该程序也演示了如何编写一个函 数处理带伸缩型数组元素的结构。 程序清单 14.12 flexmemb.c 程序 // flexmemb.c \u0026ndash; 伸缩型数组成员（C99新增特性） #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct flex\n{ # size_t count; double average; double scores []; // 伸缩型数组成员 }; void showFlex(const struct flex * p); int main(void) { struct flex * pf1, *pf2; int n = 5; int i; int tot = 0; // 为结构和数组分配存储空间 pf1 = malloc(sizeof(struct flex) + n * sizeof(double)); pf1-\u0026gt;count = n; for (i = 0; i \u0026lt; n; i++) { pf1-\u0026gt;scores[i] = 20.0 - i; tot += pf1-\u0026gt;scores[i];\n} # pf1-\u0026gt;average = tot / n; showFlex(pf1); n = 9; tot = 0; pf2 = malloc(sizeof(struct flex) + n * sizeof(double)); pf2-\u0026gt;count = n; for (i = 0; i \u0026lt; n; i++) { pf2-\u0026gt;scores[i] = 20.0 - i / 2.0; tot += pf2-\u0026gt;scores[i]; } pf2-\u0026gt;average = tot / n; showFlex(pf2); free(pf1); free(pf2); return 0; } void showFlex(const struct flex * p)\n{ # int i; printf(\u0026ldquo;Scores : \u0026ldquo;); for (i = 0; i \u0026lt; p-\u0026gt;count; i++) printf(\u0026quot;%g \u0026ldquo;, p-\u0026gt;scores[i]); printf(\u0026quot;\\nAverage: %g\\n\u0026rdquo;, p-\u0026gt;average); } 下面是该程序的输出： Scores : 20 19 18 17 16 Average: 18 Scores : 20 19.5 19 18.5 18 17.5 17 16.5 16 Average: 17 带伸缩型数组成员的结构确实有一些特殊的处理要求。第一，不能用结 构进行赋值或拷贝： struct flex * pf1, *pf2; // pf1 和pf2 都是结构 \u0026hellip; *pf2 = *pf1; // 不要这样做 这样做只能拷贝除伸缩型数组成员以外的其他成员。确实要进行拷贝， 应使用memcpy()函数（第 16 章中介绍）。 第二，不要以按值方式把这种结构传递给结构。原因相同，按值传递一\n个参数与赋值类似。要把结构的地址传递给函数。 # 第三，不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的 # 成员。 # 这种类似于在结构中最后一个成员是伸缩型数组的情况，称为struct hack。除了伸缩型数组成员在声明时用空的方括号外，struct hack特指大小为 0 的数组。然而，struct hack是针对特殊编译器（GCC）的，不属于C标准。 这种伸缩型数组成员方法是标准认可的编程技巧。\n14.7.10 匿名结构（ C11 ） # 匿名结构是一个没有名称的结构成员。为了理解它的工作原理，我们先 # 考虑如何创建嵌套结构： # struct names { char first[20]; char last[20]; }; struct person { int id; struct names name;// 嵌套结构成员 }; struct person ted = {8483, {\u0026#34;Ted\u0026#34;, \u0026#34;Grass\u0026#34;}}; 这里，name成员是一个嵌套结构，可以通过类似ted.name.first的表达式 访问\u0026quot;ted\u0026rdquo;： puts(ted.name.first); 在C11中，可以用嵌套的匿名成员结构定义person： struct person { int id; struct {char first[20]; char last[20];}; // 匿名结构 }; 初始化ted的方式相同： struct person ted = {8483, {\u0026ldquo;Ted\u0026rdquo;, \u0026ldquo;Grass\u0026rdquo;}}; 但是，在访问ted时简化了步骤，只需把first看作是person的成员那样使 用它： puts(ted.first); 当然，也可以把first和last直接作为person的成员，删除嵌套循环。匿名 特性在嵌套联合中更加有用，我们在本章后面介绍。\n14.7.11 使用结构数组的函数 # 假设一个函数要处理一个结构数组。由于数组名就是该数组的地址，所 # 以可以把它传递给函数。另外，该函数还需访问结构模板。为了理解该函数 # 的工作原理，程序清单14.13把前面的金融程序扩展为两人，所以需要一个 # 内含两个funds结构的数组。\n程序清单 14.13 funds4.c 程序 /* funds4.c \u0026ndash; 把结构数组传递给函数 */ #include \u0026lt;stdio.h\u0026gt; #define FUNDLEN 50 #define N 2 struct funds { char bank[FUNDLEN]; double bankfund; char save[FUNDLEN]; double savefund; }; double sum(const struct funds money [], int n); int main(void) { struct funds jones[N] = { { \u0026ldquo;Garlic-Melon Bank\u0026rdquo;, 4032.27, \u0026ldquo;Lucky\u0026rsquo;s Savings and Loan\u0026rdquo;,\n8543.94 # }, # { # \u0026ldquo;Honest Jack\u0026rsquo;s Bank\u0026rdquo;, 3620.88, \u0026ldquo;Party Time Savings\u0026rdquo;, 3802.91 } }; printf(\u0026ldquo;The Joneses have a total of $%.2f.\\n\u0026rdquo;,sum(jones, N)); return 0; } double sum(const struct funds money [], int n) { double total; int i; for (i = 0, total = 0; i \u0026lt; n; i++) total += money[i].bankfund + money[i].savefund; return(total);\n} # 该程序的输出如下： # The Joneses have a total of $20000.00. （读者也许认为这个总和有些巧合！） 数组名jones是该数组的地址，即该数组首元素（jones[0]）的地址。因 此，指针money的初始值相当于通过下面的表达式获得： money = \u0026amp;jones[0]; 因为money指向jones数组的首元素，所以money[0]是该数组的另一个名 称。与此类似，money[1]是第 2 个元素。每个元素都是一个funds类型的结 构，所以都可以使用点运算符（.）来访问funds类型结构的成员。 下面是几个要点。 可以把数组名作为数组中第 1 个结构的地址传递给函数。 然后可以用数组表示法访问数组中的其他结构。注意下面的函数调用与 使用数组名效果相同： sum(\u0026amp;jones[0], N) 因为jones和\u0026amp;jones[0]的地址相同，使用数组名是传递结构地址的一种 间接的方法。 由于sum()函数不能改变原始数据，所以该函数使用了ANSI C的限定符 const。\n14.8 把结构内容保存到文件中 # 由于结构可以储存不同类型的信息，所以它是构建数据库的重要工具。 # 例如，可以用一个结构储存雇员或汽车零件的相关信息。最终，我们要把这 # 些信息储存在文件中，并且能再次检索。数据库文件可以包含任意数量的此 # 类数据对象。储存在一个结构中的整套信息被称为记录（record），单独的 项被称为字段（field）。本节我们来探讨这个主题。 或许储存记录最没效率的方法是用fprintf()。例如，回忆程序清单14.1中 的book结构： #define MAXTITL 40 #define MAXAUTL 40 struct book { char title[MAXTITL]; char author[MAXAUTL]; float value; }; 如果pbook标识一个文件流，那么通过下面这条语句可以把信息储存在 struct book类型的结构变量primer中： fprintf(pbooks, \u0026ldquo;%s %s %.2f\\n\u0026rdquo;, primer.title,primer.author, primer.value); 对于一些结构（如，有 30 个成员的结构），这个方法用起来很不方 便。另外，在检索时还存在问题，因为程序要知道一个字段结束和另一个字 段开始的位置。虽然用固定字段宽度的格式可以解决这个问题（例 如，\u0026quot;%39s%39s%8.2f\u0026rdquo;），但是这个方法仍然很笨拙。\n更好的方案是使用fread()和fwrite()函数读写结构大小的单元。回忆一 下，这两个函数使用与程序相同的二进制表示法。例如： fwrite(\u0026amp;primer, sizeof(struct book), 1, pbooks); 定位到 primer 结构变量开始的位置，并把结构中所有的字节都拷贝到 与 pbooks 相关的文件中。sizeof(struct book)告诉函数待拷贝的一块数据的大 小， 1 表明一次拷贝一块数据。带相同参数的fread()函数从文件中拷贝一块 结构大小的数据到\u0026amp;primer指向的位置。简而言之，这两个函数一次读写整 个记录，而不是一个字段。 以二进制表示法储存数据的缺点是，不同的系统可能使用不同的二进制 表示法，所以数据文件可能不具可移植性。甚至同一个系统，不同编译器设 置也可能导致不同的二进制布局。\n14.8.1 保存结构的程序示例 # 为了演示如何在程序中使用这些函数，我们把程序清单14.2修改为一个 # 新的版本（即程序清单14.14），把书名保存在book.dat文件中。如果该文件 已存在，程序将显示它当前的内容，然后允许在文件中添加内容（如果你使 用的是早期的Borland编译器，请参阅程序清单14.2后面的“Borland C和浮点 数”）。 程序清单 14.14 booksave.c 程序 /* booksave.c \u0026ndash; 在文件中保存结构中的内容 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXTITL 40\n#define MAXAUTL 40 #define MAXBKS 10　/* 最大书籍数量 / char * s_gets(char * st, int n); struct book { / 建立 book 模板 / char title[MAXTITL]; char author[MAXAUTL]; float value; }; int main(void) { struct book library[MAXBKS]; / 结构数组 */ int count = 0; int index, filecount; FILE * pbooks; int size = sizeof(struct book); if ((pbooks = fopen(\u0026ldquo;book.dat\u0026rdquo;, \u0026ldquo;a+b\u0026rdquo;)) == NULL) { fputs(\u0026ldquo;Can\u0026rsquo;t open book.dat file\\n\u0026rdquo;, stderr); exit(1);\n} # rewind(pbooks); /* 定位到文件开始 */ while (count \u0026lt; MAXBKS \u0026amp;\u0026amp; fread(\u0026amp;library[count], size, 1, pbooks) == 1) { if (count == 0) puts(\u0026ldquo;Current contents of book.dat:\u0026rdquo;); printf(\u0026quot;%s by %s: $%.2f\\n\u0026quot;, library[count].title, library[count].author, library[count].value); count++; } filecount = count; if (count == MAXBKS) { fputs(\u0026ldquo;The book.dat file is full.\u0026rdquo;, stderr); exit(2); } puts(\u0026ldquo;Please add new book titles.\u0026rdquo;); puts(\u0026ldquo;Press [enter] at the start of a line to stop.\u0026rdquo;);\nwhile (count \u0026lt; MAXBKS \u0026amp;\u0026amp; s_gets(library[count].title, MAXTITL) != NULL \u0026amp;\u0026amp; library[count].title[0] != \u0026lsquo;\\0\u0026rsquo;) { puts(\u0026ldquo;Now enter the author.\u0026rdquo;); s_gets(library[count].author, MAXAUTL); puts(\u0026ldquo;Now enter the value.\u0026rdquo;); scanf(\u0026quot;%f\u0026quot;, \u0026amp;library[count++].value); while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; /* 清理输入行 */ if (count \u0026lt; MAXBKS) puts(\u0026ldquo;Enter the next title.\u0026rdquo;); } if (count \u0026gt; 0) { puts(\u0026ldquo;Here is the list of your books:\u0026rdquo;); for (index = 0; index \u0026lt; count; index++) printf(\u0026quot;%s by %s: $%.2f\\n\u0026quot;, library[index].title, library[index].author, library[index].value);\nfwrite(\u0026amp;library[filecount], size, count - filecount, pbooks); } else puts(\u0026ldquo;No books? Too bad.\\n\u0026rdquo;); puts(\u0026ldquo;Bye.\\n\u0026rdquo;); fclose(pbooks); return 0; } char * s_gets(char * st, int n) { char * ret_val; char * find; ret_val = fgets(st, n, stdin); if (ret_val) { find = strchr(st, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是 NULL， *find = \u0026lsquo;\\0\u0026rsquo;; // 在此处放置一个空字符\nelse while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; // 清理输入行 } return ret_val; } 我们先看几个运行示例，然后再讨论程序中的要点。 $ booksave Please add new book titles. Press [enter] at the start of a line to stop. Metric Merriment Now enter the author. Polly Poetica Now enter the value. 18.99 Enter the next title. Deadly Farce Now enter the author. Dudley Forse\nNow enter the value. 15.99 Enter the next title. [enter] Here is the list of your books: Metric Merriment by Polly Poetica: $18.99 Deadly Farce by Dudley Forse: $15.99 Bye. $ booksave Current contents of book.dat: Metric Merriment by Polly Poetica: $18.99 Deadly Farce by Dudley Forse: $15.99 Please add new book titles. The Third Jar Now enter the author. Nellie Nostrum Now enter the value. 22.99 Enter the next title.\n[enter] Here is the list of your books: Metric Merriment by Polly Poetica: $18.99 Deadly Farce by Dudley Forse: $15.99 The Third Jar by Nellie Nostrum: $22.99 Bye. $ 再次运行booksave.c程序把这 3 本书作为当前的文件记录打印出来。 14.8.2 程序要点 # 首先，以\u0026quot;a+b\u0026quot;模式打开文件。a+部分允许程序读取整个文件并在文件 的末尾添加内容。b 是 ANSI的一种标识方法，表明程序将使用二进制文件 格式。对于不接受b模式的UNIX系统，可以省略b，因为UNIX只有一种文件 形式。对于早期的ANSI实现，要找出和b等价的表示法。 我们选择二进制模式是因为fread()和fwrite()函数要使用二进制文件。虽 然结构中有些内容是文本，但是value成员不是文本。如果使用文本编辑器 查看book.dat，该结构本文部分的内容显示正常，但是数值部分的内容不可 读，甚至会导致文本编辑器出现乱码。 rewrite()函数确保文件指针位于文件开始处，为读文件做好准备。 第 1 个while循环每次把一个结构读到结构数组中，当数组已满或读完文 件时停止。变量filecount统计已读结构的数量。 第 2 个while按下循环提示用户进行输入，并接受用户的输入。和程序清 单14.2一样，当数组已满或用户在一行的开始处按下Enter键时，循环结束。\n注意，该循环开始时count变量的值是第 1 个循环结束后的值。该循环把新输 入项添加到数组的末尾。 然后for循环打印文件和用户输入的数据。因为该文件是以附加模式打 开，所以新写入的内容添加到文件现有内容的末尾。 我们本可以用一个循环在文件末尾一次添加一个结构，但还是决定用 fwrite()一次写入一块数据。对表达式count - filecount求值得新添加的书籍数 量，然后调用fwrite()把结构大小的块写入文件。由于表达式 \u0026amp;library[filecount]是数组中第 1 个新结构的地址，所以拷贝就从这里开始。 也许该例是把结构写入文件和检索它们的最简单的方法，但是这种方法 浪费存储空间，因为这还保存了结构中未使用的部分。该结构的大小是 2×40×sizeof(char)+sizeof(float)，在我们的系统中共 84 字节。实际上不是每个 输入项都需要这么多空间。但是，让每个输入块的大小相同在检索数据时很 方便。 另一个方法是使用可变大小的记录。为了方便读取文件中的这种记录， 每个记录以数值字段规定记录的大小。这比上一种方法复杂。通常，这种方 法涉及接下来要介绍的“链式结构”和第 16 章的动态内存分配。\n14.9 链式结构 # 在结束讨论结构之前，我们想简要介绍一下结构的多种用途之一：创建 # 新的数据形式。计算机用户已经开发出的一些数据形式比我们提到过的数组 # 和简单结构更有效地解决特定的问题。这些形式包括队列、二叉树、堆、哈 # 希表和图表。许多这样的形式都由链式结构（linked structure）组成。通 常，每个结构都包含一两个数据项和一两个指向其他同类型结构的指针。这 些指针把一个结构和另一个结构链接起来，并提供一种路径能遍历整个彼此 链接的结构。例如，图14.3演示了一个二叉树结构，每个单独的结构（或节 点）都和它下面的两个结构（或节点）相连。\n图14.3 一个二叉树结构 图14.3中显示的分级或树状的结构是否比数组高效？考虑一个有 10 级节 点的树的情况。它有 210 −1（或 1023 ）个节点，可以储存 1023 个单词。如果 这些单词以某种规则排列，那么可以从最顶层开始，逐级向下移动查找单 词，最多只需移动 9 次便可找到任意单词。如果把这些单词都放在一个数组 中，最多要查找 1023 个元素才能找出所需的单词。 如果你对这些高级概念感兴趣，可以阅读一些关于数据结构的书籍。使 用C结构，可以创建和使用那些书中介绍的各种数据形式。另外，第 17 章中 也介绍了一些高级数据形式。 本章对结构的概念介绍至此为止，第 17 章中会给出链式结构的例子。下\n面，我们介绍C语言中的联合、枚举和typedef。\n14.10 联合简介 # 联合（union）是一种数据类型，它能在同一个内存空间中储存不同的 数据类型（不是同时储存）。其典型的用法是，设计一种表以储存既无规 律、事先也不知道顺序的混合类型。使用联合类型的数组，其中的联合都大 小相等，每个联合可以储存各种数据类型。 创建联合和创建结构的方式相同，需要一个联合模板和联合变量。可以 用一个步骤定义联合，也可以用联合标记分两步定义。下面是一个带标记的 联合模板： union hold { int digit; double bigfl; char letter; }; 根据以上形式声明的结构可以储存一个int类型、一个double类型和char 类型的值。然而，声明的联合只能储存一个int类型的值或一个double类型的 值或char类型的值。 下面定义了 3 个与hold类型相关的变量： union hold fit; // hold类型的联合变量 union hold save[10]; // 内含 10 个联合变量的数组 union hold * pu; // 指向hold类型联合变量的指针 第 1 个声明创建了一个单独的联合变量fit。编译器分配足够的空间以便 它能储存联合声明中占用最大字节的类型。在本例中，占用空间最大的是\ndouble类型的数据。在我们的系统中，double类型占 64 位，即 8 字节。第 2 个 声明创建了一个数组save，内含 10 个元素，每个元素都是 8 字节。第 3 个声明 创建了一个指针，该指针变量储存hold类型联合变量的地址。 可以初始化联合。需要注意的是，联合只能储存一个值，这与结构不 同。有 3 种初始化的方法：把一个联合初始化为另一个同类型的联合；初始 化联合的第 1 个元素；或者根据C99标准，使用指定初始化器： union hold valA; valA.letter = \u0026lsquo;R\u0026rsquo;; union hold valB = valA; // 用另一个联合来初始化 union hold valC = {88}; // 初始化联合的digit 成员 union hold valD = {.bigfl = 118.2}; // 指定初始化器\n14.10.1 使用联合 # 下面是联合的一些用法： # fit.digit = 23; //把 23 储存在 fit，占 2 字节 fit.bigfl = 2.0; // 清除 23 ，储存 2.0，占 8 字节 fit.letter = \u0026lsquo;h\u0026rsquo;; // 清除2.0，储存h，占 1 字节 点运算符表示正在使用哪种数据类型。在联合中，一次只储存一个值。 即使有足够的空间，也不能同时储存一个char类型值和一个int类型值。编写 代码时要注意当前储存在联合中的数据类型。 和用指针访问结构使用-\u0026gt;运算符一样，用指针访问联合时也要使用-\u0026gt;运 算符： pu = \u0026amp;fit;\nx = pu-\u0026gt;digit; // 相当于 x = fit.digit 不要像下面的语句序列这样： fit.letter = \u0026lsquo;A\u0026rsquo;; flnum = 3.02*fit.bigfl; // 错误 以上语句序列是错误的，因为储存在 fit 中的是 char 类型，但是下一行 却假定 fit 中的内容是double类型。 不过，用一个成员把值储存在一个联合中，然后用另一个成员查看内 容，这种做法有时很有用。下一章的程序清单15.4就给出了一个这样的例 子。 联合的另一种用法是，在结构中储存与其成员有从属关系的信息。例 如，假设用一个结构表示一辆汽车。如果汽车属于驾驶者，就要用一个结构 成员来描述这个所有者。如果汽车被租赁，那么需要一个成员来描述其租赁 公司。可以用下面的代码来完成： struct owner { char socsecurity[12]; \u0026hellip; }; struct leasecompany { char name[40]; char headquarters[40]; \u0026hellip;\n}; # union data { struct owner owncar; struct leasecompany leasecar; }; struct car_data { char make[15]; int status; /* 私有为 0 ，租赁为1 */ union data ownerinfo; \u0026hellip; }; 假设flits是car_data类型的结构变量，如果flits.status为 0 ，程序将使用 flits.ownerinfo.owncar.socsecurity，如果flits.status为 1 ，程序则使用 flits.ownerinfo.leasecar.name。\n14.10.2 匿名联合（ C11 ） # 匿名联合和匿名结构的工作原理相同，即匿名联合是一个结构或联合的 # 无名联合成员。例如，我们重新定义car_data结构如下： struct owner { char socsecurity[12]; \u0026hellip;\n}; # struct leasecompany { char name[40]; char headquarters[40]; \u0026hellip; }; struct car_data { char make[15]; int status; /* 私有为 0 ，租赁为1 */ union { struct owner owncar; struct leasecompany leasecar; }; . }; 现在，如果 flits 是 car_data 类型的结构变量，可以用 flits.owncar.socsecurity 代替flits.ownerinfo.owncar.socsecurity。 总结：结构和联合运算符 成员运算符：.\n一般注释： # 该运算符与结构或联合名一起使用，指定结构或联合的一个成员。如果 # name是一个结构的名称， member是该结构模版指定的一个成员名，下面标 识了该结构的这个成员： name.member name.member的类型就是member的类型。联合使用成员运算符的方式与 结构相同。 示例： struct { int code; float cost; } item; item.code = 1265; 间接成员运算符： -\u0026gt; 一般注释： 该运算符和指向结构或联合的指针一起使用，标识结构或联合的一个成 员。假设ptrstr是指向结构的指针，member是该结构模版指定的一个成员， 那么： ptrstr-\u0026gt;member 标识了指向结构的成员。联合使用间接成员运算符的方式与结构相同。 示例：\nstruct { int code; float cost; } item, * ptrst; ptrst = \u0026amp;item; ptrst-\u0026gt;code = 3451; 最后一条语句把一个int类型的值赋给item的code成员。如下 3 个表达式 是等价的： ptrst-\u0026gt;code item.code (*ptrst).code\n14.11 枚举类型 # 可以用枚举类型（enumerated type）声明符号名称来表示整型常量。使 用enum关键字，可以创建一个新“类型”并指定它可具有的值（实际上，enum 常量是int类型，因此，只要能使用int类型的地方就可以使用枚举类型）。枚 举类型的目的是提高程序的可读性。它的语法与结构的语法相同。例如，可 以这样声明： enum spectrum {red, orange, yellow, green, blue, violet}; enum spectrum color; 第 1 个声明创建了spetrum作为标记名，允许把enum spetrum作为一个类型 名使用。第 2 个声明使color作为该类型的变量。第 1 个声明中花括号内的标 识符枚举了spectrum变量可能有的值。因此， color 可能的值是 red、 orange、yellow 等。这些符号常量被称为枚举符（enumerator）。然后，便 可这样用： int c; color = blue; if (color == yellow) \u0026hellip;; for (color = red; color \u0026lt;= violet; color++) \u0026hellip;; 虽然枚举符（如red和blue）是int类型，但是枚举变量可以是任意整数类 型，前提是该整数类型可以储存枚举常量。例如，spectrum的枚举符范围是 0 ～ 5 ，所以编译器可以用unsigned char来表示color变量。\n顺带一提，C枚举的一些特性并不适用于C++。例如，C允许枚举变量 # 使用++运算符，但是C++标准不允许。所以，如果编写的代码将来会并入 # C++程序，那么必须把上面例子中的color声明为int类型，才能C和C++都兼 容。\n14.11.1 enum 常量 # blue和red到底是什么？从技术层面看，它们是int类型的常量。例如，假 定有前面的枚举声明，可以这样写： printf(\u0026ldquo;red = %d, orange = %d\\n\u0026rdquo;, red, orange); 其输出如下： red = 0, orange = 1 red成为一个有名称的常量，代表整数 0 。类似地，其他标识符都是有名 称的常量，分别代表 1 ～ 5 。只要是能使用整型常量的地方就可以使用枚举常 量。例如，在声明数组时，可以用枚举常量表示数组的大小；在switch语句 中，可以把枚举常量作为标签。\n14.11.2 默认值 # 默认情况下，枚举列表中的常量都被赋予 0 、 1 、 2 等。因此，下面的声 # 明中nina的值是 3 ： enum kids {nippy, slats, skippy, nina, liz};\n14.11.3 赋值 # 在枚举声明中，可以为枚举常量指定整数值： # enum levels {low = 100, medium = 500, high = 2000}; 如果只给一个枚举常量赋值，没有对后面的枚举常量赋值，那么后面的 常量会被赋予后续的值。例如，假设有如下的声明： # enum feline {cat, lynx = 10, puma, tiger}; 那么，cat的值是 0 （默认），lynx、puma和tiger的值分别是 10 、 11 、 12 。\n14.11.4 enum 的用法 # 枚举类型的目的是为了提高程序的可读性和可维护性。如果要处理颜 # 色，使用red和blue比使用 0 和 1 更直观。注意，枚举类型只能在内部使用。如 果要输入color中orange的值，只能输入 1 ，而不是单词orange。或者，让程序 先读入字符串\u0026quot;orange\u0026quot;，再将其转换为orange代表的值。 因为枚举类型是整数类型，所以可以在表达式中以使用整数变量的方式 使用enum变量。它们用在case语句中很方便。 程序清单14.15演示了一个使用enum的小程序。该程序示例使用默认值 的方案，把red的值设置为 0 ，使之成为指向字符串\u0026quot;red\u0026quot;的指针的索引。 程序清单 14.15 enum.c 程序 /* enum.c \u0026ndash; 使用枚举类型的值 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; // 提供 strcmp()、strchr()函数的原型 #include \u0026lt;stdbool.h\u0026gt; // C99 特性 char * s_gets(char * st, int n); enum spectrum { red, orange, yellow, green, blue, violet }; const char * colors [] = { \u0026ldquo;red\u0026rdquo;, \u0026ldquo;orange\u0026rdquo;, \u0026ldquo;yellow\u0026rdquo;,\n\u0026ldquo;green\u0026rdquo;, \u0026ldquo;blue\u0026rdquo;, \u0026ldquo;violet\u0026rdquo; }; #define LEN 30 int main(void) { char choice[LEN]; enum spectrum color; bool color_is_found = false; puts(\u0026ldquo;Enter a color (empty line to quit):\u0026rdquo;); while (s_gets(choice, LEN) != NULL \u0026amp;\u0026amp; choice[0] != \u0026lsquo;\\0\u0026rsquo;) { for (color = red; color \u0026lt;= violet; color++) { if (strcmp(choice, colors[color]) == 0) { color_is_found = true; break; } } if (color_is_found)\nswitch (color) { case red: puts(\u0026ldquo;Roses are red.\u0026rdquo;); break; case orange: puts(\u0026ldquo;Poppies are orange.\u0026rdquo;); break; case yellow: puts(\u0026ldquo;Sunflowers are yellow.\u0026rdquo;); break; case green: puts(\u0026ldquo;Grass is green.\u0026rdquo;); break; case blue: puts(\u0026ldquo;Bluebells are blue.\u0026rdquo;); break; case violet: puts(\u0026ldquo;Violets are violet.\u0026rdquo;); break; } else printf(\u0026ldquo;I don\u0026rsquo;t know about the color %s.\\n\u0026rdquo;, choice); color_is_found = false; puts(\u0026ldquo;Next color, please (empty line to quit):\u0026rdquo;);\n} # puts(\u0026ldquo;Goodbye!\u0026rdquo;); return 0; } char * s_gets(char * st, int n) { char * ret_val; char * find; ret_val = fgets(st, n, stdin); if (ret_val) { find = strchr(st, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是 NULL， *find = \u0026lsquo;\\0\u0026rsquo;; // 在此处放置一个空字符 else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; // 清理输入行 } return ret_val;\n} # 当输入的字符串与color数组的成员指向的字符串相匹配时，for循环结 束。如果循环找到匹配的颜色，程序就用枚举变量的值与作为case标签的枚 举常量匹配。下面是该程序的一个运行示例： Enter a color (empty line to quit): blue Bluebells are blue. Next color, please (empty line to quit): orange Poppies are orange. Next color, please (empty line to quit): purple I don\u0026rsquo;t know about the color purple. Next color, please (empty line to quit): Goodbye!\n14.11.5 共享名称空间 # C语言使用名称空间（namespace）标识程序中的各部分，即通过名称来 识别。作用域是名称空间概念的一部分：两个不同作用域的同名变量不冲 突；两个相同作用域的同名变量冲突。名称空间是分类别的。在特定作用域 中的结构标记、联合标记和枚举标记都共享相同的名称空间，该名称空间与 普通变量使用的空间不同。这意味着在相同作用域中变量和标记的名称可以 相同，不会引起冲突，但是不能在相同作用域中声明两个同名标签或同名变\n量。例如，在C中，下面的代码不会产生冲突： # struct rect { double x; double y; }; int rect; // 在C中不会产生冲突 尽管如此，以两种不同的方式使用相同的标识符会造成混乱。另外， C++不允许这样做，因为它把标记名和变量名放在相同的名称空间中。\n14.12 typedef 简介 # typedef工具是一个高级数据特性，利用typedef可以为某一类型自定义名 称。这方面与#define类似，但是两者有 3 处不同： 与#define不同，typedef创建的符号名只受限于类型，不能用于值。 typedef由编译器解释，不是预处理器。 在其受限范围内，typedef比#define更灵活。 下面介绍typedef的工作原理。假设要用BYTE表示 1 字节的数组。只需像 定义个char类型变量一样定义BYTE，然后在定义前面加上关键字typedef即 可： typedef unsigned char BYTE; 随后，便可使用BYTE来定义变量： BYTE x, y[10], * z; 该定义的作用域取决于typedef定义所在的位置。如果定义在函数中，就 具有局部作用域，受限于定义所在的函数。如果定义在函数外面，就具有文 件作用域。 通常，typedef定义中用大写字母表示被定义的名称，以提醒用户这个类 型名实际上是一个符号缩写。当然，也可以用小写： typedef unsigned char byte; typedef中使用的名称遵循变量的命名规则。 为现有类型创建一个名称，看上去真是多此一举，但是它有时的确很有 用。在前面的示例中，用BYTE代替unsigned char表明你打算用BYTE类型的 变量表示数字，而不是字符码。使用typedef还能提高程序的可移植性。例\n如，我们之前提到的sizeof运算符的返回类型：size_t类型，以及time()函数 的返回类型：time_t类型。C标准规定sizeof和time()返回整数类型，但是让实 现来决定具体是什么整数类型。其原因是，C 标准委员会认为没有哪个类型 对于所有的计算机平台都是最优选择。所以，标准委员会决定建立一个新的 类型名（如，time_t），并让实现使用typedef来设置它的具体类型。以这样 的方式，C标准提供以下通用原型： time_t time(time_t *); time_t 在一个系统中是 unsigned long，在另一个系统中可以是 unsigned long long。只要包含time.h头文件，程序就能访问合适的定义，你也可以在 代码中声明time_t类型的变量。 typedef的一些特性与#define的功能重合。例如： #define BYTE unsigned char 这使预处理器用BYTE替换unsigned char。但是也有#define没有的功能： typedef char * STRING; 没有typedef关键字，编译器将把STRING识别为一个指向char的指针变 量。有了typedef关键字，编译器则把STRING解释成一个类型的标识符，该 类型是指向char的指针。因此： STRING name, sign; 相当于： char * name, * sign; 但是，如果这样假设： #define STRING char *\n然后，下面的声明： # STRING name, sign; 将被翻译成： char * name, sign; 这导致只有name才是指针。 还可以把typedef用于结构： typedef struct complex { float real; float imag; } COMPLEX; 然后便可使用COMPLEX类型代替complex结构来表示复数。使用typedef 的第 1 个原因是：为经常出现的类型创建一个方便、易识别的类型名。例 如，前面的例子中，许多人更倾向于使用 STRING 或与其等价的标记。 用typedef来命名一个结构类型时，可以省略该结构的标签： typedef struct {double x; double y;} rect; 假设这样使用typedef定义的类型名： rect r1 = {3.0, 6.0}; rect r2; 以上代码将被翻译成： struct {double x; double y;} r1= {3.0, 6.0};\nstruct {double x; double y;} r2; r2 = r1; 这两个结构在声明时都没有标记，它们的成员完全相同（成员名及其类 型都匹配），C认为这两个结构的类型相同，所以r1和r2间的赋值是有效操 作。 使用typedef的第 2 个原因是：typedef常用于给复杂的类型命名。例如， 下面的声明： typedef char (* FRPTC ()) [5]; 把FRPTC声明为一个函数类型，该函数返回一个指针，该指针指向内含 5 个char类型元素的数组（参见下一节的讨论）。 使用typedef时要记住，typedef并没有创建任何新类型，它只是为某个已 存在的类型增加了一个方便使用的标签。以前面的STRING为例，这意味着 我们创建的STRING类型变量可以作为实参传递给以指向char指针作为形参 的函数。 通过结构、联合和typedef，C提供了有效处理数据的工具和处理可移植 数据的工具。\n14.13 其他复杂的声明 # C 允许用户自定义数据形式。虽然我们常用的是一些简单的形式，但是 # 根据需要有时还会用到一些复杂的形式。在一些复杂的声明中，常包含下面 # 的符号，如表14.1所示： # 表14.1 声明时可使用的符号 下面是一些较复杂的声明示例： # int board[8][8]; // 声明一个内含int数组的数组 int ** ptr; // 声明一个指向指针的指针，被指向的指针指向int int * risks[10]; // 声明一个内含 10 个元素的数组，每个元素都是一 个指向int的指针 int (* rusks)[10]; // 声明一个指向数组的指针，该数组内含 10 个int类 型的值 int * oof[3][4]; // 声明一个3×4 的二维数组，每个元素都是指向int 的指针 int (* uuf)[3][4]; // 声明一个指向3×4二维数组的指针，该数组中内含 int类型值 int (* uof[3])[4]; // 声明一个内含 3 个指针元素的数组，其中每个指针 都指向一个内含 4 个int类型元素的数组 要看懂以上声明，关键要理解*、()和[]的优先级。记住下面几条规则。\n1.数组名后面的[]和函数名后面的()具有相同的优先级。它们比*（解引 # 用运算符）的优先级高。因此下面声明的risk是一个指针数组，不是指向数 组的指针： int * risks[10]; 2.[]和()的优先级相同，由于都是从左往右结合，所以下面的声明中， 在应用方括号之前，先与rusks结合。因此rusks是一个指向数组的指针，该 数组内含 10 个int类型的元素： int ( rusks)[10]; 3.[]和()都是从左往右结合。因此下面声明的goods是一个由 12 个内含 50 个int类型值的数组组成的二维数组，不是一个有 50 个内含 12 个int类型值的数 组组成的二维数组： int goods[12][50]; 把以上规则应用于下面的声明： int * oof[3][4]; [3]比的优先级高，由于从左往右结合，所以[3]先与oof结合。因此， oof首先是一个内含 3 个元素的数组。然后再与[4]结合，所以oof的每个元素 都是内含 4 个元素的数组。说明这些元素都是指针。最后，int表明了这 4 个 元素都是指向int的指针。因此，这条声明要表达的是：foo是一个内含 3 个元 素的数组，其中每个元素是由 4 个指向int的指针组成的数组。简而言之，oof 是一个3×4的二维数组，每个元素都是指向int的指针。编译器要为 12 个指针 预留存储空间。 现在来看下面的声明： int ( uuf)[3][4]; 圆括号使得先与uuf结合，说明uuf是一个指针，所以uuf是一个指向3×4\n的int类型二维数组的指针。编译器要为一个指针预留存储空间。 根据这些规则，还可以声明： char * fump(int); // 返回字符指针的函数 char (* frump)(int); // 指向函数的指针，该函数的返回类型为char char (* flump[3])(int); // 内含 3 个指针的数组，每个指针都指向返回 类型为char的函数 这 3 个函数都接受int类型的参数。 可以使用typedef建立一系列相关类型： typedef int arr5[5]; typedef arr5 * p_arr5; typedef p_arr5 arrp10[10]; arr5 togs; // togs 是一个内含 5 个int类型值的数组 p_arr5 p2; // p2 是一个指向数组的指针，该数组内含 5 个int类型的值 arrp10 ap; // ap 是一个内含 10 个指针的数组，每个指针都指向一个 内含 5 个int类型值的数组 如果把这些放入结构中，声明会更复杂。至于应用，我们就不再进一步 讨论了。\n14.14 函数和指针 # 通过上一节的学习可知，可以声明一个指向函数的指针。这个复杂的玩 # 意儿到底有何用处？通常，函数指针常用作另一个函数的参数，告诉该函数 # 要使用哪一个函数。例如，排序数组涉及比较两个元素，以确定先后。如果 # 元素是数字，可以使用\u0026gt;运算符；如果元素是字符串或结构，就要调用函数 # 进行比较。C库中的 qsort()函数可以处理任意类型的数组，但是要告诉 qsort()使用哪个函数来比较元素。为此， qsort()函数的参数列表中，有一个 参数接受指向函数的指针。然后，qsort()函数使用该函数提供的方案进行排 序，无论这个数组中的元素是整数、字符串还是结构。 我们来进一步研究函数指针。首先，什么是函数指针？假设有一个指向 int类型变量的指针，该指针储存着这个int类型变量储存在内存位置的地址。 同样，函数也有地址，因为函数的机器语言实现由载入内存的代码组成。指 向函数的指针中储存着函数代码的起始处的地址。 其次，声明一个数据指针时，必须声明指针所指向的数据类型。声明一 个函数指针时，必须声明指针指向的函数类型。为了指明函数类型，要指明 函数签名，即函数的返回类型和形参类型。例如，考虑下面的函数原型： void ToUpper(char *); // 把字符串中的字符转换成大写字符 ToUpper()函数的类型是“带char * 类型参数、返回类型是void的函数”。 下面声明了一个指针pf指向该函数类型： void (*pf)(char ); // pf 是一个指向函数的指针 从该声明可以看出，第 1 对圆括号把和pf括起来，表明pf是一个指向函 数的指针。因此，(*pf)是一个参数列表为(char *)、返回类型为void的函数。 注意，把函数名ToUpper替换为表达式(*pf)是创建指向函数指针最简单的方 式。所以，如果想声明一个指向某类型函数的指针，可以写出该函数的原型 后把函数名替换成(pf)形式的表达式，创建函数指针声明。前面提到过，由 于运算符优先级的规则，在声明函数指针时必须把和指针名括起来。如果\n省略第 1 个圆括号会导致完全不同的情况： # void *pf(char *); // pf 是一个返回字符指针的函数 提示 要声明一个指向特定类型函数的指针，可以先声明一个该类型的函数， 然后把函数名替换成(*pf)形式的表达式。然后，pf就成为指向该类型函数的 指针。 声明了函数指针后，可以把类型匹配的函数地址赋给它。在这种上下文 中，函数名可以用于表示函数的地址： void ToUpper(char *); void ToLower(char *); int round(double); void (*pf)(char *); pf = ToUpper; // 有效，ToUpper是该类型函数的地址 pf = ToLower; //有效，ToUpper是该类型函数的地址 pf = round; // 无效，round与指针类型不匹配 pf = ToLower(); // 无效，ToLower()不是地址 最后一条语句是无效的，不仅因为 ToLower()不是地址，而且 ToLower()的返回类型是 void，它没有返回值，不能在赋值语句中进行赋 值。注意，指针pf可以指向其他带char *类型参数、返回类型是void的函数， 不能指向其他类型的函数。 既然可以用数据指针访问数据，也可以用函数指针访问函数。奇怪的 是，有两种逻辑上不一致的语法可以这样做，下面解释：\nvoid ToUpper(char *); void ToLower(char *); void (*pf)(char *); char mis[] = \u0026ldquo;Nina Metier\u0026rdquo;; pf = ToUpper; (pf)(mis); // 把ToUpper 作用于（语法 1 ） pf = ToLower; pf(mis); // 把ToLower 作用于（语法 2 ） 这两种方法看上去都合情合理。先分析第 1 种方法：由于pf指向ToUpper 函数，那么pf就相当于ToUpper函数，所以表达式(*pf)(mis)和ToUpper(mis) 相同。从ToUpper函数和pf的声明就能看出，ToUpper和(*pf)是等价的。第 2 种方法：由于函数名是指针，那么指针和函数名可以互换使用，所以pf(mis) 和ToUpper(mis)相同。从pf的赋值表达式语句就能看出ToUpper和pf是等价 的。由于历史的原因，贝尔实验室的C和UNIX的开发者采用第 1 种形式，而 伯克利的UNIX推广者却采用第 2 种形式。K\u0026amp;R C不允许第 2 种形式。但是， 为了与现有代码兼容，ANSI C认为这两种形式（本例中是(pf)(mis)和 pf(mis)）等价。后续的标准也延续了这种矛盾的和谐。 作为函数的参数是数据指针最常见的用法之一，函数指针亦如此。例 如，考虑下面的函数原型： void show(void ( fp)(char *), char * str); 这看上去让人头晕。它声明了两个形参：fp和str。fp形参是一个函数指 针，str是一个数据指针。更具体地说，fp指向的函数接受char * 类型的参 数，其返回类型为void；str指向一个char类型的值。因此，假设有上面的声 明，可以这样调用函数：\nshow(ToLower, mis); /* show()使用ToLower()函数：fp = ToLower / show(pf, mis); / show()使用pf指向的函数： fp = pf */ show()如何使用传入的函数指针？是用fp()语法还是(fp)()语法调用函 数： void show(void ( fp)(char *), char * str) { (fp)(str); / 把所选函数作用于str / puts(str); / 显示结果 / } 例如，这里的show()首先用fp指向的函数转换str，然后显示转换后的字 符串。 顺带一提，把带返回值的函数作为参数传递给另一个函数有两种不同的 方法。例如，考虑下面的语句： function1(sqrt); / 传递sqrt()函数的地址 / function2(sqrt(4.0)); / 传递sqrt()函数的返回值 */ 第 1 条语句传递的是sqrt()函数的地址，假设function1()在其代码中会使 用该函数。第 2 条语句先调用sqrt()函数，然后求值，并把返回值（该例中是 2.0）传递给function2()。 程序清单14.16中的程序通过show()函数来演示这些要点，该函数以各 种转换函数作为参数。该程序也演示了一些处理菜单的有用技巧。 程序清单 14.16 func_ptr.c 程序\n// func_ptr.c \u0026ndash; 使用函数指针 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #define LEN 81 char * s_gets(char * st, int n); char showmenu(void); void eatline(void); // 读取至行末尾 void show(void(*fp)(char *), char * str); void ToUpper(char *); // 把字符串转换为大写 void ToLower(char *); // 把字符串转换为小写 void Transpose(char *); // 大小写转置 void Dummy(char *); // 不更改字符串 int main(void) { char line[LEN]; char copy[LEN]; char choice; void(*pfun)(char *); // 声明一个函数指针，被指向的函数接受char *类型\n的参数，无返回值 # puts(\u0026#34;Enter a string (empty line to quit):\u0026#34;); while (s_gets(line, LEN) != NULL \u0026amp;\u0026amp; line[0] != \u0026#39;\\0\u0026#39;) { while ((choice = showmenu()) != \u0026#39;n\u0026#39;) { switch (choice) // switch语句设置指针 { case \u0026#39;u\u0026#39;: pfun = ToUpper; break; case \u0026#39;l\u0026#39;: pfun = ToLower; break; case \u0026#39;t\u0026#39;: pfun = Transpose; break; case \u0026#39;o\u0026#39;: pfun = Dummy; break; } strcpy(copy, line); // 为show()函数拷贝一份 show(pfun, copy); // 根据用户的选择，使用选定的函数 } puts(\u0026#34;Enter a string (empty line to quit):\u0026#34;); } puts(\u0026#34;Bye!\u0026#34;); return 0; } char showmenu(void) { char ans; puts(\u0026ldquo;Enter menu choice:\u0026rdquo;); puts(\u0026ldquo;u) uppercase l) lowercase\u0026rdquo;); puts(\u0026ldquo;t) transposed case o) original case\u0026rdquo;); puts(\u0026ldquo;n) next string\u0026rdquo;); ans = getchar(); // 获取用户的输入 ans = tolower(ans); // 转换为小写 eatline(); // 清理输入行 while (strchr(\u0026ldquo;ulton\u0026rdquo;, ans) == NULL) { puts(\u0026ldquo;Please enter a u, l, t, o, or n:\u0026rdquo;); ans = tolower(getchar()); eatline(); } return ans;\n} # void eatline(void) { while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } void ToUpper(char * str) { while (*str) { *str = toupper(*str); str++; } } void ToLower(char * str) { while (*str) { *str = tolower(*str);\nstr++; } } void Transpose(char * str) { while (*str) { if (islower(*str)) *str = toupper(*str); else if (isupper(*str)) *str = tolower(*str); str++; } } void Dummy(char * str) { // 不改变字符串 } void show(void(*fp)(char *), char * str)\n{ # (*fp)(str); // 把用户选定的函数作用于str puts(str); // 显示结果 } char * s_gets(char * st, int n) { char * ret_val; char * find; ret_val = fgets(st, n, stdin); if (ret_val) { find = strchr(st, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是NULL， *find = \u0026lsquo;\\0\u0026rsquo;; // 在此处放置一个空字符 else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; // 清理输入行中剩余的字符 } return ret_val;\n} # 下面是该程序的输出示例： # Enter a string (empty line to quit): Does C make you feel loopy? Enter menu choice: u) uppercase l) lowercase t) transposed case o) original case n) next string t dOES c MAKE YOU FEEL LOOPY? Enter menu choice: u) uppercase l) lowercase t) transposed case o) original case n) next string l does c make you feel loopy? Enter menu choice: u) uppercase l) lowercase t) transposed case o) original case\nn) next string n Enter a string (empty line to quit): Bye! 注意，ToUpper()、ToLower()、Transpose()和 Dummy()函数的类型都相 同，所以这 4 个函数都可以赋给pfun指针。该程序把pfun作为show()的参 数，但是也可以直接把这 4 个函数中的任一个函数名作为参数，如 show(Transpose, copy)。 这种情况下，可以使用typedef。例如，该程序中可以这样写： typedef void (*V_FP_CHARP)(char *); void show (V_FP_CHARP fp, char ); V_FP_CHARP pfun; 如果还想更复杂一些，可以声明并初始化一个函数指针的数组： V_FP_CHARP arpf[4] = {ToUpper, ToLower, Transpose, Dummy}; 然后把showmenu()函数的返回类型改为int，如果用户输入u，则返回 0 ； 如果用户输入l，则返回 2 ；如果用户输入t，则返回 2 ，以此类推。可以把程 序中的switch语句替换成下面的while循环： index = showmenu(); while (index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt;= 3) { strcpy(copy, line); / 为show()拷贝一份 */\nshow(arpf[index], copy); /* 使用选定的函数 */ index = showmenu(); } 虽然没有函数数组，但是可以有函数指针数组。 以上介绍了使用函数名的 4 种方法：定义函数、声明函数、调用函数和 作为指针。图14.4进行了总结。\n图14.4 函数名的用法 至于如何处理菜单，showmenu()函数给出了几种技巧。首先，下面的代 码： ans = getchar(); // 获取用户输入 ans = tolower(ans); // 转换成小写 和 ans = tolower(getchar()); 演示了转换用户输入的两种方法。这两种方法都可以把用户输入的字符 转换为一种大小写形式，这样就不用检测用户输入的是\u0026rsquo;u\u0026rsquo;还是\u0026rsquo;U\u0026rsquo;，等等。 eatline()函数丢弃输入行中的剩余字符，在处理这两种情况时很有用。 第一，用户为了输入一个选择，输入一个字符，然后按下Enter键，将产生 一个换行符。如果不处理这个换行符，它将成为下一次读取的第 1 个字符。\n第二，假设用户输入的是整个单词uppercase，而不是一个字母u。如果 没有 eatline()函数，程序会把uppercase中的字符作为用户的响应依次读取。有了 eatline()，程序会读取u字符并丢弃输入行中剩余的字符。 其次，showmenu()函数的设计意图是，只给程序返回正确的选项。为完 成这项任务，程序使用了string.h头文件中的标准库函数strchr()： while (strchr(\u0026ldquo;ulton\u0026rdquo;, ans) == NULL) 该函数在字符串\u0026quot;ulton\u0026quot;中查找字符ans首次出现的位置，并返回一个指 向该字符的指针。如果没有找到该字符，则返回空指针。因此，上面的 while循环头可以用下面的while循环头代替，但是上面的用起来更方便： while (ans != \u0026lsquo;u\u0026rsquo; \u0026amp;\u0026amp; ans != \u0026rsquo;l\u0026rsquo; \u0026amp;\u0026amp; ans != \u0026rsquo;t\u0026rsquo; \u0026amp;\u0026amp; ans != \u0026lsquo;o\u0026rsquo; \u0026amp;\u0026amp; ans != \u0026rsquo;n\u0026rsquo;) 待检查的项越多，使用strchr()就越方便。\n14.15 关键概念 # 我们在编程中要表示的信息通常不只是一个数字或一些列数字。程序可 # 能要处理具有多种属性的实体。例如，通过姓名、地址、电话号码和其他信 # 息表示一名客户；或者，通过电影名、发行人、播放时长、售价等表示一部 # 电影DVD。C结构可以把这些信息都放在一个单元内。在组织程序时这很重 # 要，因为这样可以把相关的信息都储存在一处，而不是分散储存在多个变量 # 中。 # 设计结构时，开发一个与之配套的函数包通常很有用。例如，写一个以 # 结构（或结构的地址）为参数的函数打印结构内容，比用一堆printf()语句强 得多。因为只需要一个参数就能打印结构中的所有信息。如果把信息放到零 散的变量中，每个部分都需要一个参数。另外，如果要在结构中增加一个成 员，只需重写函数，不必改写函数调用。这在修改结构时很方便。 联合声明与结构声明类似。但是，联合的成员共享相同的存储空间，而 且在联合中同一时间内只能有一个成员。实质上，可以在联合变量中储存一 个类型不唯一的值。 enum 工具提供一种定义符号常量的方法，typedef 工具提供一种为基本 或派生类型创建新标识符的方法。 指向函数的指针提供一种告诉函数应使用哪一个函数的方法。\n14.16 本章小结 # C 结构提供在相同的数据对象中储存多个不同类型数据项的方法。可以 # 使用标记来标识一个具体的结构模板，并声明该类型的变量。通过成员点运 # 算符（.）可以使用结构模版中的标签来访问结构的各个成员。 # 如果有一个指向结构的指针，可以用该指针和间接成员运算符（-\u0026gt;）代 # 替结构名和点运算符来访问结构的各成员。和数组不同，结构名不是结构的 # 地址，要在结构名前使用\u0026amp;运算符才能获得结构的地址。 # 一贯以来，与结构相关的函数都使用指向结构的指针作为参数。现在的 # C允许把结构作为参数传递，作为返回值和同类型结构之间赋值。然而，传 # 递结构的地址通常更有效。 # 联合使用与结构相同的语法。然而，联合的成员共享一个共同的存储空 # 间。联合同一时间内只能储存一个单独的数据项，不像结构那样同时储存多 # 种数据类型。也就是说，结构可以同时储存一个int类型数据、一个double类 型数据和一个char类型数据，而相应的联合只能保存一个int类型数据，或者 一个double类型数据，或者一个char类型数据。 通过枚举可以创建一系列代表整型常量（枚举常量）的符号和定义相关 联的枚举类型。 typedef工具可用于建立C标准类型的别名或缩写。 函数名代表函数的地址，可以把函数的地址作为参数传递给其他函数， 然后这些函数就可以使用被指向的函数。如果把特定函数的地址赋给一个名 为pf的函数指针，可以通过以下两种方式调用该函数： #include \u0026lt;math.h\u0026gt; /* 提供sin()函数的原型：double sin(double) */ \u0026hellip; double (*pdf)(double);\ndouble x; pdf = sin; x = (*pdf)(1.2); // 调用sin(1.2) x = pdf(1.2); // 同样调用 sin(1.2)\n14.17 复习题 # 复习题的参考答案在附录A中。 # 1.下面的结构模板有什么问题： # structure { char itable; int num[20]; char * togs } 2.下面是程序的一部分，输出是什么？ #include \u0026lt;stdio.h\u0026gt; struct house { float sqft; int rooms; int stories; char address[40]; }; int main(void) { struct house fruzt = {1560.0, 6, 1, \u0026ldquo;22 Spiffo Road\u0026rdquo;};\nstruct house sign; sign = \u0026amp;fruzt; printf(\u0026quot;%d %d\\n\u0026quot;, fruzt.rooms, sign-\u0026gt;stories); printf(\u0026quot;%s \\n\u0026quot;, fruzt.address); printf(\u0026quot;%c %c\\n\u0026quot;, sign-\u0026gt;address[3], fruzt.address[4]); return 0; } 3.设计一个结构模板储存一个月份名、该月份名的 3 个字母缩写、该月 的天数以及月份号。 4.定义一个数组，内含 12 个结构（第 3 题的结构类型）并初始化为一个 年份（非闰年）。 5.编写一个函数，用户提供月份号，该函数就返回一年中到该月为止 （包括该月）的总天数。假设在所有函数的外部声明了第 3 题的结构模版和 一个该类型结构的数组。 6.a.假设有下面的 typedef，声明一个内含 10 个指定结构的数组。然 后，单独给成员赋值（或等价字符串），使第 3 个元素表示一个焦距长度有 500mm，孔径为f/2.0的Remarkata镜头。 typedef struct lens { / 描述镜头　/ float foclen; / 焦距长度，单位为mm / float fstop; / 孔径　/ char brand[30]; / 品牌名称　*/\n} LENS; # b.重写a，在声明中使用一个待指定初始化器的初始化列表，而不是对 每个成员单独赋值。 7.考虑下面程序片段： struct name { char first[20]; char last[20]; }; struct bem { int limbs; struct name title; char type[30]; }; struct bem * pb; struct bem deb = { 6, { \u0026ldquo;Berbnazel\u0026rdquo;, \u0026ldquo;Gwolkapwolk\u0026rdquo; }, \u0026ldquo;Arcturan\u0026rdquo; };\npb = \u0026amp;deb; a.下面的语句分别打印什么？ printf(\u0026quot;%d\\n\u0026quot;, deb.limbs); printf(\u0026quot;%s\\n\u0026quot;, pb-\u0026gt;type); printf(\u0026quot;%s\\n\u0026quot;, pb-\u0026gt;type + 2); b.如何用结构表示法（两种方法）表示\u0026quot;Gwolkapwolk\u0026quot;？ c.编写一个函数，以bem结构的地址作为参数，并以下面的形式输出结 构的内容（假定结构模板在一个名为starfolk.h的头文件中）： Berbnazel Gwolkapwolk is a 6-limbed Arcturan. 8.考虑下面的声明： struct fullname { char fname[20]; char lname[20]; }; struct bard { struct fullname name; int born; int died; };\nstruct bard willie; struct bard *pt = \u0026amp;willie; a.用willie标识符标识willie结构的born成员。 b.用pt标识符标识willie结构的born成员。 c.调用scanf()读入一个用willie标识符标识的born成员的值。 d.调用scanf()读入一个用pt标识符标识的born成员的值。 e.调用scanf()读入一个用willie标识符标识的name成员中lname成员的 值。 f.调用scanf()读入一个用pt标识符标识的name成员中lname成员的值。 g.构造一个标识符，标识willie结构变量所表示的姓名中名的第 3 个字母 （英文的名在前）。 h.构造一个表达式，表示willie结构变量所表示的名和姓中的字母总 数。 9.定义一个结构模板以储存这些项：汽车名、马力、EPA（美国环保 局）城市交通MPG（每加仑燃料行驶的英里数）评级、轴距和出厂年份。 使用car作为该模版的标记。 10.假设有如下结构： struct gas { float distance; float gals; float mpg;\n}; # a.设计一个函数，接受struct gas类型的参数。假设传入的结构包含 distance和gals信息。该函数为mpg成员计算正确的值，并把值返回该结构。 b.设计一个函数，接受struct gas类型的参数。假设传入的结构包含 distance和gals信息。该函数为mpg成员计算正确的值，并把该值赋给合适的 成员。 11.声明一个标记为choices的枚举，把枚举常量no、yes和maybe分别设置 为 0 、 1 、 2 。 12.声明一个指向函数的指针，该函数返回指向char的指针，接受一个指 向char的指针和一个char类型的值。 13.声明 4 个函数，并初始化一个指向这些函数的指针数组。每个函数都 接受两个double类型的参数，返回double类型的值。另外，用两种方法使用 该数组调用带10.0和2.5实参的第 2 个函数。\n14.18 编程练习 # 1.重新编写复习题 5 ，用月份名的拼写代替月份号（别忘了使用 # strcmp()）。在一个简单的程序中测试该函数。 2.编写一个函数，提示用户输入日、月和年。月份可以是月份号、月份 名或月份名缩写。然后该程序应返回一年中到用户指定日子（包括这一天） 的总天数。 3.修改程序清单 14.2 中的图书目录程序，使其按照输入图书的顺序输出 图书的信息，然后按照标题字母的声明输出图书的信息，最后按照价格的升 序输出图书的信息。 4.编写一个程序，创建一个有两个成员的结构模板： a.第 1 个成员是社会保险号，第 2 个成员是一个有 3 个成员的结构，第 1 个 成员代表名，第 2 个成员代表中间名，第 3 个成员表示姓。创建并初始化一个 内含 5 个该类型结构的数组。该程序以下面的格式打印数据： Dribble, Flossie M.–– 302039823 如果有中间名，只打印它的第 1 个字母，后面加一个点（.）；如果没有 中间名，则不用打印点。编写一个程序进行打印，把结构数组传递给这个函 数。 b.修改a部分，传递结构的值而不是结构的地址。 5.编写一个程序满足下面的要求。 a.外部定义一个有两个成员的结构模板name：一个字符串储存名，一个 字符串储存姓。 b.外部定义一个有 3 个成员的结构模板student：一个name类型的结构， 一个grade数组储存 3 个浮点型分数，一个变量储存 3 个分数平均数。\nc.在main()函数中声明一个内含CSIZE（CSIZE = 4）个student类型结构的 数组，并初始化这些结构的名字部分。用函数执行g、e、f和g中描述的任 务。 d.以交互的方式获取每个学生的成绩，提示用户输入学生的姓名和分 数。把分数储存到grade数组相应的结构中。可以在main()函数或其他函数中 用循环来完成。 e.计算每个结构的平均分，并把计算后的值赋给合适的成员。 f.打印每个结构的信息。 g.打印班级的平均分，即所有结构的数值成员的平均值。 6.一个文本文件中保存着一个垒球队的信息。每行数据都是这样排列： 4 Jessie Joybat 5 2 1 1 第 1 项是球员号，为方便起见，其范围是 0 ～ 18 。第 2 项是球员的名。第 3 项是球员的姓。名和姓都是一个单词。第 4 项是官方统计的球员上场次数。 接着 3 项分别是击中数、走垒数和打点（RBI）。文件可能包含多场比赛的 数据，所以同一位球员可能有多行数据，而且同一位球员的多行数据之间可 能有其他球员的数据。编写一个程序，把数据储存到一个结构数组中。该结 构中的成员要分别表示球员的名、姓、上场次数、击中数、走垒数、打点和 安打率（稍后计算）。可以使用球员号作为数组的索引。该程序要读到文件 结尾，并统计每位球员的各项累计总和。 世界棒球统计与之相关。例如，一次走垒和触垒中的失误不计入上场次 数，但是可能产生一个RBI。但是该程序要做的是像下面描述的一样读取和 处理数据文件，不会关心数据的实际含义。 要实现这些功能，最简单的方法是把结构的内容都初始化为零，把文件 中的数据读入临时变量中，然后将其加入相应的结构中。程序读完文件后， 应计算每位球员的安打率，并把计算结果储存到结构的相应成员中。计算安\n打率是用球员的累计击中数除以上场累计次数。这是一个浮点数计算。最 # 后，程序结合整个球队的统计数据，一行显示一位球员的累计数据。 # 7.修改程序清单 14.14，从文件中读取每条记录并显示出来，允许用户 # 删除记录或修改记录的内容。如果删除记录，把空出来的空间留给下一个要 # 读入的记录。要修改现有的文件内容，必须用\u0026quot;r+b\u0026quot;模式，而不是\u0026quot;a+b\u0026quot;模 式。而且，必须更加注意定位文件指针，防止新加入的记录覆盖现有记录。 最简单的方法是改动储存在内存中的所有数据，然后再把最后的信息写入文 件。跟踪的一个方法是在book结构中添加一个成员表示是否该项被删除。 8.巨人航空公司的机群由 12 个座位的飞机组成。它每天飞行一个航 班。根据下面的要求，编写一个座位预订程序。 a.该程序使用一个内含 12 个结构的数组。每个结构中包括：一个成员 表示座位编号、一个成员表示座位是否已被预订、一个成员表示预订人的 名、一个成员表示预订人的姓。 b.该程序显示下面的菜单： To choose a function, enter its letter label: a) Show number of empty seats b) Show list of empty seats c) Show alphabetical list of seats d) Assign a customer to a seat assignment e) Delete a seat assignment f) Quit c.该程序能成功执行上面给出的菜单。选择d)和e)要提示用户进行额外 输入，每个选项都能让用户中止输入。\nd.执行特定程序后，该程序再次显示菜单，除非用户选择f)。 9.巨人航空公司（编程练习 8 ）需要另一架飞机（容量相同），每天飞 4 班（航班 102 、 311 、 444 和 519 ）。把程序扩展为可以处理 4 个航班。用一 个顶层菜单提供航班选择和退出。选择一个特定航班，就会出现和编程练习 8 类似的菜单。但是该菜单要添加一个新选项：确认座位分配。而且，菜单 中的退出是返回顶层菜单。每次显示都要指明当前正在处理的航班号。另 外，座位分配显示要指明确认状态。 10.编写一个程序，通过一个函数指针数组实现菜单。例如，选择菜单 中的 a，将激活由该数组第 1 个元素指向的函数。 11.编写一个名为transform()的函数，接受 4 个参数：内含double类型数据 的源数组名、内含double类型数据的目标数组名、一个表示数组元素个数的 int类型参数、函数名（或等价的函数指针）。transform()函数应把指定函数 应用于源数组中的每个元素，并把返回值储存在目标数组中。例如： transform(source, target, 100, sin); 该声明会把target[0]设置为sin(source[0])，等等，共有 100 个元素。在一 个程序中调用transform()4次，以测试该函数。分别使用math.h函数库中的两 个函数以及自定义的两个函数作为参数。\n[1].也被称为标记化结构初始化语法。——译者注\n第 15 章 位操作 # 本章介绍以下内容： # 运算符：～、\u0026amp;、|、^、 # \u0026laquo;、\u0026raquo; # \u0026amp;=、|=、^=、\u0026raquo;=、\u0026laquo;= # 二进制、十进制和十六进制记数法（复习） # 处理一个值中的位的两个C工具：位运算符和位字段 # 关键字：_Alignas、_Alignof 在C语言中，可以单独操控变量中的位。读者可能好奇，竟然有人想这 样做。有时必须单独操控位，而且非常有用。例如，通常向硬件设备发送一 两个字节来控制这些设备，其中每个位（bit）都有特定的含义。另外，与 文件相关的操作系统信息经常被储存，通过使用特定位表明特定项。许多压 缩和加密操作都是直接处理单独的位。高级语言一般不会处理这级别的细 节，C 在提供高级语言便利的同时，还能在为汇编语言所保留的级别上工 作，这使其成为编写设备驱动程序和嵌入式代码的首选语言。 首先要介绍位、字节、二进制记数法和其他进制记数系统的一些背景知 识。\n15.1 二进制数、位和字节 # 通常都是基于数字 10 来书写数字。例如 2157 的千位是 2 ，百位是 1 ，十位 # 是 5 ，个位是 7 ，可以写成： # 2×1000 + 1×100 + 5×10 + 7×1 # 注意， 1000 是 10 的立方（即 3 次幂）， 100 是 10 的平方（即 2 次幂）， 10 # 是 10 的 1 次幂，而且 10 （以及任意正数）的 0 次幂是 1 。因此， 2157 也可以写 # 成： # 2×10^3 + 1×10^2 + 5×10^1 + 7×10^0 # 因为这种书写数字的方法是基于 10 的幂，所以称以 10 为基底书写 2157 。 # 姑且认为十进制系统得以发展是得益于我们都有 10 根手指。从某种意义 # 上看，计算机的位只有 2 根手指，因为它只能被设置为 0 或 1 ，关闭或打开。 # 因此，计算机适用基底为 2 的数制系统。它用 2 的幂而不是 10 的幂。以 2 为基 # 底表示的数字被称为二进制数（binary number）。二进制中的 2 和十进制中 的 10 作用相同。例如，二进制数 1101 可表示为：\n1×2^3 + 1×2^2 + 0×2^1 + 1×2^0 以十进制数表示为： 1×8 + 1×4 + 0×2 + 1×1 = 13 用二进制系统可以把任意整数（如果有足够的位）表示为 0 和 1 的组合。 由于数字计算机通过关闭和打开状态的组合来表示信息，这两种状态分别用 0 和 1 来表示，所以使用这套数制系统非常方便。接下来，我们来学习二进制 系统如何表示 1 字节的整数。\n15.1.1 二进制整数 # 通常， 1 字节包含 8 位。C语言用字节（byte）表示储存系统字符集所需 的大小，所以C字节可能是 8 位、 9 位、 16 位或其他值。不过，描述存储器芯 片和数据传输率中所用的字节指的是 8 位字节。为了简化起见，本章假设 1 字 节是 8 位（计算机界通常用八位组(octet)这个术语特指 8 位字节）。可以从左 往右给这 8 位分别编号为 7 ～ 0 。在 1 字节中，编号是 7 的位被称为高阶位 （high-order bit），编号是 0 的位被称为低阶位（low-order bit）。每 1 位的 编号对应 2 的相应指数。因此，可以根据图15.1所示的例子理解字节。\n图15.1 位编号和位值 这里， 128 是 2 的 7 次幂，以此类推。该字节能表示的最大数字是把所有 位都设置为 1 ： 11111111 。这个二进制数的值是： 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255 而该字节最小的二进制数是 00000000 ，其值为 0 。因此， 1 字节可储存 0 ～ 255 范围内的数字，总共 256 个值。或者，通过不同的方式解释位组合 （bit pattern），程序可以用 1 字节储存-128～+127范围内的整数，总共还是 256 个值。例如，通常unsigned char用 1 字节表示的范围是 0 ～ 255 ，而signed char用 1 字节表示的范围是-128～+127。\n15.1.2 有符号整数 # 如何表示有符号整数取决于硬件，而不是C语言。也许表示有符号数最 # 简单的方式是用 1 位（如，高阶位）储存符号，只剩下 7 位表示数字本身（假 # 设储存在 1 字节中）。用这种符号量（sign-magnitude）表示法， 10000001 表 示−1， 00000001 表示 1 。因此，其表示范围是−127～+127。 这种方法的缺点是有两个 0 ：+0和-0。这很容易混淆，而且用两个位组 合来表示一个值也有些浪费。 二进制补码（two’s-complement）方法避免了这个问题，是当今最常用 的系统。我们将以 1 字节为例，讨论这种方法。二进制补码用 1 字节中的后 7 位表示 0 ～ 127 ，高阶位设置为 0 。目前，这种方法和符号量的方法相同。另 外，如果高阶位是 1 ，表示的值为负。这两种方法的区别在于如何确定负 值。从一个 9 位组合 100000000 （ 256 的二进制形式）减去一个负数的位组 合，结果是该负值的量。例如，假设一个负值的位组合是 10000000 ，作为 一个无符号字节，该组合为表示 128 ；作为一个有符号值，该组合表示负值 （编码是 7 的位为 1 ），而且值为100000000-10000000，即 1000000 （ 128 ）。因此，该数是-128（在符号量表示法中，该位组合表示 −0）。类似地， 10000001 是−127， 11111111 是−1。该方法可以表示−128～ +127范围内的数。 要得到一个二进制补码数的相反数，最简单的方法是反转每一位（即 0 变为 1 ， 1 变为 0 ），然后加 1 。因为 1 是 00000001 ，那么−1则是11111110+1， 或 11111111 。这与上面的介绍一致。 二进制反码（one’s-complement）方法通过反转位组合中的每一位形成 一个负数。例如， 00000001 是 1 ，那么 11111110 是−1。这种方法也有一个 −0： 11111111 。该方法能表示-127～+127之间的数。\n15.1.3 二进制浮点数 # 浮点数分两部分储存：二进制小数和二进制指数。下面我们将详细介 # 绍。 # 1. 二进制小数 # 一个普通的浮点数0.527，表示如下： # 5/10 + 2/100 + 7/1000 # 从左往右，各分母都是 10 的递增次幂。在二进制小数中，使用 2 的幂作 # 为分母，所以二进制小数.101表示为： # 1/2 + 0/4 + 1/8 # 用十进制表示法为： # 0.50 + 0.00 + 0.125 # 即是0.625。 # 许多分数（如，1/3）不能用十进制表示法精确地表示。与此类似，许 # 多分数也不能用二进制表示法准确地表示。实际上，二进制表示法只能精确 # 地表示多个1/2的幂的和。因此，3/4和7/8可以精确地表示为二进制小数，但 # 是1/3和2/5却不能。 # 2. 浮点数表示法 # 为了在计算机中表示一个浮点数，要留出若干位（因系统而异）储存二 # 进制分数，其他位储存指数。一般而言，数字的实际值是由二进制小数乘以 # 2 的指定次幂组成。例如，一个浮点数乘以 4 ，那么二进制小数不变，其指数 # 乘以 2 ，二进制分数不变。如果一份浮点数乘以一个不是 2 的幂的数，会改变 # 二进制小数部分，如有必要，也会改变指数部分。 # 15.2 其他进制数 # 计算机界通常使用八进制记数系统和十六进制记数系统。因为 8 和 16 都 # 是 2 的幂，这些系统比十进制系统更接近计算机的二进制系统。 # 15.2.1 八进制 # 八进制（octal）是指八进制记数系统。该系统基于 8 的幂，用 0 ～ 7 表示 数字（正如十进制用 0 ～ 9 表示数字一样）。例如，八进制数 451 （在C中写 作 0451 ）表示为：\n4×8^2 + 5×8^1 + 1×8^0 = 297（十进制） 了解八进制的一个简单的方法是，每个八进制位对应 3 个二进制位。表 15.1列出了这种对应关系。这种关系使得八进制与二进制之间的转换很容 易。例如，八进制数 0377 的二进制形式是 11111111 。即，用 111 代替 0377 中 的最后一个 7 ，再用 111 代替倒数第 2 个 7 ，最后用 011 代替 3 ，并舍去第 1 位的 0 。这表明比 0377 大的八进制要用多个字节表示。这是八进制唯一不方便的 地方：一个 3 位的八进制数可能要用 9 位二进制数来表示。注意，将八进制数 转换为二进制形式时，不能去掉中间的 0 。例如，八进制数 0173 的二进制形 式是 01111011 ，不是 0111111 。 表15.1 与八进制位等价的二进制位\n15.2.2 十六进制 # 十六进制（hexadecimal或hex）是指十六进制记数系统。该系统基于 16 的幂，用 0 ～ 15 表示数字。但是，由于没有单独的数（digit，即 0 ～ 9 这样单\n独一位的数）表示 10 ～ 15 ，所以用字母A～F来表示。例如，十六进制数 # A3F（在C中写作0xA3F）表示为：\n10×16^2 +3×16^1 + 15×16^0 = 2623（十进制） 由于A表示 10 ，F表示 15 。在C语言中，A～F既可用小写也可用大写。 因此， 2623 也可写作0xa3f。 每个十六进制位都对应一个 4 位的二进制数（即 4 个二进制位），那么两 个十六进制位恰好对应一个 8 位字节。第 1 个十六进制表示前 4 位，第 2 个十六 进制位表示后 4 位。因此，十六进制很适合表示字节值。 表15.2列出了各进制之间的对应关系。例如，十六进制值0xC2可转换为 11000010 。相反，二进制值 11010101 可以看作是 1101 0101 ，可转换为 0xD5。 表15.2 十进制、十六进制和等价的二进制\n介绍了位和字节的相关内容，接下来我们研究C用位和字节进行哪些操 # 作。C有两个操控位的工具。第 1 个工具是一套（ 6 个）作用于位的按位运 # 算符。第 2 个工具是字段（field）数据形式，用于访问 int中的位。下面将 简要介绍这些C的特性。\n15.3 C 按位运算符 # C 提供按位逻辑运算符和移位运算符。在下面的例子中，为了方便读者 # 了解位的操作，我们用二进制记数法写出值。但是在实际的程序中不必这 # 样，用一般形式的整型变量或常量即可。例如，在程序中用 25 或 031 或 # 0x19，而不是 00011001 。另外，下面的例子均使用 8 位二进制数，从左往右 每位的编号为 7 ～ 0 。\n15.3.1 按位逻辑运算符 # 4 个按位逻辑运算符都用于整型数据，包括char。之所以叫作按位 （bitwise）运算，是因为这些操作都是针对每一个位进行，不影响它左右两 边的位。不要把这些运算符与常规的逻辑运算符（\u0026amp;\u0026amp;、||和！）混淆，常规 的逻辑运算符操作的是整个值。\n1. 二进制反码或按位取反：～ 一元运算符～把 1 变为 0 ，把 0 变为 1 。如下例子所示： ～(10011010) // 表达式 (01100101) // 结果值 假设val的类型是unsigned char，已被赋值为 2 。在二进制中， 00000010 表示 2 。那么，～val的值是 11111101 ，即 253 。注意，该运算符不会改变val 的值，就像3 * val不会改变val的值一样， val仍然是 2 。但是，该运算符确实 创建了一个可以使用或赋值的新值： newval = ～val; printf(\u0026quot;%d\u0026quot;, ～val); 如果要把val的值改为～val，使用下面这条语句：\nval = ～val; 2. 按位与： \u0026amp; 二元运算符\u0026amp;通过逐位比较两个运算对象，生成一个新值。对于每个 位，只有两个运算对象中相应的位都为 1 时，结果才为 1 （从真/假方面看， 只有当两个位都为真时，结果才为真）。因此，对下面的表达式求值： (10010011) \u0026amp; (00111101) // 表达式 由于两个运算对象中编号为 4 和 0 的位都为 1 ，得： (00010001) // 结果值 C有一个按位与和赋值结合的运算符：\u0026amp;=。下面两条语句产生的最终结 果相同： val \u0026amp;= 0377; val = val \u0026amp; 0377; 3. 按位或： | 二元运算符|，通过逐位比较两个运算对象，生成一个新值。对于每个 位，如果两个运算对象中相应的位为 1 ，结果就为 1 （从真/假方面看，如果 两个运算对象中相应的一个位为真或两个位都为真，那么结果为真）。因 此，对下面的表达式求值： (10010011) | (00111101) // 表达式 除了编号为 6 的位，这两个运算对象的其他位至少有一个位为 1 ，得： (10111111) // 结果值 C有一个按位或和赋值结合的运算符：|=。下面两条语句产生的最终作 用相同：\nval |= 0377; val = val | 0377; 4. 按位异或： ^ 二元运算符^逐位比较两个运算对象。对于每个位，如果两个运算对象 中相应的位一个为 1 （但不是两个为 1 ），结果为 1 （从真/假方面看，如果两 个运算对象中相应的一个位为真且不是两个为同为 1 ，那么结果为真）。因 此，对下面表达式求值： (10010011) ^ (00111101) // 表达式 编号为 0 的位都是 1 ，所以结果为 0 ，得： (10101110) // 结果值 C有一个按位异或和赋值结合的运算符：^=。下面两条语句产生的最终 作用相同： val ^= 0377; val = val ^ 0377;\n15.3.2 用法：掩码 # 按位与运算符常用于掩码（mask）。所谓掩码指的是一些设置为开 （ 1 ）或关（ 0 ）的位组合。要明白称其为掩码的原因，先来看通过\u0026amp;把一个 量与掩码结合后发生什么情况。例如，假设定义符号常量MASK为 2 （即， 二进制形式为 00000010 ），只有 1 号位是 1 ，其他位都是 0 。下面的语句： flags = flags \u0026amp; MASK; 把flags中除 1 号位以外的所有位都设置为 0 ，因为使用按位与运算符 （\u0026amp;）任何位与 0 组合都得 0 。 1 号位的值不变（如果 1 号位是 1 ，那么 1\u0026amp;1得\n1 ；如果 1 号位是 0 ，那么 0\u0026amp;1也得 0 ）。这个过程叫作“使用掩码”，因为掩 # 码中的 0 隐藏了flags中相应的位。 可以这样类比：把掩码中的 0 看作不透明， 1 看作透明。表达式flags \u0026amp; MASK相当于用掩码覆盖在flags的位组合上，只有MASK为 1 的位才可见（见 图15.2）。\n图15.2 掩码示例 用\u0026amp;=运算符可以简化前面的代码，如下所示： flags \u0026amp;= MASK; 下面这条语句是按位与的一种常见用法： ch \u0026amp;= 0xff; /* 或者 ch \u0026amp;= 0377; */ 前面介绍过oxff的二进制形式是 11111111 ，八进制形式是 0377 。这个掩 码保持ch中最后 8 位不变，其他位都设置为 0 。无论ch原来是 8 位、 16 位或是 其他更多位，最终的值都被修改为 1 个 8 位字节。在该例中，掩码的宽度为 8\n位。 # 15.3.3 用法：打开位（设置位） # 有时，需要打开一个值中的特定位，同时保持其他位不变。例如，一台 # IBM PC 通过向端口发送值来控制硬件。例如，为了打开内置扬声器，必须 # 打开 1 号位，同时保持其他位不变。这种情况可以使用按位或运算符 # （|）。 # 以上一节的flags和MASK（只有 1 号位为 1 ）为例。下面的语句： flags = flags | MASK; 把flags的 1 号位设置为 1 ，且其他位不变。因为使用|运算符，任何位与 0 组合，结果都为本身；任何位与 1 组合，结果都为 1 。 例如，假设flags是 00001111 ，MASK是 10110110 。下面的表达式： flags | MASK 即是： (00001111) | (10110110) // 表达式 其结果为： (10111111) // 结果值 MASK中为 1 的位，flags与其对应的位也为 1 。MASK中为 0 的位，flags与 其对应的位不变。 用|=运算符可以简化上面的代码，如下所示： flags |= MASK; 同样，这种方法根据MASK中为 1 的位，把flags中对应的位设置为 1 ，其\n他位不变。 # 15.3.4 用法：关闭位（清空位） # 和打开特定的位类似，有时也需要在不影响其他位的情况下关闭指定的 # 位。假设要关闭变量flags中的 1 号位。同样，MASK只有 1 号位为 1 （即，打 开）。可以这样做： flags = flags \u0026amp; ～MASK; 由于MASK除 1 号位为 1 以外，其他位全为 0 ，所以～MASK除 1 号位为 0 以外，其他位全为 1 。使用\u0026amp;，任何位与 1 组合都得本身，所以这条语句保持 1 号位不变，改变其他各位。另外，使用\u0026amp;，任何位与 0 组合都的 0 。所以无 论 1 号位的初始值是什么，都将其设置为 0 。 例如，假设flags是 00001111 ，MASK是 10110110 。下面的表达式： flags \u0026amp; ～MASK 即是： (00001111) \u0026amp; ～(10110110) // 表达式 其结果为： (00001001) // 结果值 MASK中为 1 的位在结果中都被设置（清空）为 0 。flags中与MASK为 0 的 位相应的位在结果中都未改变。 可以使用下面的简化形式： flags \u0026amp;= ～MASK;\n15.3.5 用法：切换位 # 切换位指的是打开已关闭的位，或关闭已打开的位。可以使用按位异或 # 运算符（^）切换位。也就是说，假设b是一个位（ 1 或 0 ），如果b为 1 ，则 1^b为 0 ；如果b为 0 ，则1^b为 1 。另外，无论b为 1 还是 0 ，0^b均为b。因此， 如果使用^组合一个值和一个掩码，将切换该值与MASK为 1 的位相对应的 位，该 值与MASK为 0 的位相对应的位不变。要切换flags中的 1 号位，可以使用 下面两种方法： flags = flags ^ MASK; flags ^= MASK; 例如，假设flags是 00001111 ，MASK是 10110110 。表达式： flags ^ MASK 即是： (00001111) ^ (10110110) // 表达式 其结果为： (10111001) // 结果值 flags中与MASK为 1 的位相对应的位都被切换了，MASK为 0 的位相对应 的位不变。\n15.3.6 用法：检查位的值 # 前面介绍了如何改变位的值。有时，需要检查某位的值。例如，flags中 1 号位是否被设置为 1 ？不能这样直接比较flags和MASK： if (flags == MASK) puts(\u0026ldquo;Wow!\u0026rdquo;); /* 不能正常工作 */\n这样做即使flags的 1 号位为 1 ，其他位的值会导致比较结果为假。因此， 必须覆盖flags中的其他位，只用 1 号位和MASK比较： if ((flags \u0026amp; MASK) == MASK) puts(\u0026ldquo;Wow!\u0026rdquo;); 由于按位运算符的优先级比==低，所以必须在flags \u0026amp; MASK周围加上 圆括号。 为了避免信息漏过边界，掩码至少要与其覆盖的值宽度相同。\n15.3.7 移位运算符 # 下面介绍C的移位运算符。移位运算符向左或向右移动位。同样，我们 # 在示例中仍然使用二进制数，有助于读者理解其工作原理。 # 1. 左移： \u0026laquo; # 左移运算符（\u0026laquo;）将其左侧运算对象每一位的值向左移动其右侧运算 # 对象指定的位数。左侧运算对象移出左末端位的值丢失，用 0 填充空出的位 # 置。下面的例子中，每一位都向左移动两个位置： # (10001010) \u0026laquo; 2 // 表达式 # (00101000) // 结果值 # 该操作产生了一个新的位值，但是不改变其运算对象。例如，假设 # stonk为 1 ，那么 stonk\u0026laquo;2为 4 ，但是stonk本身不变，仍为 1 。可以使用左移赋 值运算符（\u0026laquo;=）来更改变量的值。该运算符将变量中的位向左移动其右侧 运算对象给定值的位数。如下例： int stonk = 1; int onkoo;\nonkoo = stonk \u0026lt;\u0026lt; 2; /* 把 4 赋给onkoo */ stonk \u0026lt;\u0026lt;= 2; /* 把stonk的值改为4 */ 2. 右移： \u0026raquo; 右移运算符（\u0026raquo;）将其左侧运算对象每一位的值向右移动其右侧运算 对象指定的位数。左侧运算对象移出右末端位的值丢。对于无符号类型，用 0 填充空出的位置；对于有符号类型，其结果取决于机器。空出的位置可用 0 填充，或者用符号位（即，最左端的位）的副本填充： (10001010) \u0026raquo; 2 // 表达式，有符号值 (00100010) // 在某些系统中的结果值 (10001010) \u0026raquo; 2 // 表达式，有符号值 (11100010) // 在另一些系统上的结果值 下面是无符号值的例子： (10001010) \u0026raquo; 2 // 表达式，无符号值 (00100010) // 所有系统都得到该结果值 每个位向右移动两个位置，空出的位用 0 填充。 右移赋值运算符（\u0026raquo;=）将其左侧的变量向右移动指定数量的位数。如 下所示： int sweet = 16; int ooosw; ooosw = sweet \u0026raquo; 3; // ooosw = 2，sweet的值仍然为 16\nsweet \u0026gt;\u0026gt;=3; // sweet的值为 2 3. 用法：移位运算符 移位运算符针对 2 的幂提供快速有效的乘法和除法： number \u0026laquo; n number乘以 2 的n次幂 number \u0026raquo; n 如果number为非负，则用number除以 2 的n次幂 这些移位运算符类似于在十进制中移动小数点来乘以或除以 10 。 移位运算符还可用于从较大单元中提取一些位。例如，假设用一个 unsigned long类型的值表示颜色值，低阶位字节储存红色的强度，下一个字 节储存绿色的强度，第 3 个字节储存蓝色的强度。随后你希望把每种颜色的 强度分别储存在 3 个不同的unsigned char类型的变量中。那么，可以使用下面 的语句： #define BYTE_MASK 0xff unsigned long color = 0x002a162f; unsigned char blue, green, red; red = color \u0026amp; BYTE_MASK; green = (color \u0026raquo; 8) \u0026amp; BYTE_MASK; blue = (color \u0026raquo; 16) \u0026amp; BYTE_MASK; 以上代码中，使用右移运算符将 8 位颜色值移动至低阶字节，然后使用 掩码技术把低阶字节赋给指定的变量。\n15.3.8 编程示例 # 在第 9 章中，我们用递归的方法编写了一个程序，把数字转换为二进制 # 形式（程序清单 9.8）。现在，要用移位运算符来解决相同的问题。程序清 # 单15.1中的程序，读取用户从键盘输入的整数，将该整数和一个字符串地址 # 传递给itobs()函数（itobs表示interger to binary string，即整数转换成二进制字 符串）。然后，该函数使用移位运算符计算出正确的 1 和 0 的组合，并将其放 入字符串中。 程序清单 15.1 binbit.c 程序 /* binbit.c \u0026ndash; 使用位操作显示二进制 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;limits.h\u0026gt; // 提供 CHAR_BIT 的定义，CHAR_BIT 表示每字节 的位数 char * itobs(int, char *); void show_bstr(const char *); int main(void) { char bin_str[CHAR_BIT * sizeof(int) + 1]; int number; puts(\u0026ldquo;Enter integers and see them in binary.\u0026rdquo;); puts(\u0026ldquo;Non-numeric input terminates program.\u0026rdquo;); while (scanf(\u0026quot;%d\u0026quot;, \u0026amp;number) == 1) { itobs(number, bin_str);\nprintf(\u0026quot;%d is \u0026ldquo;, number); show_bstr(bin_str); putchar(\u0026rsquo;\\n\u0026rsquo;); } puts(\u0026ldquo;Bye!\u0026rdquo;); return 0; } char * itobs(int n, char * ps) { int i; const static int size = CHAR_BIT * sizeof(int); for (i = size - 1; i \u0026gt;= 0; i\u0026ndash;, n \u0026raquo;= 1) ps[i] = (01 \u0026amp; n) + \u0026lsquo;0\u0026rsquo;; ps[size] = \u0026lsquo;\\0\u0026rsquo;; return ps; } /*4位一组显示二进制字符串 */ void show_bstr(const char * str) {\nint i = 0; while (str[i]) /* 不是一个空字符 */ { putchar(str[i]); if (++i % 4 == 0 \u0026amp;\u0026amp; str[i]) putchar(\u0026rsquo; \u0026lsquo;); } } 程序清单15.1使用limits.h中的CHAR_BIT宏，该宏表示char中的位数。 sizeof运算符返回char的大小，所以表达式CHAE_BIT * sizeof(int)表示int类型 的位数。bin_str数组的元素个数是CHAE_BIT * sizeof(int) + 1，留出一个位置 给末尾的空字符。 itobs()函数返回的地址与传入的地址相同，可以把该函数作为printf()的 参数。在该函数中，首次执行for循环时，对01 \u0026amp; n求值。 01 是一个八进制形 式的掩码，该掩码除 0 号位是 1 之外，其他所有位都为 0 。因此，01 \u0026amp; n就是n 最后一位的值。该值为 0 或 1 。但是对数组而言，需要的是字符'0\u0026rsquo;或字符'1\u0026rsquo;。 该值加上'0\u0026rsquo;即可完成这种转换（假设按顺序编码的数字，如 ASCII）。其结 果存放在数组中倒数第 2 个元素中（最后一个元素用来存放空字符）。 顺带一提，用1 \u0026amp; n或01 \u0026amp; n都可以。我们用八进制 1 而不是十进制 1 ，只 是为了更接近计算机的表达方式。 然后，循环执行i\u0026ndash;和n \u0026raquo;= 1。i\u0026ndash;移动到数组的前一个元素，n \u0026raquo;= 1使n 中的所有位向右移动一个位置。进入下一轮迭代时，循环中处理的是n中新 的最右端的值。然后，把该值储存在倒数第 3 个元素中，以此类推。itobs() 函数用这种方式从右往左填充数组。\n可以使用printf()或puts()函数显示最终的字符串，但是程序清单15.1中定 义了show_bstr()函数，以 4 位一组打印字符串，方便阅读。 下面的该程序的运行示例： Enter integers and see them in binary. Non-numeric input terminates program. 7 7 is 0000 0000 0000 0000 0000 0000 0000 0111 2013 2013 is 0000 0000 0000 0000 0000 0111 1101 1101 -1 -1 is 1111 1111 1111 1111 1111 1111 1111 1111 32123 32123 is 0000 0000 0000 0000 0111 1101 0111 1011 q Bye!\n15.3.9 另一个例子 # 我们来看另一个例子。这次要编写的函数用于切换一个值中的后 n 位， 待处理值和 n 都是函数的参数。 ～运算符切换一个字节的所有位，而不是选定的少数位。但是，^运算 符（按位异或）可用于切换单个位。假设创建了一个掩码，把后n位设置为\n1 ，其余位设置为 0 。然后使用^组合掩码和待切换的值便可切换该值的最后n 位，而且其他位不变。方法如下： int invert_end(int num, int bits) { int mask = 0; int bitval = 1; while (bits–– \u0026gt; 0) { mask |= bitval; bitval \u0026laquo;= 1; } return num ^ mask; } while循环用于创建所需的掩码。最初，mask的所有位都为 0 。第 1 轮循 环将mask的 0 号位设置为 1 。然后第 2 轮循环将mask的 1 号位设置为 1 ，以此类 推。循环bits次，mask的后bits位就都被设置为 1 。最后，num ^ mask运算即得 所需的结果。 我们把这个函数放入前面的程序中，测试该函数。如程序清单15.2所 示。 程序清单 15.2 invert4.c 程序 /* invert4.c \u0026ndash; 使用位操作显示二进制 */\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;limits.h\u0026gt; char * itobs(int, char *); void show_bstr(const char *); int invert_end(int num, int bits); int main(void) { char bin_str[CHAR_BIT * sizeof(int) + 1]; int number; puts(\u0026ldquo;Enter integers and see them in binary.\u0026rdquo;); puts(\u0026ldquo;Non-numeric input terminates program.\u0026rdquo;); while (scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;number) == 1) { itobs(number, bin_str); printf(\u0026quot;%d is\\n\u0026quot;, number); show_bstr(bin_str); putchar(\u0026rsquo;\\n\u0026rsquo;); number = invert_end(number, 4); printf(\u0026ldquo;Inverting the last 4 bits gives\\n\u0026rdquo;);\nshow_bstr(itobs(number, bin_str)); putchar(\u0026rsquo;\\n\u0026rsquo;); } puts(\u0026ldquo;Bye!\u0026rdquo;); return 0; } char * itobs(int n, char * ps) { int i; const static int size = CHAR_BIT * sizeof(int); for (i = size - 1; i \u0026gt;= 0; i\u0026ndash;, n \u0026raquo;= 1) ps[i] = (01 \u0026amp; n) + \u0026lsquo;0\u0026rsquo;; ps[size] = \u0026lsquo;\\0\u0026rsquo;; return ps; } /* 以 4 位为一组，显示二进制字符串 */ void show_bstr(const char * str) { int i = 0;\nwhile (str[i]) /* 不是空字符 */ { putchar(str[i]); if (++i % 4 == 0 \u0026amp;\u0026amp; str[i]) putchar(\u0026rsquo; \u0026lsquo;); } } int invert_end(int num, int bits) { int mask = 0; int bitval = 1; while (bits\u0026ndash; \u0026gt; 0) { mask |= bitval; bitval \u0026laquo;= 1; } return num ^ mask; } 下面是该程序的一个运行示例：\nEnter integers and see them in binary. Non-numeric input terminates program. 7 7 is 0000 0000 0000 0000 0000 0000 0000 0111 Inverting the last 4 bits gives 0000 0000 0000 0000 0000 0000 0000 1000 12541 12541 is 0000 0000 0000 0000 0011 0000 1111 1101 Inverting the last 4 bits gives 0000 0000 0000 0000 0011 0000 1111 0010 q Bye!\n15.4 位字段 # 操控位的第 2 种方法是位字段（bit field）。位字段是一个signed int或 unsigned int类型变量中的一组相邻的位（C99和C11新增了_Bool类型的位字 段）。位字段通过一个结构声明来建立，该结构声明为每个字段提供标签， 并确定该字段的宽度。例如，下面的声明建立了一个 4 个 1 位的字段： struct { unsigned int autfd : 1; unsigned int bldfc : 1; unsigned int undln : 1; unsigned int itals : 1; } prnt; 根据该声明，prnt包含 4 个 1 位的字段。现在，可以通过普通的结构成员 运算符（.）单独给这些字段赋值： prnt.itals = 0; prnt.undln = 1; 由于每个字段恰好为 1 位，所以只能为其赋值 1 或 0 。变量prnt被储存在 int大小的内存单元中，但是在本例中只使用了其中的 4 位。 带有位字段的结构提供一种记录设置的方便途径。许多设置（如，字体 的粗体或斜体）就是简单的二选一。例如，开或关、真或假。如果只需要使 用 1 位，就不需要使用整个变量。内含位字段的结构允许在一个存储单元中 储存多个设置。 有时，某些设置也有多个选择，因此需要多位来表示。这没问题，字段\n不限制 1 位大小。可以使用如下的代码： # struct { unsigned int code1 : 2; unsigned int code2 : 2; unsigned int code3 : 8; } prcode; 以上代码创建了两个 2 位的字段和一个 8 位的字段。可以这样赋值： prcode.code1 = 0; prcode.code2 = 3; prcode.code3 = 102; 但是，要确保所赋的值不超出字段可容纳的范围。 如果声明的总位数超过了一个unsigned int类型的大小会怎样？会用到下 一个unsigned int类型的存储位置。一个字段不允许跨越两个unsigned int之间 的边界。编译器会自动移动跨界的字段，保持unsigned int的边界对齐。一旦 发生这种情况，第 1 个unsigned int中会留下一个未命名的“洞”。 可以用未命名的字段宽度“填充”未命名的“洞”。使用一个宽度为 0 的未 命名字段迫使下一个字段与下一个整数对齐： struct { unsigned int field1 : 1 ; unsigned int : 2 ;\nunsigned int field2 : 1 ; unsigned int : 0 ; unsigned int field3 : 1 ; } stuff; 这里，在stuff.field1和stuff.field2之间，有一个 2 位的空隙；stuff.field3将 储存在下一个unsigned int中。 字段储存在一个int中的顺序取决于机器。在有些机器上，存储的顺序是 从左往右，而在另一些机器上，是从右往左。另外，不同的机器中两个字段 边界的位置也有区别。由于这些原因，位字段通常都不容易移植。尽管如 此，有些情况却要用到这种不可移植的特性。例如，以特定硬件设备所用的 形式储存数据。\n15.4.1 位字段示例 # 通常，把位字段作为一种更紧凑储存数据的方式。例如，假设要在屏幕 # 上表示一个方框的属性。为简化问题，我们假设方框具有如下属性： # 方框是透明的或不透明的； # 方框的填充色选自以下调色板：黑色、红色、绿色、黄色、蓝色、紫 # 色、青色或白色； # 边框可见或隐藏； # 边框颜色与填充色使用相同的调色板； # 边框可以使用实线、点线或虚线样式。 # 可以使用单独的变量或全长（full-sized）结构成员来表示每个属性，但 是这样做有些浪费位。例如，只需 1 位即可表示方框是透明还是不透明；只\n需 1 位即可表示边框是显示还是隐藏。 8 种颜色可以用 3 位单元的 8 个可能的值 # 来表示，而 3 种边框样式也只需 2 位单元即可表示。总共 10 位就足够表示方框 # 的 5 个属性设置。 # 一种方案是：一个字节储存方框内部（透明和填充色）的属性，一个字 # 节储存方框边框的属性，每个字节中的空隙用未命名字段填充。struct box_props声明如下： struct box_props { bool opaque : 1 ; unsigned int fill_color : 3 ; unsigned int : 4 ; bool show_border : 1 ; unsigned int border_color : 3 ; unsigned int border_style : 2 ; unsigned int : 2 ; }; 加上未命名的字段，该结构共占用 16 位。如果不使用填充，该结构占 用 10 位。但是要记住，C 以unsigned int作为位字段结构的基本布局单元。 因此，即使一个结构唯一的成员是 1 位字段，该结构的大小也是一个unsigned int类型的大小，unsigned int在我们的系统中是 32 位。另外，以上代码假设 C99新增的_Bool类型可用，在stdbool.h中，bool是_Bool的别名。 对于opaque成员， 1 表示方框不透明， 0 表示透明。show_border成员也 用类似的方法。对于颜色，可以用简单的RGB（即red-green-blue的缩写）表 示。这些颜色都是三原色的混合。显示器通过混合红、绿、蓝像素来产生不\n同的颜色。在早期的计算机色彩中，每个像素都可以打开或关闭，所以可以 # 使用用 1 位来表示三原色中每个二进制颜色的亮度。常用的顺序是，左侧位 # 表示蓝色亮度、中间位表示绿色亮度、右侧位表示红色亮度。表15.3列出了 # 这 8 种可能的组合。fill_color成员和border_color成员可以使用这些组合。最 后，border_style成员可以使用 0 、 1 、 2 来表示实线、点线和虚线样式。 表 15.3 简单的颜色表示\n程序清单15.3中的程序使用box_props结构，该程序用#define创建供结构 成员使用的符号常量。注意，只打开一位即可表示三原色之一。其他颜色用 三原色的组合来表示。例如，紫色由打开的蓝色位和红色位组成，所以，紫 色可表示为BLUE|RED。 程序清单 15.3 fields.c 程序 /* fields.c \u0026ndash; 定义并使用字段 / #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; // C99定义了bool、true、false / 线的样式 */ #define SOLID 0 #define DOTTED 1 #define DASHED 2\n/* 三原色 */ # #define BLUE 4 #define GREEN 2 #define RED 1 /* 混合色 */ #define BLACK 0 #define YELLOW (RED | GREEN) #define MAGENTA (RED | BLUE) #define CYAN (GREEN | BLUE) #define WHITE (RED | GREEN | BLUE) const char * colors[8] = { \u0026ldquo;black\u0026rdquo;, \u0026ldquo;red\u0026rdquo;, \u0026ldquo;green\u0026rdquo;, \u0026ldquo;yellow\u0026rdquo;, \u0026ldquo;blue\u0026rdquo;, \u0026ldquo;magenta\u0026rdquo;, \u0026ldquo;cyan\u0026rdquo;, \u0026ldquo;white\u0026rdquo; }; struct box_props { bool opaque : 1; // 或者 unsigned int （C99以前） unsigned int fill_color : 3; unsigned int : 4; bool show_border : 1; // 或者 unsigned int （C99以前） unsigned int border_color : 3; unsigned int border_style : 2;\nunsigned int : 2; }; void show_settings(const struct box_props * pb); int main(void) { /* 创建并初始化 box_props 结构 */ struct box_props box = { true, YELLOW, true, GREEN, DASHED }; printf(\u0026ldquo;Original box settings:\\n\u0026rdquo;); show_settings(\u0026amp;box); box.opaque = false; box.fill_color = WHITE; box.border_color = MAGENTA; box.border_style = SOLID; printf(\u0026quot;\\nModified box settings:\\n\u0026quot;); show_settings(\u0026amp;box); return 0; } void show_settings(const struct box_props * pb) {\nprintf(\u0026ldquo;Box is %s.\\n\u0026rdquo;, pb-\u0026gt;opaque == true? \u0026ldquo;opaque\u0026rdquo; : \u0026ldquo;transparent\u0026rdquo;); printf(\u0026ldquo;The fill color is %s.\\n\u0026rdquo;, colors[pb-\u0026gt;fill_color]); printf(\u0026ldquo;Border %s.\\n\u0026rdquo;, pb-\u0026gt;show_border == true? \u0026ldquo;shown\u0026rdquo; : \u0026ldquo;not shown\u0026rdquo;); printf(\u0026ldquo;The border color is %s.\\n\u0026rdquo;, colors[pb-\u0026gt;border_color]); printf(\u0026ldquo;The border style is \u0026ldquo;); switch (pb-\u0026gt;border_style) { case SOLID: printf(\u0026ldquo;solid.\\n\u0026rdquo;); break; case DOTTED: printf(\u0026ldquo;dotted.\\n\u0026rdquo;); break; case DASHED: printf(\u0026ldquo;dashed.\\n\u0026rdquo;); break; default: printf(\u0026ldquo;unknown type.\\n\u0026rdquo;); } } 下面是该程序的输出： Original box settings: Box is opaque. The fill color is yellow.\nBorder shown. The border color is green. The border style is dashed. Modified box settings: Box is transparent. The fill color is white. Border shown. The border color is magenta. The border style is solid. 该程序要注意几个要点。首先，初始化位字段结构与初始化普通结构的 语法相同： struct box_props box = {YES, YELLOW , YES, GREEN, DASHED}; 类似地，也可以给位字段成员赋值： box.fill_color = WHITE; 另外，switch语句中也可以使用位字段成员，甚至还可以把位字段成员 用作数组的下标： printf(\u0026ldquo;The fill color is %s.\\n\u0026rdquo;, colors[pb-\u0026gt;fill_color]); 注意，根据 colors 数组的定义，每个索引对应一个表示颜色的字符串， 而每种颜色都把索引值作为该颜色的数值。例如，索引 1 对应字符串\u0026quot;red\u0026rdquo;， 枚举常量red的值是 1 。\n15.4.2 位字段和按位运算符 # 在同类型的编程问题中，位字段和按位运算符是两种可替换的方法，用 # 哪种方法都可以。例如，前面的例子中，使用和unsigned int类型大小相同的 结构储存图形框的信息。也可使用unsigned int变量储存相同的信息。如果不 想用结构成员表示法来访问不同的部分，也可以使用按位运算符来操作。一 般而言，这种方法比较麻烦。接下来，我们来研究这两种方法（程序中使用 了这两种方法，仅为了解释它们的区别，我们并不鼓励这样做）。 可以通过一个联合把结构方法和位方法放在一起。假定声明了 struct box_props 类型，然后这样声明联合： union Views /* 把数据看作结构或unsigned short类型的变量 */ { struct box_props st_view; unsigned short us_view; }; 在某些系统中，unsigned int和box_props类型的结构都占用 16 位内存。 但是，在其他系统中（例如我们使用的系统），unsigned int和box_props都是 32 位。无论哪种情况，通过联合，都可以使用 st_view 成员把一块内存看作 是一个结构，或者使用 us_view 成员把相同的内存块看作是一个unsigned short。结构的哪一个位字段与unsigned short中的哪一位对应？这取决于实现 和硬件。下面的程序示例假设从字节的低阶位端到高阶位端载入结构。也就 是说，结构中的第 1 个位字段对应计算机字的 0 号位（为简化起见，图15.3 以 16 位单元演示了这种情况）。\n图15.3 作为整数和结构的联合 程序清单15.4使用Views联合来比较位字段和按位运算符这两种方法。 在该程序中，box是View联合，所以box.st_view是一个使用位字段的 box_props类型的结构，box.us_view把相同的数据看作是一个unsigned short 类型的变量。联合只允许初始化第 1 个成员，所以初始化值必须与结构相匹 配。该程序分别通过两个函数显示 box 的属性，一个函数接受一个结构，一 个函数接受一个 unsigned short 类型的值。这两种方法都能访问数据，但是 所用的技术不同。该程序还使用了本章前面定义的itobs()函数，以二进制字 符串形式显示数据，以便读者查看每个位的开闭情况。 程序清单 15.4 dualview.c 程序 /* dualview.c \u0026ndash; 位字段和按位运算符 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt;\n#include \u0026lt;limits.h\u0026gt; /* 位字段符号常量 / / 边框线样式　/ #define SOLID 0 #define DOTTED 1 #define DASHED 2 / 三原色 / #define BLUE 4 #define GREEN 2 #define RED 1 / 混合颜色 / #define BLACK 0 #define YELLOW (RED | GREEN) #define MAGENTA (RED | BLUE) #define CYAN (GREEN | BLUE) #define WHITE (RED | GREEN | BLUE) / 按位方法中用到的符号常量 */ #define OPAQUE 0x1 #define FILL_BLUE 0x8\n#define FILL_GREEN 0x4 #define FILL_RED 0x2 #define FILL_MASK 0xE #define BORDER 0x100 #define BORDER_BLUE 0x800 #define BORDER_GREEN 0x400 #define BORDER_RED0x 200 #define BORDER_MASK 0xE00 #define B_SOLID 0 #define B_DOTTED 0x1000 #define B_DASHED 0x2000 #define STYLE_MASK0x 3000 const char * colors[8] = { \u0026ldquo;black\u0026rdquo;, \u0026ldquo;red\u0026rdquo;, \u0026ldquo;green\u0026rdquo;, \u0026ldquo;yellow\u0026rdquo;, \u0026ldquo;blue\u0026rdquo;, \u0026ldquo;magenta\u0026rdquo;, \u0026ldquo;cyan\u0026rdquo;, \u0026ldquo;white\u0026rdquo; }; struct box_props { bool opaque : 1; unsigned int fill_color : 3; unsigned int : 4;\nbool show_border : 1; unsigned int border_color : 3; unsigned int border_style : 2; unsigned int : 2; }; union Views /* 把数据看作结构或unsigned short类型的变量 / { struct box_props st_view; unsigned short us_view; }; void show_settings(const struct box_props * pb); void show_settings1(unsigned short); char * itobs(int n, char * ps); int main(void) { / 创建Views联合，并初始化initialize struct box view */ union Views box = { { true, YELLOW, true, GREEN, DASHED } }; char bin_str[8 * sizeof(unsigned int) + 1]; printf(\u0026ldquo;Original box settings:\\n\u0026rdquo;);\nshow_settings(\u0026amp;box.st_view); printf(\u0026quot;\\nBox settings using unsigned int view:\\n\u0026rdquo;); show_settings1(box.us_view); printf(\u0026ldquo;bits are %s\\n\u0026rdquo;, itobs(box.us_view, bin_str)); box.us_view \u0026amp;= ～FILL_MASK; /* 把表示填充色的位 清0 / box.us_view |= (FILL_BLUE | FILL_GREEN); / 重置填充色 / box.us_view ^= OPAQUE; / 切换是否透明的位 / box.us_view |= BORDER_RED; / 错误的方法 / box.us_view \u0026amp;= ～STYLE_MASK; / 把样式的位清0 / box.us_view |= B_DOTTED; / 把样式设置为点 */ printf(\u0026quot;\\nModified box settings:\\n\u0026quot;); show_settings(\u0026amp;box.st_view); printf(\u0026quot;\\nBox settings using unsigned int view:\\n\u0026quot;); show_settings1(box.us_view); printf(\u0026ldquo;bits are %s\\n\u0026rdquo;, itobs(box.us_view, bin_str)); return 0;\n} # void show_settings(const struct box_props * pb) { printf(\u0026ldquo;Box is %s.\\n\u0026rdquo;, pb-\u0026gt;opaque == true? \u0026ldquo;opaque\u0026rdquo; : \u0026ldquo;transparent\u0026rdquo;); printf(\u0026ldquo;The fill color is %s.\\n\u0026rdquo;, colors[pb-\u0026gt;fill_color]); printf(\u0026ldquo;Border %s.\\n\u0026rdquo;, pb-\u0026gt;show_border == true? \u0026ldquo;shown\u0026rdquo; : \u0026ldquo;not shown\u0026rdquo;); printf(\u0026ldquo;The border color is %s.\\n\u0026rdquo;, colors[pb-\u0026gt;border_color]); printf(\u0026ldquo;The border style is \u0026ldquo;); switch (pb-\u0026gt;border_style) { case SOLID: printf(\u0026ldquo;solid.\\n\u0026rdquo;); break; case DOTTED: printf(\u0026ldquo;dotted.\\n\u0026rdquo;); break; case DASHED: printf(\u0026ldquo;dashed.\\n\u0026rdquo;); break; default: printf(\u0026ldquo;unknown type.\\n\u0026rdquo;); } } void show_settings1(unsigned short us)\n{ # printf(\u0026ldquo;box is %s.\\n\u0026rdquo;, (us \u0026amp; OPAQUE) == OPAQUE? \u0026ldquo;opaque\u0026rdquo; : \u0026ldquo;transparent\u0026rdquo;); printf(\u0026ldquo;The fill color is %s.\\n\u0026rdquo;, colors[(us \u0026raquo; 1) \u0026amp; 07]); printf(\u0026ldquo;Border %s.\\n\u0026rdquo;, (us \u0026amp; BORDER) == BORDER? \u0026ldquo;shown\u0026rdquo; : \u0026ldquo;not shown\u0026rdquo;); printf(\u0026ldquo;The border style is \u0026ldquo;); switch (us \u0026amp; STYLE_MASK) { case B_SOLID : printf(\u0026ldquo;solid.\\n\u0026rdquo;); break; case B_DOTTED : printf(\u0026ldquo;dotted.\\n\u0026rdquo;); break; case B_DASHED : printf(\u0026ldquo;dashed.\\n\u0026rdquo;); break; default : printf(\u0026ldquo;unknown type.\\n\u0026rdquo;); } printf(\u0026ldquo;The border color is %s.\\n\u0026rdquo;, colors[(us \u0026raquo; 9) \u0026amp; 07]); } char * itobs(int n, char * ps)\n{ # int i; const static int size = CHAR_BIT * sizeof(int); for (i = size - 1; i \u0026gt;= 0; i\u0026ndash;, n \u0026raquo;= 1) ps[i] = (01 \u0026amp; n) + \u0026lsquo;0\u0026rsquo;; ps[size] = \u0026lsquo;\\0\u0026rsquo;; return ps; } 下面是该程序的输出： Original box settings: Box is opaque. The fill color is yellow. Border shown. The border color is green. The border style is dashed. Box settings using unsigned int view: box is opaque. The fill color is yellow. Border shown.\nThe border style is dashed. The border color is green. bits are 00000000000000000010010100000111 Modified box settings: Box is transparent. The fill color is cyan. Border shown. The border color is yellow. The border style is dotted. Box settings using unsigned int view: box is transparent. The fill color is cyan. Border not shown. The border style is dotted. The border color is yellow. bits are 00000000000000000001011100001100 这里要讨论几个要点。位字段视图和按位视图的区别是，按位视图需要 位置信息。例如，程序中使用BLUE表示蓝色，该符号常量的数值为 4 。但 是，由于结构排列数据的方式，实际储存蓝色设置的是 3 号位（位的编号从 0 开始，参见图15.1），而且储存边框为蓝色的设置是 11 号位。因此，该程序\n定义了一些新的符号常量： # #define FILL_BLUE 0x8 #define BORDER_BLUE 0x800 这里，0x8是 3 号位为 1 时的值，0x800是 11 号位为 1 时的值。可以使用第 1 个符号常量设置填充色的蓝色位，用第 2 个符号常量设置边框颜色的蓝色 位。用十六进制记数法更容易看出要设置二进制的哪一位，由于十六进制的 每一位代表二进制的 4 位，那么0x8的位组合是 1000 ，而0x800的位组合是 10000000000 ，0x800的位组合比0x8后面多 8 个 0 。但是以等价的十进制来看 就没那么明显，0x8是 8 ，0x800是 2048 。 如果值是 2 的幂，那么可以使用左移运算符来表示值。例如，可以用下 面的#define分别替换上面的#define： #define FILL_BLUE 1\u0026laquo;3 #define BORDER_BLUE 1\u0026laquo;11 这里，\u0026laquo;的右侧是 2 的指数，也就是说，0x8是 23 ，0x800是 211 。同样， 表达式1\u0026laquo;n指的是第n位为 1 的整数。1\u0026laquo;11是常量表达式，在编译时求值。 可以使用枚举代替#defined创建符号常量。例如，可以这样做： enum { OPAQUE = 0x1, FILL_BLUE = 0x8, FILL_GREEN = 0x4, FILL_RED = 0x2, FILL_MASK = 0xE, BORDER = 0x100, BORDER_BLUE = 0x800, BORDER_GREEN = 0x400, BORDER_RED = 0x200, BORDER_MASK = 0xE00, B_DOTTED = 0x1000, B_DASHED = 0x2000, STYLE_MASK = 0x3000};\n如果不想创建枚举变量，就不用在声明中使用标记。 # 注意，按位运算符改变设置更加复杂。例如，要设置填充色为青色。只 # 打开蓝色位和绿色位是不够的： # box.us_view |= (FILL_BLUE | FILL_GREEN); /* 重置填充色 / 问题是该颜色还依赖于红色位的设置。如果已经设置了该位（比如对于 黄色），这行代码保留了红色位的设置，而且还设置了蓝色位和绿色位，结 果是产生白色。解决这个问题最简单的方法是在设置新值前关闭所有的颜色 位。因此，程序中使用了下面两行代码： box.us_view \u0026amp;= ～FILL_MASK; / 把表示填充色的位 清0 / box.us_view |= (FILL_BLUE | FILL_GREEN); / 重置填充色 / 如果不先关闭所有的相关位，程序中演示了这种情况： box.us_view |= BORDER_RED; / 错误的方法 */ 因为BORDER_GREEN位已经设置过了，所以结果颜色是 BORDER_GREEN | BORDER_RED，被解释为黄色。 这种情况下，位字段版本更简单： box.st_view.fill_color = CYAN; /*等价的位字段方法 */ 这种方法不用先清空所有的位。而且，使用位字段成员时，可以为边框 和框内填充色使用相同的颜色值。但是用按位运算符的方法则要使用不同的 值（这些值反映实际位的位置）。 其次，比较下面两个打印语句： printf(\u0026ldquo;The border color is %s.\\n\u0026rdquo;, colors[pb-\u0026gt;border_color]);\nprintf(\u0026ldquo;The border color is %s.\\n\u0026rdquo;, colors[(us \u0026raquo; 9) \u0026amp; 07]); 第 1 条语句中，表达式pb-\u0026gt;border_color的值在 0 ～ 7 的范围内，所以该表 达式可用作colors数组的索引。用按位运算符获得相同的信息更加复杂。一 种方法是使用ui\u0026raquo;9把边框颜色右移至最右端（ 0 号位～ 2 号位），然后把该 值与掩码 07 组合，关闭除了最右端 3 位以外所有的位。这样结果也在 0 ～ 7 的 范围内，可作为colors数组的索引。 警告 位字段和位的位置之间的相互对应因实现而异。例如，在早期的 Macintosh PowerPC上运行程序清单15.4，输出如下： Original box settings: Box is opaque. The fill color is yellow. Border shown. The border color is green. The border style is dashed. Box settings using unsigned int view: box is transparent. The fill color is black. Border not shown. The border style is solid. The border color is black.\nbits are 10110000101010000000000000000000 Modified box settings: Box is opaque. The fill color is yellow. Border shown. The border color is green. The border style is dashed. Box settings using unsigned int view: box is opaque. The fill color is cyan. Border shown. The border style is dotted. The border color is red. bits are 10110000101010000001001000001101 该输出的二进制位与程序示例15.4不同，Macintosh PowerPC把结构载入 内存的方式不同。特别是，它把第 1 位字段载入最高阶位，而不是最低阶 位。所以结构表示法储存在前 16 位（与PC中的顺序不同），而unsigned int表 示法则储存在后 16 位。因此，对于Macintosh，程序清单15.4中关于位的位置 的假设是错误的，使用按位运算符改变透明设置和填充色设置时，也弄错了 位。\n15.5 对齐特性（ C11 ） # C11 的对齐特性比用位填充字节更自然，它们还代表了C在处理硬件相 # 关问题上的能力。在这种上下文中，对齐指的是如何安排对象在内存中的位 # 置。例如，为了效率最大化，系统可能要把一个 double 类型的值储存在 4 字 节内存地址上，但却允许把char储存在任意地址。大部分程序员都对对齐不 以为然。但是，有些情况又受益于对齐控制。例如，把数据从一个硬件位置 转移到另一个位置，或者调用指令同时操作多个数据项。 _Alignof运算符给出一个类型的对齐要求，在关键字_Alignof后面的圆括 号中写上类型名即可： size_t d_align = _Alignof(float); 假设d_align的值是 4 ，意思是float类型对象的对齐要求是 4 。也就是说， 4 是储存该类型值相邻地址的字节数。一般而言，对齐值都应该是 2 的非负整 数次幂。较大的对齐值被称为stricter或stronger，较小的对齐值被称为 weaker。 可以使用_Alignas 说明符指定一个变量或类型的对齐值。但是，不应该 要求该值小于基本对齐值。例如，如果float类型的对齐要求是 4 ，不要请求 其对齐值是 1 或 2 。该说明符用作声明的一部分，说明符后面的圆括号内包含 对齐值或类型： _Alignas(double) char c1; _Alignas(8) char c2; unsigned char _Alignas(long double) c_arr[sizeof(long double)]; 注意 撰写本书时，Clang（3.2版本）要求_Alignas(type)说明符在类型说明符 后面，如上面第 3 行代码所示。但是，无论_Alignas(type)说明符在类型说明\n符的前面还是后面，GCC 4.7.3都能识别，后来Clang 3.3 版本也支持了这两 种顺序。 程序清单15.5中的程序演示了_Alignas和_Alignof的用法。 程序清单 15.5 align.c 程序 // align.c \u0026ndash; 使用 _Alignof 和 _Alignas （C11） #include \u0026lt;stdio.h\u0026gt; int main(void) { double dx; char ca; char cx; double dz; char cb; char _Alignas(double) cz; printf(\u0026ldquo;char alignment: %zd\\n\u0026rdquo;, _Alignof(char)); printf(\u0026ldquo;double alignment: %zd\\n\u0026rdquo;, _Alignof(double)); printf(\u0026quot;\u0026amp;dx: %p\\n\u0026rdquo;, \u0026amp;dx); printf(\u0026quot;\u0026amp;ca: %p\\n\u0026rdquo;, \u0026amp;ca); printf(\u0026quot;\u0026amp;cx: %p\\n\u0026rdquo;, \u0026amp;cx);\nprintf(\u0026quot;\u0026amp;dz: %p\\n\u0026rdquo;, \u0026amp;dz); printf(\u0026quot;\u0026amp;cb: %p\\n\u0026quot;, \u0026amp;cb); printf(\u0026quot;\u0026amp;cz: %p\\n\u0026quot;, \u0026amp;cz); return 0; } 该程序的输出如下： char alignment: 1 double alignment: 8 \u0026amp;dx: 0x7fff5fbff660 \u0026amp;ca: 0x7fff5fbff65f \u0026amp;cx: 0x7fff5fbff65e \u0026amp;dz: 0x7fff5fbff650 \u0026amp;cb: 0x7fff5fbff64f \u0026amp;cz: 0x7fff5fbff648 在我们的系统中，double的对齐值是 8 ，这意味着地址的类型对齐可以 被 8 整除。以 0 或 8 结尾的十六进制地址可被 8 整除。这就是地址常用两个 double类型的变量和char类型的变量cz（该变量是double对齐值）。因为char 的对齐值是 1 ，对于普通的char类型变量，编译器可以使用任何地址。 在程序中包含 stdalign.h 头文件后，就可以把 alignas 和 alignof 分别作为 _Alignas 和_Alignof的别名。这样做可以与C++关键字匹配。\nC11在stdlib.h库还添加了一个新的内存分配函数，用于对齐动态分配的 内存。该函数的原型如下： void *aligned_alloc(size_t alignment, size_t size); 第 1 个参数代表指定的对齐，第 2 个参数是所需的字节数，其值应是第 1 个参数的倍数。与其他内存分配函数一样，要使用free()函数释放之前分配 的内存。\n15.6 关键概念 # C 区别于许多高级语言的特性之一是访问整数中单独位的能力。该特性 # 通常是与硬件设备和操作系统交互的关键。 # C有两种访问位的方法。一种方法是通过按位运算符，另一种方法是在 # 结构中创建位字段。 # C11新增了检查内存对齐要求的功能，而且可以指定比基本对齐值更大 # 的对齐值。 # 通常（但不总是），使用这些特性的程序仅限于特定的硬件平台或操作 # 系统，而且设计为不可移植的。 # 15.7 本章小结 # 计算硬件与二进制记数系统密不可分，因为二进制数的 1 和 0 可用于表示 # 计算机内存和寄存器中位的开闭状态。虽然C不允许以二进制形式书写数 # 字，但是它识别与二进制相关的八进制和十六进制记数法。正如每个二进制 # 数字表示 1 位一样，每个八进制位代表 3 位，每个十六进制位代表 4 位。这种 # 关系使得二进制转为八进制或十六进制较为简单。 # C 提供多种按位运算符，之所以称为按位是因为它们单独操作一个值中 # 的每个位。～运算符将其运算对象的每一位取反，将 1 转为 0 ， 0 转为 1 。按位 # 与运算符（\u0026amp;）通过两个运算对象形成一个值。如果两运算对象中相同号位 # 都为 1 ，那么该值中对应的位为 1 ；否则，该位为 0 。按位或运算符（|）同样 # 通过两个运算对象形成一个值。如果两运算对象中相同号位有一个为 1 或都 # 为 1 ，那么该值中对应的位为 1 ；否则，该位为 0 。按位异或运算符（^）也有 # 类似的操作，只有两运算对象中相同号位有一个为 1 时，结果值中对应的位 # 才为 1 。 # C还有左移（\u0026laquo;）和右移（\u0026raquo;）运算符。这两个运算符使位组合中的所 # 有位都向左或向右移动指定数量的位，以形成一个新值。对于左移运算符， # 空出的位置设为 0 。对于右移运算符，如果是无符号类型的值，空出的位设 # 为 0 ；如果是有符号类型的值，右移运算符的行为取决于实现。 # 可以在结构中使用位字段操控一个值中的单独位或多组位。具体细节因 # 实现而异。 # 可以使用_Alignas强制执行数据存储区上的对齐要求。 这些位工具帮助C程序处理硬件问题，因此它们通常用于依赖实现的场 合中。\n15.8 复习题 # 复习题的参考答案在附录A中。 # 1.把下面的十进制转换为二进制： # a.3 b.13 c.59 d.119 2.将下面的二进制值转换为十进制、八进制和十六进制的形式： a.00010101 b.01010101 c.01001100 d.10011101 3.对下面的表达式求值，假设每个值都为 8 位： a.～ 3 b.3 \u0026amp; 6 c.3 | 6 d.1 | 6 e.3 ^ 6 f.7 \u0026raquo; 1\ng.7 \u0026laquo; 2 4.对下面的表达式求值，假设每个值都为 8 位： a.～ 0 b.!0 c.2 \u0026amp; 4 d.2 \u0026amp;\u0026amp; 4 e.2 | 4 f.2 || 4 g.5 \u0026laquo; 3 5.因为ASCII码只使用最后 7 位，所以有时需要用掩码关闭其他位，其相 应的二进制掩码是什么？分别用十进制、八进制和十六进制来表示这个掩 码。 6.程序清单15.2中，可以把下面的代码： while (bits\u0026ndash; \u0026gt; 0) { mask |= bitval; bitval \u0026laquo;= 1; } 替换成： while (bits\u0026ndash; \u0026gt; 0)\n{ # mask += bitval; bitval = 2; } 程序照常工作。这是否意味着=2等同于\u0026laquo;=1？+=是否等同于|=？ 7.a.Tinkerbell计算机有一个硬件字节可读入程序。该字节包含以下信 息：\nTinkerbell和IBM PC一样，从右往左填充结构位字段。创建一个适合存 放这些信息的位字段模板。 b.Klinkerbell与Tinkerbell类似，但是它从左往右填充结构位字段。请为 Klinkerbell创建一个相应的位字段模板。\n15.9 编程练习 # 1.编写一个函数，把二进制字符串转换为一个数值。例如，有下面的语 # 句： # char * pbin = \u0026ldquo;01001001\u0026rdquo;; 那么把pbin作为参数传递给该函数后，它应该返回一个int类型的值 25 。 2.编写一个程序，通过命令行参数读取两个二进制字符串，对这两个二 进制数使用～运算符、\u0026amp;运算符、|运算符和^运算符，并以二进制字符串形 式打印结果（如果无法使用命令行环境，可以通过交互式让程序读取字符 串）。 3.编写一个函数，接受一个 int 类型的参数，并返回该参数中打开位的 数量。在一个程序中测试该函数。 4.编写一个程序，接受两个int类型的参数：一个是值；一个是位的位 置。如果指定位的位置为 1 ，该函数返回 1 ；否则返回 0 。在一个程序中测试 该函数。 5.编写一个函数，把一个 unsigned int 类型值中的所有位向左旋转指定数 量的位。例如，rotate_l(x, 4)把x中所有位向左移动 4 个位置，而且从最左端 移出的位会重新出现在右端。也就是说，把高阶位移出的位放入低阶位。在 一个程序中测试该函数。 6.设计一个位字段结构以储存下面的信息。 字体ID： 0 ～ 255 之间的一个数； 字体大小： 0 ～ 127 之间的一个数； 对齐： 0 ～ 2 之间的一个数，表示左对齐、居中、右对齐；\n加粗：开（ 1 ）或闭（ 0 ）； # 斜体：开（ 1 ）或闭（ 0 ）； # 在一个程序中使用该结构来打印字体参数，并使用循环菜单来让用户改 # 变参数。例如，该程序的一个运行示例如下： # 该程序要使用按位与运算符（\u0026amp;）和合适的掩码来把字体ID和字体大小 # 信息转换到指定的范围内。 # 7.编写一个与编程练习 6 功能相同的程序，使用 unsigned long 类型的变 量储存字体信息，并且使用按位运算符而不是位成员来管理这些信息。\n第 16 章 C 预处理器和 C 库 # 本章介绍以下内容： # 预处理指令：#define、#include、#ifdef、#else、#endif、#ifndef、#if、 #elif、#line、#error、#pragma 关键字：_Generic、_Noreturn、_Static_assert 函数/宏：sqrt()、atan()、atan2()、exit()、atexit()、assert()、memcpy()、 memmove()、va_start()、va_arg()、va_copy()、va_end() C预处理器的其他功能 通用选择表达式 内联函数 C库概述和一些特殊用途的方便函数 C语言建立在适当的关键字、表达式、语句以及使用它们的规则上。然 而，C标准不仅描述C语言，还描述如何执行C预处理器、C标准库有哪些函 数，以及详述这些函数的工作原理。本章将介绍C预处理器和C库，我们先 从C预处理器开始。 C预处理器在程序执行之前查看程序（故称之为预处理器）。根据程序 中的预处理器指令，预处理器把符号缩写替换成其表示的内容。预处理器可 以包含程序所需的其他文件，可以选择让编译器查看哪些代码。预处理器并 不知道 C。基本上它的工作是把一些文本转换成另外一些文本。这样描述预 处理器无法体现它的真正效用和价值，我们将在本章举例说明。前面的程序 示例中也有很多#define和#include的例子。下面，我们先总结一下已学过的 预处理指令，再介绍一些新的知识点。\n16.1 翻译程序的第一步 # 在预处理之前，编译器必须对该程序进行一些翻译处理。首先，编译器 # 把源代码中出现的字符映射到源字符集。该过程处理多字节字符和三字符序 # 列——字符扩展让C更加国际化（详见附录B“参考资料VII，扩展字符支 # 持”）。 # 第二，编译器定位每个反斜杠后面跟着换行符的实例，并删除它们。也 # 就是说，把下面两个物理行（physical line）： printf(\u0026ldquo;That\u0026rsquo;s wond\nerful!\\n\u0026rdquo;); 转换成一个逻辑行（logical line）： printf(\u0026ldquo;That\u0026rsquo;s wonderful\\n!\u0026rdquo;); 注意，在这种场合中，“换行符”的意思是通过按下Enter键在源代码文件 中换行所生成的字符，而不是指符号表征\\n。 由于预处理表达式的长度必须是一个逻辑行，所以这一步为预处理器做 好了准备工作。一个逻辑行可以是多个物理行。 第三，编译器把文本划分成预处理记号序列、空白序列和注释序列（记 号是由空格、制表符或换行符分隔的项，详见16.2.1）。这里要注意的是， 编译器将用一个空格字符替换每一条注释。因此，下面的代码： int/* 这看起来并不像一个空格*/fox; 将变成： int fox; 而且，实现可以用一个空格替换所有的空白字符序列（不包括换行\n符）。最后，程序已经准备好进入预处理阶段，预处理器查找一行中以#号 # 开始的预处理指令。 # 16.2 明示常量： #define # #define预处理器指令和其他预处理器指令一样，以#号作为一行的开 始。ANSI和后来的标准都允许#号前面有空格或制表符，而且还允许在#和 指令的其余部分之间有空格。但是旧版本的C要求指令从一行最左边开始， 而且#和指令其余部分之间不能有空格。指令可以出现在源文件的任何地 方，其定义从指令出现的地方到该文件末尾有效。我们大量使用#define指令 来定义明示常量（manifest constant）（也叫做符号常量），但是该指令还有 许多其他用途。程序清单16.1演示了#define指令的一些用法和属性。 预处理器指令从#开始运行，到后面的第 1 个换行符为止。也就是说，指 令的长度仅限于一行。然而，前面提到过，在预处理开始前，编译器会把多 行物理行处理为一行逻辑行。 程序清单 16.1 preproc.c 程序 /* preproc.c \u0026ndash; 简单的预处理示例 / #include \u0026lt;stdio.h\u0026gt; #define TWO 2 / 可以使用注释 / #define OW \u0026ldquo;Consistency is the last refuge of the unimagina\ntive.- Oscar Wilde\u0026rdquo; / 反斜杠把该定义延续到下一行 / #define FOUR TWOTWO #define PX printf(\u0026ldquo;X is %d.\\n\u0026rdquo;, x) #define FMT \u0026ldquo;X is %d.\\n\u0026rdquo; int main(void) {\nint x = TWO; PX; x = FOUR; printf(FMT, x); printf(\u0026quot;%s\\n\u0026quot;, OW); printf(\u0026ldquo;TWO: OW\\n\u0026rdquo;); return 0; } 每行#define（逻辑行）都由 3 部分组成。第 1 部分是#define指令本身。第 2 部分是选定的缩写，也称为宏。有些宏代表值（如本例），这些宏被称为 类对象宏（object-like macro）。C 语言还有类函数宏（function-like macro），稍后讨论。宏的名称中不允许有空格，而且必须遵循C变量的命 名规则：只能使用字符、数字和下划线（_）字符，而且首字符不能是数 字。第 3 部分（指令行的其余部分）称为替换列表或替换体（见图16.1）。 一旦预处理器在程序中找到宏的示实例后，就会用替换体代替该宏（也有例 外，稍后解释）。从宏变成最终替换文本的过程称为宏展开（macro expansion）。注意，可以在#define行使用标准C注释。如前所述，每条注释 都会被一个空格代替。\n图16.1 类对象宏定义的组成 运行该程序示例后，输出如下: X is 2. X is 4. Consistency is the last refuge of the unimaginative.- Oscar Wilde TWO: OW 下面分析具体的过程。下面的语句： int x = TWO; 变成了： int x = 2; 2 代替了TWO。而语句： PX; 变成了： printf(\u0026ldquo;X is %d.\\n\u0026rdquo;, x); 这里同样进行了替换。这是一个新用法，到目前为止我们只是用宏来表 示明示常量。从该例中可以看出，宏可以表示任何字符串，甚至可以表示整 个 C 表达式。但是要注意，虽然 PX 是一个字符串常量，它只打印一个名为 x的变量。 下一行也是一个新用法。读者可能认为FOUR被替换成 4 ，但是实际的 过程是： x = FOUR;\n变成了： # x = TWOTWO; 即是： x = 22; 宏展开到此处为止。由于编译器在编译期对所有的常量表达式（只包含 常量的表达式）求值，所以预处理器不会进行实际的乘法运算，这一过程在 编译时进行。预处理器不做计算，不对表达式求值，它只进行替换。 注意，宏定义还可以包含其他宏（一些编译器不支持这种嵌套功能）。 程序中的下一行： printf (FMT, x); 变成了： printf(\u0026ldquo;X is %d.\\n\u0026rdquo;,x); 相应的字符串替换了 FMT。如果要多次使用某个冗长的字符串，这种 方法比较方便。另外，也可以用下面的方法： const char * fmt = \u0026ldquo;X is %d.\\n\u0026rdquo;; 然后可以把fmt作为printf()的格式字符串。 下一行中，用相应的字符串替换OW。双引号使替换的字符串成为字符 串常量。编译器把该字符串储存在以空字符结尾的数组中。因此，下面的指 令定义了一个字符常量： #define HAL \u0026lsquo;Z\u0026rsquo; 而下面的指令则定义了一个字符串（Z\\0）：\n#define HAP \u0026ldquo;Z\u0026rdquo; 在程序示例16.1中，我们在一行的结尾加一个反斜杠字符使该行扩展至 下一行： #define OW \u0026ldquo;Consistency is the last refuge of the unimagina\ntive.- Oscar Wilde\u0026rdquo; 注意，第 2 行要与第 1 行左对齐。如果这样做： #define OW \u0026ldquo;Consistency is the last refuge of the unimagina\ntive.- Oscar Wilde\u0026rdquo; 那么输出的内容是： Consistency is the last refuge of the unimagina tive.- Oscar Wilde 第 2 行开始到tive之间的空格也算是字符串的一部分。 一般而言，预处理器发现程序中的宏后，会用宏等价的替换文本进行替 换。如果替换的字符串中还包含宏，则继续替换这些宏。唯一例外的是双引 号中的宏。因此，下面的语句： printf(\u0026ldquo;TWO: OW\u0026rdquo;); 打印的是TWO: OW，而不是打印： 2: Consistency is the last refuge of the unimaginative.- Oscar Wilde 要打印这行，应该这样写： printf(\u0026quot;%d: %s\\n\u0026quot;, TWO, OW); 这行代码中，宏不在双引号内。\n那么，何时使用字符常量？对于绝大部分数字常量，应该使用字符常 # 量。如果在算式中用字符常量代替数字，常量名能更清楚地表达该数字的含 # 义。如果是表示数组大小的数字，用符号常量后更容易改变数组的大小和循 # 环次数。如果数字是系统代码（如，EOF），用符号常量表示的代码更容易 # 移植（只需改变EOF的定义）。助记、易更改、可移植，这些都是符号常量 # 很有价值的特性。 # C语言现在也支持const关键字，提供了更灵活的方法。用const可以创建 在程序运行过程中不能改变的变量，可具有文件作用域或块作用域。另一方 面，宏常量可用于指定标准数组的大小和const变量的初始值。 #define LIMIT 20 const int LIM = 50; static int data1[LIMIT]; // 有效 static int data2[LIM]; // 无效 const int LIM2 = 2 * LIMIT; // 有效 const int LIM3 = 2 * LIM; // 无效 这里解释一下上面代码中的“无效”注释。在C中，非自动数组的大小应 该是整型常量表达式，这意味着表示数组大小的必须是整型常量的组合（如 5 ）、枚举常量和sizeof表达式，不包括const声明的值（这也是C++和C的区 别之一，在C++中可以把const值作为常量表达式的一部分）。但是，有的实 现可能接受其他形式的常量表达式。例如，GCC 4.7.3不允许data2的声明， 但是Clang 4.6允许。\n16.2.1 记号 # 从技术角度来看，可以把宏的替换体看作是记号（token）型字符串， 而不是字符型字符串。C预处理器记号是宏定义的替换体中单独的“词”。用\n空白把这些词分开。例如： # #define FOUR 22 该宏定义有一个记号：22序列。但是，下面的宏定义中： #define SIX 2 * 3 有 3 个记号： 2 、、 3 。 替换体中有多个空格时，字符型字符串和记号型字符串的处理方式不 同。考虑下面的定义： #define EIGHT 4 * 8 如果预处理器把该替换体解释为字符型字符串，将用4 * 8替换EIGHT。 即，额外的空格是替换体的一部分。如果预处理器把该替换体解释为记号型 字符串，则用 3 个的记号4 * 8（分别由单个空格分隔）来替换EIGHT。换而 言之，解释为字符型字符串，把空格视为替换体的一部分；解释为记号型字 符串，把空格视为替换体中各记号的分隔符。在实际应用中，一些C编译器 把宏替换体视为字符串而不是记号。在比这个例子更复杂的情况下，两者的 区别才有实际意义。 顺带一提，C编译器处理记号的方式比预处理器复杂。由于编译器理解 C语言的规则，所以不要求代码中用空格来分隔记号。例如，C编译器可以 把22直接视为 3 个记号，因为它可以识别 2 是常量，*是运算符。\n16.2.2 重定义常量 # 假设先把LIMIT定义为 20 ，稍后在该文件中又把它定义为 25 。这个过程 # 称为重定义常量。不同的实现采用不同的重定义方案。除非新定义与旧定义 # 相同，否则有些实现会将其视为错误。另外一些实现允许重定义，但会给出 # 警告。ANSI标准采用第 1 种方案，只有新定义和旧定义完全相同才允许重定 # 义。 # 具有相同的定义意味着替换体中的记号必须相同，且顺序也相同。因 # 此，下面两个定义相同： # #define SIX 2 * 3 #define SIX 2 * 3 这两条定义都有 3 个相同的记号，额外的空格不算替换体的一部分。而 下面的定义则与上面两条宏定义不同： #define SIX 2*3 这条宏定义中只有一个记号，因此与前两条定义不同。如果需要重定义 宏，使用#undef 指令（稍后讨论）。 如果确实需要重定义常量，使用const关键字和作用域规则更容易些。\n16.3 在 #define 中使用参数 # 在#define中使用参数可以创建外形和作用与函数类似的类函数宏。带有 参数的宏看上去很像函数，因为这样的宏也使用圆括号。类函数宏定义的圆 括号中可以有一个或多个参数，随后这些参数出现在替换体中，如图16.2所 示。\n图16.2 函数宏定义的组成 下面是一个类函数宏的示例： #define SQUARE(X) XX 在程序中可以这样用： z = SQUARE(2); 这看上去像函数调用，但是它的行为和函数调用完全不同。程序清单 16.2演示了类函数宏和另一个宏的用法。该示例中有一些陷阱，请读者仔细 阅读序。 程序清单 16.2 mac_arg.c 程序 / mac_arg.c \u0026ndash; 带参数的宏 / #include \u0026lt;stdio.h\u0026gt; #define SQUARE(X) XX\n#define PR(X) printf(\u0026ldquo;The result is %d.\\n\u0026rdquo;, X) int main(void) { int x = 5; int z; printf(\u0026ldquo;x = %d\\n\u0026rdquo;, x); z = SQUARE(x); printf(\u0026ldquo;Evaluating SQUARE(x): \u0026ldquo;); PR(z); z = SQUARE(2); printf(\u0026ldquo;Evaluating SQUARE(2): \u0026ldquo;); PR(z); printf(\u0026ldquo;Evaluating SQUARE(x+2): \u0026ldquo;); PR(SQUARE(x + 2)); printf(\u0026ldquo;Evaluating 100/SQUARE(2): \u0026ldquo;); PR(100 / SQUARE(2)); printf(\u0026ldquo;x is %d.\\n\u0026rdquo;, x); printf(\u0026ldquo;Evaluating SQUARE(++x): \u0026ldquo;); PR(SQUARE(++x));\nprintf(\u0026ldquo;After incrementing, x is %x.\\n\u0026rdquo;, x); return 0; } SQUARE宏的定义如下： #define SQUARE(X) XX 这里，SQUARE 是宏标识符，SQUARE(X)中的 X 是宏参数，XX 是替 换列表。程序清单 16.2 中出现SQUARE(X)的地方都会被XX替换。这与前 面的示例不同，使用该宏时，既可以用X，也可以用其他符号。宏定义中的 X由宏调用中的符号代替。因此，SQUARE(2)替换为22，X实际上起到参数 的作用。 然而，稍后你将看到，宏参数与函数参数不完全相同。下面是程序的输 出。注意有些内容可能与我们的预期不符。实际上，你的编译器输出甚至与 下面的结果完全不同。 x = 5 Evaluating SQUARE(x): The result is 25. Evaluating SQUARE(2): The result is 4. Evaluating SQUARE(x+2): The result is 17. Evaluating 100/SQUARE(2): The result is 100. x is 5. Evaluating SQUARE(++x): The result is 42. After incrementing, x is 7.\n前两行与预期相符，但是接下来的结果有点奇怪。程序中设置x的值为 5 ，你可能认为SQUARE(x+2)应该是 77，即 49 。但是，输出的结果是 17 ， 这不是一个平方值！导致这样结果的原因是，我们前面提到过，预处理器不 做计算、不求值，只替换字符序列。预处理器把出现x的地方都替换成x+2。 因此，xx变成了x+2x+2。如果x为 5 ，那么该表达式的值为： 5+25+2 = 5 + 10 + 2 = 17 该例演示了函数调用和宏调用的重要区别。函数调用在程序运行时把参 数的值传递给函数。宏调用在编译之前把参数记号传递给程序。这两个不同 的过程发生在不同时期。是否可以修改宏定义让SQUARE(x+2)得 36 ？当然 可以，要多加几个圆括号： #define SQUARE(x) (x)(x) 现在SQUARE(x+2)变成了(x+2)(x+2)，在替换字符串中使用圆括号就得 到符合预期的乘法运算。 但是，这并未解决所有的问题。下面的输出行： 100/SQUARE(2) 将变成： 100/22 根据优先级规则，从左往右对表达式求值：(100/2)2，即502，得 100 。把SQUARE(x)定义为下面的形式可以解决这种混乱： #define SQUARE(x) (xx) 这样修改定义后得100/(2*2)，即100/4，得 25 。 要处理前面的两种情况，要这样定义：\n#define SQUARE(x) ((x)(x)) 因此，必要时要使用足够多的圆括号来确保运算和结合的正确顺序。 尽管如此，这样做还是无法避免程序中最后一种情况的问题。 SQUARE(++x)变成了++x++x，递增了两次x，一次在乘法运算之前，一次 在乘法运算之后： ++x*++x = 67 = 42 由于标准并未对这类运算规定顺序，所以有些编译器得 76。而有些编 译器可能在乘法运算之前已经递增了x，所以7*7得 49 。在C标准中，对该表 达式求值的这种情况称为未定义行为。无论哪种情况，x的开始值都是 5 ，虽 然从代码上看只递增了一次，但是x的最终值是 7 。 解决这个问题最简单的方法是，避免用++x 作为宏参数。一般而言，不 要在宏中使用递增或递减运算符。但是，++x可作为函数参数，因为编译器 会对++x求值得 5 后，再把 5 传递给函数。\n16.3.1 用宏参数创建字符串： # 运算符 # 下面是一个类函数宏： # #define PSQR(X) printf(\u0026ldquo;The square of X is %d.\\n\u0026rdquo;, ((X)*(X))); 假设这样使用宏： PSQR(8); 输出为： The square of X is 64. 注意双引号字符串中的X被视为普通文本，而不是一个可被替换的记 号。\nC允许在字符串中包含宏参数。在类函数宏的替换体中，#号作为一个 # 预处理运算符，可以把记号转换成字符串。例如，如果x是一个宏形参，那 么#x就是转换为字符串\u0026quot;x\u0026quot;的形参名。这个过程称为字符串化 （stringizing）。程序清单16.3演示了该过程的用法。 程序清单 16.3 subst.c 程序 /* subst.c \u0026ndash; 在字符串中替换 / #include \u0026lt;stdio.h\u0026gt; #define PSQR(x) printf(\u0026ldquo;The square of \u0026quot; #x \u0026quot; is %d.\\n\u0026rdquo;,((x)(x))) int main(void) { int y = 5; PSQR(y); PSQR(2 + 4); return 0; } 该程序的输出如下： The square of y is 25. The square of 2 + 4 is 36. 调用第 1 个宏时，用\u0026quot;y\u0026quot;替换#x。调用第 2 个宏时，用\u0026quot;2 + 4\u0026quot;替换#x。 ANSI C字符串的串联特性将这些字符串与printf()语句的其他字符串组合，生 成最终的字符串。例如，第 1 次调用变成：\nprintf(\u0026#34;The square of \u0026#34; \u0026#34;y\u0026#34; \u0026#34; is %d.\\n\u0026#34;,((y)*(y))); 然后，字符串串联功能将这 3 个相邻的字符串组合成一个字符串： \u0026#34;The square of y is %d.\\n\u0026#34; 16.3.2 预处理器黏合剂： ## 运算符 # 与#运算符类似，##运算符可用于类函数宏的替换部分。而且，##还可 # 用于对象宏的替换部分。##运算符把两个记号组合成一个记号。例如，可以 # 这样做： # #define XNAME(n) x ## n 然后，宏XNAME(4)将展开为x4。程序清单16.4演示了##作为记号粘合 剂的用法。 程序清单 16.4 glue.c 程序 // glue.c \u0026ndash; 使用##运算符 #include \u0026lt;stdio.h\u0026gt; #define XNAME(n) x ## n #define PRINT_XN(n) printf(\u0026ldquo;x\u0026rdquo; #n \u0026quot; = %d\\n\u0026rdquo;, x ## n); int main(void) { int XNAME(1) = 14; // 变成 int x1 = 14; int XNAME(2) = 20; // 变成 int x2 = 20; int x3 = 30;\nPRINT_XN(1); // 变成 printf(\u0026ldquo;x1 = %d\\n\u0026rdquo;, x1); PRINT_XN(2); // 变成 printf(\u0026ldquo;x2 = %d\\n\u0026rdquo;, x2); PRINT_XN(3); // 变成 printf(\u0026ldquo;x3 = %d\\n\u0026rdquo;, x3); return 0; } 该程序的输出如下： x1 = 14 x2 = 20 x3 = 30 注意，PRINT_XN()宏用#运算符组合字符串，##运算符把记号组合为一 个新的标识符。\n16.3.3 变参宏： \u0026hellip; 和 _ VA_ARGS _ # 一些函数（如 printf()）接受数量可变的参数。stdvar.h 头文件（本章后 面介绍）提供了工具，让用户自定义带可变参数的函数。C99/C11也对宏提 供了这样的工具。虽然标准中未使用“可变”（variadic）这个词，但是它已 成为描述这种工具的通用词（虽然，C标准的索引添加了字符串化 (stringizing)词条，但是，标准并未把固定参数的函数或宏称为固定函数和不 变宏）。 通过把宏参数列表中最后的参数写成省略号（即， 3 个点\u0026hellip;）来实现这 一功能。这样，预定义宏 _ VA_ARGS _可用在替换部分中，表明省略号代表什么。例如，下面 的定义：\n#define PR(\u0026hellip;) printf(_ VA_ARGS ) 假设稍后调用该宏： PR(\u0026ldquo;Howdy\u0026rdquo;); PR(\u0026ldquo;weight = %d, shipping = $%.2f\\n\u0026rdquo;, wt, sp); 对于第 1 次调用， VA_ARGS 展开为 1 个参数：\u0026ldquo;Howdy\u0026rdquo;。 对于第 2 次调用， VA_ARGS _展开为 3 个参数：\u0026ldquo;weight = %d, shipping = $%.2f\\n\u0026rdquo;、wt、sp。 因此，展开后的代码是： printf(\u0026ldquo;Howdy\u0026rdquo;); printf(\u0026ldquo;weight = %d, shipping = $%.2f\\n\u0026rdquo;, wt, sp); 程序清单16.5演示了一个示例，该程序使用了字符串的串联功能和#运 算符。 程序清单 16.5 variadic.c 程序 // variadic.c \u0026ndash; 变参宏 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; #define PR(X, \u0026hellip;) printf(\u0026ldquo;Message \u0026quot; #X \u0026ldquo;: \u0026quot; VA_ARGS) int main(void) { double x = 48;\ndouble y; y = sqrt(x); PR(1, \u0026ldquo;x = %g\\n\u0026rdquo;, x); PR(2, \u0026ldquo;x = %.2f, y = %.4f\\n\u0026rdquo;, x, y); return 0; } 第 1 个宏调用，X的值是 1 ，所以#X变成\u0026quot;1\u0026rdquo;。展开后成为： print(\u0026ldquo;Message \u0026quot; \u0026ldquo;1\u0026rdquo; \u0026ldquo;: \u0026quot; \u0026ldquo;x = %g\\n\u0026rdquo;, x); 然后，串联 4 个字符，把调用简化为： print(\u0026ldquo;Message 1: x = %g\\n\u0026rdquo;, x); 下面是该程序的输出： Message 1: x = 48 Message 2: x = 48.00, y = 6.9282 记住，省略号只能代替最后的宏参数： #define WRONG(X, \u0026hellip;, Y) #X #_ VA_ARGS _ #y //不能这样做\n16.4 宏和函数的选择 # 有些编程任务既可以用带参数的宏完成，也可以用函数完成。应该使用 # 宏还是函数？这没有硬性规定，但是可以参考下面的情况。 # 使用宏比使用普通函数复杂一些，稍有不慎会产生奇怪的副作用。一些 # 编译器规定宏只能定义成一行。不过，即使编译器没有这个限制，也应该这 # 样做。 # 宏和函数的选择实际上是时间和空间的权衡。宏生成内联代码，即在程 # 序中生成语句。如果调用 20 次宏，即在程序中插入 20 行代码。如果调用函数 # 20 次，程序中只有一份函数语句的副本，所以节省了空间。然而另一方面， # 程序的控制必须跳转至函数内，随后再返回主调程序，这显然比内联代码花 # 费更多的时间。 # 宏的一个优点是，不用担心变量类型（这是因为宏处理的是字符串，而 # 不是实际的值）。因此，只要能用int或float类型都可以使用SQUARE(x)宏。 C99提供了第 3 种可替换的方法——内联函数。本章后面将介绍。 对于简单的函数，程序员通常使用宏，如下所示： #define MAX(X,Y) ((X) \u0026gt; (Y)? (X) : (Y)) #define ABS(X) ((X) \u0026lt; 0? -(X) : (X)) #define ISSIGN(X) ((X) == \u0026lsquo;+\u0026rsquo; || (X) == \u0026lsquo;-\u0026rsquo;? 1 : 0) （如果x是一个代数符号字符，最后一个宏的值为 1 ，即为真。） 要注意以下几点。 记住宏名中不允许有空格，但是在替换字符串中可以有空格。ANSI C 允许在参数列表中使用空格。\n用圆括号把宏的参数和整个替换体括起来。这样能确保被括起来的部分 # 在下面这样的表达式中正确地展开： # forks = 2 * MAX(guests + 3, last); 用大写字母表示宏函数的名称。该惯例不如用大写字母表示宏常量应用 广泛。但是，大写字母可以提醒程序员注意，宏可能产生的副作用。 如果打算使用宏来加快程序的运行速度，那么首先要确定使用宏和使用 函数是否会导致较大差异。在程序中只使用一次的宏无法明显减少程序的运 行时间。在嵌套循环中使用宏更有助于提高效率。许多系统提供程序分析器 以帮助程序员压缩程序中最耗时的部分。 假设你开发了一些方便的宏函数，是否每写一个新程序都要重写这些 宏？如果使用#include指令，就不用这样做了。\n16.5 文件包含： #include # 当预处理器发现#include 指令时，会查看后面的文件名并把文件的内容 包含到当前文件中，即替换源文件中的#include指令。这相当于把被包含文 件的全部内容输入到源文件#include指令所在的位置。#include指令有两种形 式： #include \u0026lt;stdio.h\u0026gt; ←文件名在尖括号中 #include \u0026ldquo;mystuff.h\u0026rdquo; ←文件名在双引号中 在 UNIX 系统中，尖括号告诉预处理器在标准系统目录中查找该文件。 双引号告诉预处理器首先在当前目录中（或文件名中指定的其他目录）查找 该文件，如果未找到再查找标准系统目录： #include \u0026lt;stdio.h\u0026gt; ←查找系统目录 #include \u0026ldquo;hot.h\u0026rdquo; ←查找当前工作目录 #include \u0026ldquo;/usr/biff/p.h\u0026rdquo; ←查找/usr/biff目录 集成开发环境（IDE）也有标准路径或系统头文件的路径。许多集成开 发环境提供菜单选项，指定用尖括号时的查找路径。在 UNIX 中，使用双引 号意味着先查找本地目录，但是具体查找哪个目录取决于编译器的设定。有 些编译器会搜索源代码文件所在的目录，有些编译器则搜索当前的工作目 录，还有些搜索项目文件所在的目录。 ANSI C不为文件提供统一的目录模型，因为不同的计算机所用的系统 不同。一般而言，命名文件的方法因系统而异，但是尖括号和双引号的规则 与系统无关。 为什么要包含文件？因为编译器需要这些文件中的信息。例如，stdio.h 文件中通常包含EOF、NULL、getchar()和 putchar()的定义。getchar()和 putchar()被定义为宏函数。此外，该文件中还包含C的其他I/O函数。\nC语言习惯用.h后缀表示头文件，这些文件包含需要放在程序顶部的信 息。头文件经常包含一些预处理器指令。有些头文件（如stdio.h）由系统提 供，当然你也可以创建自己的头文件。 包含一个大型头文件不一定显著增加程序的大小。在大部分情况下，头 文件的内容是编译器生成最终代码时所需的信息，而不是添加到最终代码中 的材料。\n16.5.1 头文件示例 # 假设你开发了一个存放人名的结构，还编写了一些使用该结构的函数。 # 可以把不同的声明放在头文件中。程序清单16.6演示了一个这样的例子。 # 程序清单 16.6 names_st.h 头文件 // names_st.h -- names_st 结构的头文件 // 常量 #include \u0026lt;string.h\u0026gt; #define SLEN 32 // 结构声明 struct names_st { char first[SLEN]; char last[SLEN]; }; // 类型定义 typedef struct names_st names; // 函数原型 void get_names(names *); void show_names(const names *); char * s_gets(char * st, int n); 该头文件包含了一些头文件中常见的内容：#define指令、结构声明、 typedef和函数原型。注意，这些内容是编译器在创建可执行代码时所需的信 息，而不是可执行代码。为简单起见，这个特殊的头文件过于简单。通常， 应该用#ifndef和#define防止多重包含头文件。我们稍后介绍这些内容。 可执行代码通常在源代码文件中，而不是在头文件中。例如，程序清单 16.7中有头文件中函数原型的定义。该程序包含了names_st.h头文件，所以 编译器知道names类型。 程序清单 16.7 name_st.c 源文件 // names_st.c \u0026ndash; 定义 names_st.h中的函数 #include \u0026lt;stdio.h\u0026gt; #include \u0026ldquo;names_st.h\u0026rdquo; // 包含头文件 // 函数定义 void get_names(names * pn) { printf(\u0026ldquo;Please enter your first name: \u0026ldquo;); s_gets(pn-\u0026gt;first, SLEN);\nprintf(\u0026ldquo;Please enter your last name: \u0026ldquo;); s_gets(pn-\u0026gt;last, SLEN); } void show_names(const names * pn) { printf(\u0026quot;%s %s\u0026rdquo;, pn-\u0026gt;first, pn-\u0026gt;last); } char * s_gets(char * st, int n) { char * ret_val; char * find; ret_val = fgets(st, n, stdin); if (ret_val) { find = strchr(st, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是NULL， *find = \u0026lsquo;\\0\u0026rsquo;; // 在此处放置一个空字符 else while (getchar() != \u0026lsquo;\\n\u0026rsquo;)\ncontinue; // 处理输入行中的剩余字符 } return ret_val; } get_names()函数通过s_gets()函数调用了fgets()函数，避免了目标数组溢 出。程序清单16.8使用了程序清单16.6的头文件和程序清单16.7的源文件。 程序清单 16.8 useheader.c 程序 // useheader.c \u0026ndash; 使用 names_st 结构 #include \u0026lt;stdio.h\u0026gt; #include \u0026ldquo;names_st.h\u0026rdquo; // 记住要链接 names_st.c int main(void) { names candidate; get_names(\u0026amp;candidate); printf(\u0026ldquo;Let\u0026rsquo;s welcome \u0026ldquo;); show_names(\u0026amp;candidate); printf(\u0026rdquo; to this program!\\n\u0026rdquo;); return 0;\n} # 下面是该程序的输出： # Please enter your first name: Ian Please enter your last name: Smersh Let\u0026rsquo;s welcome Ian Smersh to this program! 该程序要注意下面几点。 两个源代码文件都使用names_st类型结构，所以它们都必须包含 names_st.h头文件。 必须编译和链接names_st.c和useheader.c源代码文件。 声明和指令放在nems_st.h头文件中，函数定义放在names_st.c源代码文 件中。\n16.5.2 使用头文件 # 浏览任何一个标准头文件都可以了解头文件的基本信息。头文件中最常 # 用的形式如下。 # 明示常量——例如，stdio.h中定义的EOF、NULL和BUFSIZE（标准I/O 缓冲区大小）。 宏函数——例如，getc(stdin)通常用getchar()定义，而getc()经常用于定 义较复杂的宏，头文件ctype.h通常包含ctype系列函数的宏定义。 函数声明——例如，string.h头文件（一些旧的系统中是strings.h）包含 字符串函数系列的函数声明。在ANSI C和后面的标准中，函数声明都是函 数原型形式。 结构模版定义——标准I/O函数使用FILE结构，该结构中包含了文件和\n与文件缓冲区相关的信息。FILE结构在头文件stdio.h中。 类型定义——标准 I/O 函数使用指向 FILE 的指针作为参数。通常， stdio.h 用#define 或typedef把FILE定义为指向结构的指针。类似地，size_t和 time_t类型也定义在头文件中。 许多程序员都在程序中使用自己开发的标准头文件。如果开发一系列相 关的函数或结构，那么这种方法特别有价值。 另外，还可以使用头文件声明外部变量供其他文件共享。例如，如果已 经开发了共享某个变量的一系列函数，该变量报告某种状况（如，错误情 况），这种方法就很有效。这种情况下，可以在包含这些函数声明的源代码 文件定义一个文件作用域的外部链接变量： int status = 0; // 该变量具有文件作用域，在源代码文件 然后，可以在与源代码文件相关联的头文件中进行引用式声明： extern int status; // 在头文件中 这行代码会出现在包含了该头文件的文件中，这样使用该系列函数的文 件都能使用这个变量。虽然源代码文件中包含该头文件后也包含了该声明， 但是只要声明的类型一致，在一个文件中同时使用定义式声明和引用式声明 没问题。 需要包含头文件的另一种情况是，使用具有文件作用域、内部链接和 const 限定符的变量或数组。const 防止值被意外修改，static 意味着每个包含 该头文件的文件都获得一份副本。因此，不需要在一个文件中进行定义式声 明，在其他文件中进行引用式声明。 #include和#define指令是最常用的两个C预处理器特性。接下来，我们介 绍一些其他指令。\n16.6 其他指令 # 程序员可能要为不同的工作环境准备C程序和C库包。不同的环境可能 # 使用不同的代码类型。预处理器提供一些指令，程序员通过修改#define的值 即可生成可移植的代码。#undef指令取消之前的#define定义。#if、#ifdef、 #ifndef、#else、#elif和#endif指令用于指定什么情况下编写哪些代码。#line 指令用于重置行和文件信息，#error指令用于给出错误消息，#pragma指令用 于向编译器发出指令。\n16.6.1 #undef 指令 # #undef指令用于“取消”已定义的#define指令。也就是说，假设有如下定 义： #define LIMIT 400 然后，下面的指令: #undef LIMIT 将移除上面的定义。现在就可以把LIMIT重新定义为一个新值。即使原 来没有定义LIMIT，取消LIMIT的定义仍然有效。如果想使用一个名称，又 不确定之前是否已经用过，为安全起见，可以用#undef 指令取消该名字的定 义。\n16.6.2 从 C 预处理器角度看已定义 # 处理器在识别标识符时，遵循与C相同的规则：标识符可以由大写字 # 母、小写字母、数字和下划线字符组成，且首字符不能是数字。当预处理器 # 在预处理器指令中发现一个标识符时，它会把该标识符当作已定义的或未定 # 义的。这里的已定义表示由预处理器定义。如果标识符是同一个文件中由前 # 面的#define指令创建的宏名，而且没有用#undef 指令关闭，那么该标识符是 已定义的。如果标识符不是宏，假设是一个文件作用域的C变量，那么该标\n识符对预处理器而言就是未定义的。 # 已定义宏可以是对象宏，包括空宏或类函数宏： # #define LIMIT 1000 // LIMIT是已定义的 #define GOOD // GOOD 是已定义的 #define A(X) ((-(X))*(X)) // A 是已定义的 int q; // q 不是宏，因此是未定义的 #undef GOOD // GOOD 取消定义，是未定义的 注意，#define宏的作用域从它在文件中的声明处开始，直到用#undef指 令取消宏为止，或延伸至文件尾（以二者中先满足的条件作为宏作用域的结 束）。另外还要注意，如果宏通过头文件引入，那么#define在文件中的位置 取决于#include指令的位置。 稍后将介绍几个预定义宏，如__DATE__和__FILE__。这些宏一定是已 定义的，而且不能取消定义。\n16.6.3 条件编译 # 可以使用其他指令创建条件编译（conditinal compilation）。也就是说， 可以使用这些指令告诉编译器根据编译时的条件执行或忽略信息（或代码） 块。 1.#ifdef 、 #else 和 #endif 指令 我们用一个简短的示例来演示条件编译的情况。考虑下面的代码： #ifdef MAVIS #include \u0026ldquo;horse.h\u0026rdquo;// 如果已经用#define定义了 MAVIS，则执行下面的指 令\n#define STABLES 5 #else #include \u0026ldquo;cow.h\u0026rdquo; //如果没有用#define定义 MAVIS，则执行下面的 指令 #define STABLES 15 #endif 这里使用的较新的编译器和 ANSI 标准支持的缩进格式。如果使用旧的 编译器，必须左对齐所有的指令或至少左对齐#号，如下所示： #ifdef MAVIS #include \u0026ldquo;horse.h\u0026rdquo; // 如果已经用#define定义了 MAVIS，则执行 下面的指令 #define STABLES 5 #else #include \u0026ldquo;cow.h\u0026rdquo; //如果没有用#define定义 MAVIS，则执行下 面的指令 #define STABLES 15 #endif #ifdef指令说明，如果预处理器已定义了后面的标识符（MAVIS），则 执行#else或#endif指令之前的所有指令并编译所有C代码（先出现哪个指令 就执行到哪里）。如果预处理器未定义MAVIS，且有 #else指令，则执行 #else和#endif指令之间的所有代码。 #ifdef #else很像C的if else。两者的主要区别是，预处理器不识别用于标\n记块的花括号（{}），因此它使用#else（如果需要）和#endif（必须存在） 来标记指令块。这些指令结构可以嵌套。也可以用这些指令标记C语句块， 如程序清单16.9所示。 程序清单 16.9 ifdef.c 程序 /* ifdef.c \u0026ndash; 使用条件编译 / #include \u0026lt;stdio.h\u0026gt; #define JUST_CHECKING #define LIMIT 4 int main(void) { int i; int total = 0; for (i = 1; i \u0026lt;= LIMIT; i++) { total += 2 * ii + 1; #ifdef JUST_CHECKING printf(\u0026ldquo;i=%d, running total = %d\\n\u0026rdquo;, i, total); #endif } printf(\u0026ldquo;Grand total = %d\\n\u0026rdquo;, total);\nreturn 0; } 编译并运行该程序后，输出如下： i=1, running total = 3 i=2, running total = 12 i=3, running total = 31 i=4, running total = 64 Grand total = 64 如果省略JUST_CHECKING定义（把它放在C注释中，或者使用#undef指 令取消它的定义）并重新编译该程序，只会输出最后一行。可以用这种方法 在调试程序。定义JUST_CHECKING并合理使用#ifdef，编译器将执行用于 调试的程序代码，打印中间值。调试结束后，可移除JUST_CHECKING定义 并重新编译。如果以后还需要使用这些信息，重新插入定义即可。这样做省 去了再次输入额外打印语句的麻烦。#ifdef还可用于根据不同的C实现选择合 适的代码块。 2.#ifndef 指令 #ifndef指令与#ifdef指令的用法类似，也可以和#else、#endif一起使用， 但是它们的逻辑相反。#ifndef指令判断后面的标识符是否是未定义的，常用 于定义之前未定义的常量。如下所示： /* arrays.h */ #ifndef SIZE #define SIZE 100\n#endif （旧的实现可能不允许使用缩进的#define） 通常，包含多个头文件时，其中的文件可能包含了相同宏定义。#ifndef 指令可以防止相同的宏被重复定义。在首次定义一个宏的头文件中用#ifndef 指令激活定义，随后在其他头文件中的定义都被忽略。 #ifndef指令还有另一种用法。假设有上面的arrays.h头文件，然后把下面 一行代码放入一个头文件中： #include \u0026ldquo;arrays.h\u0026rdquo; SIZE被定义为 100 。但是，如果把下面的代码放入该头文件： #define SIZE 10 #include \u0026ldquo;arrays.h\u0026rdquo; SIZE则被设置为 10 。这里，当执行到#include \u0026ldquo;arrays.h\u0026quot;这行，处理 array.h中的代码时，由于SIZE是已定义的，所以跳过了#define SIZE 100这行 代码。鉴于此，可以利用这种方法，用一个较小的数组测试程序。测试完毕 后，移除#define SIZE 10并重新编译。这样，就不用修改头文件数组本身 了。 #ifndef指令通常用于防止多次包含一个文件。也就是说，应该像下面这 样设置头文件： /* things.h / #ifndef THINGS_H_ #define THINGS_H_ / 省略了头文件中的其他内容*/\n#endif 假设该文件被包含了多次。当预处理器首次发现该文件被包含时， THINGS_H_是未定义的，所以定义了THINGS_H_，并接着处理该文件的其 他部分。当预处理器第 2 次发现该文件被包含时，THINGS_H_是已定义的， 所以预处理器跳过了该文件的其他部分。 为何要多次包含一个文件？最常见的原因是，许多被包含的文件中都包 含着其他文件，所以显式包含的文件中可能包含着已经包含的其他文件。这 有什么问题？在被包含的文件中有某些项（如，一些结构类型的声明）只能 在一个文件中出现一次。C标准头文件使用#ifndef技巧避免重复包含。但 是，这存在一个问题：如何确保待测试的标识符没有在别处定义。通常，实 现的供应商使用这些方法解决这个问题：用文件名作为标识符、使用大写字 母、用下划线字符代替文件名中的点字符、用下划线字符做前缀或后缀（可 能使用两条下划线）。例如，查看stdio.h头文件，可以发现许多类似的代 码： #ifndef _STDIO_H #define STDIO_H // 省略了文件的内容 #endif 你也可以这样做。但是，由于标准保留使用下划线作为前缀，所以在自 己的代码中不要这样写，避免与标准头文件中的宏发生冲突。程序清单 16.10修改了程序清单16.6中的头文件，使用#ifndef避免文件被重复包含。 程序清单 16.10 names.c 程序 // names.h \u0026ndash;修订后的 names_st 头文件，避免重复包含 #ifndef NAMES_H\n#define NAMES_H_ // 明示常量 #define SLEN 32 // 结构声明 struct names_st { char first[SLEN]; char last[SLEN]; }; // 类型定义 typedef struct names_st names; // 函数原型 void get_names(names *); void show_names(const names *); char * s_gets(char * st, int n); #endif 用程序清单16.11的程序测试该头文件没问题，但是如果把清单16.10中 的#ifndef保护删除后，程序就无法通过编译。 程序清单 16.11 doubincl.c 程序\n// doubincl.c \u0026ndash; 包含头文件两次 #include \u0026lt;stdio.h\u0026gt; #include \u0026ldquo;names.h\u0026rdquo; #include \u0026ldquo;names.h\u0026rdquo; // 不小心第 2 次包含头文件 int main() { names winner = { \u0026ldquo;Less\u0026rdquo;, \u0026ldquo;Ismoor\u0026rdquo; }; printf(\u0026ldquo;The winner is %s %s.\\n\u0026rdquo;, winner.first, winner.last); return 0; } 3.#if 和 #elif 指令 #if指令很像C语言中的if。#if后面跟整型常量表达式，如果表达式为非 零，则表达式为真。可以在指令中使用C的关系运算符和逻辑运算符： #if SYS == 1 #include \u0026ldquo;ibm.h\u0026rdquo; #endif 可以按照if else的形式使用#elif（早期的实现不支持#elif）。例如，可 以这样写： #if SYS == 1\n#include \u0026ldquo;ibmpc.h\u0026rdquo; #elif SYS == 2 #include \u0026ldquo;vax.h\u0026rdquo; #elif SYS == 3 #include \u0026ldquo;mac.h\u0026rdquo; #else #include \u0026ldquo;general.h\u0026rdquo; #endif 较新的编译器提供另一种方法测试名称是否已定义，即用#if defined (VAX)代替#ifdef VAX。 这里，defined是一个预处理运算符，如果它的参数是用#defined定义 过，则返回 1 ；否则返回 0 。这种新方法的优点是，它可以和#elif一起使用。 下面用这种形式重写前面的示例： #if defined (IBMPC) #include \u0026ldquo;ibmpc.h\u0026rdquo; #elif defined (VAX) #include \u0026ldquo;vax.h\u0026rdquo; #elif defined (MAC) #include \u0026ldquo;mac.h\u0026rdquo; #else\n#include \u0026ldquo;general.h\u0026rdquo; #endif 如果在VAX机上运行这几行代码，那么应该在文件前面用下面的代码定 义VAX： #define VAX 条件编译还有一个用途是让程序更容易移植。改变文件开头部分的几个 关键的定义，即可根据不同的系统设置不同的值和包含不同的文件。\n16.6.4 预定义宏 # C标准规定了一些预定义宏，如表16.1所列。 # 表 16.1 预 定 义 宏 C99 标准提供一个名为_ func 的预定义标识符，它展开为一个代表 函数名的字符串（该函数包含该标识符）。那么， func 必须具有函数 作用域，而从本质上看宏具有文件作用域。因此， func _是C语言的预定 义标识符，而不是预定义宏。 程序清单16.12 中使用了一些预定义宏和预定义标识符。注意，其中一 些是C99 新增的，所以不支持C99的编译器可能无法识别它们。如果使用 GCC，必须设置-std=c99或-std=c11。\n程序清单 16.12 predef.c 程序 // predef.c \u0026ndash; 预定义宏和预定义标识符 #include \u0026lt;stdio.h\u0026gt; void why_me(); int main() { printf(\u0026ldquo;The file is %s.\\n\u0026rdquo;, FILE); printf(\u0026ldquo;The date is %s.\\n\u0026rdquo;, DATE); printf(\u0026ldquo;The time is %s.\\n\u0026rdquo;, TIME); printf(\u0026ldquo;The version is %ld.\\n\u0026rdquo;, STDC_VERSION); printf(\u0026ldquo;This is line %d.\\n\u0026rdquo;, LINE); printf(\u0026ldquo;This function is %s\\n\u0026rdquo;, func); why_me(); return 0; } void why_me() { printf(\u0026ldquo;This function is %s\\n\u0026rdquo;, func); printf(\u0026ldquo;This is line %d.\\n\u0026rdquo;, LINE);\n} # 下面是该程序的输出： # The file is predef.c. The date is Sep 23 2013. The time is 22:01:09. The version is 201112. This is line 11. This function is main This function is why_me This is line 21. 16.6.5 #line 和 #error # #line指令重置_ LINE 和 FILE _宏报告的行号和文件名。可以这 样使用#line： #line 1000 // 把当前行号重置为 1000 #line 10 \u0026ldquo;cool.c\u0026rdquo; // 把行号重置为 10 ，把文件名重置为cool.c #error 指令让预处理器发出一条错误消息，该消息包含指令中的文本。 如果可能的话，编译过程应该中断。可以这样使用#error指令： #if _ STDC_VERSION _ != 201112L #error Not C11 #endif\n编译以上代码生成后，输出如下： # $ gcc newish.c newish.c:14:2: error: #error Not C11 $ gcc -std=c11 newish.c $ 如果编译器只支持旧标准，则会编译失败，如果支持C11标准，就能成 功编译。\n16.6.6 #pragma # 在现在的编译器中，可以通过命令行参数或IDE菜单修改编译器的一些 # 设置。#pragma把编译器指令放入源代码中。例如，在开发C99时，标准被 称为C9X，可以使用下面的编译指示（pragma）让编译器支持C9X： #pragma c9x on 一般而言，编译器都有自己的编译指示集。例如，编译指示可能用于控 制分配给自动变量的内存量，或者设置错误检查的严格程度，或者启用非标 准语言特性等。C99 标准提供了 3 个标准编译指示，但是超出了本书讨论的 范围。 C99还提供_Pragma预处理器运算符，该运算符把字符串转换成普通的 编译指示。例如： _Pragma(\u0026ldquo;nonstandardtreatmenttypeB on\u0026rdquo;) 等价于下面的指令： #pragma nonstandardtreatmenttypeB on 由于该运算符不使用#符号，所以可以把它作为宏展开的一部分：\n#define PRAGMA(X) _Pragma(#X) #define LIMRG(X) PRAGMA(STDC CX_LIMITED_RANGE X) 然后，可以使用类似下面的代码： LIMRG ( ON ) 顺带一提，下面的定义看上去没问题，但实际上无法正常运行： #define LIMRG(X) _Pragma(STDC CX_LIMITED_RANGE #X) 问题在于这行代码依赖字符串的串联功能，而预处理过程完成之后才会 串联字符串。 _Pragma 运算符完成“解字符串”（destringizing）的工作，即把字符串中 的转义序列转换成它所代表的字符。因此， _Pragma(\u0026ldquo;use_bool \u0026quot;true \u0026quot;false\u0026rdquo;) 变成了： #pragma use_bool \u0026ldquo;true \u0026ldquo;false\n16.6.7 泛型选择（ C11 ） # 在程序设计中，泛型编程（generic programming）指那些没有特定类 型，但是一旦指定一种类型，就可以转换成指定类型的代码。例如，C++在 模板中可以创建泛型算法，然后编译器根据指定的类型自动使用实例化代 码。C没有这种功能。然而，C11新增了一种表达式，叫作泛型选择表达式 （generic selection expression），可根据表达式的类型（即表达式的类型是 int、double 还是其他类型）选择一个值。泛型选择表达式不是预处理器指 令，但是在一些泛型编程中它常用作#define宏定义的一部分。 下面是一个泛型选择表达式的示例：\n_Generic(x, int: 0, float: 1, double: 2, default: 3) _Generic是C11的关键字。_Generic后面的圆括号中包含多个用逗号分隔 的项。第 1 个项是一个表达式，后面的每个项都由一个类型、一个冒号和一 个值组成，如float: 1。第 1 个项的类型匹配哪个标签，整个表达式的值是该 标签后面的值。例如，假设上面表达式中x是int类型的变量，x的类型匹配 int:标签，那么整个表达式的值就是 0 。如果没有与类型匹配的标签，表达式 的值就是default:标签后面的值。泛型选择语句与 switch 语句类似，只是前 者用表达式的类型匹配标签，而后者用表达式的值匹配标签。 下面是一个把泛型选择语句和宏定义组合的例子： #define MYTYPE(X) _Generic((X),\nint: \u0026ldquo;int\u0026rdquo;,\nfloat : \u0026ldquo;float\u0026rdquo;,\ndouble: \u0026ldquo;double\u0026rdquo;,\ndefault: \u0026ldquo;other\u0026rdquo;\n) 宏必须定义为一条逻辑行，但是可以用\\把一条逻辑行分隔成多条物理 行。在这种情况下，对泛型选择表达式求值得字符串。例如，对 MYTYPE(5)求值得\u0026quot;int\u0026rdquo;，因为值 5 的类型与int:标签匹配。程序清单16.13演 示了这种用法。 程序清单 16.13 mytype.c 程序 // mytype.c #include \u0026lt;stdio.h\u0026gt;\n#define MYTYPE(X) _Generic((X),\nint: \u0026ldquo;int\u0026rdquo;,\nfloat : \u0026ldquo;float\u0026rdquo;,\ndouble: \u0026ldquo;double\u0026rdquo;,\ndefault: \u0026ldquo;other\u0026rdquo;\n) int main(void) { int d = 5; printf(\u0026quot;%s\\n\u0026rdquo;, MYTYPE(d)); // d 是int类型 printf(\u0026quot;%s\\n\u0026rdquo;, MYTYPE(2.0*d)); // 2.0 * d 是double类型 printf(\u0026quot;%s\\n\u0026rdquo;, MYTYPE(3L)); // 3L 是long类型 printf(\u0026quot;%s\\n\u0026rdquo;, MYTYPE(\u0026amp;d)); // \u0026amp;d 的类型是 int * return 0; } 下面是该程序的输出： int double other\nother MYTYPE()最后两个示例所用的类型与标签不匹配，所以打印默认的字 符串。可以使用更多类型标签来扩展宏的能力，但是该程序主要是为了演示 _Generic的基本工作原理。 对一个泛型选择表达式求值时，程序不会先对第一个项求值，它只确定 类型。只有匹配标签的类型后才会对表达式求值。 可以像使用独立类型（“泛型”）函数那样使用_Generic 定义宏。本章后 面介绍 math 库时会给出一个示例。\n16.7 内联函数（ C99 ） # 通常，函数调用都有一定的开销，因为函数的调用过程包括建立调用、 # 传递参数、跳转到函数代码并返回。使用宏使代码内联，可以避免这样的开 # 销。C99还提供另一种方法：内联函数（inline function）。读者可能顾名思 义地认为内联函数会用内联代码替换函数调用。其实C99和C11标准中叙述 的是：“把函数变成内联函数建议尽可能快地调用该函数，其具体效果由实 现定义”。因此，把函数变成内联函数，编译器可能会用内联代码替换函数 调用，并（或）执行一些其他的优化，但是也可能不起作用。 创建内联函数的定义有多种方法。标准规定具有内部链接的函数可以成 为内联函数，还规定了内联函数的定义与调用该函数的代码必须在同一个文 件中。因此，最简单的方法是使用函数说明符 inline 和存储类别说明符 static。通常，内联函数应定义在首次使用它的文件中，所以内联函数也相 当于函数原型。如下所示： #include \u0026lt;stdio.h\u0026gt; inline static void eatline() // 内联函数定义/原型 { while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } int main() { \u0026hellip;\neatline(); // 函数调用 \u0026hellip; } 编译器查看内联函数的定义（也是原型），可能会用函数体中的代码替 换 eatline()函数调用。也就是说，效果相当于在函数调用的位置输入函数体 中的代码： #include \u0026lt;stdio.h\u0026gt; inline static void eatline() //内联函数定义/原型 { while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } int main() { \u0026hellip; while (getchar() != \u0026lsquo;\\n\u0026rsquo;) //替换函数调用 continue; \u0026hellip; } 由于并未给内联函数预留单独的代码块，所以无法获得内联函数的地址\n（实际上可以获得地址，不过这样做之后，编译器会生成一个非内联函 # 数）。另外，内联函数无法在调试器中显示。 # 内联函数应该比较短小。把较长的函数变成内联并未节约多少时间，因 # 为执行函数体的时间比调用函数的时间长得多。 # 编译器优化内联函数必须知道该函数定义的内容。这意味着内联函数定 # 义与函数调用必须在同一个文件中。鉴于此，一般情况下内联函数都具有内 # 部链接。因此，如果程序有多个文件都要使用某个内联函数，那么这些文件 # 中都必须包含该内联函数的定义。最简单的做法是，把内联函数定义放入头 # 文件，并在使用该内联函数的文件中包含该头文件即可。 # // eatline.h #ifndef EATLINE_H_ #define EATLINE_H_ inline static void eatline() { while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } #endif 一般都不在头文件中放置可执行代码，内联函数是个特例。因为内联函 数具有内部链接，所以在多个文件中定义同一个内联函数不会产生什么问 题。 与C++不同的是，C还允许混合使用内联函数定义和外部函数定义（具\n有外部链接的函数定义）。例如，一个程序中使用下面 3 个文件： # //file1.c ... inline static double square(double); double square(double x) { return x * x; } int main() { double q = square(1.3); ... //file2.c ... double square(double x) { return (int) (x*x); } void spam(double v) { double kv = square(v); ... //file3.c ... inline double square(double x) { return (int) (x * x + 0.5); } void masp(double w) { double kw = square(w); \u0026hellip; 如上述代码所示， 3 个文件中都定义了square()函数。file1.c文件中是 inline static定义；file2.c 文件中是普通的函数定义（因此具有外部链接）； file3.c 文件中是 inline 定义，省略了static。 3 个文件中的函数都调用了square()函数，这会发生什么情况？。file1.c 文件中的main()使用square()的局部static定义。由于该定义也是inline定义， 所以编译器有可能优化代码，也许会内联该函数。file2.c 文件中，spam()函 数使用该文件中 square()函数的定义，该定义具有外部链接，其他文件也可 见。file3.c文件中，编译器既可以使用该文件中square()函数的内联定义，也 可以使用file2.c文件中的外部链接定义。如果像file3.c那样，省略file1.c文件 inline定义中的static，那么该inline定义被视为可替换的外部定义。 注意GCC在C99之前就使用一些不同的规则实现了内联函数，所以GCC 可以根据当前编译器的标记来解释inline。\n16.8 _Noreturn 函数（ C11 ） # C99新增inline关键字时，它是唯一的函数说明符（关键字extern和static 是存储类别说明符，可应用于数据对象和函数）。C11新增了第 2 个函数说 明符_Noreturn，表明调用完成后函数不返回主调函数。exit()函数是 _Noreturn 函数的一个示例，一旦调用exit()，它不会再返回主调函数。注 意，这与void返回类型不同。void类型的函数在执行完毕后返回主调函数， 只是它不提供返回值。 _Noreturn的目的是告诉用户和编译器，这个特殊的函数不会把控制返回 主调程序。告诉用户以免滥用该函数，通知编译器可优化一些代码。\n16.9 C 库 # 最初，并没有官方的C库。后来，基于UNIX的C实现成为了标准。ANSI # C委员会主要以这个标准为基础，开发了一个官方的标准库。在意识到C语 # 言的应用范围不断扩大后，该委员会重新定义了这个库，使之可以应用于其 # 他系统。 # 我们讨论过一些标准库中的 I/O 函数、字符函数和字符串函数。本章将 # 介绍更多函数。不过，首先要学习如何使用库。 # 16.9.1 访问 C 库 # 如何访问C库取决于实现，因此你要了解当前系统的一般情况。首先， # 可以在多个不同的位置找到库函数。例如，getchar()函数通常作为宏定义在 stdio.h头文件中，而strlen()通常在库文件中。其次，不同的系统搜索这些函 数的方法不同。下面介绍 3 种可能的方法。\n1. 自动访问 在一些系统中，只需编译程序，就可使用一些常用的库函数。 记住，在使用函数之前必须先声明函数的类型，通过包含合适的头文件 即可完成。在描述库函数的用户手册中，会指出使用某函数时应包含哪个头 文件。但是在一些旧系统上，可能必须自己输入函数声明。再次提醒读者， 用户手册中指明了函数类型。另外，附录B“参考资料”中根据头文件分组， 总结了ANSI C库函数。 过去，不同的实现使用的头文件名不同。ANSI C标准把库函数分为多 个系列，每个系列的函数原型都放在一个特定的头文件中。 2. 文件包含 如果函数被定义为宏，那么可以通过#include 指令包含定义宏函数的文 件。通常，类似的宏都放在合适名称的头文件中。例如，许多系统（包括所\n有的ANSI C系统）都有ctype.h文件，该文件中包含了一些确定字符性质（如 大写、数字等）的宏。\n3. 库包含 在编译或链接程序的某些阶段，可能需要指定库选项。即使在自动检查 标准库的系统中，也会有不常用的函数库。必须通过编译时选项显式指定这 些库。注意，这个过程与包含头文件不同。头文件提供函数声明或原型，而 库选项告诉系统到哪里查找函数代码。虽然这里无法涉及所有系统的细节， 但是可以提醒读者应该注意什么。\n16.9.2 使用库描述 # 篇幅有限，我们无法讨论完整的库。但是，可以看几个具有代表性的示 # 例。首先，了解函数文档。 # 可以在多个地方找到函数文档。你所使用的系统可能有在线手册，集成 # 开发环境通常都有在线帮助。C实现的供应商可能提供描述库函数的纸质版 # 用户手册，或者把这些材料放在CD-ROM中或网上。有些出版社也出版C库 # 函数的参考手册。这些材料中，有些是一般材料，有些则是针对特定实现 # 的。本书附录B中提供了一个库函数的总结。 # 阅读文档的关键是看懂函数头。许多内容随时间变化而变化。下面是旧 # 的UNIX文档中，关于fread()的描述： #include \u0026lt;stdio.h\u0026gt; fread(ptr, sizeof(*ptr), nitems, stream) FILE *stream; 首先，给出了应该包含的文件，但是没有给出fread()、ptr、sizeof(*ptr) 或nitems的类型。过去，默认类型都是int，但是从描述中可以看出ptr是一个 指针（在早期的C中，指针被作为整数处理）。参数stream声明为指向FILE\n的指针。上面的函数声明中的第 2 个参数看上去像是sizeof运算符，而实际上 这个参数的值应该是ptr所指向对象的大小。虽然用sizeof作为参数没什么问 题，但是用int类型的值作为参数更符合语法。 后来，上面的描述变成了： #include \u0026lt;stdio.h\u0026gt; int fread(ptr, size, nitems, stream;) char *ptr; int size, nitems; FILE *stream; 现在，所有的类型都显式说明，ptr作为指向char的指针。 ANSI C90标准提供了下面的描述： #include \u0026lt;stdio.h\u0026gt; size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 首先，使用了新的函数原型格式。其次，改变了一些类型。size_t 类型 被定义为 sizeof 运算符的返回值类型——无符号整数类型，通常是unsigned int或unsigned long。stddef.h文件中包含了size_t类型的typedef或#define定义。 其他文件（包括stdio.h）通过包含stddef.h来包含这个定义。许多函数（包括 fread()）的实际参数中都要使用sizeof运算符，形式参数的size_t类型中正好 匹配这种常见的情况。 另外，ANSI C把指向void的指针作为一种通用指针，用于指针指向不同 类型的情况。例如，fread()的第 1 个参数可能是指向一个double类型数组的指 针，也可能是指向其他类型结构的指针。如果假设实际参数是一个指向内含 20 个double类型元素数组的指针，且形式参数是指向void的指针，那么编译\n器会选用合适的类型，不会出现类型冲突的问题。 # C99/C11标准在以上的描述中加入了新的关键字restric： #include \u0026lt;stdio.h\u0026gt; size_t fread(void * restrict ptr, size_t size,size_t nmemb, FILE * restrict stream); 接下来，我们讨论一些特殊的函数。\n16.10 数学库 # 数学库中包含许多有用的数学函数。math.h头文件提供这些函数的原 型。表16.2中列出了一些声明在 math.h 中的函数。注意，函数中涉及的角度 都以弧度为单位（ 1 弧度=180/π=57.296 度）。参考资料 V“新增C99和C11标 准的ANSI C库”列出了C99和C11标准的所有函数。 表16.2 ANSI C标准的一些数学函数\n16.10.1 三角问题 # 我们可以使用数学库解决一些常见的问题：把x/y坐标转换为长度和角 度。例如，在网格上画了一条线，该线条水平穿过了 4 个单元（x的值），垂 直穿过了 3 个单元（y的值）。那么，该线的长度（量）和方向是什么？根据 数学的三角公式可知：\n大小 =square root (x^2 +y^2 ) 角度 = arctan(y/x) 数学库提供平方根函数和一对反正切函数，所以可以用C程序表示这个 问题。平方根函数是sqrt()，接受一个double类型的参数，并返回参数的平方 根，也是double类型。 atan()函数接受一个double类型的参数（即正切值），并返回一个角度 （该角度的正切值就是参数值）。但是，当线的x值和y值均为-5时，atan() 函数产生混乱。因为(-5)/(-5)得 1 ，所以atan()返回45°，该值与x和y均为 5 时的 返回值相同。也就是说，atan()无法区分角度相同但反向相反的线（实际 上，atan()返回值的单位是弧度而不是度，稍后介绍两者的转换）。 当然，C库还提供了atan2()函数。它接受两个参数：x的值和y的值。这 样，通过检查x和y的正负号就可以得出正确的角度值。atan2()和 atan()均返 回弧度值。把弧度转换为度，只需将弧度值乘以 180 ，再除以pi即可。pi的 值通过计算表达式4atan(1)得到。程序清单16.13演示了这些步骤。另外，学 习该程序还复习了结构和typedef相关的知识。 程序清单 16.14 rect_pol.c 程序 / rect_pol.c \u0026ndash; 把直角坐标转换为极坐标 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; #define RAD_TO_DEG (180/(4 * atan(1))) typedef struct polar_v { double magnitude; double angle; } Polar_V;\ntypedef struct rect_v { double x; double y; } Rect_V; Polar_V rect_to_polar(Rect_V); int main(void) { Rect_V input; Polar_V result; puts(\u0026ldquo;Enter x and y coordinates; enter q to quit:\u0026rdquo;); while (scanf(\u0026quot;%lf %lf\u0026rdquo;, \u0026amp;input.x, \u0026amp;input.y) == 2) { result = rect_to_polar(input); printf(\u0026ldquo;magnitude = %0.2f, angle = %0.2f\\n\u0026rdquo;, result.magnitude, result.angle); } puts(\u0026ldquo;Bye.\u0026rdquo;); return 0; }\nPolar_V rect_to_polar(Rect_V rv) { Polar_V pv; pv.magnitude = sqrt(rv.x * rv.x + rv.y * rv.y); if (pv.magnitude == 0) pv.angle = 0.0; else pv.angle = RAD_TO_DEG * atan2(rv.y, rv.x); return pv; } 下面是运行该程序后的一个输出示例： Enter x and y coordinates; enter q to quit: 10 10 magnitude = 14.14, angle = 45.00 -12 -5 magnitude = 13.00, angle = -157.38 q Bye. 如果编译时出现下面的消息：\nUndefined: _sqrt 或 \u0026lsquo;sqrt\u0026rsquo;: unresolved external 或者其他类似的消息，表明编译器链接器没有找到数学库。UNIX系统 会要求使用-lm标记（flag）指示链接器搜索数学库： cc rect_pol.c –lm 注意，-lm标记在命令行的末尾。因为链接器在编译器编译C文件后才开 始处理。在Linux中使用GCC编译器可能要这样写： gcc rect_pol.c -lm\n16.10.2 类型变体 # 基本的浮点型数学函数接受double类型的参数，并返回double类型的 值。当然，也可以把float或 long double 类型的参数传递给这些函数，它们仍 然能正常工作，因为这些类型的参数会被转换成double类型。这样做很方 便，但并不是最好的处理方式。如果不需要双精度，那么用float类型的单精 度值来计算会更快些。而且把long double类型的值传递给double类型的形参 会损失精度，形参获得的值可能不是原来的值。为了解决这些潜在的问题， C标准专门为float类型和long double类型提供了标准函数，即在原函数名前 加上f或l前缀。因此，sqrtf()是sqrt()的float版本，sqrtl()是sqrt()的long double 版本。 利用C11 新增的泛型选择表达式定义一个泛型宏，根据参数类型选择最 合适的数学函数版本。程序清单16.15演示了两种方法。 程序清单 16.15 generic.c 程序 // generic.c \u0026ndash; 定义泛型宏\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; #define RAD_TO_DEG (180/(4 * atanl(1))) // 泛型平方根函数 #define SQRT(X) _Generic((X),\nlong double: sqrtl, default: sqrt, float: sqrtf)(X) // 泛型正弦函数，角度的单位为度 #define SIN(X) _Generic((X),\nlong double: sinl((X)/RAD_TO_DEG),\ndefault: sin((X)/RAD_TO_DEG),\nfloat: sinf((X)/RAD_TO_DEG)\n) int main(void) { float x = 45.0f; double xx = 45.0; long double xxx = 45.0L;\nlong double y = SQRT(x); long double yy = SQRT(xx); long double yyy = SQRT(xxx); printf(\u0026rdquo;%.17Lf\\n\u0026rdquo;, y); // 匹配 float printf(\u0026rdquo;%.17Lf\\n\u0026rdquo;, yy); // 匹配 default printf(\u0026rdquo;%.17Lf\\n\u0026rdquo;, yyy); // 匹配 long double int i = 45; yy = SQRT(i); // 匹配 default printf(\u0026rdquo;%.17Lf\\n\u0026rdquo;, yy); yyy = SIN(xxx); // 匹配 long double printf(\u0026rdquo;%.17Lf\\n\u0026rdquo;, yyy); return 0; } 下面是该程序的输出： 6.70820379257202148 6.70820393249936942 6.70820393249936909 6.70820393249936942 0.70710678118654752\n如上所示，SQRT(i)和SQRT(xx)的返回值相同，因为它们的参数类型分 别是int和double，所以只能与default标签对应。 有趣的一点是，如何让_Generic 宏的行为像一个函数。SIN()的定义也 许提供了一个方法：每个带标号的值都是函数调用，所以_Generic表达式的 值是一个特定的函数调用，如sinf((X)/RAD_TO_DEG)，用传入SIN()的参数 替换X。 SQRT()的定义也许更简洁。_Generic表达式的值就是函数名，如sinf。 函数的地址可以代替该函数名，所以_Generic表达式的值是一个指向函数的 指针。然而，紧随整个_Generic表达式之后的是(X)，函数指针(参数)表示函 数指针。因此，这是一个带指定的参数的函数指针。 简而言之，对于 SIN()，函数调用在泛型选择表达式内部；而对于 SQRT()，先对泛型选择表达式求值得一个指针，然后通过该指针调用它所 指向的函数。\n16.10.3 tgmath.h 库（ C99 ） # C99标准提供的tgmath.h头文件中定义了泛型类型宏，其效果与程序清单 16.15类似。如果在math.h中为一个函数定义了 3 种类型（float、double和long double）的版本，那么tgmath.h文件就创建一个泛型类型宏，与原来 double 版本的函数名同名。例如，根据提供的参数类型，定义 sqrt()宏展开为 sqrtf()、sqrt()或 sqrtl()函数。换言之，sqrt()宏的行为和程序清单 16.15 中的 SQRT()宏类似。 如果编译器支持复数运算，就会支持complex.h头文件，其中声明了与 复数运算相关的函数。例如，声明有 csqrtf()、csqrt()和 csqrtl()，这些函数 分别返回 float complex、double complex和long double complex类型的复数平 方根。如果提供这些支持，那么tgmath.h中的sqrt()宏也能展开为相应的复数 平方根函数。 如果包含了tgmath.h，要调用sqrt()函数而不是sqrt()宏，可以用圆括号把\n被调用的函数名括起来： # #include \u0026lt;tgmath.h\u0026gt; \u0026hellip; float x = 44.0; double y; y = sqrt(x); // 调用宏，所以是 sqrtf(x) y = (sqrt)(x); // 调用函数 sqrt() 这样做没问题，因为类函数宏的名称必须用圆括号括起来。圆括号只会 影响操作顺序，不会影响括起来的表达式，所以这样做得到的仍然是函数调 用的结果。实际上，在讨论函数指针时提到过，由于C语言奇怪而矛盾的函 数指针规则，还也可以使用(*sqrt)()的形式来调用sqrt()函数。 不借助C标准以外的机制，C11新增的_Generic表达式是实现tgmath.h最 简单的方式。\n16.11 通用工具库 # 通用工具库包含各种函数，包括随机数生成器、查找和排序函数、转换 # 函数和内存管理函数。第 12 章介绍过rand()、srand()、malloc()和free()函数。 在ANSI C标准中，这些函数的原型都在stdlib.h头文件中。附录B参考资料V 列出了该系列的所有函数。现在，我们来进一步讨论其中的几个函数。\n16.11.1 exit() 和 atexit() 函数 # 在前面的章节中我们已经在程序示例中用过 exit()函数。而且，在 main()返回系统时将自动调用exit()函数。ANSI 标准还新增了一些不错的功 能，其中最重要的是可以指定在执行 exit()时调用的特定函数。atexit()函数 通过退出时注册被调用的函数提供这种功能，atexit()函数接受一个函数指针 作为参数。程序清单16.16演示了它的用法。 程序清单 16.16 byebye.c 程序 /* byebye.c \u0026ndash; atexit()示例 / #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void sign_off(void); void too_bad(void); int main(void) { int n; atexit(sign_off); / 注册 sign_off()函数 */\nputs(\u0026ldquo;Enter an integer:\u0026rdquo;); if (scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;n) != 1) { puts(\u0026ldquo;That\u0026rsquo;s no integer!\u0026rdquo;); atexit(too_bad); /* 注册 too_bad()函数 */ exit(EXIT_FAILURE); } printf(\u0026quot;%d is %s.\\n\u0026rdquo;, n, (n % 2 == 0)? \u0026ldquo;even\u0026rdquo; : \u0026ldquo;odd\u0026rdquo;); return 0; } void sign_off(void) { puts(\u0026ldquo;Thus terminates another magnificent program from\u0026rdquo;); puts(\u0026ldquo;SeeSaw Software!\u0026rdquo;); } void too_bad(void) { puts(\u0026ldquo;SeeSaw Software extends its heartfelt condolences\u0026rdquo;); puts(\u0026ldquo;to you upon the failure of your program.\u0026rdquo;);\n} # 下面是该程序的一个运行示例： # Enter an integer: 212 212 is even. Thus terminates another magnificent program from SeeSaw Software! 如果在IDE中运行，可能看不到最后两行。下面是另一个运行示例： Enter an integer: what? That\u0026rsquo;s no integer! SeeSaw Software extends its heartfelt condolences to you upon the failure of your program. Thus terminates another magnificent program from SeeSaw Software! 在IDE中运行，可能看不到最后 4 行。 接下来，我们讨论atexit()和exit()的参数。 1.atexit() 函数的用法 这个函数使用函数指针。要使用 atexit()函数，只需把退出时要调用的\n函数地址传递给 atexit()即可。函数名作为函数参数时相当于该函数的地 址，所以该程序中把sign_off或too_bad作为参数。然后，atexit()注册函数列 表中的函数，当调用exit()时就会执行这些函数。ANSI保证，在这个列表中 至少可以放 32 个函数。最后调用 exit()函数时，exit()会执行这些函数（执 行顺序与列表中的函数顺序相反，即最后添加的函数最先执行）。 注意，输入失败时，会调用sign_off()和too_bad()函数；但是输入成功时 只会调用sign_off()。因为只有输入失败时，才会进入if语句中注册 too_bad()。另外还要注意，最先调用的是最后一个被注册的函数。 atexit()注册的函数（如sign_off()和too_bad()）应该不带任何参数且返回 类型为void。通常，这些函数会执行一些清理任务，例如更新监视程序的文 件或重置环境变量。 注意，即使没有显式调用exit()，还是会调用sign_off()，因为main()结束 时会隐式调用exit()。 2.exit() 函数的用法 exit()执行完atexit()指定的函数后，会完成一些清理工作：刷新所有输出 流、关闭所有打开的流和关闭由标准I/O函数tmpfile()创建的临时文件。然后 exit()把控制权返回主机环境，如果可能的话，向主机环境报告终止状态。 通常，UNIX程序使用 0 表示成功终止，用非零值表示终止失败。UNIX返回 的代码并不适用于所有的系统，所以ANSI C为了可移植性的要求，定义了 一个名为EXIT_FAILURE的宏表示终止失败。类似地，ANSI C还定义了 EXIT_SUCCESS表示成功终止。不过，exit()函数也接受 0 表示成功终止。在 ANSI C中，在非递归的main()中使用exit()函数等价于使用关键字return。尽 管如此，在main()以外的函数中使用exit()也会终止整个程序。\n16.11.2 qsort() 函数 # 对较大型的数组而言，“快速排序”方法是最有效的排序算法之一。该算 # 法由C.A.R.Hoare于 1962 年开发。它把数组不断分成更小的数组，直到变成\n单元素数组。首先，把数组分成两部分，一部分的值都小于另一部分的值。 # 这个过程一直持续到数组完全排序好为止。 # 快速排序算法在C实现中的名称是qsort()。qsort()函数排序数组的数据 对象，其原型如下： void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)); 第 1 个参数是指针，指向待排序数组的首元素。ANSI C允许把指向任何 数据类型的指针强制转换成指向void的指针，因此，qsort()的第 1 个实际参数 可以引用任何类型的数组。 第 2 个参数是待排序项的数量。函数原型把该值转换为size_t类型。前面 提到过，size_t定义在标准头文件中，是sizeof运算符返回的整数类型。 由于qsort()把第 1 个参数转换为void指针，所以qsort()不知道数组中每个 元素的大小。为此，函数原型用第 3 个参数补偿这一信息，显式指明待排序 数组中每个元素的大小。例如，如果排序 double类型的数组，那么第 3 个参 数应该是sizeof(double)。 最后，qsort()还需要一个指向函数的指针，这个被指针指向的比较函数 用于确定排序的顺序。该函数应接受两个参数：分别指向待比较两项的指 针。如果第 1 项的值大于第 2 项，比较函数则返回正数；如果两项相同，则返 回 0 ；如果第 1 项的值小于第 2 项，则返回负数。qsort()根据给定的其他信息 计算出两个指针的值，然后把它们传递给比较函数。 qsort()原型中的第 4 个函数确定了比较函数的形式： int (*compar)(const void *, const void *) 这表明 qsort()最后一个参数是一个指向函数的指针，该函数返回 int 类 型的值且接受两个指向const void的指针作为参数，这两个指针指向待比较\n项。 # 程序清单16.17和后面的讨论解释了如何定义一个比较函数，以及如何 # 使用qsort()。该程序创建了一个内含随机浮点值的数组，并排序了这个数 组。 程序清单 16.17 qsorter.c 程序 /* qsorter.c \u0026ndash; 用 qsort()排序一组数字 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define NUM 40 void fillarray(double ar [], int n); void showarray(const double ar [], int n); int mycomp(const void * p1, const void * p2); int main(void) { double vals[NUM]; fillarray(vals, NUM); puts(\u0026ldquo;Random list:\u0026rdquo;); showarray(vals, NUM); qsort(vals, NUM, sizeof(double), mycomp); puts(\u0026quot;\\nSorted list:\u0026quot;);\nshowarray(vals, NUM); return 0; } void fillarray(double ar [], int n) { int index; for (index = 0; index \u0026lt; n; index++) ar[index] = (double) rand() / ((double) rand() + 0.1); } void showarray(const double ar [], int n) { int index; for (index = 0; index \u0026lt; n; index++) { printf(\u0026quot;%9.4f \u0026ldquo;, ar[index]); if (index % 6 == 5) putchar(\u0026rsquo;\\n\u0026rsquo;); } if (index % 6 != 0)\nputchar(\u0026rsquo;\\n\u0026rsquo;); } /* 按从小到大的顺序排序 / int mycomp(const void * p1, const void * p2) { / 要使用指向double的指针来访问这两个值 */ const double * a1 = (const double *) p1; const double * a2 = (const double *) p2; if (*a1 \u0026lt; *a2) return -1; else if (*a1 == *a2) return 0; else return 1; } 下面是该程序的运行示例: Random list: 0.0001 1.6475 2.4332 0.0693 0.7268 0.7383 24.0357 0.1009 87.1828 5.7361 0.6079 0.6330\n1.6058 0.1406 0.5933 1.1943 5.5295 2.2426 # 0.8364 2.7127 0.2514 0.9593 8.9635 0.7139 # 0.6249 1.6044 0.8649 2.1577 0.5420 15.0123 # 1.7931 1.6183 1.9973 2.9333 12.8512 1.3034 # 0.3032 1.1406 18.7880 0.9887 # Sorted list: 0.0001 0.0693 0.1009 0.1406 0.2514 0.3032 0.5420 0.5933 0.6079 0.6249 0.6330 0.7139 0.7268 0.7383 0.8364 0.8649 0.9593 0.9887 1.1406 1.1943 1.3034 1.6044 1.6058 1.6183 1.6475 1.7931 1.9973 2.1577 2.2426 2.4332 2.7127 2.9333 5.5295 5.7361 8.9635 12.8512 15.0123 18.7880 24.0357 87.1828 接下来分析两点：qsort()的用法和mycomp()的定义。 1.qsort() 的用法 qsort()函数排序数组的数据对象。该函数的ANSI原型如下： void qsort (void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *)); 第 1 个参数值指向待排序数组首元素的指针。在该程序中，实际参数是\ndouble类型的数组名vals，因此指针指向该数组的首元素。根据该函数的原 型，参数 vals 会被强制转换成指向 void 的指针。由于ANSI C允许把指向任 何数据类型的指针强制转换成指向void的指针，所以qsort()的第 1 个实际参数 可以引用任何类型的数组。 第 2 个参数是待排序项的数量。在程序清单16.17中是NUM，即数组元素 的数量。函数原型把该值转换为size_t类型。 第 3 个参数是数组中每个元素占用的空间大小，本例中为 sizeof(double)。 最后一个参数是mycomp，这里函数名即是函数的地址，该函数用于比 较元素。 2.mycomp() 的定义 前面提到过，qsort()的原型中规定了比较函数的形式： int (*compar)(const void *, const void *) 这表明 qsort()最后一个参数是一个指向函数的指针，该函数返回 int 类 型的值且接受两个指向const void的指针作为参数。程序中mycomp()使用的 就是这个原型： int mycomp(const void * p1, const void * p2); 记住，函数名作为参数时即是指向该函数的指针。因此，mycomp与 compar原型相匹配。 qsort()函数把两个待比较元素的地址传递给比较函数。在该程序中，把 待比较的两个double类型值的地址赋给p1和p2。注意，qsort()的第 1 个参数引 用整个数组，比较函数中的两个参数引用数组中的两个元素。这里存在一个 问题。为了比较指针所指向的值，必须解引用指针。因为值是 double 类 型，所以要把指针解引用为 double 类型的值。然而，qsort()要求指针指向\nvoid。要解决这个问题，必须在比较函数的内部声明两个类型正确的指针， 并初始化它们分别指向作为参数传入的值： /* 按从小到大的顺序排序值 / int mycomp(const void * p1, const void * p2) { / 使用指向double类型的指针访问值 */ const double * a1 = (const double *) p1; const double * a2 = (const double *) p2; if (*a1 \u0026lt; *a2) return -1; else if (*a1 == a2) return 0; else return 1; } 简而言之，为了让该方法具有通用性，qsort()和比较函数使用了指向 void 的指针。因此，必须把数组中每个元素的大小明确告诉qsort()，并且在 比较函数的定义中，必须把该函数的指针参数转换为对具体应用而言类型正 确的指针。 注意C和C++中的void\nC和C++对待指向void的指针有所不同。在这两种语言中，都可以把任 何类型的指针赋给void类型的指针。例如，程序清单16.17中，qsort()的函数 调用中把double指针赋给void指针。但是，C++要求在把void*指针赋给任 何类型的指针时必须进行强制类型转换。而C没有这样的要求。例如，程序 清单16.17中的mycomp()函数，就使用了这样的强制类型转换： const double * a1 = (const double ) p1; 这种强制类型转换，在C中是可选的，但在C++中是必须的。因为两种 语言都使用强制类型转换，所以遵循C++的要求也无不妥。将来如果要把该 程序转成C++，就不必更改这部分的代码。 下面再来看一个比较函数的例子。假设有下面的声明： struct names { char first[40]; char last[40]; }; struct names staff[100]; 如何调用qsort()？模仿程序清单16.17中qsort()的函数调用，应该是这 样： qsort(staff, 100, sizeof(struct names), comp); 这里 comp 是比较函数的函数名。那么，应如何编写这个函数？假设要 先按姓排序，如果同姓再按名排序，可以这样编写该函数： #include \u0026lt;string.h\u0026gt; int comp(const void * p1, const void * p2) / 该函数的形式必须是这样 */\n{ # /* 得到正确类型的指针 */ # const struct names *ps1 = (const struct names *) p1; const struct names *ps2 = (const struct names ) p2; int res; res = strcmp(ps1-\u0026gt;last, ps2-\u0026gt;last); / 比较姓 / if (res != 0) return res; else / 如果同姓，则比较名 */ return strcmp(ps1-\u0026gt;first, ps2-\u0026gt;first); } 该函数使用 strcmp()函数进行比较。strcmp()的返回值与比较函数的要求 相匹配。注意，通过指针访问结构成员时必须使用-\u0026gt;运算符。\n16.12 断言库 # assert.h 头文件支持的断言库是一个用于辅助调试程序的小型库。它由 assert()宏组成，接受一个整型表达式作为参数。如果表达式求值为假（非 零），assert()宏就在标准错误流（stderr）中写入一条错误信息，并调用 abort()函数终止程序（abort()函数的原型在stdlib.h头文件中）。assert()宏是 为了标识出程序中某些条件为真的关键位置，如果其中的一个具体条件为 假，就用 assert()语句终止程序。通常，assert()的参数是一个条件表达式或 逻辑表达式。如果 assert()中止了程序，它首先会显示失败的测试、包含测 试的文件名和行号。\n16.12.1 assert 的用法 # 程序清单16.18演示了一个使用assert的小程序。在求平方根之前，该程 序断言z是否大于或等于 0 。程序还错误地减去一个值而不是加上一个值，故 意让z得到不合适的值。 程序清单 16.18 assert.c 程序 /* assert.c \u0026ndash; 使用 assert() */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { double x, y, z; puts(\u0026ldquo;Enter a pair of numbers (0 0 to quit): \u0026ldquo;);\nwhile (scanf(\u0026quot;%lf%lf\u0026rdquo;, \u0026amp;x, \u0026amp;y) == 2 \u0026amp;\u0026amp; (x != 0 || y != 0)) { z = x * x - y * y; /* 应该用 + */ assert(z \u0026gt;= 0); printf(\u0026ldquo;answer is %f\\n\u0026rdquo;, sqrt(z)); puts(\u0026ldquo;Next pair of numbers: \u0026ldquo;); } puts(\u0026ldquo;Done\u0026rdquo;); return 0; } 下面是该程序的运行示例： Enter a pair of numbers (0 0 to quit): 4 3 answer is 2.645751 Next pair of numbers: 5 3 answer is 4.000000 Next pair of numbers:\n3 5 # Assertion failed: (z \u0026gt;= 0), function main, file /Users/assert.c, line 14. 具体的错误提示因编译器而异。让人困惑的是，这条消息可能不是指明 z \u0026gt;= 0，而是指明没有满足z \u0026gt;=0的条件。 用if语句也能完成类似的任务： if (z \u0026lt; 0) { puts(\u0026ldquo;z less than 0\u0026rdquo;); abort(); } 但是，使用 assert()有几个好处：它不仅能自动标识文件和出问题的行 号，还有一种无需更改代码就能开启或关闭 assert()的机制。如果认为已经 排除了程序的 bug，就可以把下面的宏定义写在包含assert.h的位置前面： #define NDEBUG 并重新编译程序，这样编译器就会禁用文件中的所有 assert()语句。如 果程序又出现问题，可以移除这条#define指令（或者把它注释掉），然后重 新编译程序，这样就重新启用了assert()语句。\n16.12.2 _Static_assert （ C11 ） # assert()表达式是在运行时进行检查。C11新增了一个特性： _Static_assert声明，可以在编译时检查assert()表达式。因此，assert()可以导 致正在运行的程序中止，而_Static_assert()可以导致程序无法通过编译。 _Static_assert()接受两个参数。第 1 个参数是整型常量表达式，第 2 个参数是\n一个字符串。如果第 1 个表达式求值为 0 （或_False），编译器会显示字符 串，而且不编译该程序。看看程序清单16.19的小程序，然后查看assert()和 _Static_assert()的区别。 程序清单 16.19 statasrt.c 程序 // statasrt.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;limits.h\u0026gt; _Static_assert(CHAR_BIT == 16, \u0026ldquo;16-bit char falsely assumed\u0026rdquo;); int main(void) { puts(\u0026ldquo;char is 16 bits.\u0026rdquo;); return 0; } 下面是在命令行编译的示例： $ clang statasrt.c statasrt.c:4:1: error: static_assert failed \u0026ldquo;16-bit char falsely assumed\u0026rdquo; _Static_assert(CHAR_BIT == 16, \u0026ldquo;16-bit char falsely assumed\u0026rdquo;); ^ ～～～～～～～～～～～～～～ 1 error generated. $\n根据语法，_Static_assert()被视为声明。因此，它可以出现在函数中， 或者在这种情况下出现在函数的外部。 _Static_assert要求它的第 1 个参数是整型常量表达式，这保证了能在编 译期求值（sizeof表达式被视为整型常量）。不能用程序清单16.18中的assert 代替_Static_assert，因为assert中作为测试表达式的z \u0026gt; 0不是常量表达式，要 到程序运行时才求值。当然，可以在程序清单16.19的main()函数中使用 assert(CHAR_BIT == 16)，但这会在编译和运行程序后才生成一条错误信 息，很没效率。\n16.13 string.h 库中的 memcpy() 和 memmove() # 不能把一个数组赋给另一个数组，所以要通过循环把数组中的每个元素 # 赋给另一个数组相应的元素。有一个例外的情况是：使用strcpy()和strncpy() 函数来处理字符数组。memcpy()和memmove()函数提供类似的方法处理任意 类型的数组。下面是这两个函数的原型： void *memcpy(void * restrict s1, const void * restrict s2, size_t n); void *memmove(void *s1, const void *s2, size_t n); 这两个函数都从 s2 指向的位置拷贝 n 字节到 s1 指向的位置，而且都返 回 s1 的值。所不同的是， memcpy()的参数带关键字restrict，即memcpy()假 设两个内存区域之间没有重叠；而memmove()不作这样的假设，所以拷贝过 程类似于先把所有字节拷贝到一个临时缓冲区，然后再拷贝到最终目的地。 如果使用 memcpy()时，两区域出现重叠会怎样？其行为是未定义的，这意 味着该函数可能正常工作，也可能失败。编译器不会在本不该使用 memcpy()时禁止你使用，作为程序员，在使用该函数时有责任确保两个区域 不重叠。 由于这两个函数设计用于处理任何数据类型，所有它们的参数都是两个 指向 void 的指针。C 允许把任何类型的指针赋给void 类型的指针。如此宽 容导致函数无法知道待拷贝数据的类型。因此，这两个函数使用第 3 个参数 指明待拷贝的字节数。注意，对数组而言，字节数一般与元素个数不同。如 果要拷贝数组中 10 个double类型的元素，要使用10sizeof(double)，而不是 10 。 程序清单16.20中的程序使用了这两个函数。该程序假设double类型是int 类型的两倍大小。另外，该程序还使用了C11的_Static_assert特性测试断 言。 程序清单 16.20 mems.c 程序\n// mems.c \u0026ndash; 使用 memcpy() 和 memmove() #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define SIZE 10 void show_array(const int ar [], int n); // 如果编译器不支持C11的_Static_assert，可以注释掉下面这行 _Static_assert(sizeof(double) == 2 * sizeof(int), \u0026ldquo;double not twice int size\u0026rdquo;); int main() { int values[SIZE] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; int target[SIZE]; double curious[SIZE / 2] = { 2.0, 2.0e5, 2.0e10, 2.0e20, 5.0e30 }; puts(\u0026ldquo;memcpy() used:\u0026rdquo;); puts(\u0026ldquo;values (original data): \u0026ldquo;); show_array(values, SIZE); memcpy(target, values, SIZE * sizeof(int)); puts(\u0026ldquo;target (copy of values):\u0026rdquo;); show_array(target, SIZE);\nputs(\u0026quot;\\nUsing memmove() with overlapping ranges:\u0026rdquo;); memmove(values + 2, values, 5 * sizeof(int)); puts(\u0026ldquo;values \u0026ndash; elements 0-4 copied to 2-6:\u0026rdquo;); show_array(values, SIZE); puts(\u0026quot;\\nUsing memcpy() to copy double to int:\u0026rdquo;); memcpy(target, curious, (SIZE / 2) * sizeof(double)); puts(\u0026ldquo;target \u0026ndash; 5 doubles into 10 int positions:\u0026rdquo;); show_array(target, SIZE / 2); show_array(target + 5, SIZE / 2); return 0; } void show_array(const int ar [], int n) { int i; for (i = 0; i \u0026lt; n; i++) printf(\u0026quot;%d \u0026ldquo;, ar[i]); putchar(\u0026rsquo;\\n\u0026rsquo;); } 下面是该程序的输出：\nmemcpy() used: values (original data): 1 2 3 4 5 6 7 8 9 10 target (copy of values): 1 2 3 4 5 6 7 8 9 10 Using memmove() with overlapping ranges: values \u0026ndash; elements 0-4 copied to 2-6: 1 2 1 2 3 4 5 8 9 10 Using memcpy() to copy double to int: target \u0026ndash; 5 doubles into 10 int positions: 0 1073741824 0 1091070464 536870912 1108516959 2025163840 1143320349 -2012696540 1179618799 程序中最后一次调用 memcpy()从 double 类型数组中把数据拷贝到 int 类 型数组中，这演示了memcpy()函数不知道也不关心数据的类型，它只负责从 一个位置把一些字节拷贝到另一个位置（例如，从结构中拷贝数据到字符数 组中）。而且，拷贝过程中也不会进行数据转换。如果用循环对数组中的每 个元素赋值，double类型的值会在赋值过程被转换为int类型的值。这种情况 下，按原样拷贝字节，然后程序把这些位组合解释成int类型。\n16.14 可变参数： stdarg.h # 本章前面提到过变参宏，即该宏可以接受可变数量的参数。stdarg.h 头 文件为函数提供了一个类似的功能，但是用法比较复杂。必须按如下步骤进 行： 1.提供一个使用省略号的函数原型； 2.在函数定义中创建一个va_list类型的变量； 3.用宏把该变量初始化为一个参数列表； 4.用宏访问参数列表； 5.用宏完成清理工作。 接下来详细分析这些步骤。这种函数的原型应该有一个形参列表，其中 至少有一个形参和一个省略号： void f1(int n, \u0026hellip;); // 有效 int f2(const char * s, int k, \u0026hellip;); // 有效 char f3(char c1, \u0026hellip;, char c2);// 无效，省略号不在最后 double f3(\u0026hellip;); // 无效，没有形参 最右边的形参（即省略号的前一个形参）起着特殊的作用，标准中用 parmN这个术语来描述该形参。在上面的例子中，第 1 行f1()中parmN为n，第 2 行f2()中parmN为k。传递给该形参的实际参数是省略号部分代表的参数数 量。例如，可以这样使用前面声明的f1()函数： f1(2, 200, 400); // 2个额外的参数 f1(4, 13, 117, 18, 23); // 4个额外的参数\n接下来，声明在stdarg.h中的va_list类型代表一种用于储存形参对应的形 参列表中省略号部分的数据对象。变参函数的定义起始部分类似下面这样： double sum(int lim,\u0026hellip;) { va_list ap; //声明一个储存参数的对象 在该例中，lim是parmN形参，它表明变参列表中参数的数量。 然后，该函数将使用定义在stdarg.h中的va_start()宏，把参数列表拷贝到 va_list类型的变量中。该宏有两个参数：va_list类型的变量和parmN形参。 接着上面的例子讨论，va_list类型的变量是ap，parmN形参是lim。所以，应 这样调用它： va_start(ap, lim); // 把ap初始化为参数列表 下一步是访问参数列表的内容，这涉及使用另一个宏va_arg()。该宏接 受两个参数：一个va_list类型的变量和一个类型名。第 1 次调用va_arg()时， 它返回参数列表的第 1 项；第 2 次调用时返回第 2 项，以此类推。表示类型的 参数指定了返回值的类型。例如，如果参数列表中的第 1 个参数是double类 型，第 2 个参数是int类型，可以这样做： double tic; int toc; \u0026hellip; tic = va_arg(ap, double); // 检索第 1 个参数 toc = va_arg(ap, int); //检索第 2 个参数 注意，传入的参数类型必须与宏参数的类型相匹配。如果第 1 个参数是\n10.0，上面tic那行代码可以正常工作。但是如果参数是 10 ，这行代码可能会 出错。这里不会像赋值那样把double类型自动转换成int类型。 最后，要使用va_end()宏完成清理工作。例如，释放动态分配用于储存 参数的内存。该宏接受一个va_list类型的变量： va_end(ap); // 清理工作 调用va_end(ap)后，只有用va_start重新初始化ap后，才能使用变量ap。 因为va_arg()不提供退回之前参数的方法，所以有必要保存va_list类型 变量的副本。C99新增了一个宏用于处理这种情况：va_copy()。该宏接受两 个va_list类型的变量作为参数，它把第 2 个参数拷贝给第 1 个参数： va_list ap; va_list apcopy; double double tic; int toc; \u0026hellip; va_start(ap, lim); // 把ap初始化为一个参数列表 va_copy(apcopy, ap); // 把apcopy作为ap的副本 tic = va_arg(ap, double); // 检索第 1 个参数 toc = va_arg(ap, int); // 检索第 2 个参数 此时，即使删除了ap，也可以从apcopy中检索两个参数。\n程序清单 16.21 中的程序示例中演示了如何创建这样的函数，该函数对 # 可变参数求和。sum()的第 1 个参数是待求和项的数目。 程序清单 16.21 varargs.c 程序 //varargs.c \u0026ndash; use variable number of arguments #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; double sum(int, \u0026hellip;); int main(void) { double s, t; s = sum(3, 1.1, 2.5, 13.3); t = sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1); printf(\u0026ldquo;return value for \u0026quot; \u0026ldquo;sum(3, 1.1, 2.5, 13.3): %g\\n\u0026rdquo;, s); printf(\u0026ldquo;return value for \u0026quot; \u0026ldquo;sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1): %g\\n\u0026rdquo;, t); return 0; } double sum(int lim, \u0026hellip;)\n{ # va_list ap; // 声明一个对象储存参数 double tot = 0; int i; va_start(ap, lim); // 把ap初始化为参数列表 for (i = 0; i \u0026lt; lim; i++) tot += va_arg(ap, double); // 访问参数列表中的每一项 va_end(ap); // 清理工作 return tot; } 下面是该程序的输出： return value for sum(3, 1.1, 2.5, 13.3): 16.9 return value for sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1): 31.6 查看程序中的运算可以发现，第 1 次调用sum()时对 3 个数求和，第 2 次调 用时对 6 个数求和。 总而言之，使用变参函数比使用变参宏更复杂，但是函数的应用范围更 广。\n16.15 关键概念 # C标准不仅描述C语言，还描述了组成C语言的软件包、C预处理器和C # 标准库。通过预处理器可以控制编译过程、列出要替换的内容、指明要编译 # 的代码行和影响编译器其他方面的行为。C库扩展了C语言的作用范围，为 # 许多编程问题提供现成的解决方案。 # 16.16 本章小结 # C预处理器和C库是C语言的两个重要的附件。C预处理器遵循预处理器 # 指令，在编译源代码之前调整源代码。C 库提供许多有助于完成各种任务的 # 函数，包括输入、输出、文件处理、内存管理、排序与搜索、数学运算、字 # 符串处理等。附录B的参考资料V中列出了完整的ANSI C库。 # 16.17 复习题 # 1.下面的几组代码由一个或多个宏组成，其后是使用宏的源代码。在每 # 种情况下代码的结果是什么？这些代码是否是有效代码？（假设其中的变量 # 已声明） # a. #define FPM 5280 /*每英里的英尺数*/ dist = FPM * miles; b. #define FEET 4 #define POD FEET + FEET plort = FEET * POD; c. #define SIX = 6; nex = SIX; d. #define NEW(X) X + 5 y = NEW(y); berg = NEW(berg) * lob; est = NEW(berg) / NEW(y); nilp = lob * NEW(-berg); 2.修改复习题 1 中d部分的定义，使其更可靠。 3.定义一个宏函数，返回两值中的较小值。 4.定义EVEN_GT(X, Y)宏，如果X为偶数且大于Y，该宏返回 1 。 5.定义一个宏函数，打印两个表达式及其值。例如，若参数为3+4和 412，则打印： 3+4 is 7 and 412 is 48 6.创建#define指令完成下面的任务。 a.创建一个值为 25 的命名常量。 b.SPACE表示空格字符。 c.PS()代表打印空格字符。 d.BIG(X)代表X的值加 3 。 e.SUMSQ(X, Y)代表X和Y的平方和。 7.定义一个宏，以下面的格式打印名称、值和int类型变量的地址： name: fop; value: 23; address: ff464016 8.假设在测试程序时要暂时跳过一块代码，如何在不移除这块代码的前 提下完成这项任务？ 9.编写一段代码，如果定义了PR_DATE宏，则打印预处理的日期。 10.内联函数部分讨论了 3 种不同版本的square()函数。从行为方面看， 这 3 种版本的函数有何不同？\n11.创建一个使用泛型选择表达式的宏，如果宏参数是_Bool类型， 对\u0026quot;boolean\u0026quot;求值，否则对\u0026quot;not boolean\u0026quot;求值。 12.下面的程序有什么错误？ #include \u0026lt;stdio.h\u0026gt; int main(int argc, char argv[]) { printf(\u0026ldquo;The square root of %f is %f\\n\u0026rdquo;, argv[1],sqrt(argv[1]) ); } 13.假设 scores 是内含 1000 个 int 类型元素的数组，要按降序排序该数 组中的值。假设你使用qsort()和comp()比较函数。 a.如何正确调用qsort()？ b.如何正确定义comp()？ 14.假设data1是内含 100 个double类型元素的数组，data2是内含 300 个 double类型元素的数组。 a.编写memcpy()的函数调用，把data2中的前 100 个元素拷贝到data1中。 b.编写memcpy()的函数调用，把data2中的后 100 个元素拷贝到data1中。\n16.18 编程练习 # 1.开发一个包含你需要的预处理器定义的头文件。 # 2.两数的调和平均数这样计算：先得到两数的倒数，然后计算两个倒数 # 的平均值，最后取计算结果的倒数。使用#define指令定义一个宏“函数”，执 行该运算。编写一个简单的程序测试该宏。 3.极坐标用向量的模（即向量的长度）和向量相对x轴逆时针旋转的角 度来描述该向量。直角坐标用向量的x轴和y轴的坐标来描述该向量（见图 16.3）。编写一个程序，读取向量的模和角度（单位：度），然后显示x轴 和y轴的坐标。相关方程如下： x = rcos A y = rsin A 需要一个函数来完成转换，该函数接受一个包含极坐标的结构，并返回 一个包含直角坐标的结构（或返回指向该结构的指针）。\n图16.3 直角坐标和极坐标 4.ANSI库这样描述clock()函数的特性： #include \u0026lt;time.h\u0026gt; clock_t clock (void); 这里，clock_t是定义在time.h中的类型。该函数返回处理器时间，其单 位取决于实现（如果处理器时间不可用或无法表示，该函数将返回-1）。然 而，CLOCKS_PER_SEC（也定义在time.h中）是每秒处理器时间单位的数 量。因此，两个 clock()返回值的差值除以 CLOCKS_PER_SEC得到两次调用 之间经过的秒数。在进行除法运算之前，把值的类型强制转换成double类 型，可以将时间精确到小数点以后。编写一个函数，接受一个double类型的 参数表示时间延迟数，然后在这段时间运行一个循环。编写一个简单的程序 测试该函数。 5.编写一个函数接受这些参数：内含int类型元素的数组名、数组的大小 和一个代表选取次数的值。该函数从数组中随机选择指定数量的元素，并打 印它们。每个元素只能选择一次（模拟抽奖数字或挑选陪审团成员）。另 外，如果你的实现有time()（第 12 章讨论过）或类似的函数，可在srand()中 使用这个函数的输出来初始化随机数生成器rand()。编写一个简单的程序测 试该函数。 6.修改程序清单16.17，使用struct names元素（在程序清单16.17后面的 讨论中定义过），而不是double类型的数组。使用较少的元素，并用选定的 名字显式初始化数组。 7.下面是使用变参函数的一个程序段： #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdarg.h\u0026gt; void show_array(const double ar[], int n);\ndouble * new_d_array(int n, \u0026hellip;); int main() { double * p1; double * p2; p1 = new_d_array(5, 1.2, 2.3, 3.4, 4.5, 5.6); p2 = new_d_array(4, 100.0, 20.00, 8.08, -1890.0); show_array(p1, 5); show_array(p2, 4); free(p1); free(p2); return 0; } new_d_array()函数接受一个int类型的参数和double类型的参数。该函数 返回一个指针，指向由malloc()分配的内存块。int类型的参数指定了动态数 组中的元素个数，double类型的值用于初始化元素（第 1 个值赋给第 1 个元 素，以此类推）。编写show_array()和new_d_array()函数的代码，完成这个 程序。\n第 17 章高级数据表示 # 本章介绍以下内容： # 函数：进一步学习malloc() 使用C表示不同类型的数据 新的算法，从概念上增强开发程序的能力 抽象数据类型（ADT） 学习计算机语言和学习音乐、木工或工程学一样。首先，要学会使用工 具：学习如何演奏音阶、如何使用锤子等，然后解决各种问题，如降落、滑 行以及平衡物体之类。到目前为止，读者一直在本书中学习和练习各种编程 技能，如创建变量、结构、函数等。然而，如果想提高到更高层次时，工具 是次要的，真正的挑战是设计和创建一个项目。本章将重点介绍这个更高的 层次，教会读者如何把项目看作一个整体。本章涉及的内容可能比较难，但 是这些内容非常有价值，将帮助读者从编程新手成长为老手。 我们先从程序设计的关键部分，即程序表示数据的方式开始。通常，程 序开发最重要的部分是找到程序中表示数据的好方法。正确地表示数据可以 更容易地编写程序其余部分。到目前为止，读者应该很熟悉C的内置类型： 简单变量、数组、指针、结构和联合。 然而，找出正确的数据表示不仅仅是选择一种数据类型，还要考虑必须 进行哪些操作。也就是说，必须确定如何储存数据，并且为数据类型定义有 效的操作。例如，C实现通常把int类型和指针类型都储存为整数，但是这两 种类型的有效操作不相同。例如，两个整数可以相乘，但是两个指针不能相 乘；可以用*运算符解引用指针，但是对整数这样做毫无意义。C 语言为它 的基本类型都定义了有效的操作。但是，当你要设记数据表示的方案时，你 可能需要自己定义有效操作。在C语言中，可以把所需的操作设计成C函数\n来表示。简而言之，设计一种数据类型包括设计如何储存该数据类型和设计 # 一系列管理该数据的函数。 # 本章还会介绍一些算法（algorithm），即操控数据的方法。作为一名程 序员，应该掌握这些可以反复解决类似问题的处理方法。 本章将进一步研究设计数据类型的过程，这是一个把算法和数据表示相 匹配的过程。期间会用到一些常见的数据形式，如队列、列表和二叉树。 本章还将介绍抽象数据类型（ADT）的概念。抽象数据类型以面向问题 而不是面向语言的方式，把解决问题的方法和数据表示结合起来。设计一个 ADT后，可以在不同的环境中复用。理解ADT可以为将来学习面向对象程序 设计（OOP）以及C++语言做好准备。\n17.1 研究数据表示 # 我们先从数据开始。假设要创建一个地址簿程序。应该使用什么数据形 # 式储存信息？由于储存的每一项都包含多种信息，用结构来表示每一项很合 # 适。如何表示多个项？是否用标准的结构数组？还是动态数组？还是一些其 # 他形式？各项是否按字母顺序排列？是否要按照邮政编码（或地区编码）查 # 找各项？需要执行的行为将影响如何储存信息？简而言之，在开始编写代码 # 之前，要在程序设计方面做很多决定。 # 如何表示储存在内存中的位图图像？位图图像中的每个像素在屏幕上都 # 单独设置。在以前黑白屏的年代，可以使用一个计算机位（ 1 或 0 ）来表示 # 一个像素点（开或闭），因此称之为位图。对于彩色显示器而言，如果 8 位 # 表示一个像素，可以得到 256 种颜色。现在行业标准已发展到 65536 色（每像 # 素 16 位）、 16777216 色（每像素 24 位）、 2147483 色（每像素 32 位），甚至 # 更多。如果有 32 位色，且显示器有2560×1440的分辨率，则需要将近1.18亿 # 位（14M）来表示一个屏幕的位图图像。是用这种方法表示，还是开发一种 # 压缩信息的方法？是有损压缩（丢失相对次要的数据）还是无损压缩（没有 # 丢失数据）？再次提醒读者注意，在开始编写代码之前，需要做很多程序设 # 计方面的决定。 # 我们来处理一个数据表示的示例。假设要编写一个程序，让用户输入一 # 年内看过的所有电影（包括DVD和蓝光光碟）。要储存每部影片的各种信 # 息，如片名、发行年份、导演、主演、片长、影片的种类（喜剧、科幻、爱 # 情等）、评级等。建议使用一个结构储存每部电影，一个数组储存一年内看 # 过的电影。为简单起见，我们规定结构中只有两个成员：片名和评级（ 0 ～ # 10 ）。程序清单17.1演示了一个基本的实现。 # 程序清单 17.1 films1.c 程序 /* films1.c -- 使用一个结构数组 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define TSIZE 45　/* 储存片名的数组大小 / #define FMAX 5　/ 影片的最大数量 */ struct film { char title[TSIZE]; int rating; }; char * s_gets(char str[], int lim); int main(void) { struct film movies[FMAX]; int i = 0; int j; puts(\u0026ldquo;Enter first movie title:\u0026rdquo;); while (i \u0026lt; FMAX \u0026amp;\u0026amp; s_gets(movies[i].title, TSIZE) != NULL \u0026amp;\u0026amp; movies[i].title[0] != \u0026lsquo;\\0\u0026rsquo;) { puts(\u0026ldquo;Enter your rating \u0026lt;0-10\u0026gt;:\u0026rdquo;);\nscanf(\u0026quot;%d\u0026rdquo;, \u0026amp;movies[i++].rating); while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; puts(\u0026ldquo;Enter next movie title (empty line to stop):\u0026rdquo;); } if (i == 0) printf(\u0026ldquo;No data entered. \u0026ldquo;); else printf(\u0026ldquo;Here is the movie list:\\n\u0026rdquo;); for (j = 0; j \u0026lt; i; j++) printf(\u0026ldquo;Movie: %s Rating: %d\\n\u0026rdquo;, movies[j].title,movies[j].rating); printf(\u0026ldquo;Bye!\\n\u0026rdquo;); return 0; } char * s_gets(char * st, int n) { char * ret_val; char * find; ret_val = fgets(st, n, stdin);\nif (ret_val) { find = strchr(st, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是 NULL, *find = \u0026lsquo;\\0\u0026rsquo;; // 在此处放置一个空字符 else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; // 处理剩余输入行 } return ret_val; } 该程序创建了一个结构数组，然后把用户输入的数据储存在数组中。直 到数组已满（用 FMAX 进行判断）或者到达文件结尾（用NULL进行判 断），或者用户在首行按下Enter键（用\u0026rsquo;\\0\u0026rsquo;进行判断），输入才会终止。 这样设计程序有点问题。首先，该程序很可能会浪费许多空间，因为大 部分的片名都不会超过 40 个字符。但是，有些片名的确很长，如The Discreet Charm of the Bourgeoisie和Won Ton Ton, The Dog Who Saved Hollywood。其次，许多人会觉得每年 5 部电影的限制太严格了。当然，也可 以放宽这个限制，但是，要多大才合适？有些人每年可以看 500 部电影，因 此可以把FMAX改为 500 。但是，对有些人而言，这可能仍然不够，而对有 些人而言一年根本看不了这么多部电影，这样就浪费了大量的内存。另外， 一些编译器对自动存储类别变量（如 movies）可用的内存数量设置了一个 默认的限制，如此大型的数组可能会超过默认设置的值。可以把数组声明为\n静态或外部数组，或者设置编译器使用更大的栈来解决这个问题。但是，这 # 样做并不能根本解决问题。 # 该程序真正的问题是，数据表示太不灵活。程序在编译时确定所需内存 # 量，其实在运行时确定会更好。要解决这个问题，应该使用动态内存分配来 # 表示数据。可以这样做： # #define TSIZE 45 /储存片名的数组大小/ struct film { char title[TSIZE]; int rating; }; \u0026hellip; int n, i; struct film * movies; /* 指向结构的指针 */ \u0026hellip; printf(\u0026ldquo;Enter the maximum number of movies you\u0026rsquo;ll enter:\\n\u0026rdquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;n); movies = (struct film *) malloc(n * sizeof(struct film)); 第 12 章介绍过，可以像使用数组名那样使用指针movies。 while (i \u0026lt; FMAX \u0026amp;\u0026amp; s_gets(movies[i].title, TSIZE) != NULL \u0026amp;\u0026amp;movies[i].title[0] != \u0026lsquo;\\0\u0026rsquo;)\n使用malloc()，可以推迟到程序运行时才确定数组中的元素数量。所 以，如果只需要 20 个元素，程序就不必分配存放 500 个元素的空间。但是， 这样做的前提是，用户要为元素个数提供正确的值。\n17.2 从数组到链表 # 理想的情况是，用户可以不确定地添加数据（或者不断添加数据直到用 # 完内存量），而不是先指定要输入多少项，也不用让程序分配多余的空间。 # 这可以通过在输入每一项后调用 malloc()分配正好能储存该项的空间。如果 用户输入 3 部影片，程序就调用malloc()3次；如果用户输入 300 部影片，程序 就调用malloc()300次。 不过，我们又制造了另一个麻烦。比较一下，一种方法是调用malloc() 一次，为 300 个filem结构请求分配足够的空间；另一种方法是调用 malloc()300次，分别为每个file结构请求分配足够的空间。前者分配的是连 续的内存块，只需要一个单独的指向struct变量（film）的指针，该指针指向 已分配块中的第 1 个结构。简单的数组表示法让指针访问块中的每个结构， 如前面代码段所示。第 2 种方法的问题是，无法保证每次调用malloc()都能分 配到连续的内存块。这意味着结构不一定被连续储存（见图17.1）。因此， 与第 1 种方法储存一个指向 300 个结构块的指针相比，你需要储存 300 个指 针，每个指针指向一个单独储存的结构。\n图17.1 一块内存中分配结构和单独分配结构 一种解决方法是创建一个大型的指针数组，并在分配新结构时逐个给这 些指针赋值，但是我们不打算使用这种方法： #define TSIZE 45 /储存片名的数组大小/ #define FMAX 500 /影片的最大数量/ struct film { char title[TSIZE];\nint rating; }; \u0026hellip; struct film * movies[FMAX]; /* 结构指针数组 / int i; \u0026hellip; movies[i] = (struct film ) malloc (sizeof (struct film)); 如果用不完 500 个指针，这种方法节约了大量的内存，因为内含 500 个指 针的数组比内含 500 个结构的数组所占的内存少得多。尽管如此，如果用不 到 500 个指针，还是浪费了不少空间。而且，这样还是有 500 个结构的限 制。 还有一种更好的方法。每次使用 malloc()为新结构分配空间时，也为新 指针分配空间。但是，还得需要另一个指针来跟踪新分配的指针，用于跟踪 新指针的指针本身，也需要一个指针来跟踪，以此类推。要重新定义结构才 能解决这个潜在的问题，即每个结构中包含指向 next 结构的指针。然后， 当创建新结构时，可以把该结构的地址储存在上一个结构中。简而言之，可 以这样定义film结构： #define TSIZE 45 / 储存片名的数组大小/ struct film { char title[TSIZE]; int rating; struct film * next;\n}; # 虽然结构不能含有与本身类型相同的结构，但是可以含有指向同类型结 # 构的指针。这种定义是定义链表（linked list）的基础，链表中的每一项都包 含着在何处能找到下一项的信息。 在学习链表的代码之前，我们先从概念上理解一个链表。假设用户输入 的片名是Modern Times，等级为 10 。程序将为film类型的结构分配空间，把 字符串Modern Times拷贝到结构中的title成员中，然后设置rating成员为 10 。 为了表明该结构后面没有其他结构，程序要把next成员指针设置为 NULL（NULL是一个定义在stdio.h头文件中的符号常量，表示空指针）。当 然，还需要一个单独的指针储存第 1 个结构的地址，该指针被称为头指针 （head pointer）。头指针指向链表中的第 1 项。图17.2演示了这种结构（为 节约图片空间，压缩了title成员中的空白）。\n图17.2 链表中的第 1 个项 现在，假设用户输入第 2 部电影及其评级，如Midnight in Paris和 8 。程序 为第 2 个film类型结构分配空间，把新结构的地址储存在第 1 个结构的next成 员中（擦写了之前储存在该成员中的NULL），这样链表中第 1 个结构中的 next指针指向第 2 个结构。然后程序把Midnight in Paris和 8 拷贝到新结构中，\n并把第 2 个结构中的next成员设置为NULL，表明该结构是链表中的最后一个 结构。图17.3演示了这两个项。\n图17.3 链表中的两个项 每加入一部新电影，就以相同的方式来处理。新结构的地址将储存在上 一个结构中，新信息储存在新结构中，而且新结构中的next成员设置为 NULL。从而建立起如图17.4所示的链表。\n图17.4 链表中的多个项 假设要显示这个链表，每显示一项，就可以根据该项中已储存的地址来 定位下一个待显示的项。然而，这种方案能正常运行，还需要一个指针储存 链表中第 1 项的地址，因为链表中没有其他项储存该项的地址。此时，头指 针就派上了用场。\n17.2.1 使用链表 # 从概念上了解了链表的工作原理，接着我们来实现它。程序清单17.2修 # 改了程序清单17.1，用链表而不是数组来储存电影信息。 # 程序清单 17.2 films2.c 程序 /* films2.c -- 使用结构链表 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; /* 提供malloc()原型 */ #include \u0026lt;string.h\u0026gt; /* 提供strcpy()原型 */ #define TSIZE 45　/* 储存片名的数组大小 */ struct film { char title[TSIZE]; int rating; struct film * next; /* 指向链表中的下一个结构 */ }; char * s_gets(char * st, int n); int main(void) { struct film * head = NULL; struct film * prev, *current; char input[TSIZE]; /* 收集并储存信息 */ # puts(\u0026ldquo;Enter first movie title:\u0026rdquo;); while (s_gets(input, TSIZE) != NULL \u0026amp;\u0026amp; input[0] != \u0026lsquo;\\0\u0026rsquo;) { current = (struct film ) malloc(sizeof(struct film)); if (head == NULL) / 第 1 个结构 / head = current; else / 后续的结构 / prev-\u0026gt;next = current; current-\u0026gt;next = NULL; strcpy(current-\u0026gt;title, input); puts(\u0026ldquo;Enter your rating \u0026lt;0-10\u0026gt;:\u0026rdquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;current-\u0026gt;rating); while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; puts(\u0026ldquo;Enter next movie title (empty line to stop):\u0026rdquo;); prev = current; } / 显示电影列表 */\nif (head == NULL) printf(\u0026ldquo;No data entered. \u0026ldquo;); else printf(\u0026ldquo;Here is the movie list:\\n\u0026rdquo;); current = head; while (current != NULL) { printf(\u0026ldquo;Movie: %s Rating: %d\\n\u0026rdquo;, current-\u0026gt;title, current-\u0026gt;rating); current = current-\u0026gt;next; } /* 完成任务，释放已分配的内存 */ current = head; while (current != NULL) { current = head; head = current-\u0026gt;next; free(current); }\nprintf(\u0026ldquo;Bye!\\n\u0026rdquo;); return 0; } char * s_gets(char * st, int n) { char * ret_val; char * find; ret_val = fgets(st, n, stdin); if (ret_val) { find = strchr(st, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是 NULL， *find = \u0026lsquo;\\0\u0026rsquo;; // 在此处放置一个空字符 else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; // 处理剩余输入行 } return ret_val; }\n该程序用链表执行两个任务。第 1 个任务是，构造一个链表，把用户输 # 入的数据储存在链表中。第 2 个任务是，显示链表。显示链表的任务比较简 # 单，所以我们先来讨论它。 # 1. 显示链表 # 显示链表从设置一个指向第 1 个结构的指针（名为current）开始。由于 头指针（名为head）已经指向链表中的第 1 个结构，所以可以用下面的代码 来完成： current = head; 然后，可以使用指针表示法访问结构的成员： printf(\u0026ldquo;Movie: %s Rating: %d\\n\u0026rdquo;, current-\u0026gt;title, current-\u0026gt;rating); 下一步是根据储存在该结构中next成员中的信息，重新设置current指针 指向链表中的下一个结构。代码如下： current = current-\u0026gt;next; 完成这些之后，再重复整个过程。当显示到链表中最后一个项时， current 将被设置为 NULL，因为这是链表最后一个结构中next成员的值。 while (current != NULL) { printf(\u0026ldquo;Movie: %s Rating: %d\\n\u0026rdquo;, current-\u0026gt;title, current-\u0026gt;rating); current = current-\u0026gt;next; } 遍历链表时，为何不直接使用head指针，而要重新创建一个新指针 （current）？因为如果使用head会改变head中的值，程序就找不到链表的开\n始处。 # 2. 创建链表 # 创建链表涉及下面 3 步： # （ 1 ）使用malloc()为结构分配足够的空间； （ 2 ）储存结构的地址； （ 3 ）把当前信息拷贝到结构中。 如无必要不用创建一个结构，所以程序使用临时存储区（input数组）获 取用户输入的电影名。如果用户通过键盘模拟EOF或输入一行空行，将退出 下面的循环： while (s_gets(input, TSIZE) != NULL \u0026amp;\u0026amp; input[0] != \u0026lsquo;\\0\u0026rsquo;) 如果用户进行输入，程序就分配一个结构的空间，并将其地址赋给指针 变量current: current = (struct film ) malloc(sizeof(struct film)); 链表中第 1 个结构的地址应储存在指针变量head中。随后每个结构的地 址应储存在其前一个结构的next成员中。因此，程序要知道它处理的是否是 第 1 个结构。最简单的方法是在程序开始时，把head指针初始化为NULL。然 后，程序可以使用head的值进行判断： if (head == NULL) / 第 1 个结构*/ head = current; else /* subsequent structures */ prev-\u0026gt;next = current;\n在上面的代码中，指针prev指向上一次分配的结构。 接下来，必须为结构成员设置合适的值。尤其是，把next成员设置为 NULL，表明当前结构是链表的最后一个结构。还要把input数组中的电影名 拷贝到title成员中，而且要给rating成员提供一个值。如下代码所示： current-\u0026gt;next = NULL; strcpy(current-\u0026gt;title, input); puts(\u0026ldquo;Enter your rating \u0026lt;0-10\u0026gt;:\u0026rdquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;current-\u0026gt;rating); 由于s_gets()限制了只能输入TSIZE-1个字符，所以用strcpy()函数把input 数组中的字符串拷贝到title成员很安全。 最后，要为下一次输入做好准备。尤其是，要设置 prev 指向当前结 构。因为在用户输入下一部电影且程序为新结构分配空间后，当前结构将成 为新结构的上一个结构，所以程序在循环末尾这样设置该指针： prev = current; 程序是否能正常运行？下面是该程序的一个运行示例： Enter first movie title: Spirited Away Enter your rating \u0026lt;0-10\u0026gt;: 9 Enter next movie title (empty line to stop): The Duelists\nEnter your rating \u0026lt;0-10\u0026gt;: 8 Enter next movie title (empty line to stop): Devil Dog: The Mound of Hound Enter your rating \u0026lt;0-10\u0026gt;: 1 Enter next movie title (empty line to stop): Here is the movie list: Movie: Spirited Away Rating: 9 Movie: The Duelists Rating: 8 Movie: Devil Dog: The Mound of Hound Rating: 1 Bye! 3. 释放链表 在许多环境中，程序结束时都会自动释放malloc()分配的内存。但是， 最好还是成对调用malloc()和free()。因此，程序在清理内存时为每个已分配 的结构都调用了free()函数： current = head; while (current != NULL) { current = head;\nhead = current-\u0026gt;next; free(current); } 17.2.2 反思 # films2.c 程序还有些不足。例如，程序没有检查 malloc()是否成功请求 到内存，也无法删除链表中的项。这些不足可以弥补。例如，添加代码检查 malloc()的返回值是否是NULL（返回NULL说明未获得所需内存）。如果程 序要删除链表中的项，还要编写更多的代码。 这种用特定方法解决特定问题，并且在需要时才添加相关功能的编程方 式通常不是最好的解决方案。另一方面，通常都无法预料程序要完成的所有 任务。随着编程项目越来越大，一个程序员或编程团队事先计划好一切模 式，越来越不现实。很多成功的大型程序都是由成功的小型程序逐步发展而 来。 如果要修改程序，首先应该强调最初的设计，并简化其他细节。程序清 单 17.2 中的程序示例没有遵循这个原则，它把概念模型和代码细节混在一 起。例如，该程序的概念模型是在一个链表中添加项，但是程序却把一些细 节（如，malloc()和 current-\u0026gt;next 指针）放在最明显的位置，没有突出接 口。如果程序能以某种方式强调给链表添加项，并隐藏具体的处理细节（如 调用内存管理函数和设置指针）会更好。把用户接口和代码细节分开的程 序，更容易理解和更新。学习下面的内容就可以实现这些目标。\n17.3 抽象数据类型（ ADT ） # 在编程时，应该根据编程问题匹配合适的数据类型。例如，用int类型代 表你有多少双鞋，用float或 double 类型代表每双鞋的价格。在前面的电影示 例中，数据构成了链表，每个链表项由电影名（C 字符串）和评级（一个int 类型值）。C中没有与之匹配的基本类型，所以我们定义了一个结构代表单 独的项，然后设计了一些方法把一系列结构构成一个链表。本质上，我们使 用 C语言的功能设计了一种符合程序要求的新数据类型。但是，我们的做法 并不系统。现在，我们用更系统的方法来定义数据类型。 什么是类型？类型特指两类信息：属性和操作。例如，int 类型的属性 是它代表一个整数值，因此它共享整数的属性。允许对int类型进行算术操作 是：改变int类型值的符号、两个int类型值相加、相减、相乘、相除、求模。 当声明一个int类型的变量时，就表明了只能对该变量进行这些操作。 注意 整数属性 C的int类型背后是一个更抽象的整数概念。数学家已经用正式的抽象方 式定义了整数的属性。例如，假设N和M是整数，那么N+M=M+N；假设S、 Q也是整数，如果N+M=S，而且N+Q=S，那么M=Q。可以认为数学家提供 了整数的抽象概念，而C则实现了这一抽象概念。注意，实现整数的算术运 算是表示整数必不可少的部分。如果只是储存值，并未在算术表达式中使 用，int类型就没那么有用了。还要注意的是，C并未很好地实现整数。例 如，整数是无穷大的数，但是 2 字节的int类型只能表示 65536 个整数。因此， 不要混淆抽象概念和具体的实现。 假设要定义一个新的数据类型。首先，必须提供储存数据的方法，例如 设计一个结构。其次，必须提供操控数据的方法。例如，考虑films2.c程序 （程序清单17.2）。该程序用链接的结构来储存信息，而且通过代码实现了 如何添加和显示信息。尽管如此，该程序并未清楚地表明正在创建一个新类 型。我们应该怎么做？\n计算机科学领域已开发了一种定义新类型的好方法，用 3 个步骤完成从 # 抽象到具体的过程。 # 1.提供类型属性和相关操作的抽象描述。这些描述既不能依赖特定的实 # 现，也不能依赖特定的编程语言。这种正式的抽象描述被称为抽象数据类型 # （ADT）。 # 2.开发一个实现 ADT 的编程接口。也就是说，指明如何储存数据和执 # 行所需操作的函数。例如在 C中，可以提供结构定义和操控该结构的函数原 # 型。这些作用于用户定义类型的函数相当于作用于 C基本类型的内置运算 # 符。需要使用该新类型的程序员可以使用这个接口进行编程。 # 3.编写代码实现接口。这一步至关重要，但是使用该新类型的程序员无 # 需了解具体的实现细节。 # 我们再次以前面的电影项目为例来熟悉这个过程，并用新方法重新完成 # 这个示例。 # 17.3.1 建立抽象 # 从根本上看，电影项目所需的是一个项链表。每一项包含电影名和评 # 级。你所需的操作是把新项添加到链表的末尾和显示链表中的内容。我们把 # 需要处理这些需求的抽象类型叫作链表。链表具有哪些属性？首先，链表应 # 该能储存一系列的项。也就是说，链表能储存多个项，而且这些项以某种方 # 式排列，这样才能描述链表的第 1 项、第 2 项或最后一项。其次，链表类型应 # 该提供一些操作，如在链表中添加新项。下面是链表的一些有用的操作： # 初始化一个空链表； # 在链表末尾添加一个新项； # 确定链表是否为空； # 确定链表是否已满； # 确定链表中的项数； # 访问链表中的每一项执行某些操作，如显示该项。 # 对该电影项目而言，暂时不需要其他操作。但是一般的链表还应包含以 # 下操作： # 在链表的任意位置插入一个项； # 移除链表中的一个项； # 在链表中检索一个项（不改变链表）； # 用另一个项替换链表中的一个项； # 在链表中搜索一个项。 # 非正式但抽象的链表定义是：链表是一个能储存一系列项且可以对其进 # 行所需操作的数据对象。该定义既未说明链表中可以储存什么项，也未指定 # 是用数组、结构还是其他数据形式来储存项，而且并未规定用什么方法来实 # 现操作（如，查找链表中元素的个数）。这些细节都留给实现完成。 # 为了让示例尽量简单，我们采用一种简化的链表作为抽象数据类型。它 # 只包含电影项目中的所需属性。该类型总结如下： # 类型名：　简单链表 # 类型属性：　可以储存一系列项 # 类型操作：　初始化链表为空 # 确定链表为空 # 确定链表已满 # 确定链表中的项数 # 在链表末尾添加项 # 遍历链表，处理链表中的项 # 清空链表 # 下一步是为开发简单链表ADT开发一个C接口。 # 17.3.2 建立接口 # 这个简单链表的接口有两个部分。第 1 部分是描述如何表示数据，第 2 部 # 分是描述实现ADT操作的函数。例如，要设计在链表中添加项的函数和报告 # 链表中项数的函数。接口设计应尽量与ADT的描述保持一致。因此，应该用 # 某种通用的Item类型而不是一些特殊类型，如int或struct film。可以用C的 typedef功能来定义所需的Item类型： #define TSIZE 45 /* 储存电影名的数组大小 */ struct film { char title[TSIZE]; int rating; }; typedef struct film Item; 然后，就可以在定义的其余部分使用 Item 类型。如果以后需要其他数 据形式的链表，可以重新定义Item类型，不必更改其余的接口定义。 定义了 Item 之后，现在必须确定如何储存这种类型的项。实际上这一 步属于实现步骤，但是现在决定好可以让示例更简单些。在films2.c程序中 用链接的结构处理得很好，所以，我们在这里也采用相同的方法：\ntypedef struct node { Item item; struct node * next; } Node; typedef Node * List; 在链表的实现中，每一个链节叫作节点（node）。每个节点包含形成链 表内容的信息和指向下一个节点的指针。为了强调这个术语，我们把node作 为节点结构的标记名，并使用typedef把Node作为struct node结构的类型名。 最后，为了管理链表，还需要一个指向链表开始处的指针，我们使用typedef 把List作为该类型的指针名。因此，下面的声明： List movies; 创建了该链表所需类型的指针movies。 这是否是定义List类型的唯一方法？不是。例如，还可以添加一个变量 记录项数： typedef struct list { Node * head; /* 指向链表头的指针 / int size; / 链表中的项数 / } List; / List的另一种定义 */ 可以像稍后的程序示例中那样，添加第 2 个指针储存链表的末尾。现\n在，我们还是使用 List类型的第 1 种定义。这里要着重理解下面的声明创建 了一个链表，而不一个指向节点的指针或一个结构： List movies; movies代表的确切数据应该是接口层次不可见的实现细节。 例如，程序启动后应把头指针初始化为NULL。但是，不要使用下面这 样的代码： movies = NULL; 为什么？因为稍后你会发现List类型的结构实现更好，所以应这样初始 化： movies.next = NULL; movies.size = 0; 使用List的人都不用担心这些细节，只要能使用下面的代码就行： InitializeList(movies); 使用该类型的程序员只需知道用InitializeList()函数来初始化链表，不必 了解List类型变量的实现细节。这是数据隐藏的一个示例，数据隐藏是一种 从编程的更高层次隐藏数据表示细节的艺术。 为了指导用户使用，可以在函数原型前面提供以下注释： /* 操作：初始化一个链表　/ / 前提条件：plist指向一个链表*/ /* 后置条件：该链表初始化为空　*/ void InitializeList(List * plist);\n这里要注意 3 点。第 1 ，注释中的“前提条件”（precondition）是调用该函 数前应具备的条件。例如，需要一个待初始化的链表。第 2 ，注释中的“后置 条件”（postcondition）是执行完该函数后的情况。第 3 ，该函数的参数是一 个指向链表的指针，而不是一个链表。所以应该这样调用该函数： InitializeList(\u0026amp;movies); 由于按值传递参数，所以该函数只能通过指向该变量的指针才能更改主 调程序传入的变量。这里，由于语言的限制使得接口和抽象描述略有区别。 C 语言把所有类型和函数的信息集合成一个软件包的方法是：把类型定 义和函数原型（包括前提条件和后置条件注释）放在一个头文件中。该文件 应该提供程序员使用该类型所需的所有信息。程序清单 17.3给出了一个简单 链表类型的头文件。该程序定义了一个特定的结构作为Item类型，然后根据 Item定义了Node，再根据Node定义了List。然后，把表示链表操作的函数设 计为接受Item类型和List类型的参数。如果函数要修改一个参数，那么该参 数的类型应是指向相应类型的指针，而不是该类型。在头文件中，把组成函 数名的每个单词的首字母大写，以这种方式表明这些函数是接口包的一部 分。另外，该文件使用第 16 章介绍的#ifndef指令，防止多次包含一个文件。 如果编译器不支持C99的bool类型，可以用下面的代码： enum bool {false, true}; /* 把bool定义为类型，false和true是该类型的值 / 替换下面的头文件： #include \u0026lt;stdbool.h\u0026gt; / C99特性 / 程序清单 17.3 list.h 接口头文件 / list.h \u0026ndash; 简单链表类型的头文件 */ #ifndef LIST_H_ #define LIST_H_\n#include \u0026lt;stdbool.h\u0026gt; /* C99特性　/ / 特定程序的声明 / #define TSIZE 45　/ 储存电影名的数组大小　/ struct film { char title[TSIZE]; int rating; }; / 一般类型定义 / typedef struct film Item; typedef struct node { Item item; struct node * next; } Node; typedef Node * List; / 函数原型 / / 操作：　初始化一个链 表　*/\n/* 前提条件：　plist指向一个链 表　/ / 后置条件：　链表初始化为 空　/ void InitializeList(List * plist); / 操作：　确定链表是否为空定义，plist指向一个已初始化的链 表　/ / 后置条件：　如果链表为空，该函数返回true；否则返回 false */ bool ListIsEmpty(const List plist); / 操作：　确定链表是否已满，plist指向一个已初始化的链 表　/ / 后置条件：　如果链表已满，该函数返回真；否则返回 假　*/ bool ListIsFull(const List plist); / 操作：　确定链表中的项数, plist指向一个已初始化的链 表　/ / 后置条件：　该函数返回链表中的项 数　*/ unsigned int ListItemCount(const List plist); / 操作：　在链表的末尾添加 项　*/\n/* 前提条件：　item是一个待添加至链表的项, plist指向一个已初始化 的链表　/ / 后置条件：　如果可以，该函数在链表末尾添加一个项，且返回 true；否则返回false / bool AddItem(Item item, List * plist); / 操作：　把函数作用于链表中的每一 项　/ / plist指向一个已初始化的链 表　/ / pfun指向一个函数，该函数接受一个Item类型的参数， 且无返回值　/ / 后置条件：　pfun指向的函数作用于链表中的每一项一 次　*/ void Traverse(const List *plist, void(pfun)(Item item)); / 操作：　释放已分配的内存（如果有的 话）　/ / plist指向一个已初始化的链 表　/ / 后置条件：　释放了为链表分配的所有内存，链表设置为 空　*/ void EmptyTheList(List * plist); #endif\n只有InitializeList()、AddItem()和EmptyTheList()函数要修改链表，因此从 技术角度看，这些函数需要一个指针参数。然而，如果某些函数接受 List 类 型的变量作为参数，而其他函数却接受 List类型的地址作为参数，用户会很 困惑。因此，为了减轻用户的负担，所有的函数均使用指针参数。 头文件中的一个函数原型比其他原型复杂： /* 操作：　把函数作用于链表中的每一 项　/ / plist指向一个已初始化的链 表　/ / pfun指向一个函数，该函数接受一个Item类型的参数， 且无返回值　/ / 后置条件：　pfun指向的函数作用于链表中的每一项一 次　*/ void Traverse(const List *plist, void(*pfun)(Item item)); 参数pfun是一个指向函数的指针，它指向的函数接受item值且无返回 值。第 14 章中介绍过，可以把函数指针作为参数传递给另一个函数，然后该 函数就可以使用这个被指针指向的函数。例如，该例中可以让pfun指向显示 链表项的函数。然后把Traverse()函数把该函数作用于链表中的每一项，显 示链表中的内容。\n17.3.3 使用接口 # 我们的目标是，使用这个接口编写程序，但是不必知道具体的实现细节 # （如，不知道函数的实现细节）。在编写具体函数之前，我们先编写电影程 # 序的一个新版本。由于接口要使用List和Item类型，所以该程序也应使用这 些类型。下面是编写该程序的一个伪代码方案。\n创建一个List类型的变量。 创建一个Item类型的变量。 初始化链表为空。 当链表未满且有输入时： 把输入读取到Item类型的变量中。 在链表末尾添加项。 访问链表中的每个项并显示它们。 程序清单 17.4 中的程序按照以上伪代码来编写，其中还加入了一些错 误检查。注意该程序利用了list.h（程序清单 17.3）中描述的接口。另外，还 需注意，链表中含有 showmovies()函数的代码，它与Traverse()的原型一 致。因此，程序可以把指针showmovies传递给Traverse()，这样Traverse()可 以把showmovies()函数应用于链表中的每一项（回忆一下，函数名是指向该 函数的指针）。 程序清单 17.4 films3.c 程序 /* films3.c \u0026ndash; 使用抽象数据类型（ADT）风格的链表 / / 与list.c一起编译　/ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; / 提供exit()的原型 / #include \u0026ldquo;list.h\u0026rdquo; / 定义List、Item */ void showmovies(Item item); char * s_gets(char * st, int n);\nint main(void) { List movies; Item temp; /* 初始化　/ InitializeList(\u0026amp;movies); if (ListIsFull(\u0026amp;movies)) { fprintf(stderr, \u0026ldquo;No memory available! Bye!\\n\u0026rdquo;); exit(1); } / 获取用户输入并储存 */ puts(\u0026ldquo;Enter first movie title:\u0026rdquo;); while (s_gets(temp.title, TSIZE) != NULL \u0026amp;\u0026amp; temp.title[0] != \u0026lsquo;\\0\u0026rsquo;) { puts(\u0026ldquo;Enter your rating \u0026lt;0-10\u0026gt;:\u0026rdquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;temp.rating); while (getchar() != \u0026lsquo;\\n\u0026rsquo;)\ncontinue; if (AddItem(temp, \u0026amp;movies) == false) { fprintf(stderr, \u0026ldquo;Problem allocating memory\\n\u0026rdquo;); break; } if (ListIsFull(\u0026amp;movies)) { puts(\u0026ldquo;The list is now full.\u0026rdquo;); break; } puts(\u0026ldquo;Enter next movie title (empty line to stop):\u0026rdquo;); } /* 显示　*/ if (ListIsEmpty(\u0026amp;movies)) printf(\u0026ldquo;No data entered. \u0026ldquo;); else { printf(\u0026ldquo;Here is the movie list:\\n\u0026rdquo;);\nTraverse(\u0026amp;movies, showmovies); } printf(\u0026ldquo;You entered %d movies.\\n\u0026rdquo;, ListItemCount(\u0026amp;movies)); /* 清理　*/ EmptyTheList(\u0026amp;movies); printf(\u0026ldquo;Bye!\\n\u0026rdquo;); return 0; } void showmovies(Item item) { printf(\u0026ldquo;Movie: %s Rating: %d\\n\u0026rdquo;, item.title, item.rating); } char * s_gets(char * st, int n) { char * ret_val; char * find; ret_val = fgets(st, n, stdin); if (ret_val)\n{ # find = strchr(st, \u0026#39;\\n\u0026#39;); // 查找换行符 if (find) // 如果地址不是NULL， *find = \u0026#39;\\0\u0026#39;; // 在此处放置一个空字符 else while (getchar() != \u0026#39;\\n\u0026#39;) continue; // 处理输入行的剩余内容 } return ret_val; } 17.3.4 实现接口 # 当然，我们还是必须实现List接口。C方法是把函数定义统一放在list.c 文件中。然后，整个程序由 list.h（定义数据结构和提供用户接口的原 型）、list.c（提供函数代码实现接口）和 films3.c （把链表接口应用于特定 编程问题的源代码文件）组成。程序清单17.5演示了list.c的一种实现。要运 行该程序，必须把films3.c和list.c一起编译和链接（可以复习一下第 9 章关于 编译多文件程序的内容）。list.h、list.c和films3.c组成了整个程序（见图 17.5）。 程序清单 17.5 list.c 实现文件 /* list.c \u0026ndash; 支持链表操作的函数 */ #include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026ldquo;list.h\u0026rdquo; /* 局部函数原型 / static void CopyToNode(Item item, Node * pnode); / 接口函数　/ / 把链表设置为空 */ void InitializeList(List * plist) { plist = NULL; } / 如果链表为空，返回true */ bool ListIsEmpty(const List * plist) { if (plist == NULL) return true; else return false; } / 如果链表已满，返回true */\nbool ListIsFull(const List * plist) { Node * pt; bool full; pt = (Node )malloc(sizeof(Node)); if (pt == NULL) full = true; else full = false; free(pt); return full; } / 返回节点的数量 */ unsigned int ListItemCount(const List * plist) { unsigned int count = 0; Node * pnode = plist; / 设置链表的开始 */ while (pnode != NULL) {\n++count; pnode = pnode-\u0026gt;next; /* 设置下一个节点 / } return count; } / 创建储存项的节点，并将其添加至由plist指向的链表末尾（较慢的实 现） */ bool AddItem(Item item, List * plist) { Node * pnew; Node * scan = *plist; pnew = (Node ) malloc(sizeof(Node)); if (pnew == NULL) return false; / 失败时退出函数 / CopyToNode(item, pnew); pnew-\u0026gt;next = NULL; if (scan == NULL) / 空链表，所以把 */ plist = pnew; / pnew放在链表的开头 */ else\n{ # while (scan-\u0026gt;next != NULL) scan = scan-\u0026gt;next; /* 找到链表的末尾 / scan-\u0026gt;next = pnew; / 把pnew添加到链表的末尾 / } return true; } / 访问每个节点并执行pfun指向的函数 */ void Traverse(const List * plist, void(*pfun)(Item item)) { Node * pnode = plist; / 设置链表的开始 */ while (pnode != NULL) { (pfun)(pnode-\u0026gt;item); / 把函数应用于链表中的项 / pnode = pnode-\u0026gt;next; / 前进到下一项　/ } } / 释放由malloc()分配的内存 / / 设置链表指针为NULL */\nvoid EmptyTheList(List * plist) { Node * psave; while (*plist != NULL) { psave = (plist)-\u0026gt;next; / 保存下一个节点的地址　*/ free(plist); / 释放当前节点　*/ plist = psave; / 前进至下一个节点　/ } } / 局部函数定义 / / 把一个项拷贝到节点中 / static void CopyToNode(Item item, Node * pnode) { pnode-\u0026gt;item = item; / 拷贝结构 */ }\n图17.5 电影程序的 3 个部分 1. 程序的一些注释 list.c文件有几个需要注意的地方。首先，该文件演示了什么情况下使用\n内部链接函数。如第 12 章所述，具有内部链接的函数只能在其声明所在的文 # 件夹可见。在实现接口时，有时编写一个辅助函数（不作为正式接口的一部 # 分）很方便。例如，使用CopyToNode()函数把一个Item类型的值拷贝到Item 类型的变量中。由于该函数是实现的一部分，但不是接口的一部分，所以我 们使用 static 存储类别说明符把它隐藏在list.c文件中。接下来，讨论其他函 数。 InitializeList()函数将链表初始化为空。在我们的实现中，这意味着把 List类型的变量设置为NULL。前面提到过，这要求把指向List类型变量的指 针传递给该函数。 ListIsEmpty()函数很简单，但是它的前提条件是，当链表为空时，链表 变量被设置为NULL。因此，在首次调用 ListIsEmpty()函数之前初始化链表 非常重要。另外，如果要扩展接口添加删除项的功能，那么当最后一个项被 删除时，应该确保该删除函数重置链表为空。对链表而言，链表的大小取决 于可用内存量。ListIsFull()函数尝试为新项分配空间。如果分配失败，说明 链表已满；如果分配成功，则必须释放刚才分配的内存供真正的项所用。 ListItemCount()函数使用常用的链表算法遍历链表，同时统计链表中的 项： unsigned int ListItemCount(const List * plist) { unsigned int count = 0; Node * pnode = plist; / 设置链表的开始 */ while (pnode != NULL) { ++count;\npnode = pnode-\u0026gt;next; /* 设置下一个节点 */ } return count; } AddItem()函数是这些函数中最复杂的： bool AddItem(Item item, List * plist) { Node * pnew; Node * scan = *plist; pnew = (Node ) malloc(sizeof(Node)); if (pnew == NULL) return false; / 失败时退出函数 / CopyToNode(item, pnew); pnew-\u0026gt;next = NULL; if (scan == NULL) / 空链表，所以把 */ plist = pnew; / pnew放在链表的开头 */ else { while (scan-\u0026gt;next != NULL)\nscan = scan-\u0026gt;next; /* 找到链表的末尾 / scan-\u0026gt;next = pnew; / 把pnew添加到链表的末尾 / } return true; } AddItem()函数首先为新节点分配空间。如果分配成功，该函数使用 CopyToNode()把项拷贝到新节点中。然后把该节点的next成员设置为NULL。 这表明该节点是链表中的最后一个节点。最后，完成创建节点并为其成员赋 正确的值之后，该函数把该节点添加到链表的末尾。如果该项是添加到链表 的第 1 个项，需要把头指针设置为指向第 1 项（记住，头指针的地址是传递 给AddItem()函数的第 2 个参数，所以plist就是头指针的值）。否则，代码继 续在链表中前进，直到发现被设置为NULL的next成员。此时，该节点就是 当前的最后一个节点，所以，函数重置它的next成员指向新节点。 要养成良好的编程习惯，给链表添加项之前应调用ListIsFull()函数。但 是，用户可能并未这样做，所以在AddItem()函数内部检查malloc()是否分配 成功。而且，用户还可能在调用ListIsFull()和调用AddItem()函数之间做其他 事情分配了内存，所以最好还是检查malloc()是否分配成功。 Traverse()函数与ListItemCount()函数类似，不过它还把一个指针函数作 用于链表中的每一项。 void Traverse (const List * plist, void (* pfun)(Item item) ) { Node * pnode = plist; / 设置链表的开始 */ while (pnode != NULL)\n{ # (pfun)(pnode-\u0026gt;item); / 把函数应用于该项*/ pnode = pnode-\u0026gt;next; /* 前进至下一个项 */ } } pnode-\u0026gt;item代表储存在节点中的数据，pnode-\u0026gt;next标识链表中的下一个 节点。如下函数调用： Traverse(movies, showmovies); 把showmovies()函数应用于链表中的每一项。 最后，EmptyTheList()函数释放了之前malloc()分配的内存： void EmptyTheList(List * plist) { Node * psave; while (*plist != NULL) { psave = (plist)-\u0026gt;next; / 保存下一个节点的地址　*/ free(plist); / 释放当前节点　*/ plist = psave; / 前进至下一个节点　*/ }\n} # 该函数的实现通过把List类型的变量设置为NULL来表明一个空链表。因 此，要把List类型变量的地址传递给该函数，以便函数重置。由于List已经是 一个指针，所以plist是一个指向指针的指针。因此，在上面的代码中，plist 是指向Node的指针。当到达链表末尾时，plist为NULL，表明原始的实际参 数现在被设置为NULL。 代码中要保存下一节点的地址，因为原则上调用了free()会使当前节点 （即plist指向的节点）的内容不可用。 提示 const 的限制 多个处理链表的函数都把const List * plist作为形参，表明这些函数不会 更改链表。这里， const确实提供了一些保护。它防止了plist（即plist所指 向的量）被修改。在该程序中，plist指向movies，所以const防止了这些函数 修改movies。因此，在ListItemCount()中，不允许有类似下面的代码： plist = (plist)-\u0026gt;next; // 如果plist是const，不允许这样做 因为改变plist就改变了movies，将导致程序无法跟踪数据。然而， plist和movies都被看作是const并不意味着plist或movies指向的数据是 const。例如，可以编写下面的代码： (plist)-\u0026gt;item.rating = 3; // 即使plist是const，也可以这样做 因为上面的代码并未改变plist，它改变的是plist指向的数据。由此可 见，不要指望const能捕获到意外修改数据的程序错误。\n2. 考虑你要做的 现在花点时间来评估ADT方法做了什么。首先，比较程序清单17.2和程 序清单17.4。这两个程序都使用相同的内存分配方法（动态分配链接的结 构）解决电影链表的问题，但是程序清单17.2暴露了所有的编程细节，把\nmalloc()和prev-\u0026gt;next这样的代码都公之于众。而程序清单17.4隐藏了这些细 节，并用与任务直接相关的方式表达程序。也就是说，该程序讨论的是创建 链表和向链表中添加项，而不是调用内存函数或重置指针。简而言之，程序 清单17.4是根据待解决的问题来表达程序，而不是根据解决问题所需的具体 工具来表达程序。ADT版本可读性更高，而且针对的是最终的用户所关心的 问题。 其次，list.h 和 list.c 文件一起组成了可复用的资源。如果需要另一个简 单的链表，也可以使用这些文件。假设你需要储存亲戚的一些信息：姓名、 关系、地址和电话号码，那么先要在 list.h 文件中重新定义Item类型： typedef struct itemtag { char fname[14]; char lname [24]; char relationship[36]; char address [60]; char phonenum[20]; } Item; 然后„„只需要做这些就行了。因为所有处理简单链表的函数都与Item类 型有关。根据不同的情况，有时还要重新定义CopyToNode()函数。例如，当 项是一个数组时，就不能通过赋值来拷贝。 另一个要点是，用户接口是根据抽象链表操作定义的，不是根据某些特 定的数据表示和算法来定义。这样，不用重写最后的程序就能随意修改实 现。例如，当前使用的AddItem()函数效率不高，因为它总是从链表第 1 个 项开始，然后搜索至链表末尾。可以通过保存链表结尾处的地址来解决这个\n问题。例如，可以这样重新定义List类型： typedef struct list { Node * head; /* 指向链表的开头 / Node * end; / 指向链表的末尾 / } List; 当然，还要根据新的定义重写处理链表的函数，但是不用修改程序清单 17.4中的内容。对大型编程项目而言，这种把实现和最终接口隔离的做法相 当有用。这称为数据隐藏，因为对终端用户隐藏了数据表示的细节。 注意，这种特殊的ADT甚至不要求以链表的方式实现简单链表。下面是 另一种方法： #define MAXSIZE 100 typedef struct list { Item entries[MAXSIZE]; / 项数组 / int items; / 其中的项数 */ } List; 这样做也需要重写list.c文件，但是使用list的程序不用修改。 最后，考虑这种方法给程序开发过程带来了哪些好处。如果程序运行出 现问题，可以把问题定位到具体的函数上。如果想用更好的方法来完成某个 任务（如，添加项），只需重写相应的函数即可。如果需要新功能，可以添\n加一个新的函数。如果觉得数组或双向链表更好，可以重写实现的代码，不 # 用修改使用实现的程序。 # 17.4 队列 ADT # 在C语言中使用抽象数据类型方法编程包含以下 3 个步骤。 # 1.以抽象、通用的方式描述一个类型，包括该类型的操作。 # 2.设计一个函数接口表示这个新类型。 # 3.编写具体代码实现这个接口。 # 前面已经把这种方法应用到简单链表中。现在，把这种方法应用于更复 # 杂的数据类型：队列。 # 17.4.1 定义队列抽象数据类型 # 队列（queue）是具有两个特殊属性的链表。第一，新项只能添加到链 表的末尾。从这方面看，队列与简单链表类似。第二，只能从链表的开头移 除项。可以把队列想象成排队买票的人。你从队尾加入队列，买完票后从队 首离开。队列是一种“先进先出”（first in,first out，缩写为FIFO）的数据形 式，就像排队买票的队伍一样（前提是没有人插队）。接下来，我们建立一 个非正式的抽象定义： 类型名：　队列 类型属性：　可以储存一系列项 类型操作：　初始化队列为空 确定队列为空 确定队列已满 确定队列中的项数 在队列末尾添加项\n在队列开头删除或恢复项 # 清空队列 # 17.4.2 定义一个接口 # 接口定义放在queue.h文件中。我们使用C的typedef工具创建两个类型 名：Item和Queue。相应结构的具体实现应该是queue.h文件的一部分，但是 从概念上来看，应该在实现阶段才设计结构。现在，只是假定已经定义了这 些类型，着重考虑函数的原型。 首先，考虑初始化。这涉及改变Queue类型，所以该函数应该以Queue的 地址作为参数： void InitializeQueue (Queue * pq); 接下来，确定队列是否为空或已满的函数应返回真或假值。这里，假设 C99的stdbool.h头文件可用。如果该文件不可用，可以使用int类型或自己定 义bool类型。由于该函数不更改队列，所以接受Queue类型的参数。但是， 传递Queue的地址更快，更节省内存，这取决于Queue类型的对象大小。这次 我们尝试这种方法。这样做的好处是，所有的函数都以地址作为参数，而不 像 List 示例那样。为了表明这些函数不更改队列，可以且应该使用const限 定符： bool QueueIsFull(const Queue * pq); bool QueueIsEmpty (const Queue * pq); 指针pq指向Queue数据对象，不能通过pq这个代理更改数据。可以定义 一个类似该函数的原型，返回队列的项数： int QueueItemCount(const Queue * pq); 在队列末尾添加项涉及标识项和队列。这次要更改队列，所以有必要\n（而不是可选）使用指针。该函数的返回类型可以是void，或者通过返回值 来表示是否成功添加项。我们采用后者： bool EnQueue(Item item, Queue * pq); 最后，删除项有多种方法。如果把项定义为结构或一种基本类型，可以 通过函数返回待删除的项。函数的参数可以是Queue类型或指向Queue的指 针。因此，可能是下面这样的原型： Item DeQueue(Queue q); 然而，下面的原型会更合适一些： bool DeQueue(Item * pitem, Queue * pq); 从队列中待删除的项储存在pitem指针指向的位置，函数的返回值表明 是否删除成功。 清空队列的函数所需的唯一参数是队列的地址，可以使用下面的函数原 型： void EmptyTheQueue(Queue * pq);\n17.4.3 实现接口数据表示 # 第一步是确定在队列中使用何种C数据形式。有可能是数组。数组的优 # 点是方便使用，而且向数组的末尾添加项很简单。问题是如何从队列的开头 # 删除项。类比于排队买票的队列，从队列的开头删除一个项包括拷贝数组首 # 元素的值和把数组剩余各项依次向前移动一个位置。编程实现这个过程很简 # 单，但是会浪费大量的计算机时间（见图17.6）。 # 图17.6 用数组实现队列 第二种解决数组队列删除问题的方法是改变队列首端的位置，其余元素 不动（见图17.7）。\n图17.7 重新定义首元素 解决这种问题的一个好方法是，使队列成为环形。这意味着把数组的首 尾相连，即数组的首元素紧跟在最后一个元素后面。这样，当到达数组末尾 时，如果首元素空出，就可以把新添加的项储存到这些空出的元素中（见图 17.8）。可以想象在一张条形的纸上画出数组，然后把数组的首尾粘起来形 成一个环。当然，要做一些标记，以免尾端超过首端。\n图17.8 环形队列\n另一种方法是使用链表。使用链表的好处是删除首项时不必移动其余元 # 素，只需重置头指针指向新的首元素即可。由于我们已经讨论过链表，所以 # 采用这个方案。我们用一个整数队列开始测试： # typedef int Item; 链表由节点组成，所以，下一步是定义节点： typedef struct node { Item item; struct node * next; } Node; 对队列而言，要保存首尾项，这可以使用指针来完成。另外，可以用一 个计数器来记录队列中的项数。因此，该结构应由两个指针成员和一个int类 型的成员构成： typedef struct queue { Node * front; /* 指向队列首项的指针 / Node * rear; /指向队列尾项的指针/ int items; / 队列中的项数*/ } Queue; 注意，Queue是一个内含 3 个成员的结构，所以用指向队列的指针作为参 数比直接用队列作为参数节约了时间和空间。\n接下来，考虑队列的大小。对链表而言，其大小受限于可用的内存量， # 因此链表不要太大。例如，可能使用一个队列模拟飞机等待在机场着陆。如 # 果等待的飞机数量太多，新到的飞机就应该改到其他机场降落。我们把队列 # 的最大长度设置为 10 。程序清单17.6包含了队列接口的原型和定义。Item类 型留给用户定义。使用该接口时，可以根据特定的程序插入合适的定义。 程序清单 17.6 queue.h 接口头文件 /* queue.h \u0026ndash; Queue的接口 */ #ifndef QUEUE_H #define QUEUE_H #include \u0026lt;stdbool.h\u0026gt; // 在这里插入Item类型的定义，例如 typedef int Item; // 用于use_q.c // 或者 typedef struct item {int gumption; int charisma;} Item; #define MAXQUEUE 10 typedef struct node { Item item; struct node * next; } Node; typedef struct queue\n{ # Node * front; /* 指向队列首项的指针　/ Node * rear; / 指向队列尾项的指针　/ int items; / 队列中的项数　/ } Queue; / 操作：　初始化队列　/ / 前提条件：　pq 指向一个队列　/ / 后置条件：　队列被初始化为空　/ void InitializeQueue(Queue * pq); / 操作：　检查队列是否已满　/ / 前提条件：　pq 指向之前被初始化的队列　/ / 后置条件：　如果队列已满则返回true，否则返回false / bool QueueIsFull(const Queue * pq); / 操作：　检查队列是否为空　/ / 前提条件：　pq 指向之前被初始化的队列　/ / 后置条件：　如果队列为空则返回true，否则返回false */ bool QueueIsEmpty(const Queue pq); / 操作：　确定队列中的项数　*/\n/* 前提条件：　pq 指向之前被初始化的队列　/ / 后置条件：　返回队列中的项数　/ int QueueItemCount(const Queue * pq); / 操作：　在队列末尾添加项　/ / 前提条件：　pq 指向之前被初始化的队列　/ / item是要被添加在队列末尾的项　/ / 后置条件：　如果队列不为空，item将被添加在队列的末 尾，　/ /　该函数返回true；否则，队列不改变，该函数返回false*/ bool EnQueue(Item item, Queue * pq); /* 操作：　从队列的开头删除项　/ / 前提条件：　pq 指向之前被初始化的队列　/ / 后置条件：　如果队列不为空，队列首端的item将被拷贝到*pitem中 / /　并被删除，且函数返回true；　/ /　如果该操作使得队列为空，则重置队列为 空　/ /　如果队列在操作前为空，该函数返回false */\nbool DeQueue(Item pitem, Queue * pq); / 操作：　清空队列　/ / 前提条件：　pq 指向之前被初始化的队列　/ / 后置条件：　队列被清空　*/ void EmptyTheQueue(Queue * pq); #endif\n1. 实现接口函数 接下来，我们编写接口代码。首先，初始化队列为空，这里“空”的意思 是把指向队列首项和尾项的指针设置为NULL，并把项数（items成员）设置 为 0 ： void InitializeQueue(Queue * pq) { pq-\u0026gt;front = pq-\u0026gt;rear = NULL; pq-\u0026gt;items = 0; } 这样，通过检查items的值可以很方便地了解到队列是否已满、是否为 空和确定队列的项数： bool QueueIsFull(const Queue * pq) {\nreturn pq-\u0026gt;items == MAXQUEUE; } bool QueueIsEmpty(const Queue * pq) { return pq-\u0026gt;items == 0; } int QueueItemCount(const Queue * pq) { return pq-\u0026gt;items; } 把项添加到队列中，包括以下几个步骤： （ 1 ）创建一个新节点； （ 2 ）把项拷贝到节点中； （ 3 ）设置节点的next指针为NULL，表明该节点是最后一个节点； （ 4 ）设置当前尾节点的next指针指向新节点，把新节点链接到队列 中； （ 5 ）把rear指针指向新节点，以便找到最后的节点； （ 6 ）项数加 1 。 函数还要处理两种特殊情况。第一种情况，如果队列为空，应该把front 指针设置为指向新节点。因为如果队列中只有一个节点，那么这个节点既是\n首节点也是尾节点。第二种情况是，如果函数不能为节点分配所需内存，则 # 必须执行一些动作。因为大多数情况下我们都使用小型队列，这种情况很少 # 发生，所以，如果程序运行的内存不足，我们只是通过函数终止程序。 # EnQueue()的代码如下： bool EnQueue(Item item, Queue * pq) { Node * pnew; if (QueueIsFull(pq)) return false; pnew = (Node )malloc( sizeof(Node)); if (pnew == NULL) { fprintf(stderr,\u0026ldquo;Unable to allocate memory!\\n\u0026rdquo;); exit(1); } CopyToNode(item, pnew); pnew-\u0026gt;next = NULL; if (QueueIsEmpty(pq)) pq-\u0026gt;front = pnew; / 项位于队列首端　*/ else\npq-\u0026gt;rear-\u0026gt;next = pnew; /* 链接到队列尾端　/ pq-\u0026gt;rear = pnew; / 记录队列尾端的位置　/ pq-\u0026gt;items++; / 队列项数加 1　*/ return true; } CopyToNode()函数是静态函数，用于把项拷贝到节点中： static void CopyToNode(Item item, Node * pn) { pn-\u0026gt;item = item; } 从队列的首端删除项，涉及以下几个步骤： （ 1 ）把项拷贝到给定的变量中； （ 2 ）释放空出的节点使用的内存空间； （ 3 ）重置首指针指向队列中的下一个项； （ 4 ）如果删除最后一项，把首指针和尾指针都重置为NULL； （ 5 ）项数减 1 。 下面的代码完成了这些步骤： bool DeQueue(Item * pitem, Queue * pq) {\nNode * pt; if (QueueIsEmpty(pq)) return false; CopyToItem(pq-\u0026gt;front, pitem); pt = pq-\u0026gt;front; pq-\u0026gt;front = pq-\u0026gt;front-\u0026gt;next; free(pt); pq-\u0026gt;items\u0026ndash;; if (pq-\u0026gt;items == 0) pq-\u0026gt;rear = NULL; return true; } 关于指针要注意两点。第一，删除最后一项时，代码中并未显式设置 front指针为NULL，因为已经设置front指针指向被删除节点的next指针。如果 该节点不是最后一个节点，那么它的next指针就为NULL。第二，代码使用 临时指针（pt）储存待删除节点的位置。因为指向首节点的正式指针（pt-\nfront）被重置为指向下一个节点，所以如果没有临时指针，程序就不知道 该释放哪块内存。 我们使用DeQueue()函数清空队列。循环调用DeQueue()函数直到队列为 空： void EmptyTheQueue(Queue * pq)\n{ # Item dummy; while (!QueueIsEmpty(pq)) DeQueue(\u0026amp;dummy, pq); } 注意 保持纯正的 ADT 定义ADT接口后，应该只使用接口函数处理数据类型。例如， Dequeue()依赖EnQueue()函数来正确设置指针和把rear节点的next指针设置为 NULL。如果在一个使用ADT的程序中，决定直接操控队列的某些部分，有 可能破坏接口包中函数之间的协作关系。 程序清单17.7演示了该接口中的所有函数，包括EnQueue()函数中用到的 CopyToItem()函数。 程序清单 17.7 queue.c 实现文件 /* queue.c \u0026ndash; Queue类型的实现 / #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026ldquo;queue.h\u0026rdquo; / 局部函数 */ static void CopyToNode(Item item, Node * pn); static void CopyToItem(Node * pn, Item * pi);\nvoid InitializeQueue(Queue * pq) { pq-\u0026gt;front = pq-\u0026gt;rear = NULL; pq-\u0026gt;items = 0; } bool QueueIsFull(const Queue * pq) { return pq-\u0026gt;items == MAXQUEUE; } bool QueueIsEmpty(const Queue * pq) { return pq-\u0026gt;items == 0; } int QueueItemCount(const Queue * pq) { return pq-\u0026gt;items; } bool EnQueue(Item item, Queue * pq) {\nNode * pnew; if (QueueIsFull(pq)) return false; pnew = (Node ) malloc(sizeof(Node)); if (pnew == NULL) { fprintf(stderr, \u0026ldquo;Unable to allocate memory!\\n\u0026rdquo;); exit(1); } CopyToNode(item, pnew); pnew-\u0026gt;next = NULL; if (QueueIsEmpty(pq)) pq-\u0026gt;front = pnew; / 项位于队列的首端　/ else pq-\u0026gt;rear-\u0026gt;next = pnew; / 链接到队列的尾端　/ pq-\u0026gt;rear = pnew; / 记录队列尾端的位置　/ pq-\u0026gt;items++; / 队列项数加 1　*/ return true; }\nbool DeQueue(Item * pitem, Queue * pq) { Node * pt; if (QueueIsEmpty(pq)) return false; CopyToItem(pq-\u0026gt;front, pitem); pt = pq-\u0026gt;front; pq-\u0026gt;front = pq-\u0026gt;front-\u0026gt;next; free(pt); pq-\u0026gt;items\u0026ndash;; if (pq-\u0026gt;items == 0) pq-\u0026gt;rear = NULL; return true; } /* 清空队列 */ void EmptyTheQueue(Queue * pq) { Item dummy; while (!QueueIsEmpty(pq))\nDeQueue(\u0026amp;dummy, pq); } /* 局部函数 */ static void CopyToNode(Item item, Node * pn) { pn-\u0026gt;item = item; } static void CopyToItem(Node * pn, Item * pi) { *pi = pn-\u0026gt;item; } 17.4.4 测试队列 # 在重要程序中使用一个新的设计（如，队列包）之前，应该先测试该设 # 计。测试的一种方法是，编写一个小程序。这样的程序称为驱动程序 # （driver），其唯一的用途是进行测试。例如，程序清单17.8使用一个添加 和删除整数的队列。在运行该程序之前，要确保queue.h中包含下面这行代 码： typedef int item; 记住，还必须链接queue.c和use_q.c。 程序清单 17.8 use_q.c 程序\n/* use_q.c \u0026ndash; 驱动程序测试 Queue 接口　/ / 与 queue.c 一起编译　/ #include \u0026lt;stdio.h\u0026gt; #include \u0026ldquo;queue.h\u0026rdquo; / 定义Queue、Item / int main(void) { Queue line; Item temp; char ch; InitializeQueue(\u0026amp;line); puts(\u0026ldquo;Testing the Queue interface. Type a to add a value,\u0026rdquo;); puts(\u0026ldquo;type d to delete a value, and type q to quit.\u0026rdquo;); while ((ch = getchar()) != \u0026lsquo;q\u0026rsquo;) { if (ch != \u0026lsquo;a\u0026rsquo; \u0026amp;\u0026amp; ch != \u0026rsquo;d\u0026rsquo;) / 忽略其他输出 */ continue; if (ch == \u0026lsquo;a\u0026rsquo;) { printf(\u0026ldquo;Integer to add: \u0026ldquo;);\nscanf(\u0026quot;%d\u0026rdquo;, \u0026amp;temp); if (!QueueIsFull(\u0026amp;line)) { printf(\u0026ldquo;Putting %d into queue\\n\u0026rdquo;, temp); EnQueue(temp, \u0026amp;line); } else puts(\u0026ldquo;Queue is full!\u0026rdquo;); } else { if (QueueIsEmpty(\u0026amp;line)) puts(\u0026ldquo;Nothing to delete!\u0026rdquo;); else { DeQueue(\u0026amp;temp, \u0026amp;line); printf(\u0026ldquo;Removing %d from queue\\n\u0026rdquo;, temp); } }\nprintf(\u0026quot;%d items in queue\\n\u0026rdquo;, QueueItemCount(\u0026amp;line)); puts(\u0026ldquo;Type a to add, d to delete, q to quit:\u0026rdquo;); } EmptyTheQueue(\u0026amp;line); puts(\u0026ldquo;Bye!\u0026rdquo;); return 0; } 下面是一个运行示例。除了这样测试，还应该测试当队列已满后，实现 是否能正常运行。 Testing the Queue interface. Type a to add a value, type d to delete a value, and type q to quit. a Integer to add: 40 Putting 40　into queue 1　items in queue Type a to add, d to delete, q to quit: a Integer to add: 20 Putting 20　into queue\n2　items in queue Type a to add, d to delete, q to quit: a Integer to add: 55 Putting 55　into queue 3　items in queue Type a to add, d to delete, q to quit: d Removing 40　from queue 2　items in queue Type a to add, d to delete, q to quit: d Removing 20　from queue 1　items in queue Type a to add, d to delete, q to quit: d Removing 55　from queue 0　items in queue Type a to add, d to delete, q to quit:\nd Nothing to delete! 0　items in queue Type a to add, d to delete, q to quit: q Bye!\n17.5 用队列进行模拟 # 经过测试，队列没问题。现在，我们用它来做一些有趣的事情。许多现 # 实生活的情形都涉及队列。例如，在银行或超市的顾客队列、机场的飞机队 # 列、多任务计算机系统中的任务队列等。我们可以用队列包来模拟这些情 # 形。 # 假设Sigmund Landers在商业街设置了一个提供建议的摊位。顾客可以购 买 1 分钟、 2 分钟或 3 分钟的建议。为确保交通畅通，商业街规定每个摊位前 排队等待的顾客最多为 10 人（相当于程序中的最大队列长度）。假设顾客都 是随机出现的，并且他们花在咨询上的时间也是随机选择的（ 1 分钟、 2 分 钟、 3 分钟）。那么 Sigmund 平均每小时要接待多少名顾客？每位顾客平均 要花多长时间？排队等待的顾客平均有多少人？队列模拟能回答类似的问 题。 首先，要确定在队列中放什么。可以根据顾客加入队列的时间和顾客咨 询时花费的时间来描述每一位顾客。因此，可以这样定义Item类型。 typedef struct item { long arrive; /* 一位顾客加入队列的时间 / int processtime; / 该顾客咨询时花费的时间 */ } Item; 要用队列包来处理这个结构，必须用typedef定义的Item替换上一个示例 的int类型。这样做就不用担心队列的具体工作机制，可以集中精力分析实际 问题，即模拟咨询Sigmund的顾客队列。 这里有一种方法，让时间以 1 分钟为单位递增。每递增 1 分钟，就检查是 否有新顾客到来。如果有一位顾客且队列未满，将该顾客添加到队列中。这\n涉及把顾客到来的时间和顾客所需的咨询时间记录在Item类型的结构中，然 后在队列中添加该项。然而，如果队列已满，就让这位顾客离开。为了做统 计，要记录顾客的总数和被拒顾客（队列已满不能加入队列的人）的总数。 接下来，处理队列的首端。也就是说，如果队列不为空且前面的顾客没 有在咨询 Sigmund，则删除队列首端的项。记住，该项中储存着这位顾客加 入队列的时间，把该时间与当前时间作比较，就可得出该顾客在队列中等待 的时间。该项还储存着这位顾客需要咨询的分钟数，即还要咨询 Sigmund多 长时间。因此还要用一个变量储存这个时长。如果Sigmund 正忙，则不用让 任何人离开队列。尽管如此，记录等待时间的变量应该递减 1 。 核心代码类似下面这样，每一轮迭代对应 1 分钟的行为： for (cycle = 0; cycle \u0026lt; cyclelimit; cycle++) { if (newcustomer(min_per_cust)) { if (QueueIsFull(\u0026amp;line)) turnaways++; else { customers++; temp = customertime(cycle); EnQueue(temp, \u0026amp;line); }\n} # if (wait_time \u0026lt;= 0　\u0026amp;\u0026amp; !QueueIsEmpty(\u0026amp;line)) { DeQueue(\u0026amp;temp, \u0026amp;line); wait_time = temp.processtime; line_wait += cycle - temp.arrive; served++; } if (wait_time \u0026gt; 0) wait_time––; sum_line += QueueItemCount(\u0026amp;line); } 注意，时间的表示比较粗糙（ 1 分钟），所以一小时最多 60 位顾客。下 面是一些变量和函数的含义。 min_per_cus是顾客到达的平均间隔时间。 newcustomer()使用C的rand()函数确定在特定时间内是否有顾客到来。 turnaways是被拒绝的顾客数量。 customers是加入队列的顾客数量。 temp是表示新顾客的Item类型变量。\ncustomertime()设置temp结构中的arrive和processtime成员。 wait_time是Sigmund完成当前顾客的咨询还需多长时间。 line_wait是到目前为止队列中所有顾客的等待总时间。 served是咨询过Sigmund的顾客数量。 sum_line是到目前为止统计的队列长度。 如果到处都是malloc()、free()和指向节点的指针，整个程序代码会非常 混乱和晦涩。队列包让你把注意力集中在模拟问题上，而不是编程细节上。 程序清单 17.9 演示了模拟商业街咨询摊位队列的完整代码。根据第 12 章介绍的方法，使用标准函数rand()、srand()和 time()来产生随机数。另外要 特别注意，必须用下面的代码更新 queue.h 中的Item，该程序才能正常工 作： typedef struct item { long arrive; //一位顾客加入队列的时间 int processtime; //该顾客咨询时花费的时间 } Item; 记住，还要把mall.c和queue.c一起链接。 程序清单 17.9 mall.c 程序 // mall.c \u0026ndash; 使用 Queue 接口 // 和 queue.c 一起编译\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 提供 rand() 和 srand() 的原型 #include \u0026lt;time.h\u0026gt; // 提供 time() 的原型 #include \u0026ldquo;queue.h\u0026rdquo; // 更改 Item 的 typedef #define MIN_PER_HR 60.0 bool newcustomer(double x); // 是否有新顾客到来？ Item customertime(long when); // 设置顾客参数 int main(void) { Queue line; Item temp; // 新的顾客数据 int hours; // 模拟的小时数 int perhour; // 每小时平均多少位顾客 long cycle, cyclelimit; // 循环计数器、计数器的上限 long turnaways = 0; // 因队列已满被拒的顾客数量 long customers = 0; // 加入队列的顾客数量 long served = 0; // 在模拟期间咨询过Sigmund的顾客数量 long sum_line = 0; // 累计的队列总长 int wait_time = 0; // 从当前到Sigmund空闲所需的时间\ndouble min_per_cust; // 顾客到来的平均时间 long line_wait = 0; // 队列累计的等待时间 InitializeQueue(\u0026amp;line); srand((unsigned int) time(0)); // rand() 随机初始化 puts(\u0026ldquo;Case Study: Sigmund Lander\u0026rsquo;s Advice Booth\u0026rdquo;); puts(\u0026ldquo;Enter the number of simulation hours:\u0026rdquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;hours); cyclelimit = MIN_PER_HR * hours; puts(\u0026ldquo;Enter the average number of customers per hour:\u0026rdquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;perhour); min_per_cust = MIN_PER_HR / perhour; for (cycle = 0; cycle \u0026lt; cyclelimit; cycle++) { if (newcustomer(min_per_cust)) { if (QueueIsFull(\u0026amp;line)) turnaways++; else {\ncustomers++; temp = customertime(cycle); EnQueue(temp, \u0026amp;line); } } if (wait_time \u0026lt;= 0　\u0026amp;\u0026amp; !QueueIsEmpty(\u0026amp;line)) { DeQueue(\u0026amp;temp, \u0026amp;line); wait_time = temp.processtime; line_wait += cycle - temp.arrive; served++; } if (wait_time \u0026gt; 0) wait_time\u0026ndash;; sum_line += QueueItemCount(\u0026amp;line); } if (customers \u0026gt; 0) { printf(\u0026ldquo;customers accepted: %ld\\n\u0026rdquo;, customers);\nprintf(\u0026rdquo; customers served: %ld\\n\u0026rdquo;, served); printf(\u0026rdquo; turnaways: %ld\\n\u0026rdquo;, turnaways); printf(\u0026ldquo;average queue size: %.2f\\n\u0026rdquo;, (double) sum_line / cyclelimit); printf(\u0026rdquo; average wait time: %.2f minutes\\n\u0026rdquo;, (double) line_wait / served); } else puts(\u0026ldquo;No customers!\u0026rdquo;); EmptyTheQueue(\u0026amp;line); puts(\u0026ldquo;Bye!\u0026rdquo;); return 0; } // x是顾客到来的平均时间（单位：分钟） // 如果 1 分钟内有顾客到来，则返回true bool newcustomer(double x) { if (rand() * x / RAND_MAX \u0026lt; 1) return true;\nelse return false; } // when是顾客到来的时间 // 该函数返回一个Item结构，该顾客到达的时间设置为when， // 咨询时间设置为 1 ～ 3 的随机值 Item customertime(long when) { Item cust; cust.processtime = rand() % 3　+ 1; cust.arrive = when; return cust; } 该程序允许用户指定模拟运行的小时数和每小时平均有多少位顾客。模 拟时间较长得出的值较为平均，模拟时间较短得出的值随时间的变化而随机 变化。下面的运行示例解释了这一点（先保持每小时的顾客平均数量不 变）。注意，在模拟 80 小时和 800 小时的情况下，平均队伍长度和等待时间 基本相同。但是，在模拟 1 小时的情况下这两个量差别很大，而且与长时间 模拟的情况差别也很大。这是因为小数量的统计样本往往更容易受相对变化 的影响。 Case Study: Sigmund Lander\u0026rsquo;s Advice Booth\nEnter the number of simulation hours: 80 Enter the average number of customers per hour: 20 customers accepted: 1633 customers served: 1633 turnaways: 0 average queue size: 0.46 average wait time: 1.35 minutes Case Study: Sigmund Lander\u0026rsquo;s Advice Booth Enter the number of simulation hours: 800 Enter the average number of customers per hour: 20 customers accepted: 16020 customers served: 16019 turnaways: 0 average queue size: 0.44 average wait time: 1.32 minutes\nCase Study: Sigmund Lander\u0026rsquo;s Advice Booth Enter the number of simulation hours: 1 Enter the average number of customers per hour: 20 customers accepted: 20 customers served: 20 turnaways: 0 average queue size: 0.23 average wait time: 0.70 minutes Case Study: Sigmund Lander\u0026rsquo;s Advice Booth Enter the number of simulation hours: 1 Enter the average number of customers per hour: 20 customers accepted: 22 customers served: 22 turnaways: 0 average queue size: 0.75\naverage wait time: 2.05 minutes 然后保持模拟的时间不变，改变每小时的顾客平均数量： Case Study: Sigmund Lander\u0026rsquo;s Advice Booth Enter the number of simulation hours: 80 Enter the average number of customers per hour: 25 customers accepted: 1960 customers served: 1959 turnaways: 3 average queue size: 1.43 average wait time: 3.50 minutes Case Study: Sigmund Lander\u0026rsquo;s Advice Booth Enter the number of simulation hours: 80 Enter the average number of customers per hour: 30 customers accepted: 2376 customers served: 2373\nturnaways: 94 average queue size: 5.85 average wait time: 11.83 minutes 注意，随着每小时顾客平均数量的增加，顾客的平均等待时间迅速增 加。在每小时 20 位顾客（ 80 小时模拟时间）的情况下，每位顾客的平均等待 时间是1.35分钟；在每小时 25 位顾客的情况下，平均等待时间增加至3.50分 钟；在每小时 30 位顾客的情况下，该数值攀升至11.83分钟。而且，这 3 种情 况下被拒顾客分别从 0 位增加至 3 位最后陡增至 94 位。Sigmund可以根据程序 模拟的结果决定是否要增加一个摊位。\n17.6 链表和数组 # 许多编程问题，如创建一个简单链表或队列，都可以用链表（指的是动 # 态分配结构的序列链）或数组来处理。每种形式都有其优缺点，所以要根据 # 具体问题的要求来决定选择哪一种形式。表17.1总结了链表和数组的性质。 # 表17.1 比较数组和链表 接下来，详细分析插入和删除元素的过程。在数组中插入元素，必须移 # 动其他元素腾出空位插入新元素，如图17.9所示。新插入的元素离数组开头 # 越近，要被移动的元素越多。然而，在链表中插入节点，只需给两个指针赋 # 值，如图17.10所示。类似地，从数组中删除一个元素，也要移动许多相关 # 的元素。但是从链表中删除节点，只需重新设置一个指针并释放被删除节点 # 占用的内存即可。 # 图17.9 在数组中插入一个元素\n图17.10 在链表中插入一个元素 接下来，考虑如何访问元素。对数组而言，可以使用数组下标直接访问 该数组中的任意元素，这叫做随机访问（random access）。对链表而言，必 须从链表首节点开始，逐个节点移动到要访问的节点，这叫做顺序访问 （sequential access）。当然，也可以顺序访问数组。只需按顺序递增数组下 标即可。在某些情况下，顺序访问足够了。例如，显示链表中的每一项，顺 序访问就不错。其他情况用随机访问更合适。 假设要查找链表中的特定项。一种算法是从列表的开头开始按顺序查 找，这叫做顺序查找（sequential search）。如果项并未按某种顺序排列，则 只能顺序查找。如果待查找的项不在链表里，必须查找完所有的项才知道该 项不在链表中（在这种情况下可以使用并发编程，同时查找列表中的不同部 分）。\n我们可以先排序列表，以改进顺序查找。这样，就不必查找排在待查找 # 项后面的项。例如，假设在一个按字母排序的列表中查找Susan。从开头开 始查找每一项，直到Sylvia都没有查找到Susan。这时就可以退出查找，因为 如果Susan在列表中，应该排在Sylvia前面。平均下来，这种方法查找不在列 表中的项的时间减半。 对于一个排序的列表，用二分查找（binary search）比顺序查找好得 多。下面分析二分查找的原理。首先，把待查找的项称为目标项，而且假设 列表中的各项按字母排序。然后，比较列表的中间项和目标项。如果两者相 等，查找结束；假设目标项在列表中，如果中间项排在目标项前面，则目标 项一定在后半部分项中；如果中间项在目标项后面，则目标项一定在前半部 分项中。无论哪种情况，两项比较的结果都确定了下次查找的范围只有列表 的一半。接着，继续使用这种方法，把需要查找的剩下一半的中间项与目标 项比较。同样，这种方法会确定下一次查找的范围是当前查找范围的一半。 以此类推，直到找到目标项或最终发现列表中没有目标项（见图17.11）。 这种方法非常有效率。假如有 127 个项，顺序查找平均要进行 64 次比较才能 找到目标项或发现不在其中。但是二分查找最多只用进行 7 次比较。第 1 次比 较剩下 63 项进行比较，第 2 次比较剩下 31 项进行比较，以此类推，第 6 次剩下 最后 1 项进行比较，第 7 次比较确定剩下的这个项是否是目标项。一般而言， n 次比较能处理有 2 n-1 个元素的数组。所以项数越多，越能体现二分查找的 优势。\n图17.11 用二分查找法查找Susan 用数组实现二分查找很简单，因为可以使用数组下标确定数组中任意部 分的中点。只要把数组的首元素和尾元素的索引相加，得到的和再除以 2 即 可。例如，内含 100 个元素的数组，首元素下标是 0 ，尾元素下标是 99 ，那 么用于首次比较的中间项的下标应为(0+99)/2，得 49 （整数除法）。如果比 较的结果是下标为 49 的元素在目标项的后面，那么目标项的下标应在 0 ～ 48 的范围内。所以，第 2 次比较的中间项的下标应为(0+48)/2，得 24 。如果中 间项与目标项的比较结果是，中间项在目标项前面，那么第 3 次比较的中间 项下标应为(25+48)/2，得 36 。这体现了随机访问的特性，可以从一个位置 跳至另一个位置，不用一次访问两位置之间的项。但是，链表只支持顺序访 问，不提供跳至中间节点的方法。所以在链表中不能使用二分查找。 如前所述，选择何种数据类型取决于具体的问题。如果因频繁地插入和 删除项导致经常调整大小，而且不需要经常查找，选择链表会更好。如果只 是偶尔插入或删除项，但是经常进行查找，使用数组会更好。 如果需要一种既支持频繁插入和删除项又支持频繁查找的数据形式，数 组和链表都无法胜任，怎么办？这种情况下应该选择二叉查找树。\n17.7 二叉查找树 # 二叉查找树是一种结合了二分查找策略的链接结构。二叉树的每个节点 # 都包含一个项和两个指向其他节点（称为子节点）的指针。图17.12演示了 # 二叉查找树中的节点是如何链接的。二叉树中的每个节点都包含两个子节点 # ——左节点和右节点，其顺序按照如下规定确定：左节点的项在父节点的项 # 前面，右节点的项在父节点的项后面。这种关系存在于每个有子节点的节点 # 中。进一步而言，所有可以追溯其祖先回到一个父节点的左节点的项，都在 # 该父节点项的前面；所有以一个父节点的右节点为祖先的项，都在该父节点 # 项的后面。图17.12中的树以这种方式储存单词。有趣的是，与植物学的树 # 相反，该树的顶部被称为根（root）。树具有分层组织，所以以这种方式储 存的数据也以等级或层次组织。一般而言，每级都有上一级和下一级。如果 二叉树是满的，那么每一级的节点数都是上一级节点数的两倍。\n图17.12 一个从存储单词的二叉树 二叉查找树中的每个节点是其后代节点的根，该节点与其后代节点构成 称了一个子树（subtree）。如图 17.12 所示，包含单词fate、carpet和llama的\n节点构成了整个二叉树的左子树，而单词 voyage是style-plenum-voyage子树 的右子树。 假设要在二叉树中查找一个项（即目标项）。如果目标项在根节点项的 前面，则只需查找左子树；如果目标项在根节点项的后面，则只需查找右子 树。因此，每次比较就排除半个树。假设查找左子树，这意味着目标项与左 子节点项比较。如果目标项在左子节点项的前面，则只需查找其后代节点的 左半部分，以此类推。与二分查找类似，每次比较都能排除一半的可能匹配 项。 我们用这种方法来查找puppy是否在图17.12的二叉树中。比较puppy和 melon（根节点项），如果puppy在该树中，一定在右子树中。因此，在右子 树中比较puppy和style，发现puppy在style前面，所以必须链接到其左节点。 然后发现该节点是plenum，在puppy前面。现在要向下链接到该节点的右子 节点，但是没有右子节点了。所以经过 3 次比较后发现puppy不在该树中。 二叉查找树在链式结构中结合了二分查找的效率。但是，这样编程的代 价是构建一个二叉树比创建一个链表更复杂。下面我们在下一个ADT项目中 创建一个二叉树。\n17.7.1 二叉树 ADT # 和前面一样，先从概括地定义二叉树开始。该定义假设树不包含相同的 # 项。许多操作与链表相同，区别在于数据层次的安排。下面建立一个非正式 # 的树定义： # 类型名：　二叉查找树 # 类型属性：　二叉树要么是空节点的集合（空树），要么是有一 # 个根节点的节点集合 # 每个节点都有两个子树，叫做左子树和右子树 # 每个子树本身也是一个二叉树，也有可能是空树 # 二叉查找树是一个有序的二叉树，每个节点包含一个项， # 左子树的所有项都在根节点项的前面，右子树的所有项都在根节点项的 # 后面 # 类型操作：　初始化树为空 # 确定树是否为空 # 确定树是否已满 # 确定树中的项数 # 在树中添加一个项 # 在树中删除一个项 # 在树中查找一个项 # 在树中访问一个项 # 清空树 # 17.7.2 二叉查找树接口 # 原则上，可以用多种方法实现二叉查找树，甚至可以通过操控数组下标 # 用数组来实现。但是，实现二叉查找树最直接的方法是通过指针动态分配链 # 式节点。因此我们这样定义： # typedef SOMETHING Item; typedef struct trnode { Item item; struct trnode * left; struct trnode * right; } Trn; typedef struct tree { Trnode * root; int size; } Tree; 每个节点包含一个项、一个指向左子节点的指针和一个指向右子节点的 指针。可以把 Tree 定义为指向 Trnode 的指针类型，因为只需要知道根节点 的位置就可访问整个树。然而，使用有成员大小的结构能很方便地记录树的 大小。 我们要开发一个维护 Nerfville 宠物俱乐部的花名册，每一项都包含宠 物名和宠物的种类。程序清单17.10就是该花名册的接口。我们把树的大小 限制为 10 ，较小的树便于在树已满时测试程序的行为是否正确。当然，你也 可以把MAXITEMS设置为更大的值。 程序清单 17.10 tree.h 接口头文件 /* tree.h \u0026ndash; 二叉查找数　/ /　树种不允许有重复的项 */ #ifndef TREE_H #define TREE_H\n#include \u0026lt;stdbool.h\u0026gt; /* 根据具体情况重新定义 Item / #define SLEN 20 typedef struct item { char petname[SLEN]; char petkind[SLEN]; } Item; #define MAXITEMS 10 typedef struct trnode { Item item; struct trnode * left; / 指向左分支的指针 / struct trnode * right; / 指向右分支的指针 / } Trnode; typedef struct tree { Trnode * root;/ 指向根节点的指针　/ int size; / 树的项数　*/\n} Tree; /* 函数原型 / / 操作：　把树初始化为空*/ /* 前提条件：　ptree指向一个树　/ / 后置条件：　树被初始化为空　/ void InitializeTree(Tree * ptree); / 操作：　确定树是否为空　/ / 前提条件：　ptree指向一个树　/ / 后置条件：　如果树为空，该函数返回true / /　否则，返回false / bool TreeIsEmpty(const Tree * ptree); / 操作：　确定树是否已满　/ / 前提条件：　ptree指向一个树　/ / 后置条件：　如果树已满，该函数返回true / /　否则，返回false / bool TreeIsFull(const Tree * ptree); / 操作：　确定树的项数　/ / 前提条件：　ptree指向一个树　/ / 后置条件：　返回树的项数　*/\nint TreeItemCount(const Tree * ptree); /* 操作：　在树中添加一个项　/ / 前提条件：　pi是待添加项的地址　/ / ptree指向一个已初始化的树　/ / 后置条件：　如果可以添加，该函数将在树中添加一个项　/ /　并返回true；否则，返回false / bool AddItem(const Item * pi, Tree * ptree); / 操作：　在树中查找一个项　/ / 前提条件：　pi指向一个项　/ / ptree指向一个已初始化的树　/ / 后置条件：　如果在树中添加一个项，该函数返回true / /　否则，返回false / bool InTree(const Item * pi, const Tree * ptree); / 操作：　从树中删除一个项　/ / 前提条件：　pi是删除项的地址　/ / ptree指向一个已初始化的树　/ / 后置条件：　如果从树中成功删除一个项，该函数返回true*/ /*　否则，返回false */ bool DeleteItem(const Item * pi, Tree * ptree);\n/* 操作：　把函数应用于树中的每一项　*/ # /* 前提条件：　ptree指向一个树　*/ /* pfun指向一个函数，　*/ /*　该函数接受一个Item类型的参数，并无返回值*/ /* 后置条件：　pfun指向的这个函数为树中的每一项执行一次*/ void Traverse(const Tree * ptree, void(*pfun)(Item item)); /* 操作：　删除树中的所有内容　*/ /* 前提条件：　ptree指向一个已初始化的树　*/ /* 后置条件：　树为空　*/ void DeleteAll(Tree * ptree); #endif 17.7.3 二叉树的实现 # 接下来，我们要实现tree.h中的每个函数。InitializeTree()、 EmptyTree()、FullTree()和TreeItems()函数都很简单，与链表ADT、队列ADT 类似，所以下面着重讲解其他函数。\n1. 添加项 在树中添加一个项，首先要检查该树是否有空间放得下一个项。由于我 们定义二叉树时规定其中的项不能重复，所以接下来要检查树中是否有该 项。通过这两步检查后，便可创建一个新节点，把待添加项拷贝到该节点 中，并设置节点的左指针和右指针都为NULL。这表明该节点没有子节点。 然后，更新Tree结构的 size 成员，统计新增了一项。接下来，必须找出应该 把这个新节点放在树中的哪个位置。如果树为空，则应设置根节点指针指向\n该新节点。否则，遍历树找到合适的位置放置该节点。AddItem()函数就根 据这个思路来实现，并把一些工作交给几个尚未定义的函数：SeekItem()、 MakeNode()和AddNode()。 bool AddItem(const Item * pi, Tree * ptree) { Trnode * new_node; if (TreeIsFull(ptree)) { fprintf(stderr, \u0026ldquo;Tree is full\\n\u0026rdquo;); return false; /* 提前返回　/ } if (SeekItem(pi, ptree).child != NULL) { fprintf(stderr, \u0026ldquo;Attempted to add duplicate item\\n\u0026rdquo;); return false; / 提前返回　/ } new_node = MakeNode(pi); / 指向新节点　*/ if (new_node == NULL) { fprintf(stderr, \u0026ldquo;Couldn\u0026rsquo;t create node\\n\u0026rdquo;);\nreturn false; /* 提前返回　/ } / 成功创建了一个新节点 / ptree-\u0026gt;size++; if (ptree-\u0026gt;root == NULL) / 情况 1 ：树为空　/ ptree-\u0026gt;root = new_node; / 新节点是根节点　/ else / 情况 2 ：树不为空　/ AddNode(new_node, ptree-\u0026gt;root);/ 在树中添加一个节点*/ return true; /* 成功返回 */ } SeekItem()、MakeNode()和 AddNode()函数不是 Tree 类型公共接口的一 部分。它们是隐藏在tree.c文件中的静态函数，处理实现的细节（如节点、 指针和结构），不属于公共接口。 MakeNode()函数相当简单，它处理动态内存分配和初始化节点。该函 数的参数是指向新项的指针，其返回值是指向新节点的指针。如果 malloc() 无法分配所需的内存，则返回空指针。只有成功分配了内存，MakeNode() 函数才会初始化新节点。下面是MakeNode()的代码： static Trnode * MakeNode(const Item * pi) { Trnode * new_node; new_node = (Trnode *) malloc(sizeof(Trnode));\nif (new_node != NULL) { new_node-\u0026gt;item = *pi; new_node-\u0026gt;left = NULL; new_node-\u0026gt;right = NULL; } return new_node; } AddNode()函数是二叉查找树包中最麻烦的第 2 个函数。它必须确定新 节点的位置，然后添加新节点。具体来说，该函数要比较新项和根项，以确 定应该把新项放在左子树还是右子树中。如果新项是一个数字，则使用\u0026lt;和\n进行比较；如果新项是一个字符串，则使用strcmp()函数来比较。但是，该 项是内含两个字符串的结构，所以，必须自定义用于比较的函数。如果新项 应放在左子树中，ToLeft()函数（稍后定义）返回true；如果新项应放在右子 树中，ToRight()函数（稍后定义）返回true。这两个函数分别相当于\u0026lt;和\u0026gt;。 假设把新项放在左子树中。如果左子树为空，AddNode()函数只需让左子节 点指针指向新项即可。如果左子树不为空怎么办？此时，AddNode()函数应 该把新项和左子节点中的项做比较，以确定新项应该放在该子节点的左子树 还是右子树。这个过程一直持续到函数发现一个空子树为止，并在此此处添 加新节点。递归是一种实现这种查找过程的方法，即把AddNode()函数应用 于子节点，而不是根节点。当左子树或右子树为空时，即当root-\u0026gt;left或root- right为NULL时，函数的递归调用序列结束。记住，root是指向当前子树顶 部的指针，所以每次递归调用它都指向一个新的下一级子树（递归详见第 9 章）。 static void AddNode(Trnode * new_node, Trnode * root)\n{ # if (ToLeft(\u0026amp;new_node-\u0026gt;item, \u0026amp;root-\u0026gt;item)) { if (root-\u0026gt;left == NULL) /* 空子树 / root-\u0026gt;left = new_node; / 所以，在此处添加节点 / else AddNode(new_node, root-\u0026gt;left); / 否则，处理该子树*/ } else if (ToRight(\u0026amp;new_node-\u0026gt;item, \u0026amp;root-\u0026gt;item)) { if (root-\u0026gt;right == NULL) root-\u0026gt;right = new_node; else AddNode(new_node, root-\u0026gt;right); } else /* 不应含有重复的项 */ { fprintf(stderr, \u0026ldquo;location error in AddNode()\\n\u0026rdquo;); exit(1);\n} # } # ToLeft()和ToRight()函数依赖于Item类型的性质。Nerfville宠物俱乐部的 成员名按字母排序。如果两个宠物名相同，按其种类排序。如果种类也相 同，这两项属于重复项，根据该二叉树的定义，这是不允许的。回忆一下， 如果标准C库函数strcmp()中的第 1 个参数表示的字符串在第 2 个参数表示的字 符串前面，该函数则返回负数；如果两个字符串相同，该函数则返回 0 ；如 果第 1 个字符串在第 2 个字符串后面，该函数则返回正数。ToRight()函数的实 现代码与该函数类似。通过这两个函数完成比较，而不是直接在AddNode() 函数中直接比较，这样的代码更容易适应新的要求。当需要比较不同的数据 形式时，就不必重写整个AddNode()函数，只需重写Toleft()和ToRight()即 可。 static bool ToLeft(const Item * i1, const Item * i2) { int comp1; if ((comp1 = strcmp(i1-\u0026gt;petname, i2-\u0026gt;petname)) \u0026lt; 0) return true; else if (comp1 == 0　\u0026amp;\u0026amp; strcmp(i1-\u0026gt;petkind, i2-\u0026gt;petkind) \u0026lt; 0) return true; else return false;\n} # 2. 查找项 # 3 个接口函数都要在树中查找特定项：AddItem()、InItem()和 DeleteItem()。这些函数的实现中使用SeekItem()函数进行查找。DeleteItem() 函数有一个额外的要求：该函数要知道待删除项的父节点，以便在删除子节 点后更新父节点指向子节点的指针。因此，我们设计SeekItem()函数返回的 结构包含两个指针：一个指针指向包含项的节点（如果未找到指定项则为 NULL）；一个指针指向父节点（如果该节点为根节点，即没有父节点，则 为NULL）。这个结构类型的定义如下： typedef struct pair { Trnode * parent; Trnode * child; } Pair; SeekItem()函数可以用递归的方式实现。但是，为了给读者介绍更多编 程技巧，我们这次使用while循环处理树中从上到下的查找。和AddNode()一 样，SeekItem()也使用ToLeft()和ToRight()在树中导航。开始时，SeekItem()设 置look.child指针指向该树的根节点，然后沿着目标项应在的路径重置 look.child指向后续的子树。同时，设置look.parent指向后续的父节点。如果 没有找到匹配的项， look.child则被设置为NULL。如果在根节点找到匹配的 项，则设置look.parent为NULL，因为根节点没有父节点。下面是SeekItem() 函数的实现代码： static Pair SeekItem(const Item * pi, const Tree * ptree) { Pair look;\nlook.parent = NULL; look.child = ptree-\u0026gt;root; if (look.child == NULL) return look; /* 提前退出 / while (look.child != NULL) { if (ToLeft(pi, \u0026amp;(look.child-\u0026gt;item))) { look.parent = look.child; look.child = look.child-\u0026gt;left; } else if (ToRight(pi, \u0026amp;(look.child-\u0026gt;item))) { look.parent = look.child; look.child = look.child-\u0026gt;right; } else / 如果前两种情况都不满足，则必定是相等的情况 / break; / look.child 目标项的节点 */ }\nreturn look; /* 成功返回 */ } 注意，如果 SeekItem()函数返回一个结构，那么该函数可以与结构成员 运算符一起使用。例如， AddItem()函数中有如下的代码： if (SeekItem(pi, ptree).child != NULL) 有了SeekItem()函数后，编写InTree()公共接口函数就很简单了： bool InTree(const Item * pi, const Tree * ptree) { return (SeekItem(pi, ptree).child == NULL)? false : true; }\n3. 考虑删除项 删除项是最复杂的任务，因为必须重新连接剩余的子树形成有效的树。 在准备编写这部分代码之前，必须明确需要做什么。 图17.13演示了最简单的情况。待删除的节点没有子节点，这样的节点 被称为叶节点（leaf）。这种情况只需把父节点中的指针重置为NULL，并使 用free()函数释放已删除节点所占用的内存。\n图17.13 删除一个叶节点 删除带有一个子节点的情况比较复杂。删除该节点会导致其子树与其他 部分分离。为了修正这种情况，要把被删除节点父节点中储存该节点的地址 更新为该节点子树的地址（见图17.14）。\n图17.14 删除有一个子节点的节点 最后一种情况是删除有两个子树的节点。其中一个子树（如左子树）可 连接在被删除节点之前连接的位置。但是，另一个子树怎么处理？牢记树的 基本设计：左子树的所有项都在父节点项的前面，右子树的所有项都在父节 点项的后面。也就是说，右子树的所有项都在左子树所有项的后面。而且， 因为该右子树曾经是被删除节点的父节点的左子树的一部分，所以该右节点 中的所有项在被删除节点的父节点项的前面。想像一下如何在树中从上到下 查找该右子树的头所在的位置。它应该在被删除节点的父节点的前面，所以 要沿着父节点的左子树向下找。但是，该右子树的所有项又在被删除节点左 子树所有项的后面。因此要查看左子树的右支是否有新节点的空位。如果没\n有，就要沿着左子树的右支向下找，一直找到一个空位为止。图17.15演示 # 了这种方法。 # 图17.15 删除一个有两个子节点的项 ① 删除一个节点 现在可以设计所需的函数了，可以分成两个任务：第一个任务是把特定 项与待删除节点关联；第二个任务是删除节点。无论哪种情况都必须修改待 删除项父节点的指针。因此，要注意以下两点。\n该程序必须标识待删除节点的父节点。 # 为了修改指针，代码必须把该指针的地址传递给执行删除任务的函数。 # 第一点稍后讨论，下面先分析第二点。要修改的指针本身是Trnode *类 型，即指向Trnode的指针。由于该函数的参数是该指针的地址，所以参数的 类型是Trnode **，即指向指针（该指针指向Trnode）的指针。假设有合适的 地址可用，可以这样编写执行删除任务的函数： static void DeleteNode(Trnode *ptr) / ptr 是指向目标节点的父节点指针成员的地址 */ { Trnode * temp; if ((*ptr)-\u0026gt;left == NULL) { temp = *ptr; *ptr = (*ptr)-\u0026gt;right; free(temp); } else if ((*ptr)-\u0026gt;right == NULL) { temp = *ptr; *ptr = (*ptr)-\u0026gt;left;\nfree(temp); } else /* 被删除的节点有两个子节点 / { / 找到重新连接右子树的位置 */ for (temp = (*ptr)-\u0026gt;left; temp-\u0026gt;right != NULL; temp = temp-\u0026gt;right) continue; temp-\u0026gt;right = (*ptr)-\u0026gt;right; temp = *ptr; *ptr = (*ptr)-\u0026gt;left; free(temp); } } 该函数显式处理了 3 种情况：没有左子节点的节点、没有右子节点的节 点和有两个子节点的节点。无子节点的节点可作为无左子节点的节点的特 例。如果该节点没有左子节点，程序就将右子节点的地址赋给其父节点的指 针。如果该节点也没有右子节点，则该指针为NULL。这就是无子节点情况 的值。 注意，代码中用临时指针记录被删除节点的地址。被删除节点的父节点 指针（*ptr）被重置后，程序会丢失被删除节点的地址，但是free()函数需要\n这个信息。所以，程序把ptr的原始值储存在temp中，然后用free()函数使用 temp来释放被删除节点所占用的内存。 有两个子节点的情况，首先在for循环中通过temp指针从左子树的右半 部分向下查找一个空位。找到空位后，把右子树连接于此。然后，再用 temp 保存被删除节点的位置。接下来，把左子树连接到被删除节点的父节 点上，最后释放temp指向的节点。 注意，由于ptr的类型是Trnode **，所以ptr的类型是Trnode ，与temp的 类型相同。 ② 删除一个项 剩下的问题是把一个节点与特定项相关联。可以使用SeekItem()函数来 完成。回忆一下，该函数返回一个结构（内含两个指针，一个指针指向父节 点，一个指针指向包含特定项的节点）。然后就可以通过父节点的指针获得 相应的地址传递给DeleteNode()函数。根据这个思路，DeleteNode()函数的定 义如下： bool DeleteItem(const Item * pi, Tree * ptree) { Pair look; look = SeekItem(pi, ptree); if (look.child == NULL) return false; if (look.parent == NULL) / 删除根节点 */ DeleteNode(\u0026amp;ptree-\u0026gt;root);\nelse if (look.parent-\u0026gt;left == look.child) DeleteNode(\u0026amp;look.parent-\u0026gt;left); else DeleteNode(\u0026amp;look.parent-\u0026gt;right); ptree-\u0026gt;size\u0026ndash;; return true; } 首先，SeekItem()函数的返回值被赋给look类型的结构变量。如果 look.child是NULL，表明未找到指定项，DeleteItem()函数退出，并返回 false。如果找到了指定的Item，该函数分 3 种情况来处理。第一种情况是， look.parent的值为NULL，这意味着该项在根节点中。在这情况下，不用更新 父节点，但是要更新Tree结构中根节点的指针。因此，函数该函数把该指针 的地址传递给DeleteNode()函数。否则（即剩下两种情况），程序判断待删 除节点是其父节点的左子节点还是右子节点，然后传递合适指针的地址。 注意，公共接口函数（DeleteItem()）处理的是最终用户所关心的问题 （项和树），而隐藏的DeleteNode()函数处理的是与指针相关的实质性任 务。\n4. 遍历树 遍历树比遍历链表更复杂，因为每个节点都有两个分支。这种分支特性 很适合使用分而制之的递归（详见第 9 章）来处理。对于每一个节点，执行 遍历任务的函数都要做如下的工作： 处理节点中的项； 处理左子树（递归调用）；\n处理右子树（递归调用）。 # 可以把遍历分成两个函数来完成：Traverse()和InOrder()。注意， InOrder()函数处理左子树，然后处理项，最后处理右子树。这种遍历树的顺 序是按字母排序进行。如果你有时间，可以试试用不同的顺序，比如，项- 左子树-右子树或者左子树-右子树-项，看看会发生什么。 void Traverse(const Tree * ptree, void(*pfun)(Item item)) { if (ptree != NULL) InOrder(ptree-\u0026gt;root, pfun); } static void InOrder(const Trnode * root, void(*pfun)(Item item)) { if (root != NULL) { InOrder(root-\u0026gt;left, pfun); (*pfun)(root-\u0026gt;item); InOrder(root-\u0026gt;right, pfun); } }\n5. 清空树\n清空树基本上和遍历树的过程相同，即清空树的代码也要访问每个节 # 点，而且要用 free()函数释放内存。除此之外，还要重置Tree类型结构的成 员，表明该树为空。DeleteAll()函数负责处理Tree类型的结构，把释放内存 的任务交给 DeleteAllNode()函数。DeleteAllNode()与 InOrder()函数的构造相 同，它储存了指针的值root-\u0026gt;right，使其在释放根节点后仍然可用。下面是 这两个函数的代码： void DeleteAll(Tree * ptree) { if (ptree != NULL) DeleteAllNodes(ptree-\u0026gt;root); ptree-\u0026gt;root = NULL; ptree-\u0026gt;size = 0; } static void DeleteAllNodes(Trnode * root) { Trnode * pright; if (root != NULL) { pright = root-\u0026gt;right; DeleteAllNodes(root-\u0026gt;left); free(root);\nDeleteAllNodes(pright); } } 6. 完整的包 程序清单17.11演示了整个tree.c的代码。tree.h和tree.c共同组成了树的程 序包。 程序清单 17.11 tree.c 程序 /* tree.c \u0026ndash; 树的支持函数 / #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026ldquo;tree.h\u0026rdquo; / 局部数据类型 / typedef struct pair { Trnode * parent; Trnode * child; } Pair; / 局部函数的原型 */ static Trnode * MakeNode(const Item * pi);\nstatic bool ToLeft(const Item * i1, const Item * i2); static bool ToRight(const Item * i1, const Item * i2); static void AddNode(Trnode * new_node, Trnode * root); static void InOrder(const Trnode * root, void(*pfun)(Item item)); static Pair SeekItem(const Item * pi, const Tree * ptree); static void DeleteNode(Trnode *ptr); static void DeleteAllNodes(Trnode * ptr); / 函数定义 */ void InitializeTree(Tree * ptree) { ptree-\u0026gt;root = NULL; ptree-\u0026gt;size = 0; } bool TreeIsEmpty(const Tree * ptree) { if (ptree-\u0026gt;root == NULL) return true; else return false;\n} # bool TreeIsFull(const Tree * ptree) { if (ptree-\u0026gt;size == MAXITEMS) return true; else return false; } int TreeItemCount(const Tree * ptree) { return ptree-\u0026gt;size; } bool AddItem(const Item * pi, Tree * ptree) { Trnode * new_node; if (TreeIsFull(ptree)) { fprintf(stderr, \u0026ldquo;Tree is full\\n\u0026rdquo;); return false; /* 提前返回　*/\n} # if (SeekItem(pi, ptree).child != NULL) { fprintf(stderr, \u0026ldquo;Attempted to add duplicate item\\n\u0026rdquo;); return false; /* 提前返回　/ } new_node = MakeNode(pi); / 指向新节点　/ if (new_node == NULL) { fprintf(stderr, \u0026ldquo;Couldn\u0026rsquo;t create node\\n\u0026rdquo;); return false; / 提前返回　/ } / 成功创建了一个新节点 / ptree-\u0026gt;size++; if (ptree-\u0026gt;root == NULL) / 情况 1 ：树为空　/ ptree-\u0026gt;root = new_node; / 新节点为树的根节点　/ else / 情况 2 ：树不为空　/ AddNode(new_node, ptree-\u0026gt;root);/ 在树中添加新节点　/ return true; / 成功返回　*/\n} # bool InTree(const Item * pi, const Tree * ptree) { return (SeekItem(pi, ptree).child == NULL)? false : true; } bool DeleteItem(const Item * pi, Tree * ptree) { Pair look; look = SeekItem(pi, ptree); if (look.child == NULL) return false; if (look.parent == NULL) /* 删除根节点项　*/ DeleteNode(\u0026amp;ptree-\u0026gt;root); else if (look.parent-\u0026gt;left == look.child) DeleteNode(\u0026amp;look.parent-\u0026gt;left); else DeleteNode(\u0026amp;look.parent-\u0026gt;right); ptree-\u0026gt;size\u0026ndash;; return true;\n} # void Traverse(const Tree * ptree, void(pfun)(Item item)) { if (ptree != NULL) InOrder(ptree-\u0026gt;root, pfun); } void DeleteAll(Tree * ptree) { if (ptree != NULL) DeleteAllNodes(ptree-\u0026gt;root); ptree-\u0026gt;root = NULL; ptree-\u0026gt;size = 0; } / 局部函数 */ static void InOrder(const Trnode * root, void(*pfun)(Item item)) { if (root != NULL) { InOrder(root-\u0026gt;left, pfun);\n(*pfun)(root-\u0026gt;item); InOrder(root-\u0026gt;right, pfun); } } static void DeleteAllNodes(Trnode * root) { Trnode * pright; if (root != NULL) { pright = root-\u0026gt;right; DeleteAllNodes(root-\u0026gt;left); free(root); DeleteAllNodes(pright); } } static void AddNode(Trnode * new_node, Trnode * root) { if (ToLeft(\u0026amp;new_node-\u0026gt;item, \u0026amp;root-\u0026gt;item)) {\nif (root-\u0026gt;left == NULL) /* 空子树　/ root-\u0026gt;left = new_node; / 把节点添加到此处　/ else AddNode(new_node, root-\u0026gt;left); / 否则处理该子树　/ } else if (ToRight(\u0026amp;new_node-\u0026gt;item, \u0026amp;root-\u0026gt;item)) { if (root-\u0026gt;right == NULL) root-\u0026gt;right = new_node; else AddNode(new_node, root-\u0026gt;right); } else / 不允许有重复项　*/ { fprintf(stderr, \u0026ldquo;location error in AddNode()\\n\u0026rdquo;); exit(1); } }\nstatic bool ToLeft(const Item * i1, const Item * i2) { int comp1; if ((comp1 = strcmp(i1-\u0026gt;petname, i2-\u0026gt;petname)) \u0026lt; 0) return true; else if (comp1 == 0　\u0026amp;\u0026amp;strcmp(i1-\u0026gt;petkind, i2-\u0026gt;petkind) \u0026lt; 0) return true; else return false; } static bool ToRight(const Item * i1, const Item * i2) { int comp1; if ((comp1 = strcmp(i1-\u0026gt;petname, i2-\u0026gt;petname)) \u0026gt; 0) return true; else if (comp1 == 0　\u0026amp;\u0026amp; strcmp(i1-\u0026gt;petkind, i2-\u0026gt;petkind) \u0026gt; 0) return true; else\nreturn false; } static Trnode * MakeNode(const Item * pi) { Trnode * new_node; new_node = (Trnode *) malloc(sizeof(Trnode)); if (new_node != NULL) { new_node-\u0026gt;item = *pi; new_node-\u0026gt;left = NULL; new_node-\u0026gt;right = NULL; } return new_node; } static Pair SeekItem(const Item * pi, const Tree * ptree) { Pair look; look.parent = NULL; look.child = ptree-\u0026gt;root;\nif (look.child == NULL) return look; /* 提前返回　/ while (look.child != NULL) { if (ToLeft(pi, \u0026amp;(look.child-\u0026gt;item))) { look.parent = look.child; look.child = look.child-\u0026gt;left; } else if (ToRight(pi, \u0026amp;(look.child-\u0026gt;item))) { look.parent = look.child; look.child = look.child-\u0026gt;right; } else / 如果前两种情况都不满足，则必定是相等的情 况　/ break; / look.child 目标项的节点　/ } return look; / 成功返回 */\n} # static void DeleteNode(Trnode *ptr) / ptr 是指向目标节点的父节点指针成员的地址 */ { Trnode * temp; if ((*ptr)-\u0026gt;left == NULL) { temp = *ptr; *ptr = (*ptr)-\u0026gt;right; free(temp); } else if ((*ptr)-\u0026gt;right == NULL) { temp = *ptr; *ptr = (ptr)-\u0026gt;left; free(temp); } else / 被删除的节点有两个子节点 */ {\n/* 找到重新连接右子树的位置 */ # for (temp = (*ptr)-\u0026gt;left; temp-\u0026gt;right != NULL;temp = temp-\u0026gt;right) continue; temp-\u0026gt;right = (*ptr)-\u0026gt;right; temp = *ptr; *ptr = (*ptr)-\u0026gt;left; free(temp); } } 17.7.4 使用二叉树 # 现在，有了接口和函数的实现，就可以使用它们了。程序清单17.12中 # 的程序以菜单的方式提供选择：向俱乐部成员花名册添加宠物、显示成员列 # 表、报告成员数量、核实成员及退出。main()函数很简单，主要提供程序的 大纲。具体工作主要由支持函数来完成。 程序清单 17.12 petclub.c 程序 /* petclub.c \u0026ndash; 使用二叉查找数 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026ldquo;tree.h\u0026rdquo;\nchar menu(void); void addpet(Tree * pt); void droppet(Tree * pt); void showpets(const Tree * pt); void findpet(const Tree * pt); void printitem(Item item); void uppercase(char * str); char * s_gets(char * st, int n); int main(void) { Tree pets; char choice; InitializeTree(\u0026amp;pets); while ((choice = menu()) != \u0026lsquo;q\u0026rsquo;) { switch (choice) { case \u0026lsquo;a\u0026rsquo;: addpet(\u0026amp;pets); break;\ncase \u0026rsquo;l\u0026rsquo;: showpets(\u0026amp;pets); break; case \u0026lsquo;f\u0026rsquo;: findpet(\u0026amp;pets); break; case \u0026rsquo;n\u0026rsquo;: printf(\u0026quot;%d pets in club\\n\u0026quot;, TreeItemCount(\u0026amp;pets)); break; case \u0026rsquo;d\u0026rsquo;: droppet(\u0026amp;pets); break; default: puts(\u0026ldquo;Switching error\u0026rdquo;); } } DeleteAll(\u0026amp;pets); puts(\u0026ldquo;Bye.\u0026rdquo;); return 0; } char menu(void) { int ch;\nputs(\u0026ldquo;Nerfville Pet Club Membership Program\u0026rdquo;); puts(\u0026ldquo;Enter the letter corresponding to your choice:\u0026rdquo;); puts(\u0026ldquo;a) add a pet l) show list of pets\u0026rdquo;); puts(\u0026ldquo;n) number of pets f) find pets\u0026rdquo;); puts(\u0026ldquo;d) delete a pet q) quit\u0026rdquo;); while ((ch = getchar()) != EOF) { while (getchar() != \u0026lsquo;\\n\u0026rsquo;) /* 处理输入行的剩余内容 / continue; ch = tolower(ch); if (strchr(\u0026ldquo;alrfndq\u0026rdquo;, ch) == NULL) puts(\u0026ldquo;Please enter an a, l, f, n, d, or q:\u0026rdquo;); else break; } if (ch == EOF) / 使程序退出 */ ch = \u0026lsquo;q\u0026rsquo;; return ch; }\nvoid addpet(Tree * pt) { Item temp; if (TreeIsFull(pt)) puts(\u0026ldquo;No room in the club!\u0026rdquo;); else { puts(\u0026ldquo;Please enter name of pet:\u0026rdquo;); s_gets(temp.petname, SLEN); puts(\u0026ldquo;Please enter pet kind:\u0026rdquo;); s_gets(temp.petkind, SLEN); uppercase(temp.petname); uppercase(temp.petkind); AddItem(\u0026amp;temp, pt); } } void showpets(const Tree * pt) { if (TreeIsEmpty(pt))\nputs(\u0026ldquo;No entries!\u0026rdquo;); else Traverse(pt, printitem); } void printitem(Item item) { printf(\u0026ldquo;Pet: %-19s Kind: %-19s\\n\u0026rdquo;, item.petname,item.petkind); } void findpet(const Tree * pt) { Item temp; if (TreeIsEmpty(pt)) { puts(\u0026ldquo;No entries!\u0026rdquo;); return; /* 如果树为空，则退出该函数 */ } puts(\u0026ldquo;Please enter name of pet you wish to find:\u0026rdquo;); s_gets(temp.petname, SLEN); puts(\u0026ldquo;Please enter pet kind:\u0026rdquo;);\ns_gets(temp.petkind, SLEN); uppercase(temp.petname); uppercase(temp.petkind); printf(\u0026quot;%s the %s \u0026ldquo;, temp.petname, temp.petkind); if (InTree(\u0026amp;temp, pt)) printf(\u0026ldquo;is a member.\\n\u0026rdquo;); else printf(\u0026ldquo;is not a member.\\n\u0026rdquo;); } void droppet(Tree * pt) { Item temp; if (TreeIsEmpty(pt)) { puts(\u0026ldquo;No entries!\u0026rdquo;); return; /* 如果树为空，则退出该函数 */ } puts(\u0026ldquo;Please enter name of pet you wish to delete:\u0026rdquo;); s_gets(temp.petname, SLEN);\nputs(\u0026ldquo;Please enter pet kind:\u0026rdquo;); s_gets(temp.petkind, SLEN); uppercase(temp.petname); uppercase(temp.petkind); printf(\u0026quot;%s the %s \u0026ldquo;, temp.petname, temp.petkind); if (DeleteItem(\u0026amp;temp, pt)) printf(\u0026ldquo;is dropped from the club.\\n\u0026rdquo;); else printf(\u0026ldquo;is not a member.\\n\u0026rdquo;); } void uppercase(char * str) { while (*str) { *str = toupper(*str); str++; } } char * s_gets(char * st, int n)\n{ # char * ret_val; char * find; ret_val = fgets(st, n, stdin); if (ret_val) { find = strchr(st, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是 NULL， *find = \u0026lsquo;\\0\u0026rsquo;; // 在此处放置一个空字符 else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; // 处理输入行的剩余内容 } return ret_val; } 该程序把所有字母都转换为大写字母，所以SNUFFY、Snuffy和snuffy都 被视为相同。下面是该程序的一个运行示例： Nerfville Pet Club Membership Program Enter the letter corresponding to your choice:\na) add a pet l) show list of pets n) number of pets f) find pets q) quit a Please enter name of pet: Quincy Please enter pet kind: pig Nerfville Pet Club Membership Program Enter the letter corresponding to your choice: a) add a pet l) show list of pets n) number of pets f) find pets q) quit a Please enter name of pet: Bennie Haha Please enter pet kind: parrot Nerfville Pet Club Membership Program\nEnter the letter corresponding to your choice: a) add a pet l) show list of pets n) number of pets f) find pets q) quit a Please enter name of pet: Hiram Jinx Please enter pet kind: domestic cat Nerfville Pet Club Membership Program Enter the letter corresponding to your choice: a) add a pet l) show list of pets n) number of pets f) find pets q) quit n 3　pets in club Nerfville Pet Club Membership Program Enter the letter corresponding to your choice: a) add a pet l) show list of pets\nn) number of pets f) find pets q) quit l Pet: BENNIE HAHA Kind: PARROT Pet: HIRAM JINX Kind: DOMESTIC CAT Pet: QUINCY Kind: PIG Nerfville Pet Club Membership Program Enter the letter corresponding to your choice: a) add a pet l) show list of pets n) number of pets f) find pets q) quit q Bye. 17.7.5 树的思想 # 二叉查找树也有一些缺陷。例如，二叉查找树只有在满员（或平衡）时 # 效率最高。假设要储存用户随机输入的单词。该树的外观应如图17.12所 # 示。现在，假设用户按字母顺序输入数据，那么每个新节点应该被添加到右 # 边，该树的外观应如图17.16所示。图17.12所示是平衡的树，图17.16所示是 # 不平衡的树。查找这种树并不比查找链表要快。 # 避免串状树的方法之一是在创建树时多加注意。如果树或子树的一边或 # 另一边太不平衡，就需要重新排列节点使之恢复平衡。与此类似，可能在进 # 行删除操作后要重新排列树。俄国数学家Adel’son-Vel’skii和Landis发明了一 种算法来解决这个问题。根据他们的算法创建的树称为AVL树。因为要重 构，所以创建一个平衡的树所花费的时间更多，但是这样的树可以确保最大 化搜索效率。 你可能需要一个能储存相同项的二叉查找树。例如，在分析一些文本 时，统计某个单词在文本中出现的次数。一种方法是把 Item 定义成包含一 个单词和一个数字的结构。第一次遇到一个单词时，将其添加到树中，并且 该单词的数量加 1 。下一次遇到同样的单词时，程序找到包含该单词的节 点，并递增表示该单词数量的值。把基本二叉查找树修改成具有这一特性， 不费多少工夫。 考虑Nerfville宠物俱乐部的示例，有另一种情况。示例中的树根据宠物 的名字和种类进行排列，所以，可以把名为Sam的猫储存在一个节点中，把 名为Sam的狗储存在另一节点中，把名为Sam的山羊储存在第 3 个节点中。但 是，不能储存两只名为Sam的猫。另一种方法是以名字来排序，但是这样做 只能储存一个名为Sam的宠物。还需要把Item定义成多个结构，而不是一个 结构。第一次出现Sally时，程序创建一个新的节点，并创建一个新的列 表，然后把Sally及其种类添加到列表中。下一次出现Sally时，程序将定位 到之前储存Sally的节点，并把新的数据添加到结构列表中。 提示 插件库 读者可能意识到实现一个像链表或树这样的ADT比较困难，很容易犯 错。插件库提供了一种可选的方法：让其他人来完成这些工作和测试。在学 完本章这两个相对简单的例子后，读者应该能很好地理解和认识这样的库。\n图17.16 不平衡的二叉查找树\n17.8 其他说明 # 本书中，我们涵盖了C语言的基本特性，但是只是简要介绍了库。ANSI # C库中包含多种有用的函数。绝大部分实现都针对特定的系统提供扩展库。 # 基于Windows的编译器支持Windows图形接口。Macintosh C编译器提供访问 Macintosh 工具箱的函数，以便编写具有标准 Macintosh 接口或 iOS 系统的程 序产品，如iPhone或iPad。与此类似，还有一些工具用于创建Linux程序的图 形接口。花时间查看你的系统提供什么。如果没有你想要的工具，就自己编 写函数。这是C的一部分。如果认为自己能编写一个更好的（如，输入函 数），那就去做！随着你不断练习并提高自己的编程技术，会从一名新手成 为经验丰富的资深程序员。 如果对链表、队列和树的相关概念感兴趣或觉得很有用，可以阅读其他 相关的书籍，学习高级编程技巧。计算机科学家在开发和分析算法以及如何 表示数据方面投入了大量的时间和精力。也许你会发现已经有人开发了你正 需要的工具。 学会C语言后，你可能想研究C++、Objectiv C或Java。这些都是以C为 基础的面向对象（object-oriented）语言。C已经涵盖了从简单的char类型变 量到大型且复杂的结构在内的数据对象。面向对象语言更进一步发展了对象 的观点。例如，对象的性质不仅包括它所储存的信息类型，而且还包括了对 其进行的操作类型。本章介绍的ADT就遵循了这种模式。而且，对象可以继 承其他对象的属性。OOP提供比C更高级的抽象，很适合编写大型程序。 请参阅附录B中的参考资料I“补充阅读”中找到你感兴趣的书籍。\n17.9 关键概念 # 一种数据类型通过以下几点来表征：如何构建数据、如何储存数据、有 # 哪些可能的操作。抽象数据类型（ADT）以抽象的方式指定构成某种类型特 # 征的属性和操作。从概念上看，可以分两步把ADT翻译成一种特定的编程语 # 言。第 1 步是定义编程接口。在C中，通过使用头文件定义类型名，并提供 # 与允许的操作相应的函数原型来实现。第 2 步是实现接口。在C中，可以用 # 源代码文件提供与函数原型相应的函数定义来实现。 # 17.10 本章小结 # 链表、队列和二叉树是ADT在计算机程序设计中常用的示例。通常用动 # 态内存分配和链式结构来实现它们，但有时用数组来实现会更好。 # 当使用一种特定类型（如队列或树）进行编程时，要根据类型接口来编 # 写程序。这样，在修改或改进实现时就不用更改使用接口的那些程序。 # 17.11 复习题 # 1.定义一种数据类型涉及哪些内容？ # 2.为什么程序清单17.2 只能沿一个方向遍历链表？如何修改struct film定 义才能沿两个方向遍历链表？ 3.什么是ADT？ 4.QueueIsEmpty()函数接受一个指向queue结构的指针作为参数，但是也 可以将其编写成接受一个queue结构作为参数。这两种方式各有什么优缺 点？ 5.栈（stack）是链表系列的另一种数据形式。在栈中，只能在链表的一 端添加和删除项，项被“压入”栈和“弹出”栈。因此，栈是一种LIFO（即后进 先出last in,first out）结构。 a.设计一个栈ADT b.为栈设计一个C编程接口，例如stack.h头文件 6.在一个含有 3 个项的分类列表中，判断一个特定项是否在该列表中， 用顺序查找和二叉查找方法分别需要最多多少次？当列表中有 1023 个项时分 别是多少次？ 65535 个项是分别是多少次？ 7.假设一个程序用本章介绍的算法构造了一个储存单词的二叉查找树。 假设根据下面所列的顺序输入 单词，请画出每种情况的树： a.nice food roam dodge gate office wave b.wave roam office nice gate food dodge c.food dodge roam wave office gate nice\nd.nice roam office food wave gate dodge 8.考虑复习题 7 构造的二叉树，根据本章的算法，删除单词food之后， 各树是什么样子？\n17.12 编程练习 # 1.修改程序清单17.2，让该程序既能正序也能逆序显示电影列表。一种 # 方法是修改链表的定义，可以双向遍历链表。另一种方法是用递归。 # 2.假设list.h（程序清单17.3）使用下面的list定义： typedef struct list { Node * head; /* 指向list的开头 / Node * end;/ 指向list的末尾 / } List; 重写 list.c（程序清单 17.5）中的函数以适应新的定义，并通过 films.c（程序清单 17.4）测试最终的代码。 3.假设list.h（程序清单17.3）使用下面的list定义： #define MAXSIZE 100 typedef struct list { Item entries[MAXSIZE]; / 内含项的数组 / int items; / list中的项数 */ } List; 重写 list.c（程序清单 17.5）中的函数以适应新的定义，并通过 films.c（程序清单 17.4）测试最终的代码。\n4.重写mall.c（程序清单17.7），用两个队列模拟两个摊位。 5.编写一个程序，提示用户输入一个字符串。然后该程序把该字符串的 字符逐个压入一个栈（参见复习题 5 ），然后从栈中弹出这些字符，并显示 它们。结果显示为该字符串的逆序。 6.编写一个函数接受 3 个参数：一个数组名（内含已排序的整数）、该 数组的元素个数和待查找的整数。如果待查找的整数在数组中，那么该函数 返回 1 ；如果该数不在数组中，该函数则返回 0 。用二分查找法实现。 7.编写一个程序，打开和读取一个文本文件，并统计文件中每个单词出 现的次数。用改进的二叉查找树储存单词及其出现的次数。程序在读入文件 后，会提供一个有 3 个选项的菜单。第 1 个选项是列出所有的单词和出现的次 数。第 2 个选项是让用户输入一个单词，程序报告该单词在文件中出现的次 数。第 3 个选项是退出。 8.修改宠物俱乐部程序，把所有同名的宠物都储存在同一个节点中。当 用户选择查找宠物时，程序应询问用户该宠物的名字，然后列出该名字的所 有宠物（及其种类）。\n附录 A 复习题答案 # A.1 第 1 章复习题答案 # 1.完美的可移植程序是，其源代码无需修改就能在不同计算机系统中成 # 功编译的程序。 # 2.源代码文件包含程序员使用的任何编程语言编写的代码。目标代码文 # 件包含机器语言代码，它不必是完整的程序代码。可执行文件包含组成可执 # 行程序的完整机器语言代码。 # 3.（ 1 ）定义程序目标；（ 2 ）设计程序；（ 3 ）编写程序；（ 4 ）编译程 # 序；（ 5 ）运行程序；（ 6 ）测试和调试程序；（ 7 ）维护和修改程序。 # 4.编译器把源代码（如，用C语言编写的代码）翻译成等价的机器语言 # 代码（也叫作目标代码）。 # 5.链接器把编译器翻译好的源代码以及库代码和启动代码组合起来，生 # 成一个可执行程序。 # A.2 第 2 章复习题答案 # 1.它们都叫作函数。 # 2.语法错误违反了组成语句或程序的规则。这是一个有语法错误的英文 # 例子：Me speak English good.。这是一个有语法错误的C语言例子： printf\u0026quot;Where are the parentheses?\u0026quot;;。 3.语义错误是指含义错误。这是一个有语义错误的英文例子：This sentence isexcellent Czech.[1]。这是一个有语义错误的C语言例子： thrice_n = 3 + n;[2]。 4.第 1 行：以一个#开始；studio.h应改成stdio.h；然后用一对尖括号把\nstdio.h括起来。 第 2 行：把{}改成()；注释末尾把/改成/。 第 3 行：把(改成｛ 第 4 行：int s末尾加上一个分号。 第 5 行没问题。 第 6 行：把:=改成，赋值用=，而不是用:=（这说明Indiana Sloth了解 Pascal）。另外，用于赋值的值 56 也不对，一年有 52 周，不是 56 周。 第 7 行应该是：printf(\u0026ldquo;There are %d weeks in a year.\\n\u0026rdquo;, s); 第 9 行：原程序中没有第 9 行，应该在该行加上一个右花括号｝。 修改后的程序如下： #include \u0026lt;stdio.h\u0026gt; int main(void) /* this prints the number of weeks in a year */ { int s; s = 52; printf(\u0026ldquo;There are %d weeks in a year.\\n\u0026rdquo;, s); return 0; } 5.a.Baa Baa Black Sheep.Have you any wool?（注意，Sheep.和Have之间 没有空格）\nb.Begone! O creature of lard! c.What? No/nfish? （注意斜杠/和反斜杠\\的效果不同，/只是一个普通的字符，原样打印） d.2 + 2 = 4 （注意，每个%d与列表中的值相对应。还要注意，+的意思是加法，可 以在printf()语句内部计算） 6.关键字是int和char（main是一个函数名；function是函数的意思；=是 一个运算符）。 7.printf(\u0026ldquo;There were %d words and %d lines.\\n\u0026rdquo;, words, lines); 8.执行完第 7 行后，a是 5 ，b是 2 。执行完第 8 行后，a和b都是 5 。执行完 第 9 行后，a和b仍然是 5 （注意，a不会是 2 ，因为在执行a = b;时，b的值已经 被改为 5 ）。 9.执行完第 7 行后，x是 10 ，b是 5 。执行完第 8 行后，x是 10 ，y是 15 。执 行完第 9 行后，x是 150 ，y是 15 。 A.3 第 3 章复习题答案 1.a.int类型，也可以是short类型或unsigned short类型。人口数是一个整 数。 b.float类型，价格通常不是一个整数（也可以使用double类型，但实际 上不需要那么高的精度）。 c.char类型。\nd.int类型，也可以是unsigned类型。 2.原因之一：在系统中要表示的数超过了int可表示的范围，这时要使用 long类型。原因之二：如果要处理更大的值，那么使用一种在所有系统上都 保证至少是 32 位的类型，可提高程序的可移植性。 3.如果要正好获得 32 位的整数，可以使用int32_t类型。要获得可储存至 少 32 位整数的最小类型，可以使用int_least32_t类型。如果要为 32 位整数提 供最快的计算速度，可以选择int_fast32_t类型（假设你的系统已定义了上述 类型）。 4.a.char类型常量（但是储存为int类型） b.int类型常量 c.double类型常量 d.unsigned int类型常量，十六进制格式 e.double类型常量 5.第 1 行：应该是#include \u0026lt;stdio.h\u0026gt; 第 2 行：应该是int main(void) 第 3 行：把(改为｛ 第 4 行：g和h之间的;改成, 第 5 行：没问题 第 6 行：没问题 第 7 行：虽然这数字比较大，但在e前面应至少有一个数字，如1e21或 1.0e21都可以。\n第 8 行：没问题，至少没有语法问题。 # 第 9 行：把)改成} # 除此之外，还缺少一些内容。首先，没有给rate变量赋值；其次未使用h 变量；而且程序不会报告计算结果。虽然这些错误不会影响程序的运行（编 译器可能给出变量未被使用的警告），但是它们确实与程序设计的初衷不符 合。另外，在该程序的末尾应该有一个return语句。 下面是一个正确的版本，仅供参考： #include \u0026lt;stdio.h\u0026gt; int main(void) { float g, h; float tax, rate; rate = 0.08; g = 1.0e5; tax = rate*g; h = g + tax; printf(\u0026ldquo;You owe $%f plus $%f in taxes for a total of $%f.\\n\u0026rdquo;, g, tax, h); return 0; } 6.\n7. # 8.printf(\u0026ldquo;The odds against the %d were %ld to 1.\\n\u0026rdquo;, imate, shot);printf(\u0026ldquo;A score of %f is not an %c grade.\\n\u0026rdquo;, log, grade); 9.ch = \u0026lsquo;\\r\u0026rsquo;; ch = 13; ch = \u0026lsquo;\\015\u0026rsquo; ch = \u0026lsquo;\\xd\u0026rsquo; 10.最前面缺少一行（第 0 行）：#include \u0026lt;stdio.h\u0026gt; 第 1 行：使用/和/把注释括起来，或者在注释前面使用//。 第 3 行：int cows, legs; 第 4 行：country？\\n\u0026rdquo;);\n第 5 行：把%c改为%d，把legs改为\u0026amp;legs。 第 7 行：把%f改为%d。 另外，在程序末尾还要加上return语句。 下面是修改后的版本： #include \u0026lt;stdio.h\u0026gt; int main(void) /* this program is perfect */ { int cows, legs; printf(\u0026ldquo;How many cow legs did you count?\\n\u0026rdquo;); scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;legs); cows = legs / 4; printf(\u0026ldquo;That implies there are %d cows.\\n\u0026rdquo;, cows); return 0; } 11.a.换行字符 b.反斜杠字符 c.双引号字符 d.制表字符 A.4 第 4 章复习题答案\n1.程序不能正常运行。第 1 个scanf()语句只读取用户输入的名，而用户 输入的姓仍留在输入缓冲区中（缓冲区是用于储存输入的临时存储区）。下 一条scang()语句在输入缓冲区查找重量时，从上次读入结束的地方开始读 取。这样就把留在缓冲区的姓作为体重来读取，导致 scanf()读取失败。另一 方面，如果在要求输入姓名时输入Lasha 144，那么程序会把 144 作为用户的 体重（虽然用户是在程序提示输入体重之前输入了 144 ）。 2.a.He sold the painting for $234.50. b.Hi!（注意，第 1 个字符是字符常量；第 2 个字符由十进制整数转换而 来；第 3 个字符是八进制字符常量的ASCII表示） c.His Hamlet was funny without being vulgar.has 42 characters. d.Is 1.20e+003 the same as 1201.00? 3.在这条语句中使用\u0026quot;：printf(\u0026quot;\u0026quot;%s\u0026quot;\\nhas %d characters.\\n\u0026quot;, Q, strlen(Q)); 4.下面是修改后的程序： #include \u0026lt;stdio.h\u0026gt; /* 别忘了要包含合适的头文件 / #define B \u0026ldquo;booboo\u0026rdquo; / 添加#、双引号 / #define X 10 / 添加# / int main(void) / 不是main(int) / { int age; int xp; / 声明所有的变量 / char name[40]; / 把name声明为数组 */\nprintf(\u0026ldquo;Please enter your first name.\\n\u0026rdquo;); /* 添加\\n，提高可读性 / scanf(\u0026quot;%s\u0026quot;, name); printf(\u0026ldquo;All right, %s, what\u0026rsquo;s your age?\\n\u0026rdquo;, name); / %s用于打印字符串*/ scanf(\u0026quot;%d\u0026quot;, \u0026amp;age); /* 把%f改成%d，把age改成\u0026amp;age / xp = age + X; printf(\u0026ldquo;That\u0026rsquo;s a %s! You must be at least %d.\\n\u0026rdquo;, B, xp); return 0; / 不是rerun */ } 5.记住，要打印%必须用%%： printf(\u0026ldquo;This copy of \u0026quot;%s\u0026quot; sells for $%0.2f.\\n\u0026rdquo;, BOOK, cost); printf(\u0026ldquo;That is %0.0f%% of list.\\n\u0026rdquo;, percent); 6.a.%d b.%4X c.%10.3f d.%12.2e e.%-30s 7.a.%15lu b.%#4x c.%-12.2E\nd.%+10.3f e.%8.8s 8.a.%6.4d b.%*o c.%2c d.%+0.2f e.%-7.5s 9.a.int dalmations; scanf(\u0026quot;%d\u0026quot;, \u0026amp;dalmations); b.float kgs, share; scanf(\u0026quot;%f%f\u0026quot;, \u0026amp;kgs, \u0026amp;share); （注意：对于本题的输入，可以使用转换字符e、f和g。另外，除了%c 之外，在%和转换字符之间加空格不会影响最终的结果） c.char pasta[20]; scanf(\u0026quot;%s\u0026quot;, pasta); d.char action[20]; int value; scanf(\u0026quot;%s %d\u0026quot;, action, \u0026amp;value); e.int value;\nscanf(\u0026quot;%*s %d\u0026quot;, \u0026amp;value); 10.空白包括空格、制表符和换行符。C 语言使用空白分隔记号。scanf() 使用空白分隔连续的输入项。 11.%z 中的 z 是修饰符，不是转换字符，所以要在修饰符后面加上一个 它修饰的转换字符。可以使用%zd打印十进制数，或用不同的说明符打印不 同进制的数，例如，%zx打印十六进制的数。 12.可以分别把(和)替换成{和}。但是预处理器无法区分哪些圆括号应替 换成花括号，哪些圆括号不能替换成花括号。因此， #define ( { #define ) } int main(void) ( printf(\u0026ldquo;Hello, O Great One!\\n\u0026rdquo;); ) 将变成： int main{void} { printf{\u0026ldquo;Hello, O Great One!\\n\u0026rdquo;}; } A.5 第 5 章复习题答案\n1.a.30 b.27（不是 3 ）。(12+6)/(2*3)得 3 。 c.x = 1，y = 1（整数除法）。 d.x = 3（整数除法），y = 9。 2.a.6（由3 + 3.3截断而来） b.52 c.0（0 * 22.0的结果） d.13（66.0 / 5或13.2，然后把结果赋给int类型变量） 3.a.37.5（7.5 * 5.0的结果） b.1.5（30.0 / 20.0的结果） c.35（7 * 5的结果） d.37（150 / 4的结果） e.37.5（7.5 * 5的结果） f.35.0（7 * 5.0的结果） 4.第 0 行：应增加一行#include \u0026lt;stdio.h\u0026gt;。 第 3 行：末尾用分号，而不是逗号。 第 6 行：while语句创建了一个无限循环。因为i的值始终为 1 ，所以它总 是小于 30 。推测一下，应该是想写while(i++ \u0026lt; 30)。 第 6 ～ 8 行：这样的缩进布局不能使第 7 行和第 8 行组成一个代码块。由于 没有用花括号括起来， while循环只包括第 7 行，所以要添加花括号。\n第 7 行：因为 1 和i都是整数，所以当i为 1 时，除法的结果是 1 ；当i为更大 的数时，除法结果为 0 。用n = 1.0/i，i在除法运算之前会被转换为浮点数， 这样就能得到非零值。 第 8 行：在格式化字符串中没有换行符（\\n），这导致数字被打印成一 行。 第 10 行：应该是return 0; 下面是正确的版本： #include \u0026lt;stdio.h\u0026gt; int main(void) { int i = 1; float n; printf(\u0026ldquo;Watch out! Here come a bunch of fractions!\\n\u0026rdquo;); while (i++ \u0026lt; 30) { n = 1.0/i; printf(\u0026quot; %f\\n\u0026quot;, n); } printf(\u0026ldquo;That\u0026rsquo;s all, folks!\\n\u0026rdquo;); return 0;\n} # 5.这个版本最大的问题是测试条件（sec是否大于 0 ？）和scanf()语句获 取sec变量的值之间的关系。具体地说，第一次测试时，程序尚未获得sec的 值，用来与 0 作比较的是正好在sec变量内存位置上的一个垃圾值。一个比较 笨拙的方法是初始化 sec（如，初始化为 1 ）。这样就可通过第一次测试。 不过，还有另一个问题。当最后输入 0 结束程序时，在循环结束之前不会检 查sec，所以 0 也被打印了出来。因此，更好的方法是在while测试之前使用 scanf()语句。可以这样修改： scanf(\u0026quot;%d\u0026quot;, \u0026amp;sec); while ( sec \u0026gt; 0 ) { min = sec/S_TO_M; left = sec % S_TO_M; printf(\u0026quot;%d sec is %d min, %d sec.\\n\u0026quot;, sec, min, left); printf(\u0026ldquo;Next input?\\n\u0026rdquo;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;sec); } while循环第一轮迭代使用的是scanf()在循环外面获取的值。因此，在 while循环的末尾还要使用一次scanf()语句。这是处理类似问题的常用方法。 6.下面是该程序的输出： %s! C is cool! ! C is cool! 11\n11 # 12 # 11 # 解释一下。第 1 个printf()语句与下面的语句相同： printf(\u0026quot;%s! C is cool!\\n\u0026quot;,\u0026quot;%s! C is cool!\\n\u0026quot;); 第 2 个printf()语句首先把num递增为 11 ，然后打印该值。第 3 个printf()语 句打印num的值（值为 11 ）。第 4 个printf()语句打印n当前的值（仍为 12 ）， 然后将其递减为 11 。最后一个printf()语句打印num的当前值（值为 11 ）。 7.下面是该程序的输出： SOS:4 4.00 表达式c1 -c2的值和\u0026rsquo;S\u0026rsquo; - \u0026lsquo;0\u0026rsquo;的值相同（其对应的ASCII值是83 - 79）。 8.把 1 ～ 10 打印在一行，每个数字占 5 列宽度，然后开始新的一行： 1 2 3 4 5 6 7 8 9 10 9.下面是一个参考程序，假定字母连续编码，与ASCII中的情况一样。 #include \u0026lt;stdio.h\u0026gt; int main(void) { char ch = \u0026lsquo;a\u0026rsquo;; while (ch \u0026lt;= \u0026lsquo;g\u0026rsquo;) printf(\u0026quot;%5c\u0026quot;, ch++);\nprintf(\u0026quot;\\n\u0026quot;); return 0; } 10.下面是每个部分的输出： a.1 2 注意，先递增x的值再比较。光标仍留在同一行。 b.101 102 103 104 注意，这次x先比较后递增。在示例a和b中，x都是在先递增后打印。另 外还要注意，虽然第 2 个printf()语句缩进了，但是这并不意味着它是while循 环的一部分。因此，在while循环结束后，才会调用一次该printf()语句。 c.stuvw 该例中，在第 1 次调用printf()语句后才会递增ch。 11.这个程序有点问题。while循环没有用花括号把两个缩进的语句括起 来，只有printf()是循环的一部分，所以该程序一直重复打印消息 COMPUTER BYTES DOG，直到强行关闭程序为止。 12.a.x = x + 10; b.x++; or ++x; or x = x + 1;\nc.c = 2 * (a + b); d.c = a + 2* b; 13 a.x\u0026ndash;; or \u0026ndash;x; or x = x - 1; b.m = n % k; c.p = q / (b - a); d.x = (a + b) / (c * d); A.6 第 6 章复习题答案 1.2， 7 ， 70 ， 64 ， 8 ， 2 。 2.该循环的输出是： 36 18 9 4 2 1 如果value是double类型，即使value小于 1 ，循环的测试条件仍然为真。 循环将一直执行，直到浮点数下溢生成 0 为止。另外，value是double类型 时，%3d转换说明也不正确。 3.a.x \u0026gt; 5 b.scanf(\u0026quot;%lf\u0026quot;,\u0026amp;x) != 1 c.x == 5 4.a.scanf(\u0026quot;%d\u0026quot;, \u0026amp;x) == 1 b.x != 5 c.x \u0026gt;= 20 5.第 4 行：应该是list[10]。\n第 6 行：逗号改为分号。i的范围应该是 0 ～ 9 ，不是 1 ～ 10 。 第 9 行：逗号改为分号。\u0026gt;=改成\u0026lt;=，否则，当i等于 1 时，该循环将成为 无限循环。 第 10 行：在第 10 行和第 11 行之间少了一个右花括号。该右花括号与第 7 行的左花括号配对，形成一个for循环块。然后在这个右花括号与最后一个 右花括号之间，少了一行return 0;。 下面是一个正确的版本： #include \u0026lt;stdio.h\u0026gt; int main(void) { /* 第 3 行 / int i, j, list(10); / 第 4 行 / for (i = 1, i \u0026lt;= 10, i++) / 第 6 行 / { / 第 7 行 / list[i] = 2i + 3; /* 第 8 行 / for (j = 1, j \u0026gt; = i, j++) / 第 9 行 / printf(\u0026quot; %d\u0026quot;, list[j]); / 第 10 行 / printf(\u0026quot;\\n\u0026quot;); / 第 11 行 */ ｝ return 0; }\n6.下面是一种方法： # #include \u0026lt;stdio.h\u0026gt; int main(void) { int col, row; for (row = 1; row \u0026lt;= 4; row++) { for (col = 1; col \u0026lt;= 8; col++) printf(\u0026quot;$\u0026quot;); printf(\u0026quot;\\n\u0026quot;); } return 0; } 7.a.Hi! Hi! Hi! Bye! Bye! Bye! Bye! Bye! b.ACGM（因为代码中把int类型值与char类型值相加，编译器可能警告 会损失有效数字） 8.a.Go west, youn b.Hp!xftu-!zpvo c.Go west, young\nd.$o west, youn 9.其输入如下： 31|32|33|30|31|32|33|\n1 5 9 13\n2 6 4 8 8 10\n====== # ==== # == 10.a.mint\nb.10个元素 c.double 类型的值 d.第ii行正确，mint[2]是double类型的值，\u0026amp;mingt[2]是它在内存中的位 置。 11.因为第 1 个元素的索引是 0 ，所以循环的范围应该是 0 ～SIZE - 1，而 不是 1 ～SIZE。但是，如果只是这样更改会导致赋给第 1 个元素的值是 0 ，不 是 2 。所以，应重写这个循环： for (index = 0; index \u0026lt; SIZE; index++) by_twos[index] = 2 * (index + 1); 与此类似，第 2 个循环的范围也要更改。另外，应该在数组名后面使用 数组索引： for( index = 0; index \u0026lt; SIZE; index++) printf(\u0026quot;%d \u0026ldquo;, by_twos[index]); 错误的循环条件会成为程序的定时炸弹。程序可能开始运行良好，但是 由于数据被放在错误的位置，可能在某一时刻导致程序不能正常工作。 12.该函数应声明为返回类型为long，并包含一个返回long类型值的return 语句。 13.把num的类型强制转换成long类型，确保计算使用long类型而不是int 类型。在int为 16 位的系统中，两个int类型值的乘积在返回之前会被截断为一 个int类型的值，这可能会丢失数据。 long square(int num) {\nreturn ((long) num) * num; } 14.输出如下： 1: Hi! k = 1 k is 1 in the loop Now k is 3 k = 3 k is 3 in the loop Now k is 5 k = 5 k is 5 in the loop Now k is 7 k = 7 A.7 第 7 章复习题答案 1.b是true。 2.a.number \u0026gt;= 90 \u0026amp;\u0026amp; number \u0026lt; 100 b.ch != \u0026lsquo;q\u0026rsquo; \u0026amp;\u0026amp; ch != \u0026lsquo;k\u0026rsquo; c.(number \u0026gt;= 1 \u0026amp;\u0026amp; number \u0026lt;= 9) \u0026amp;\u0026amp; number != 5\nd.可以写成!(number \u0026gt;= 1 \u0026amp;\u0026amp; number \u0026lt;= 9)，但是number \u0026lt; 1 || number \u0026gt; 9 更好理解。 3.第 5 行：应该是scanf(\u0026quot;%d %d\u0026rdquo;, \u0026amp;weight, \u0026amp;height);。不要忘记scanf()中 要用\u0026amp;。另外，这一行前面应该有提示用户输入的语句。 第 9 行：测试条件中要表达的意思是(height \u0026lt; 72 \u0026amp;\u0026amp; height \u0026gt; 64)。根据前 面第 7 行中的测试条件，能到第 9 行的height一定小于 72 ，所以，只需要用表 达式(height \u0026gt; 64)即可。但是，第 6 行中已经包含了height \u0026gt; 64这个条件，所以 这里完全不必再判断，if else应改成else。 第 11 行：条件冗余。第 2 个表达式（weight不小于或不等于 300 ）和第 1 个表达式含义相同。只需用一个简单的表达式(weight \u0026gt; 300)即可。但是，问 题不止于此。第 11 行是一个错误的if，这行的else if与第 6 行的if匹配。但 是，根据if的“最接近规则”，该else if应该与第 9 行的else if匹配。因此，在 weight小于 100 且小于或等于 64 时到达第 11 行，而此时weight不可能超过 300 。 第 7 行～第 10 行：应该用花括号括起来。这样第 11 行就确定与第 6 行匹 配。但是，如果把第 9 行的else if替换成简单的else，就不需要使用花括号。 第 13 行：应简化成if (height \u0026gt; 48)。实际上，完全可以省略这一行。因为 第 12 行已经测试过该条件。 下面是修改后的版本： #include \u0026lt;stdio.h\u0026gt; int main(void) { int weight, height; /* weight in lbs, height in inches */ printf(\u0026ldquo;Enter your weight in pounds and \u0026ldquo;);\nprintf(\u0026ldquo;your height in inches.\\n\u0026rdquo;); scanf(\u0026quot;%d %d\u0026rdquo;, \u0026amp;weight, \u0026amp;height); if (weight \u0026lt; 100 \u0026amp;\u0026amp; height \u0026gt; 64) if (height \u0026gt;= 72) printf(\u0026ldquo;You are very tall for your weight.\\n\u0026rdquo;); else printf(\u0026ldquo;You are tall for your weight.\\n\u0026rdquo;); else if (weight \u0026gt; 300 \u0026amp;\u0026amp; height \u0026lt; 48) printf(\u0026rdquo; You are quite short for your weight.\\n\u0026quot;); else printf(\u0026ldquo;Your weight is ideal.\\n\u0026rdquo;); return 0; } 4.a.1。 5 确实大于 2 ，表达式为真，即是 1 。 b.0。 3 比 2 大，表达式为假，即是 0 。 c.1。如果第 1 个表达式为假，则第 2 个表达式为真，反之亦然。所 以，只要一个表达式为真，整个表达式的结果即为真。 d.6。因为6 \u0026gt; 2为真，所以(6 \u0026gt; 2)的值为 1 。 e.10。因为测试条件为真。\nf.0。如果x \u0026gt; y为真，表达式的值就是y \u0026gt; x，这种情况下它为假或 0 。如 果x \u0026gt; y为假，那么表达式的值就是x \u0026gt; y，这种情况下为假。 5.该程序打印以下内容： #%#%$#%#%#%$#%#%#%$#%#%#% 无论怎样缩排，每次循环都会打印#，因为缩排并不能让putchar(\u0026rsquo;#\u0026rsquo;);成 为if else复合语句的一部分。 6.程序打印以下内容： fat hat cat Oh no! hat cat Oh no! cat Oh no! 7.第 5 行～第 7 行的注释要以*/结尾，或者把注释开头的/*换成//。表达 式\u0026rsquo;a\u0026rsquo; \u0026lt;= ch \u0026gt;= \u0026lsquo;z\u0026rsquo;应替换成ch \u0026gt;= \u0026lsquo;a\u0026rsquo; \u0026amp;\u0026amp; ch \u0026lt;= \u0026lsquo;z\u0026rsquo;。 或者，包含 ctype.h 并使用 islower()，这种方法更简单，而且可移植性 更高。顺带一提，虽然从 C 的语法方面看，\u0026lsquo;a\u0026rsquo; \u0026lt;= ch \u0026gt;= \u0026lsquo;z\u0026rsquo;是有效的表达式， 但是它的含义不明。因为关系运算符从左往右结合，该表达式被解释成(\u0026lsquo;a\u0026rsquo; \u0026lt;= ch) \u0026gt;= \u0026lsquo;z\u0026rsquo;。圆括号中的表达式的值不是 1 就是 0 （真或假），然后判断该值 是否大于或等于\u0026rsquo;z\u0026rsquo;的数值码。 1 和 0 都不满足测试条件，所以整个表达式恒为 0 （假）。在第 2 个测试表达式中，应该把||改成\u0026amp;\u0026amp;。另外，虽然!(ch\u0026lt; \u0026lsquo;A\u0026rsquo;)是 有 效的表达式，而且含义也正确，但是用ch \u0026gt;= \u0026lsquo;A\u0026rsquo;更简单。这一行的\u0026rsquo;z\u0026rsquo;后 面应该有两个圆括号。更简单的方法是使用isuupper()。在uc++;前面应该加 一行else。否则，每输入一个字符， uc 都会递增 1 。另外，在 printf()语句中 的格式化字符串应该用双引号括起来。下面是修改后的版本： #include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;ctype.h\u0026gt; int main(void) { char ch; int lc = 0; /统计小写字母/ int uc = 0; /统计大写字母/ int oc = 0; /统计其他字母/ while ((ch = getchar()) != \u0026lsquo;#\u0026rsquo;) { if (islower(ch)) lc++; else if (isupper(ch)) uc++; else oc++; } printf(\u0026quot;%d lowercase, %d uppercase, %d other\u0026quot;, lc, uc, oc); return 0; }\n8.该程序将不停重复打印下面一行： # You are 65.Here is your gold watch. 问题出在这一行：if (age = 65) 这行代码把age设置为 65 ，使得每次迭代的测试条件都为真。 9.下面是根据给定输入的运行结果： q Step 1 Step 2 Step 3 c Step 1 h Step 1 Step 3 b Step 1 Done 注意，b和#都可以结束循环。但是输入b会使得程序打印step 1，而输入 #则不会。\n10.下面是一种解决方案： # #include \u0026lt;stdio.h\u0026gt; int main(void) { char ch; while ((ch = getchar()) != \u0026lsquo;#\u0026rsquo;) { if (ch != \u0026lsquo;\\n\u0026rsquo;) { printf(\u0026ldquo;Step 1\\n\u0026rdquo;); if (ch == \u0026lsquo;b\u0026rsquo;) break; else if (ch != \u0026lsquo;c\u0026rsquo;) { if (ch != \u0026lsquo;h\u0026rsquo;) printf(\u0026ldquo;Step 2\\n\u0026rdquo;); printf(\u0026ldquo;Step 3\\n\u0026rdquo;); } }\n} # printf(\u0026ldquo;Done\\n\u0026rdquo;); return 0; } A.8 第 8 章复习题答案 1.表达式 putchar(getchar())使程序读取下一个输入字符并打印出来。 getchar()的返回值是putchar()的参数。但getchar(putchar())是无效的表达式， 因为getchar()不需要参数，而putchar()需要一个参数。 2.a.显示字符H。 b.如果系统使用ASCII，则发出一声警报。 c.把光标移至下一行的开始。 d.退后一格。 3.count essayct或者count \u0026gt;essayct \u0026lt;essay 4.都不是有效的命令。 5.EOF是由getchar()和scanf()返回的信号（一个特殊值），表明函数检测 到文件结尾。 6.a.输出是：If you qu 注意，字符I与字符i不同。还要注意，没有打印i，因为循环在检测到i 之后就退出了。 b.如果系统使用ASCII，输出是：HJacrthjacrt\nwhile的第 1 轮迭代中，为ch读取的值是H。第 1 个putchar()语句使用的ch 的值是H，打印完毕后，ch的值加 1 （现在是ch的值是I）。然后到第 2 个 putchar()语句，因为是++ch，所以先递增ch（现在ch的值是J）再打印它的 值。然后进入下一轮迭代，读取输入序列中的下一个字符（a），重复以上 步骤。需要注意的是，两个递增运算符只在ch被赋值后影响它的值，不会让 程序在输入序列中移动。 7.C的标准I/O库把不同的文件映射为统一的流来统一处理。 8.数值输入会跳过空格和换行符，但是字符输入不会。假设有下面的代 码： int score; char grade; printf(\u0026ldquo;Enter the score.\\n\u0026rdquo;); scanf(\u0026quot;%s\u0026quot;, %score); printf(\u0026ldquo;Enter the letter grade.\\n\u0026rdquo;); grade = getchar(); 如果输入分数 98 ，然后按下Enter键把分数发送给程序，其实还发送了 一个换行符。这个换行符会留在输入序列中，成为下一个读取的值 （grade）。如果在字符输入之前输入了数字，就应该在处理字符输入之前 添加删除换行符的代码。 A.9 第 9 章复习题答案 1.形式参数是定义在被调函数中的变量。实际参数是出现在函数调用中 的值，该值被赋给形式参数。可以把实际参数视为在函数调用时初始化形式 参数的值。\n2.a.void donut(int n) b.int gear(int t1, int t2) c.int guess(void) d.void stuff_it(double d, double *pd) 3.a.char n_to_char(int n) b.int digits(double x, int n) c.double * which(double * p1, double * p2) d.int random(void) 4. int sum(int a, int b) { return a + b; } 5.用double替换int即可： double sum(double a, double b) { return a + b; } 6.该函数要使用指针：\nvoid alter(int * pa, int * pb) { int temp; temp = *pa + *pb; *pb = *pa - *pb; *pa = temp; } 或者： void alter(int * pa, int * pb) { *pa += *pb; *pb = *pa - 2 * *pb; } 7.不正确。num应声明在salami()函数的参数列表中，而不是声明在函数 体中。另外，把count++改成num++。 8.下面是一种方案： int largest(int a, int b, int c) { int max = a;\nif (b \u0026gt; max) max = b; if (c \u0026gt; max) max = c; return max; } 9.下面是一个最小的程序，showmenu()和getchoice()函数分别是a和b的答 案。 #include \u0026lt;stdio.h\u0026gt; /* 声明程序中要用到的函数 */ void showmenu(void); int getchoice(int, int); int main() { int res; showmenu(); while ((res = getchoice(1, 4)) != 4) { printf(\u0026ldquo;I like choice %d.\\n\u0026rdquo;, res);\nshowmenu(); } printf(\u0026ldquo;Bye!\\n\u0026rdquo;); return 0; } void showmenu(void) { printf(\u0026ldquo;Please choose one of the following:\\n\u0026rdquo;); printf(\u0026ldquo;1) copy files 2) move files\\n\u0026rdquo;); printf(\u0026ldquo;3) remove files 4) quit\\n\u0026rdquo;); printf(\u0026ldquo;Enter the number of your choice:\\n\u0026rdquo;); } int getchoice(int low, int high) { int ans; int good; good = scanf(\u0026quot;%d\u0026quot;, \u0026amp;ans); while (good == 1 \u0026amp;\u0026amp; (ans \u0026lt; low || ans \u0026gt; high)) {\nprintf(\u0026quot;%d is not a valid choice; try again\\n\u0026quot;, ans); showmenu(); scanf(\u0026quot;%d\u0026quot;, \u0026amp;ans); } if (good != 1) { printf(\u0026ldquo;Non-numeric input.\u0026rdquo;); ans = 4; } return ans; } A.10 第 10 章复习题答案 1.打印的内容如下： 8 8 4 4 0 0 2 2 2.数组ref有 4 个元素，因为初始化列表中的值是 4 个。 3.数组名ref指向该数组的首元素（整数 8 ）。表达式ref + 1指向该数组的\n第 2 个元素（整数 4 ）。++ref不是有效的表达式，因为ref是一个常量，不是 变量。 4.ptr指向第 1 个元素，ptr + 2指向第 3 个元素（即第 2 行的第 1 个元素）。 a.12和 16 。 b.12和 14 （初始化列表中，用花括号把 12 括起来，把 14 和 16 括起来，所 以 12 初始化第 1 行的第 1 个元素，而 14 初始化第 2 行的第 1 个元素）。 5.ptr指向第 1 行，ptr + 1指向第 2 行。ptr指向第 1 行的第 1 个元素，而(ptr\n1)指向第 2 行的第 1 个元素。 a.12和 16 。 b.12和 14 （同第 4 题， 12 初始化第 1 行的第 1 个元素，而 14 初始化第 2 行的 第 1 个元素）。 6.a.\u0026amp;grid[22][56] b.\u0026amp;grid[22][0]或grid[22] （grid[22]是一个内含 100 个元素的一维数组，因此它就是首元素 grid[22][0]的地址。） c.\u0026amp;grid[0][0]或grid[0]或(int *) grid （grid[0]是int类型元素grid[0][0]的地址，grid是内含 100 个元素的grid[0] 数组的地址。 这两个地址的数值相同，但是类型不同，可以用强制类型转换把它们转 换成相同的类型。） 7.a.int digits[10]; b.float rates[6]; c.int mat[3][5]; d.char * psa[20] ; 注意，[]比的优先级高，所以在没有圆括号的情况下，psa先与[20]结 合，然后再与结合。因此该声明与char *(psa[20]);相同。 e.char (*pstr)[20]; 注意 对第e小题而言，char *pstr[20];不正确。这会让pstr成为一个指针数组， 而不是一个指向数组的指针。具体地说，如果使用该声明，pstr就指向一个 char类型的值（即数组的第 1 个成员），而pstr + 1则指向下一个字节。使用 正确的声明，pstr是一个变量，而不是一个数组名。而且pstr+ 1指向起始字 节后面的第 20 个字节。 8.a.int sextet[6] = {1, 2, 4, 8, 16, 32}; b.sextet[2] c.int lots[100] = { [99] = -1}; d.int pots[100] = { [5] = 101, [10] = 101,101, 101, 101}; 9.0～ 9 10.a.rootbeer[2] = value;有效。 b.scanf(\u0026quot;%f\u0026quot;, \u0026amp;rootbeer );无效，rootbeer不是float类型。 c.rootbeer = value;无效，rootbeer不是float类型。 d.printf(\u0026quot;%f\u0026quot;, rootbeer);无效，rootbeer不是float类型。 e.things[4][4] = rootbeer[3];有效。\nf.things[5] = rootbeer;无效，不能用数组赋值。 g.pf = value;无效，value不是地址。 h.pf = rootbeer;有效。 11.int screen[800][600] ; 12.a. void process(double ar[], int n); void processvla(int n, double ar[n]); process(trots, 20); processvla(20, trots); b. void process2(short ar2[30], int n); void process2vla(int n, int m, short ar2[n][m]); process2(clops, 10); process2vla(10, 30, clops); c. void process3(long ar3[10][15], int n); void process3vla(int n, int m,int k, long ar3[n][m][k]); process3(shots, 5); process3vla(5, 10, 15, shots);\n13.a. show( (int [4]) {8,3,9,2}, 4); b. show2( (int [][3]){{8,3,9}, {5,4,1}}, 2); A.11 第 11 章复习题答案 1.如果希望得到一个字符串，初始化列表中应包含\u0026rsquo;\\0\u0026rsquo;。当然，也可以用 另一种语法自动添加空字符： char name[] = \u0026ldquo;Fess\u0026rdquo;; 2. See you at the snack bar. ee you at the snack bar. See you e you 3. y my mmy ummy Yummy\n4.I read part of it all the way through. 5.a.Ho Ho Ho!!oH oH oH b.指向char的指针（即，char ）。 c.第 1 个H的地址。 d.\u0026ndash;pc的意思是把指针递减 1 ，并使用储存在该位置上的值。\u0026ndash;*pc的意 思是解引用pc指向的值，然后把该值减 1 （例如，H变成G）。 e.Ho Ho Ho!!oH oH o 注意 在两个！之间有一个空字符，但是通常该字符不会产生任何打印的效 果。 f.while (*pc)检查 pc 是否指向一个空字符（即，是否指向字符串的末 尾）。while 的测试条件中使用储存在指针指向位置上的值。 while (pc - str)检查pc是否与str指向相同的位置（即，字符串的开头）。 while的测试条件中使用储存在指针指向位置上的值。 g.进入第 1 个while循环后，pc指向空字符。进入第 2 个while循环后，它 指向空字符前面的存储区（即，str 所指向位置前面的位置）。把该字节解 释成一个字符，并打印这个字符。然后指针退回到前面的字节处。永远都不 会满足结束条件(pc == str)，所以这个过程会一直持续下去。 h.必须在主调程序中声明pr()：char * pr(char *); 6.字符变量占用一个字节，所以sign占 1 字节。但是字符常量储存为int类 型，意思是\u0026rsquo;$\u0026lsquo;通常占用 2 或 4 字节。但是实际上只使用int的 1 字节储存\u0026rsquo;$\u0026lsquo;的编 码。字符串\u0026quot;$\u0026ldquo;使用 2 字节：一个字节储存\u0026rsquo;$\u0026lsquo;的编码，一个字节储存的\u0026rsquo;\\0\u0026rsquo;编 码。\n7.打印的内容如下： # How are ya, sweetie? How are ya, sweetie? Beat the clock. eat the clock. Beat the clock.Win a toy. Beat chat hat at t t at How are ya, sweetie? 8.打印的内容如下： faavrhee leon*sm 9.下面是一种方案： #include \u0026lt;stdio.h\u0026gt; // 提供fgets()和getchar()的原型 char * s_gets(char * st, int n)\n{ # char * ret_val; ret_val = fgets(st, n, stdin); if (ret_val) { while (*st != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; *st != \u0026lsquo;\\0\u0026rsquo;) st++; if (*st == \u0026lsquo;\\n\u0026rsquo;) *st = \u0026lsquo;\\0\u0026rsquo;; else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } return ret_val; } 10.下面是一种方案： int strlen(const char * s) { int ct = 0;\nwhile (*s++) // 或者while (*s++ != \u0026lsquo;\\0\u0026rsquo;) ct++; return(ct); } 11.下面是一种方案： #include \u0026lt;stdio.h\u0026gt; // 提供 fgets()和getchar()的原型 #include \u0026lt;string.h\u0026gt; // 提供 strchr()的原型 char * s_gets(char * st, int n) { char * ret_val; char * find; ret_val = fgets(st, n, stdin); if (ret_val) { find = strchr(st, \u0026lsquo;\\n\u0026rsquo;); // 查找换行符 if (find) // 如果地址不是 NULL, *find = \u0026lsquo;\\0\u0026rsquo;; // 在此处放置一个空字符 else while (getchar() != \u0026lsquo;\\n\u0026rsquo;)\ncontinue; } return ret_val; } 12.下面是一种方案： #include \u0026lt;stdio.h\u0026gt; /* 提供 NULL 的定义 */ char * strblk(char * string) { while (*string != \u0026rsquo; \u0026rsquo; \u0026amp;\u0026amp; string != \u0026lsquo;\\0\u0026rsquo;) string++; / 在第 1 个空白或空字符处停止 */ if (string == \u0026lsquo;\\0\u0026rsquo;) return NULL; / NULL 指空指针 / else return string; } 下面是第 2 种方案，可以防止函数修改字符串，但是允许使用返回值改 变字符串。表达式(char)string被称为“通过强制类型转换取消const”。 #include \u0026lt;stdio.h\u0026gt; /提供 NULL 的定义/ char * strblk(const char * string)\n{ # while (*string != \u0026rsquo; \u0026rsquo; \u0026amp;\u0026amp; string != \u0026lsquo;\\0\u0026rsquo;) string++; /在第 1 个空白或空字符处停止/ if (string == \u0026lsquo;\\0\u0026rsquo;) return NULL; / NULL 指空指针/ else return (char )string; } 13.下面是一种方案： / compare.c \u0026ndash; 可行方案 */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; // 提供strcmp()的原型 #include \u0026lt;ctype.h\u0026gt; #define ANSWER \u0026ldquo;GRANT\u0026rdquo; #define SIZE 40 char * s_gets(char * st, int n); void ToUpper(char * str); int main(void) {\nchar try[SIZE]; puts(\u0026ldquo;Who is buried in Grant\u0026rsquo;s tomb?\u0026rdquo;); s_gets(try, SIZE); ToUpper(try); while (strcmp(try, ANSWER) != 0) { puts(\u0026ldquo;No, that\u0026rsquo;s wrong.Try again.\u0026rdquo;); s_gets(try, SIZE); ToUpper(try); } puts(\u0026ldquo;That\u0026rsquo;s right!\u0026rdquo;); return 0; } void ToUpper(char * str) { while (*str != \u0026lsquo;\\0\u0026rsquo;) { *str = toupper(*str); str++;\n} # } # char * s_gets(char * st, int n) { char * ret_val; int i = 0; ret_val = fgets(st, n, stdin); if (ret_val) { while (st[i] != \u0026lsquo;\\n\u0026rsquo; \u0026amp;\u0026amp; st[i] != \u0026lsquo;\\0\u0026rsquo;) i++; if (st[i] == \u0026lsquo;\\n\u0026rsquo;) st[i] = \u0026lsquo;\\0\u0026rsquo;; else while (getchar() != \u0026lsquo;\\n\u0026rsquo;) continue; } return ret_val; }\nA.12 第 12 章复习题答案 # 1.自动存储类别；寄存器存储类别；静态、无链接存储类别。 # 2.静态、无链接存储类别；静态、内部链接存储类别；静态、外部链接 # 存储类别。 # 3.静态、外部链接存储类别可以被多个文件使用。静态、内部链接存储 # 类别只能在一个文件中使用。 # 4.无链接。 # 5.关键字extern用于声明中，表明该变量或函数已定义在别处。 6.两者都分配了一个内含 100 个int类型值的数组。第 2 行代码使用calloc() 把数组中的每个元素都设置为 0 。 7.默认情况下，daisy只对main()可见，以extern声明的daisy才对petal()、 stem()和root()可见。文件 2 中的extern int daisy;声明使得daisy对文件 2 中的所 有函数都可见。第 1 个lily是main()的局部变量。petal()函数中引用的lily是错 误的，因为两个文件中都没有外部链接的lily。虽然文件 2 中有一个静态的 lily，但是它只对文件 2 可见。第 1 个外部rose对root()函数可见，但是stem()中 的局部rose覆盖了外部的rose。 8.下面是程序的输出： color in main() is B color in first() is R color in main() is B color in second() is G color in main() is G\nfirst()函数没有使用color变量，但是second()函数使用了。 9.a.声明告诉我们，程序将使用一个变量plink，该文件包含的函数都可 以使用这个变量。calu_ct()函数的第 1 个参数是指向一个整数的指针，并假 定它指向内含n个元素的数组。这里关键是要理解该程序不允许使用指针arr 修改原始数组中的值。 b.不会。value和n已经是原始数据的备份，所以该函数无法更改主调函 数中相应的值。这些声明的作用是防止函数修改value和n的值。例如，如果 用const限定n，就不能使用n++表达式。 A.13 第 13 章复习题答案 1.根据文件定义，应包含#include \u0026lt;stdio.h\u0026gt;。应该把fp声明为文件指针： FILE *fp;。要给fopen()函数提供一种模式：fopen(\u0026ldquo;gelatin\u0026rdquo;,\u0026ldquo;w\u0026rdquo;)，或者\u0026quot;a\u0026quot;模 式。fputs()函数的参数顺序应该反过来。输出字符串应该有一个换行符，提 高可读性。fclose()函数需要一个文件指针，而不是一个文件名： fclose(fp);。下面是修改后的版本： #include \u0026lt;stdio.h\u0026gt; int main(void) { FILE * fp; int k; fp = fopen(\u0026ldquo;gelatin\u0026rdquo;, \u0026ldquo;w\u0026rdquo;); for (k = 0; k \u0026lt; 30; k++) fputs(\u0026ldquo;Nanette eats gelatin.\\n\u0026rdquo;, fp);\nfclose(fp); return 0; } 2.如果可以打开的话，会打开与命令行第 1 个参数名相同名称的文件， 并在屏幕上显示文件中的每个数字字符。 3.a.ch = getc(fp1); b.fprintf(fp2,\u0026quot;%c\u0026rdquo;\\n\u0026quot;,ch); c.putc(ch,fp2); d.fclose(fp1); /* 关闭terky文件 */ 注意 fp1用于输入操作，因为它识别以读模式打开的文件。与此类似，fp2以 写模式打开文件，所以常用于输出操作。 4.下面是一种方案： #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(int argc, char * argv []) { FILE * fp; double n; double sum = 0.0;\nint ct = 0; if (argc == 1) fp = stdin; else if (argc == 2) { if ((fp = fopen(argv[1], \u0026ldquo;r\u0026rdquo;)) == NULL) { fprintf(stderr, \u0026ldquo;Can\u0026rsquo;t open %s\\n\u0026rdquo;, argv[1]); exit(EXIT_FAILURE); } } else { fprintf(stderr, \u0026ldquo;Usage: %s [filename]\\n\u0026rdquo;, argv[0]); exit(EXIT_FAILURE); } while (fscanf(fp, \u0026ldquo;%lf\u0026rdquo;, \u0026amp;n) == 1) { sum += n;\n++ct; } if (ct \u0026gt; 0) printf(\u0026ldquo;Average of %d values = %f\\n\u0026rdquo;, ct, sum / ct); else printf(\u0026ldquo;No valid data.\\n\u0026rdquo;); return 0; } 5.下面是一种方案： #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define BUF 256 int has_ch(char ch, const char * line); int main(int argc, char * argv []) { FILE * fp; char ch; char line[BUF]; if (argc != 3)\n{ # printf(\u0026ldquo;Usage: %s character filename\\n\u0026rdquo;, argv[0]); exit(EXIT_FAILURE); } ch = argv[1][0]; if ((fp = fopen(argv[2], \u0026ldquo;r\u0026rdquo;)) == NULL) { printf(\u0026ldquo;Can\u0026rsquo;t open %s\\n\u0026rdquo;, argv[2]); exit(EXIT_FAILURE); } while (fgets(line, BUF, fp) != NULL) { if (has_ch(ch, line)) fputs(line, stdout); } fclose(fp); return 0; } int has_ch(char ch, const char * line)\n{ # while (*line) if (ch == *line++) return(1); return 0; } fgets()和 fputs()函数要一起使用，因为 fgets()会把按下 Enter 键的\\n 留在 字符串中， fputs()与puts()不一样，不会添加一个换行符。 6.二进制文件与文本文件的区别是，这两种文件格式对系统的依赖性不 同。二进制流和文本流的区别包括是在读写流时程序执行的转换（二进制流 不转换，而文本流可能要转换换行符和其他字符）。 7.a.用fprintf()储存 8238201 时，将其视为 7 个字符，保存在 7 字节中。用 fwrite()储存时，使用该数的二进制表示，将其储存为一个 4 字节的整数。 b.没有区别。两个函数都将其储存为一个单字节的二进制码。 8.第 1 条语句是第 2 条语句的速记表示。第 3 条语句把消息写到标准错误 上。通常，标准错误被定向到与标准输出相同的位置。但是标准错误不受标 准输出重定向的影响。 9.可以在以\u0026quot;r+\u0026ldquo;模式打开的文件中读写，所以该模式最合适。\u0026ldquo;a+\u0026ldquo;只允 许在文件的末尾添加内容。\u0026ldquo;w+\u0026ldquo;模式提供一个空文件，丢弃文件原来的内 容。 A.14 第 14 章复习题答案 1.正确的关键是 struct，不是 structure。该结构模板要在左花括号前面有\n一个标记，或者在右花括号后面有一个结构变量名。另外，*togs后面和模 板结尾处都少一个分号。 2.输出如下： 6 1 22 Spiffo Road S p 3. struct month { char name[10]; char abbrev[4]; int days; int monumb; }; 4. struct month months[12] = { { \u0026ldquo;January\u0026rdquo;, \u0026ldquo;jan\u0026rdquo;, 31, 1 }, { \u0026ldquo;February\u0026rdquo;, \u0026ldquo;feb\u0026rdquo;, 28, 2 }, { \u0026ldquo;March\u0026rdquo;, \u0026ldquo;mar\u0026rdquo;, 31, 3 },\n{ \u0026ldquo;April\u0026rdquo;, \u0026ldquo;apr\u0026rdquo;, 30, 4 }, { \u0026ldquo;May\u0026rdquo;, \u0026ldquo;may\u0026rdquo;, 31, 5 }, { \u0026ldquo;June\u0026rdquo;, \u0026ldquo;jun\u0026rdquo;, 30, 6 }, { \u0026ldquo;July\u0026rdquo;, \u0026ldquo;jul\u0026rdquo;, 31, 7 }, { \u0026ldquo;August\u0026rdquo;, \u0026ldquo;aug\u0026rdquo;, 31, 8 }, { \u0026ldquo;September\u0026rdquo;, \u0026ldquo;sep\u0026rdquo;, 30, 9 }, { \u0026ldquo;October\u0026rdquo;, \u0026ldquo;oct\u0026rdquo;, 31, 10 }, { \u0026ldquo;November\u0026rdquo;, \u0026ldquo;nov\u0026rdquo;, 30, 11 }, { \u0026ldquo;December\u0026rdquo;, \u0026ldquo;dec\u0026rdquo;, 31, 12 } }; 5. extern struct month months []; int days(int month) { int index, total; if (month \u0026lt; 1 || month \u0026gt; 12) return(-1); /* error signal */ else {\nfor (index = 0, total = 0; index \u0026lt; month; index++) total += months[index].days; return(total); } } 注意，index比月数小 1 ，因为数组下标从 0 开始。然后，用index \u0026lt; month 代替index \u0026lt;= month。 6.a.要包含string.h头文件，提供strcpy()的原型： typedef struct lens { /* lens 描述 / float foclen; / 焦距长度，单位：mm / float fstop; / 孔径 / char brand[30];/ 品牌 */ } LENS; LENS bigEye[10]; bigEye[2].foclen = 500; bigEye[2].fstop = 2.0; strcpy(bigEye[2].brand, \u0026ldquo;Remarkatar\u0026rdquo;); b.LENS bigEye[10] = { [2] = {500, 2, \u0026ldquo;Remarkatar\u0026rdquo;} }; 7.a.\n6 # Arcturan cturan b.使用结构名和指针： deb.title.last pb-\u0026gt;title.last c.下面是一个版本： #include \u0026lt;stdio.h\u0026gt; #include \u0026ldquo;starfolk.h\u0026rdquo; /* 让结构定义可用 */ void prbem (const struct bem * pbem ) { printf(\u0026quot;%s %s is a %d-limbed %s.\\n\u0026rdquo;, pbem-\u0026gt;title.first, pbem-\u0026gt;title.last, pbem-\u0026gt;limbs, pbem-\u0026gt;type); } 8.a.willie.born b.pt-\u0026gt;born c.scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;willie.born); d.scanf(\u0026quot;%d\u0026rdquo;, \u0026amp;pt-\u0026gt;born); e.scanf(\u0026quot;%s\u0026rdquo;, willie.name.lname);\nf.scanf(\u0026quot;%s\u0026rdquo;, pt-\u0026gt;name.lname); g.willie.name.fname[2] h.strlen(willie.name.fname) + strlen(willie.name.lname) 9.下面是一种方案： struct car { char name[20]; float hp; float epampg; float wbase; int year; }; 10.应该这样建立函数： struct gas { float distance; float gals; float mpg; }; struct gas mpgs(struct gas trip) {\nif (trip.gals \u0026gt; 0) trip.mpg = trip.distance / trip.gals; else trip.mpg = -1.0; return trip; } void set_mpgs(struct gas * ptrip) { if (ptrip-\u0026gt;gals \u0026gt; 0) ptrip-\u0026gt;mpg = ptrip-\u0026gt;distance / ptrip-\u0026gt;gals; else ptrip-\u0026gt;mpg = -1.0; } 注意，第 1 个函数不能直接改变其主调程序中的值，所以必须用返回值 才能传递信息。 struct gas idaho = {430.0, 14.8}; // 设置前两个成员 idaho = mpgs(idaho); // 重置数据结构 但是，第 2 个函数可以直接访问最初的结构： struct gas ohio = {583, 17.6}; //设置前两个成员\nset_mpgs(\u0026amp;ohio); // 设置第 3 个成员 11.enum choices {no, yes, maybe}; 12.char * (*pfun)(char *, char); 13. double sum(double, double); double diff(double, double); double times(double, double); double divide(double, double); double (*pf1[4])(double, double) = {sum, diff, times, divide}; 或者用更简单的形式，把代码中最后一行替换成： typedef double (*ptype) (double, double); ptype pfl[4] = {sum,diff, times, divide}; 调用diff()函数： pf1[1](10.0, 2.5); // 第 1 种表示法 (*pf1[1])(10.0, 2.5); // 等价表示法 A.15 第 15 章复习题答案 1.a.00000011 b.00001101 c.00111011\nd.01110111 2.a.21, 025, 0x15 b.85, 0125, 0x55 c.76, 0114, 0x4C d.157, 0235, 0x9D 3.a.252 b.2 c.7 d.7 e.5 f.3 g.28 4.a.255 b.1 (not false is true) c.0 d.1 (true and true is true) e.6 f.1 (true or true is true) g.40\n5.掩码的二进制是 1111111 ；十进制是 127 ；八进制是 0177 ；十六进制是 # 0x7F。 6.bitval * 2和bitval \u0026laquo; 1都把bitval的当前值增加一倍，它们是等效的。 但是mask +=bitval和mask |= bitval只有在bitval和mask没有同时打开的位时效 果才相同。例如， 2 | 4得 6 ，但是3 | 6也得 6 。 7.a. struct tb_drives { unsigned int diskdrives : 2; unsigned int : 1; unsigned int cdromdrives : 2; unsigned int : 1; unsigned int harddrives : 2; }; b. struct kb_drives { unsigned int harddrives : 2; unsigned int : 1; unsigned int cdromdrives : 2; unsigned int : 1; unsigned int diskdrives : 2;\n}; # A.16 第 16 章复习题答案 # 1.a.dist = 5280 * miles;有效。 b.plort = 4 * 4 + 4;有效。但是如果用户需要的是4 * (4 + 4)，则应该使用 #define POD (FEET + FEET)。 c.nex = = 6;;无效（如果两个等号之间没有空格，则有效，但是没有意 义）。显然，用户忘记了在编写预处理器代码时不用加=。 d.y = y + 5;有效。berg = berg + 5 * lob;有效，但是可能得不到想要的结 果。est = berg +5/y + 5;有效，但是可能得不到想要的结果。 2.#define NEW(X) ((X) + 5) 3.#define MIN(X,Y) ( (X) \u0026lt; (Y)? (X) : (Y) ) 4.#define EVEN_GT(X,Y) ( (X) \u0026gt; (Y) \u0026amp;\u0026amp; (X) % 2 == 0? 1 : 0 ) 5.#define PR(X,Y) printf(#X \u0026quot; is %d and \u0026quot; #Y \u0026quot; is %d\\n\u0026quot;, X,Y) （因为该宏中没有运算符（如，乘法）作用于X和Y，所以不需要使用 圆括号。） 6.a.#define QUARTERCENTURY 25 b.#define SPACE \u0026rsquo; ' c.#define PS() putchar(\u0026rsquo; \u0026lsquo;)或#define PS() putchar(SPACE) d.#define BIG(X) ((X) + 3) e.#define SUMSQ(X,Y) ((X)(X) + (Y)(Y))\n7.试试这样：#define P(X) printf(\u0026ldquo;name: \u0026ldquo;#X\u0026rdquo;; value: %d; address: %p\\n\u0026rdquo;, X, \u0026amp;X) （如果你的实现无法识别地址专用的%p转换说明，可以用%u或%lu 代替。） 8.使用条件编译指令。一种方法是使用#ifndef： #define SKIP /* 如果不需要跳过代码，则删除这条指令 / #ifndef SKIP / 需要跳过的代码 / #endif 9. #ifdef PR_DATE printf(\u0026ldquo;Date = %s\\n\u0026rdquo;, _ DATE _); #endif 10.第 1 个版本返回xx，这只是返回了square()的double类型值。例如， square(1.3)会返回1.69。第 2 个版本返回 (int)(xx)，计算结果被截断后返回。 但是，由于该函数的返回类型是double，int类型的值将被升级为double类型 的值，所以1.69将先被转换成 1 ，然后被转换成1.00。第 3 个版本返回(int) (xx+0.5)。加上 0.5可以让函数把结果四舍五入至与原值最接近的值，而不 是简单地截断。所以，1.69+0.5得2.19，然后被截断为 2 ，然后被转换成 2.00；而1.44+0.5得1.94，被截断为 1 ，然后被转换成1.00。 11.这是一种方案: #define BOOL(X) _Generic((X), _Bool : \u0026ldquo;boolean\u0026rdquo;, default : \u0026ldquo;not boolean\u0026rdquo;)12.应该把argv参数声明为char *argv[]类型。命令行参 数被储存为字符串，所以该程序应该先把argv[1]中的字符串转换成double类 型的值。例如，用stdlib.h库中的atof()函数。程序中使用了sqrt()函数，所以 应包含math.h头文件。程序在求平方根之前应排除参数为负的情况（检查参\n数是否大于或等于 0 ）。 # 13.a.qsort( (void )scores, (size_t) 1000, sizeof (double), comp); b.下面是一个比较使用的比较函数： int comp(const void * p1, const void * p2) { / 要用指向int的指针来访问值 / / 在C中是否进行强制类型转换都可以，在C++中必须进行强制类型转 换 */ const int * a1 = (const int *) p1; const int * a2 = (const int *) p2; if (*a1 \u0026gt; *a2) return -1; else if (*a1 == *a2) return 0; else return 1; } 14.a.函数调用应该类似：memcpy(data1, data2, 100 * sizeof(double)); b.函数调用应该类似：memcpy(data1, data2 + 200 , 100 * sizeof(double));\nA.17 第 17 章复习题答案 # 1.定义一种数据类型包括确定如何储存数据，以及设计管理该数据的一 # 系列函数。 # 2.因为每个结构包含下一个结构的地址，但是不包含上一个结构的地 # 址，所以这个链表只能沿着一个方向遍历。可以修改结构，在结构中包含两 # 个指针，一个指向上一个结构，一个指向下一个结构。当然，程序也要添加 # 代码，在每次新增结构时为这些指针赋正确的地址。 # 3.ADT是抽象数据类型，是对一种类型属性集和可以对该类型进行的操 # 作的正式定义。ADT应该用一般语言表示，而不是用某种特殊的计算机语 # 言，而且不应该包含实现细节。 # 4.直接传递变量的优点：该函数查看一个队列，但是不改变其中的内 # 容。直接传递队列变量，意味着该函数使用的是原始队列的副本，这保证了 # 该函数不会更改原始的数据。直接传递变量时，不需要使用地址运算符或指 # 针。 # 直接传递变量的缺点：程序必须分配足够的空间储存整个变量，然后拷 # 贝原始数据的信息。如果变量是一个大型结构，用这种方法将花费大量的时 # 间和内存空间。 # 传递变量地址的优点：如果待传递的变量是大型结构，那么传递变量的 # 地址和访问原始数据会更快，所需的内存空间更少。 # 传递变量地址的缺点：必须记得使用地址运算符或指针。在K\u0026amp;R C中， # 函数可能会不小心改变原 # 始数据，但是用ANSI C中的const限定符可以解决这个问题。 5.a. 类型名：　栈 类型属性：　可以储存有序项 # 类型操作：　初始化栈为空 # 确定栈是否为空 # 确定栈是否已满 # 从栈顶添加项（压入项） # 从栈顶删除项（弹出项） # b.下面以数组形式实现栈，但是这些信息只影响结构定义和函数定义的 细节，不会影响函数原型的接口。 /* stack.h –– 栈的接口 / #include \u0026lt;stdbool.h\u0026gt; / 在这里插入 Item 类型 / / 例如： typedef int Item; / #define MAXSTACK 100 typedef struct stack { Item items[MAXSTACK]; / 储存信息　/ int top; / 第 1 个空位的索引 / } Stack; / 操作：　初始化栈　*/\n/* 前提条件：　ps 指向一个栈　/ / 后置条件：　该栈被初始化为空　/ void InitializeStack(Stack * ps); / 操作：　检查栈是否已满　/ / 前提条件：　ps 指向之前已被初始化的栈　/ / 后置条件：　如果栈已满，该函数返回true；否则，返回false / bool FullStack(const Stack * ps); / 操作：　检查栈是否为空　/ / 前提条件：　ps 指向之前已被初始化的栈　/ / 后置条件：　如果栈为空，该函数返回true；否则，返回false */ bool EmptyStack(const Stack ps); / 操作：　把项压入栈顶　/ / 前提条件：　ps 指向之前已被初始化的栈　/ / item 是待压入栈顶的项　/ / 后置条件：　如果栈不满，把 item 放在栈顶，该函数返回ture；　/ /　否则，栈不变，该函数返回 false */ bool Push(Item item, Stack * ps);\n/* 操作：　从栈顶删除项　*/ # /* 前提条件：　ps 指向之前已被初始化的栈　/ / 后置条件：　如果栈不为空，把栈顶的item拷贝到*pitem，　/ /　删除栈顶的item，该函数返回ture；　/ /　如果该操作后栈中没有项，则重置该栈为空。　/ /　如果删除操作之前栈为空，栈不变，该函数返回false */ bool Pop(Item *pitem, Stack * ps); 6.比较所需的最大次数如下：\n7.见图A.1。 # 图A.1 单词的二分查找树 8.见图A.2。\n图A.2 删除项后的单词二分查找树 [1].是语言中的语义错误。这句英文翻译成中文是——“这句话是出色的捷克人译者注 ”。显然不知所云，这就\n[2].示。thrice_n——译者注本应表示n的 3 倍，但是3 + n表示的并不是n的 3 倍，应该用3*n来表\n附录 B 参考资料 # 本书这部分总结了C语言的基本特性和一些特定主题的详细内容，包括 # 以下 9 个部分。 # 参考资料I：补充阅读 # 参考资料II：C运算符 # 参考资料III：基本类型和存储类别 # 参考资料IV：表达式、语句和程序流 # 参考资料V：新增了C99和C11的标准ANSI C库 # 参考资料VI：扩展的整数类型 # 参考资料VII：扩展的字符支持 # 参考资料VIII：C99/C11数值计算增强 # 参考资料IX：C与C++的区别 # B.1 参考资料 I ：补充阅读 # 如果想了解更多C语言和编程方面的知识，下面提供的资料会对你有所 # 帮助。 # B.1.1 在线资源 # C程序员帮助建立了互联网，而互联网可以帮助你学习C。互联网时刻 # 都在发展、变化，这里所列的资源只是在撰写本书时可用的资源。当然，你 # 可以在互联网中找到其他资源。 # 如果有一些与C语言相关的问题或只是想扩展你的知识，可以浏览C # FAQ（常见问题解答）的站点： # c-faq.com 但是，这个站点的内容主要涵盖到C89。 如果对C库有疑问，可以访问这个站点获得信息： http://www.acm.uiuc.edu/webmonkeys/book/c_guide/index.html。 这个站点全面讨论指针：pweb.netcom.com/～tjensen/ptr/pointers.htm。 还可以使用谷歌和雅虎的搜索引擎，查找相关文章和站点： http://www.google.com search.yahoo.com http://www.bing.com 可以使用这些站点中的高级搜索特性来优化你要搜索的内容。例如，尝 试搜索C教程。 你可以通过新闻组（newsgroup）在网上提问。通常，新闻组阅读程序\n通过你的互联网服务提供商提供的账号访问新闻组。另一种访问方法是在网 # 页浏览器中输入这个地址：http://groups.google.com。 你应该先花时间阅读新闻组，了解它涵盖了哪些主题。例如，如果你对 如何使用C语言完成某事有疑问，可以试试这些新闻组： comp.lang.c comp.lang.c.moderated 可以在这里找到愿意提供帮助的人。你所提的问题应该与标准 C 语言 相关，不要在这里询问如何在UNIX系统中获得无缓冲输入之类的问题。特 定平台都有专门的新闻组。最重要的是，不要询问他们如何解决家庭作业中 的问题。 如果对C标准有疑问，试试这个新闻组：comp.std.c。但是，不要在这里 询问如何声明一个指向三维数组的指针，这类问题应该到另一个新闻组： comp.lang.c。 最后，如果对C语言的历史感兴趣，可以浏览下C创始人Dennis Ritchie 的站点，其中 1993 年中有一篇文章介绍了C的起源和发展：cm.bell- labs.com/cm/cs/who/dmr/chist.html。 B.1.2 C 语言书籍 Feuer,Alan R.The C Puzzle Book,Revised Printing Upper Saddle River, NJ: Addison-WesleyProfessional, 1998。这本书包含了许多程序，可以用来学 习，推测这些程序应输出的内容。预测输出对测试和扩展 C 的理解很有帮 助。本书也附有答案和解释。 Kernighan, Brian W.and Dennis M.Ritchie.The C Programming Language, Second Edition .Englewood Cliffs, NJ: Prentice Hall, 1988。第 1 本C语言书的第 2 版（注意，作者Dennis Ritchie是C的创始者）。本书的第 1 版给出了K\u0026amp;R C 的定义，许多年来它都是非官方的标准。第 2 版基于当时的ANSI草案进行了\n修订，在编写本书时该草案已成为了标准。本书包含了许多有趣的例子，但 # 是它假定读者已经熟悉了系统编程。 # Koenig,Andrew.C Traps and Pitfalls.Reading,MA:Addison-Wesley,1989。本 书的中文版《C陷阱与缺陷》已由人民邮电出版社出版。 Summit,Steve.C Programming FAQs.Reading,MA:Addison-Wesley,1995。这 本书是互联网FAQ的延伸阅读版本。 B.1.3 编程书籍 Kernighan, Brian W.and P.J.Plauger.The Elements of Programming Style, Second Edition .NewYork:McGraw-Hill, 1978。这本短小精悍的绝版书籍，历 经岁月却无法掩盖其真知灼见。书中介绍了要编写高效的程序，什么该做， 什么不该做。 Knuth,Donald E.The Art of Computer Programming, 第 1 卷（基本算法）， Third Edition.Reading,MA:Addison-Wesley, 1997。这本经典的标准参考书非常 详尽地介绍了数据表示和算法分析。第 2 卷（半数学算法， 1997 ）探讨了伪 随机数。第 3 卷（排序和搜索， 1998 ）介绍了排序和搜索，以伪代码和汇编 语言的形式给出示例。 Sedgewick, Robert.Algorithms in C, Parts 1-4:Fundamentals,Data Structures,Sorting,Searching,Third Edition.Reading, MA: Addison-Wesley Professional, 1997。顾名思义，这本书介绍了数据结构、排序和搜索。本书 中文版《C算法（第 1 卷）基础、数据结构、排序和搜索（第 3 版）》已由人 民邮电出版社出版。 B.1.4 参考书籍 Harbison, Samuel P.and Steele, Guy L.C: A Reference Manual, Fifth Edition.Englewood Cliffs,NJ:Prentice Hall, 2002。这本参考手册介绍了C语言 的规则和大多数标准库函数。它结合了C99，提供了许多例子。《C语言参\n考手册（第 5 版）（英文版）》已由人民邮电出版社出版。 # Plauger,P.J.The Standard C Library.Englewood Cliffs,NJ:Prentice Hall,1992。这本大型的参考手册介绍了标准库函数，比一般的编译器手册更 详尽。 The International C Standard.ISO/IEC 9899:2011。在撰写本书时，可以花 285 美元从www.ansi.org下载该标准的电子版，或者花 238 欧元从IEC下载。 别指望通过这本书学习C语言，因为它并不是一本学习教程。这是一句有代 表性的话，可见一斑：“如果在一个翻译单元中声明一个特定标识符多次， 在该翻译单元中都可见，那么语法可根据上下文无歧义地引用不同的实 体”。 B.1.5 C++ 书籍 Prata,Stephen.C++Primer Plus,Sixth Edition.Upper Saddle River,NJ:Addison- Wesley,2012。本书介绍了C++语言（C++11标准）和面向对象编程的原则。 Stroustrup, Bjarne.The C++Programming Language, Fourth Edition.Reading, MA: Addison-Wesley, 2013。本书由C++的创始人撰写，介绍了C++11标准。\nB.2 参考资料 II ： C 运算符 # C语言有大量的运算符。表B.2.1按优先级从高至低的顺序列出了C运算 # 符，并给出了其结合性。除非特别指明，否则所有运算符都是二元运算符 # （需要两个运算对象）。注意，一些二元运算符和一元运算符的表示符号相 # 同，但是其优先级不同。例如，（乘法运算符）和（间接运算符）。表后 # 面总结了每个运算符的用法。 # 表B.2.1 C运算符 B.2.1 算术运算符 # + 把右边的值加到左边的值上。 # + 作为一元运算符，生成一个大小和符号都与右边值相同的值。 # - 从左边的值中减去右边的值。 # - 作为一元运算符，生成一个与右边值大小相等符号相反的值。 # * 把左边的值乘以右边的值。 # / 把左边的值除以右边的值；如果两个运算对象都是整数，其结果要被 # 截断。 # % 得左边值除以右边值时的余数 # ++ 把右边变量的值加 1 （前缀模式），或把左边变量的值加 1 （后缀模 # 式）。 # \u0026ndash; 把右边变量的值减 1 （前缀模式），或把左边变量的值减 1 （后缀模 # 式）。 # B.2.2 关系运算符 # 下面的每个运算符都把左边的值与右边的值相比较。 # \u0026lt;　小于 # \u0026lt;= 小于或等于 # == 等于 # \u0026gt;= 大于或等于 # \u0026gt;　大于 # != 不等于 # 关系表达式 # 简单的关系表达式由关系运算符及其两侧的运算对象组成。如果关系为 # 真，则关系表达式的值为 1 ；如果关系为假，则关系表达式的值为 0 。下面 # 是两个例子： # 5 \u0026gt; 2 关系为真，整个表达式的值为 1 。 # (2 + a) == a 关系为假，整个表达式的值为 0 。 B.2.3 赋值运算符 C语言有一个基本赋值运算符和多个复合赋值运算符。=运算符是基本 的形式： = 把它右边的值赋给其左边的左值。 下面的每个赋值运算符都根据它右边的值更新其左边的左值。我们使用 R-H表示右边，L-R表示左边。 += 把左边的变量加上右边的量，并把结果储存在左边的变量中。 -= 从左边的变量中减去右边的量，并把结果储存在左边的变量中。 *= 把左边的变量乘以右边的量，并把结果储存在左边的变量中。 /= 把左边的变量除以右边的量，并把结果储存在左边的变量中。 %= 得到左边量除以右边量的余数，并把结果储存在左边的变量中。 \u0026amp;= 把L-H \u0026amp; R-H的值赋给左边的量，并把结果储存在左边的变量中。 |= 把L-H | R-H的值赋给左边的量，并把结果储存在左边的变量中。 ^=　把L-H ^ R-H的值赋给左边的量，并把结果储存在左边的变量中。\n= 把L-H \u0026raquo; R-H的值赋给左边的量，并把结果储存在左边的变量中。 \u0026laquo;= 把L-H \u0026laquo; R-H的值赋给左边的量，并把结果储存在左边的变量中。 示例 rabbits *= 1.6;与rabbits = rabbits * 1.6效果相同。\nB.2.4 逻辑运算符 # 逻辑运算符通常以关系表达式作为运算对象。!运算符只需要一个运算 # 对象，其他运算符需要两个运算对象，运算符左边一个，右边一个。 # \u0026amp;\u0026amp; 逻辑与 # || 逻辑或 # ！ 逻辑非 # 1. 逻辑表达式 # 当且仅当两个表达式都为真时，expresson1 \u0026amp;\u0026amp; expresson 2的值才为 真。 两个表达式中至少有一个为真时，expresson 1 \u0026amp;\u0026amp; expresson 2的值就为 真。 如果expresson的值为假，则!expresson为真，反之亦然。\n2. 逻辑表达式的求值顺序 逻辑表达式的求值顺序是从左往右。当发现可以使整个表达式为假的条 件时立即停止求值。 3. 示例 6 \u0026gt; 2 \u0026amp;\u0026amp; 3 == 3 为真。 !(6 \u0026gt; 2 \u0026amp;\u0026amp; 3 == 3) 为假。 x != 0 \u0026amp;\u0026amp; 20/x \u0026lt; 5 只有在x是非零时才会对第 2 个表达式求值。 B.2.5 条件运算符\n?:有 3 个运算对象，每个运算对象都是一个表达式：expression1? expression2 : expression3 如果expression1为真，则整个表达式的值等于expression2的值；否则， 等于expression3的值。 示例 (5 \u0026gt; 3)? 1 : 2的值为 1 。 (3 \u0026gt; 5)? 1 : 2的值为 2 。 (a \u0026gt; b)? a : b的值是a和b中较大者 B.2.6 与指针有关的运算符 \u0026amp;是地址运算符。当它后面是一个变量名时，\u0026amp;给出该变量的地址。 *是间接或解引用运算符。当它后面是一个指针时，给出储存在指针指 向地址中的值。 示例 \u0026amp;nurse是变量nurse的地址： nurse = 22; ptr = \u0026amp;nurse; / 指向nurse的指针 */ val = *ptr; 以上代码的效果是把 22 赋给val。 B.2.7 符号运算符\n是负号，反转运算对象的符号。 + 是正号，不改变运算对象的符号。 # B.2.8 结构和联合运算符 # 结构和联合使用一些运算符标识成员。成员运算符与结构和联合一起使 # 用，间接成员运算符与指向结构或联合的指针一起使用。 # 1. 成员运算符 # 成员运算符（.）与结构名或联合名一起使用，指定结构或联合中的一 # 个成员。如果name是一个结构名，member是该结构模板指定的成员名，那 么name.member标识该结构中的这个成员。name.member的类型就是被指定 member的类型。在联合中也可以用相同的方式使用成员运算符。 示例 struct { int code; float cost; } item; item.code = 1265; 上面这条语句把 1265 赋给结构变量item的成员code。\n2. 间接成员运算符（或结构指针运算符） 间接成员运算符（-\u0026gt;）与一个指向结构或联合的指针一起使用，标识该 结构或联合的一个成员。假设ptrstr是一个指向结构的指针，member是该结 构模板指定的成员，那么ptrstr-\u0026gt;member标识了指针所指向结构的这个成 员。在联合中也可以用相同的方式使用间接成员运算符。 示例\nstruct { int code; float cost; } item, * ptrst; ptrst = \u0026amp;item; ptrst-\u0026gt;code = 3451; 以上程序段把 3451 赋给结构item的成员code。下面 3 种写法是等效的： ptrst-\u0026gt;code item.code (*ptrst).code B.2.9 按位运算符 下面所列除了～，都是按位运算符。 ～ 是一元运算符，它通过翻转运算对象的每一位得到一个值。 \u0026amp; 是逻辑与运算符，只有当两个运算对象中对应的位都为 1 时，它生成 的值中对应的位才为 1 。 | 是逻辑或运算符，只要两个运算对象中对应的位有一位为 1 ，它生成的 值中对应的位就为 1 。 ^ 是按位异或运算符，只有两个运算对象中对应的位中只有一位为 1 （不能全为 1 ），它生成的值中对应的位才为 1 。 \u0026laquo; 是左移运算符，把左边运算对象中的位向左移动得到一个值。移动 的位数由该运算符右边的运算对象确定，空出的位用 0 填充。\n是右移运算符，把左边运算对象中的位向右移动得到一个值。移动 的位数由该运算符右边的运算对象确定，空出的位用 0 填充。\n示例 # 假设有下面的代码： # int x = 2; int y = 3; x \u0026amp; y的值为 2 ，因为x和y的位组合中，只有第 1 位均为 1 。而y \u0026laquo; x的值 为 12 ，因为在y的位组合中， 3 的位组合向左移动两位，得到 12 。 B.2.10 混合运算符 sizeof给出它右边运算对象的大小，单位是char的大小。通常，char类型 的大小是 1 字节。运算对象可以圆括号中的类型说明符，如sizeof(float)，也 可以是特定的变量名、数组名等，如sizeof foo。sizeof表达式的类型是 size_t。 _Alignof（C11）给出它的运算对象指定类型的对齐要求。一些系统要 求以特定值的倍数在地址上储存特定类型，如 4 的倍数。这个整数就是对齐 要求。 （类型名）是强制类型转换运算符，它把后面的值转换成圆括号中关键 字指定的类型。例如，(float)9把整数 9 转换成浮点数9.0。 ,是逗号运算符，它把两个表达式链接成一个表达式，并保证先对最左 端的表达式求值。整个表达式的值是最右边表达式的值。该运算符通常在 for循环头中用于包含更多的信息。 示例 for (step = 2, fargo = 0; fargo \u0026lt; 1000; step *= 2) fargo += step;\nB.3 参考资料 III ：基本类型和存储类别 # B.3.1 总结：基本数据类型 # C语言的基本数据类型分为两大类：整数类型和浮点数类型。不同的种 # 类提供了不同的范围和精度。 # 1. 关键字 # 创建基本数据类型要用到 8 个关键字：int、long、short、unsigned、 char、float、double、signed（ANSI C）。\n2. 有符号整数 有符号整数可以具有正值或负值。 int是所有系统中基本整数类型。 long或long int可储存的整数应大于或等于int可储存的最大数；long至少 是 32 位。 short或short int整数应小于或等于int可储存的最大数；short至少是 16 位。通常，long比short大。例如，在PC中的C DOS编译器提供 16 位的short和 int、 32 位的long。这完全取决于系统。 C99标准提供了long long类型，至少和long一样大，至少是 64 位。 3. 无符号整数 无符号整数只有 0 和正值，这使得该类型能表示的正数范围更大。在所 需的类型前面加上关键字unsigned：unsigned int、unsigned long、unsigned short、unsigned long long。单独的unsigned相当于unsigned int。 4. 字符\n字符是如A、\u0026amp;、+这样的印刷符号。根据定义，char类型的变量占用 1 字节的内存。过去，char类型的大小通常是 8 位。然而，C在处理更大的字符 集时，char类型可以是 16 位，或者甚至是 32 位。 这种类型的关键字是char。一些实现使用有符号的char，但是其他实现 使用无符号的char。ANSI C允许使用关键字signed 和 unsigned指定所需类 型。从技术层面上看，char、unsigned char和signed char是 3 种不同的类型， 但是char类型与其他两种类型的表示方法相同。\n5. 布尔类型（ C99 ） _Bool是C99新增的布尔类型。它一个无符号整数类型，只能储存 0 （表 示假）或 1 （表示真）。包含stdbool.c头文件后，可以用bool表示_Bool、ture 表示 1 、false表示 0 ，让代码与C++兼容。 6. 实浮点数和复浮点数类型 C99识别两种浮点数类型：实浮点数和复浮点数。浮点类型由这两种类 型构成。 实浮点数可以是正值或负值。C识别 3 种实浮点类型。 float是系统中的基本浮点类型。它至少可以精确表示 6 位有效数字，通 常float为 32 位。 double（可能）表示更大的浮点数。它能表示比 float更多的有效数字和 更大的指数。它至少能精确表示 10 位有效数字。通常，double为 64 位。 long double（可能）表示更大的浮点数。它能表示比double更多的有效 数字和更大的指数。 复数由两部分组成：实部和虚部。C99 规定一个复数在内部用一个有两 个元素的数组表示，第 1 个元素表示实部，第 2 个元素表示虚部。有 3 种复浮 点数类型。\nfloat _Complex表示实部和虚部都是float类型的值。 double _Complex表示实部虚部都是double类型的值。 long double _Complex表示实部和虚部都是long double类型的值。 每种情况，前缀部分的类型都称为相应的实数类型（corresponding real type）。例如，double是double_Complex相应的实数类型。 C99中，复数类型在独立环境中是可选的，这样的环境中不需要操作系 统也可运行C程序。在C11中，复数类型在独立环境和主机环境都是可选 的。 有 3 种虚数类型。它们在独立环境中和主机环境中（C 程序在一种操作 系统下运行的环境）都是可选的。虚数只有虚部。这 3 种类型如下。 float _Imaginary表示虚部是float类型的值。 double _Imaginary表示虚部是double类型的值。 long double _Imaginary表示虚部是long double类型的值。 可以用实数和I值来初始化复数。I定义在complex.h头文件中，表示 i（即-1的平方根）。 #include \u0026lt;complex.h\u0026gt; // I定义在该头文件中 double _Complex z = 3.0; // 实部 = 3.0，虚部 = 0 double _Complex w = 4.0 * I; // 实部 = 0.0，虚部 = 4.0 double Complex u = 6.0 – 8.0 * I; //实部= 6.0，虚部 = -8.0 前面章节讨论过，complex.h库包含一些返回复数实部和虚部的函数。 B.3.2 总结：如何声明一个简单变量\n1.选择所需的类型。 # 2.选择一个合适的变量名。 # 3.使用这种声明格式：type-specifiervariable-name; type-specifier由一个或多个类型关键字组成，下面是一些例子： int erest; unsigned short cash; 4.声明多个同类型变量时，使用逗号分隔符隔开各变量名： char ch, init, ans; 5.可以在声明的同时初始化变量： float mass = 6.0E24; 总结：存储类别 关键字：auto、extern、static、register、_Thread_local（C11） 一般注解： 变量的存储类别取决于它的作用域、链接和存储期。存储类别由声明变 量的位置和与之关联的关键字决定。定义在所有函数外部的变量具有文件作 用域、外部链接、静态存储期。声明在函数中的变量是自动变量，除非该变 量前面使用了其他关键字。它们具有块作用域、无链接、自动存储期。以 static关键字声明在函数中的变量具有块作用域、无链接、静态存储期。以 static关键字声明在函数外部的变量具有文件作用域、内部链接、静态存储 期。 C11 新增了一个存储类别说明符：_Thread_local。以该关键字声明的对 象具有线程存储期，意思是在线程中声明的对象在该线程运行期间一直存\n在，且在线程开始时被初始化。因此，这种对象属于线程私有。 # 属性： # 下面总结了这些存储类别的属性： # 续表 注意，关键字extern只能用来再次声明在别处已定义过的变量。在函数 外部定义变量，该变量具有外部链接属性。 除了以上介绍的存储类别，C 还提供了动态分配内存。这种内存通过调 用 malloc()函数系列中的一个函数来分配。这种函数返回一个可用于访问内 存的指针。调用 free()函数或结束程序可以释放动态分配的内存。任何可以 访问指向该内存指针的函数均可访问这块内存。例如，一个函数可以把这个 指针的值返回给另一个函数，那么另一个函数也可以访问该指针所指向的内 存。 B.3.3 总结：限定符 关键字 使用下面关键字限定变量：\nconst、volatile、restrict 一般注释 限定符用于限制变量的使用方式。不能改变初始化以后的 const 变量。 编译器不会假设 volatile变量不被某些外部代理（如，一个硬件更新）改 变。restrict 限定的指针是访问它所指向内存的唯一方式（在特定作用域 中）。 属性 const int joy = 101;声明创建了变量joy，它的值被初始化为 101 。 volatile unsigned int incoming;声明创建了变量incoming，该变量在程序中 两次出现之间，其值可能会发生改变。 const int * ptr = \u0026amp;joy;声明创建了指针ptr，该指针不能用来改变变量joy的 值，但是它可以指向其他位置。 int * const ptr = \u0026amp;joy;声明创建了指针ptr，不能改变该指针的值，即ptr只 能指向joy，但是可以用它来改变joy的值。 void simple (const char * s);声明表明形式参数s被传递给simple()的值初始 化后，simple()不能改变s指向的值。 void supple(int * const pi);与void supple(int pi[const]);等价。这两个声明 都表明supple()函数不会改变形参pi。 void interleave(int * restrict p1, int * restrict p2, int n);声明表明p1和p2是访 问它们所指向内存的唯一方法，这意味着这两个块不能重叠。\nB.4 参考资料 IV ：表达式、语句和程序流 # B.4.1 总结：表达式和语句 # 在C语言中，对表达式可以求值，通过语句可以执行某些行为。 # 表达式 # 表达式由运算符和运算对象组成。最简单的表达式是一个常量或一个不 # 带运算符的变量，如 22 或beebop。稍复杂些的例子是55 + 22和vap = 2 * (vip + (vup = 4))。 语句 大部分语句都以分号结尾。以分号结尾的表达式都是语句，但这样的语 句不一定有意义。语句分为简单语句和复合语句。简单语句以分号结尾，如 下所示： toes = 12; // 赋值表达式语句 printf(\u0026quot;%d\\n\u0026quot;, toes); // 函数调用表达式语句 ; //空语句，什么也不做 （注意，在C语言中，声明不是语句。） 用花括号括起来的一条或多条语句是复合语句或块。如下面的while语 句所示： while (years \u0026lt; 100) { wisdom = wisdom + 1; printf(\u0026quot;%d %d\\n\u0026quot;, years, wisdom);\nyears = years + 1; } B.4.2 总结： while 语句 关键字 while语句的关键字是while。 一般注释 while语句创建了一个循环，在expression为假之前重复执行。while语句 是一个入口条件循环，在下一轮迭代之前先确定是否要再次循环。因此可能 一次循环也不执行。statement可以是一个简单语句或复合语句。 形式 while ( expression ) statement 当expression为假（或 0 ）之前，重复执行statement部分。 示例 while (n++ \u0026lt; 100) printf(\u0026quot; %d %d\\n\u0026quot;,n, 2*n+1); while (fargo \u0026lt; 1000) { fargo = fargo + step; step = 2 * step;\n} # B.4.3 总结： for 语句 关键字 for语句的关键字是for。 一般注释 for语句使用 3 个控制表达式控制循环过程，分别用分号隔开。initialize 表达式在执行for语句之前只执行一次；然后对test表达式求值，如果表达式 为真（或非零），执行循环一次；接着对update表达式求值，并再次检查test 表达式。for语句是一种入口条件循环，即在执行循环之前就决定了是否执 行循环。因此，for循环可能一次都不执行。statement部分可以是一条简单语 句或复合语句。 形式： for ( initialize; test; update ) statement 在test为假或 0 之前，重复执行statement部分。 C99允许在for循环头中包含声明。变量的作用域和生命期被限制在for循 环中。 示例： for (n = 0; n \u0026lt; 10 ; n++) printf(\u0026quot; %d %d\\n\u0026quot;, n, 2 * n + 1); for (int k = 0; k \u0026lt; 10 ; ++k) // C99\nprintf(\u0026quot;%d %d\\n\u0026quot;, k, 2 * k+1); B.4.4 总结： do while 语句 关键字 do while语句的关键字是do和while。 一般注解： do while语句创建一个循环，在expression为假或 0 之前重复执行循环体 中的内容。do while语句是一种出口条件循环，即在执行完循环体后才根据 测试条件决定是否再次执行循环。因此，该循环至少必须执行一次。 statement部分可是一条简单语句或复合语句。 形式： do statement while ( expression ); 在test为假或 0 之前，重复执行statement部分。 示例： do scanf(\u0026quot;%d\u0026quot;, \u0026amp;number); while (number != 20); B.4.5 总结： if 语句 小结：用 if 语句进行选择\n关键字： if 、 else 一般注解： 下面各形式中，statement可以是一条简单语句或复合语句。表达式为真 说明其值是非零值。 形式 1 ： if (expression) statement 如果expression为真，则执行statement部分。 形式 2 ： if (expression) statement1 else statement2 如果expression为真，执行statement1部分；否则，执行statement2部分。 形式 3 ： if (expression1) statement1 else if (expression2) statement2\nelse statement3 如果expression1为真，执行statement1部分；如果expression2为真，执行 statement2部分；否则，执行statement3部分。 示例： if (legs == 4) printf(\u0026ldquo;It might be a horse.\\n\u0026rdquo;); else if (legs \u0026gt; 4) printf(\u0026ldquo;It is not a horse.\\n\u0026rdquo;); else /* 如果legs \u0026lt; 4 */ { legs++; printf(\u0026ldquo;Now it has one more leg.\\n\u0026rdquo;); } B.4.6 带多重选择的 switch 语句 关键字： switch 一般注解： 程序控制根据expression的值跳转至相应的case标签处。然后，程序流执 行剩下的所有语句，除非执行到break语句进行重定向。expression和case标 签都必须是整数值（包括char类型），标签必须是常量或完全由常量组成的\n表达式。如果没有case标签与expression的值匹配，控制则转至标有default的 语句（如果有的话）；否则，控制将转至紧跟在switch语句后面的语句。控 制转至特定标签后，将执行switch语句中其后的所有语句，除非到达switch 末尾，或执行到break语句。 形式： switch ( expression ) { case label1 : statement1//使用break跳出switch case label2 : statement2 default : statement3 } 可以有多个标签语句，default语句可选。 示例： switch (value) { case 1 : find_sum(ar, n); break; case 2 : show_array(ar, n); break; case 3 : puts(\u0026ldquo;Goodbye!\u0026rdquo;);\nbreak; default : puts(\u0026ldquo;Invalid choice, try again.\u0026rdquo;); break; } switch (letter) { case \u0026lsquo;a\u0026rsquo; : case \u0026rsquo;e\u0026rsquo; : printf(\u0026quot;%d is a vowel\\n\u0026quot;, letter); case \u0026lsquo;c\u0026rsquo; : case \u0026rsquo;n\u0026rsquo; : printf(\u0026quot;%d is in \u0026quot;cane\u0026quot;\\n\u0026quot;, letter); default : printf(\u0026ldquo;Have a nice day.\\n\u0026rdquo;); } 如果letter的值是\u0026rsquo;a\u0026rsquo;或\u0026rsquo;e\u0026rsquo;，就打印这 3 条消息；如果letter的值是\u0026rsquo;c\u0026rsquo;或\u0026rsquo;n\u0026rsquo;，则 只打印后两条消息；letter是其他值时，值打印最后一条消息。 B.4.7 总结：程序跳转 关键字： break 、 continue 、 goto 一般注解： 这 3 种语句都能使程序流从程序的一处跳转至另一处。 break语句：\n所有的循环和switch语句都可以使用break语句。它使程序控制跳出当前 循环或switch语句的剩余部分，并继续执行跟在循环或switch后面的语句。 示例： while ((ch = getchar()) != EOF) { putchar(ch); if (ch == \u0026rsquo; \u0026lsquo;) break; // 结束循环 chcount++; } continue语句： 所有的循环都可以使用continue语句，但是switch语句不行。continue语 句使程序控制跳出循环的剩余部分。对于while或for循环，程序执行到 continue语句后会开始进入下一轮迭代。对于do while循环，对出口条件求值 后，如有必要会进入下一轮迭代。 示例： while ((ch = getchar()) != EOF) { if (ch == \u0026rsquo; \u0026lsquo;) continue; // 跳转至测试条件\nputchar(ch); chcount++; } 以上程序段打印用户输入的内容并统计非空格字符 goto语句： goto语句使程序控制跳转至相应标签语句。冒号用于分隔标签和标签语 句。标签名遵循变量命名规则。标签语句可以出现在goto的前面或后面。 形式： goto label ;\nlabel : statement 示例： top : ch = getchar(); if (ch != \u0026#39;y\u0026#39;) goto top; B.5 参考资料 V ：新增 C99 和 C11 的 ANSI C 库 # ANSI C库把函数分成不同的组，每个组都有相关联的头文件。本节将 # 概括地介绍库函数，列出头文件并简要描述相关的函数。文中会较详细地介 # 绍某些函数（例如，一些I/O函数）。欲了解完整的函数说明，请参考具体 # 实现的文档或参考手册，或者试试这个在线参考： # http://www.acm.uiuc.edu/webmonkeys/book/c_guide/。 B.5.1 断言： assert.h assert.h 头文件中把 assert()定义为一个宏。在包含 assert.h 头文件之前定 义宏标识符NDEBUG，可以禁用assert()宏。通常用一个关系表达式或逻辑表 达式作为assert()的参数，如果运行正常，那么程序在执行到该点时，作为参 数的表达式应该为真。表B.5.1描述了assert()宏。 表B.5.1 断言宏\nC11新增了static_assert宏，展开为_Static_assert。_Static_assert是一个关 键字，被认为是一种声明形式。它以这种方式提供一个编译时检查： _Static_assert( 常量表达式,字符串字面量); 如果对常量表达式求值为 0 ，编译器会给出一条包含字符串字面量的错 误消息；否则，没有任何效果。 B.5.2 复数： complex.h （ C99 ） C99 标准支持复数计算，C11 进一步支持了这个功能。实现除提供 _Complex 类型外还可以选择是否提供_Imaginary类型。在C11中，可以选择 是否提供这两种类型。C99规定，实现必须提供_Complex类型，但是 _Imaginary类型为可选，可以提供或不提供。附录B的参考资料VIII中进一步\n讨论了C如何支持复数。complex.h头文件中定义了表B.5.2所列的宏。 表B.5.2 complex.h宏\n对于实现复数方面，C和C++不同。C通过complex.h头文件支持，而 C++通过complex头文件支持。而且，C++使用类来定义复数类型。 可以使用STDC CX_LIMITED_RANGE编译指令来表明是使用普通的数 学公式（设置为on时），还是要特别注意极值（设置为off时）： #include \u0026lt;complex.h\u0026gt; #pragma STDC CX_LIMITED_RANGE on 库函数分为 3 种：double、float、long double。表B.5.3列出了double版本 的函数。float和long double版本只需要在函数名后面分别加上f和l。即csinf() 就是csin()的float版本，而csinl()是csin()的long double版本。另外要注意，角 度的单位是弧度。 表B.5.3 复数函数\n续表 B.5.3 字符处理： ctype.h 这些函数都接受int类型的参数，这些参数可以表示为unsigned char类型 的值或EOF。使用其他值的效果是未定义的。在表B.5.4中，“真”表示“非 0 值”。对一些定义的解释取决于当前的本地设置，这些由locale.h中的函数来 控制。该表显示了在解释本地化的“C”时要用到的一些函数。 表B.5.4 字符处理函数\nB.5.4 错误报告： errno.h errno.h头文件支持较老式的错误报告机制。该机制提供一个标识符（或 有时称为宏）ERRNO可访问的外部静态内存位置。一些库函数把一个值放 进这个位置用于报告错误，然后包含该头文件的程序就可以通过查看 ERRNO的值检查是否报告了一个特定的错误。ERRNO机制被认为不够艺 术，而且设置ERRNO值也不需要数学函数了。标准提供了 3 个宏值表示特殊 的错误，但是有些实现会提供更多。表B.5.5列出了这些标准宏。 表B.5.5 errno.h宏\nB.5.5 浮点环境： fenv.h （ C99 ） C99标准通过fenv.h头文件提供访问和控制浮点环境。 浮点环境（floating-point environment）由一组状态标志（status flag）和 控制模式（control mode）组成。在浮点计算中发生异常情况时（如，被零 除），可以“抛出一个异常”。这意味着该异常情况设置了一个浮点环境标 志。控制模式值可以进行一些控制，例如控制舍入的方向。fenv.h头文件定 义了一组宏表示多种异常情况和控制模式，并提供了与环境交互的函数原 型。头文件还提供了一个编译指令来启用或禁用访问浮点环境的功能。 下面的指令开启访问浮点环境： #pragma STDC FENV_ACCESS on 下面的指令关闭访问浮点环境： #pragma STDC FENV_ACCESS off 应该把该编译指示放在所有外部声明之前或者复合块的开始处。在遇到 下一个编译指示之前、或到达文件末尾（外部指令）、或到达复合语句的末 尾（块指令），当前编译指示一直有效。 头文件定义了两种类型，如表B.5.6所示。 表B.5.6 fenv.h类型\n头文件定义了一些宏，表示一些可能发生的浮点异常情况控制状态。其 # 他实现可能定义更多的宏，但是必须以FE_开头，后面跟大写字母。表B.5.7 # 列出了一些标准异常宏。 # 表B.5.7 fenv.h中的标准异常宏 表B.5.8中列出了fenv.h头文件中的标准函数原型。注意，常用的参数值 和返回值与表B.5.7中的宏相对应。例如，FE_UPWARD是fesetround()的一个 合适参数。 表B.5.8 fenv.h中的标准函数原型\nB.5.6 浮点特性： float.h float.h头文件中定义了一些表示各种限制和形参的宏。表B.5.9列出了这 些宏，C11新增的宏以斜体并缩进标出。许多宏都涉及下面的浮点表示模 # 型： # 如果第 1 个数f 1 是非 0 （且x是非 0 ），该数字被称为标准化浮点数。附录 B的参考资料VIII中将更详细地解释一些宏。 表B.5.9 float.h宏\n1 FLT_RADIX用于表示 3 种浮点数类型的基数。——译者注 续表 B.5.7 整数类型的格式转换： inttypes.h\n该头文件定义了一些宏可用作转换说明来扩展整数类型。参考资料 # VI“扩展的整数类型”将进一步讨论。该头文件还声明了这个类型： # imaxdiv_t。这是一个结构类型，表示idivmax()函数的返回值。 该头文件中还包含 stdint.h，并声明了一些使用最大长度整数类型的函 数，这种整数类型在stdint.h中声明为intmax。表B.5.10列出了这些函数。 表B.5.10 使用最大长度整数的函数\nB.5.8 可选拼写： iso646.h 该头文件提供了 11 个宏，扩展了指定的运算符，如表B.5.11所列。 表B.5.11 可 选 拼写 B.5.9 本地化： locale.h 本地化是一组设置，用于控制一些特定的设置项，如表示小数点的符 # 号。本地值储存在struct lconv类型的结构中，定义在 locale.h 头文件中。可 以用一个字符串来指定本地化，该字符串指定了一组结构成员的特殊值。默 认的本地化由字符串\u0026quot;C\u0026quot;指定。表 B.5.12 列出了本地化函数，后面做了简要 说明。 表B.5.12 本地化函数\nsetlocale()函数的locale形参所需的值可能是默认值\u0026quot;C\u0026quot;，也可能是\u0026quot;\u0026quot;，表 示实现定义的本地环境。实现可以定义更多的本地化设置。category形参的 值可能由表B.5.13中所列的宏表示。 表B.5.13 category宏\n表B.5.14列出了struct lconv结构所需的成员。 表B.5.14 struct lcconv所需的成员 续表\nB.5.10 数学库： math.h C99为math.h头文件定义了两种类型：float_t和double_t。这两种类型分 别与float和double类型至少等宽，是计算float和double时效率最高的类型。 该头文件还定义了一些宏，如表B.5.15所列。该表中除了HUGE_VAL 外，都是C99新增的。在参考资料VIII：“C99数值计算增强”中会进一步详细 介绍。 表B.5.15 math.h宏\n续表 数学函数通常使用double类型的值。C99新增了这些函数的float和long double版本，其函数名为分别在原函数名后添加f后缀和l后缀。例如，C语言 现在提供这些函数原型： double sin(double); float sinf(float); long double sinl(long double); 篇幅有限，表B.5.16仅列出了数学库中这些函数的double版本。该表引 用了FLT_RADIX，该常量定义在float.h中，代表内部浮点表示法中幂的底 数。最常用的值是 2 。 表B.5.16 ANSI C标准数学函数\n续表 续表\n1 NaN 分为两类：quite NaN 1 ，而和 singaling NaNsingaling NaN最高位定义为。两者的区别是： 0 。——quite NaN 译者注的尾数部分最高位定义为 续表\nB.5.11 非本地跳转： setjmp.h setjmp.h 头文件可以让你不遵循通常的函数调用、函数返回顺序。 setjmp()函数把当前执行环境的信息（例如，指向当前指令的指针）储存在 jmp_buf类型（定义在setjmp.h头文件中的数组类型）的变量中，然后 longjmp()函数把执行转至这个环境中。这些函数主要是用来处理错误条件， 并不是通常程序流控制的一部分。表B.5.17列出了这些函数。 表B.5.17 setjmp.h中的函数\nB.5.12 信号处理： signal.h 信号（signal）是在程序执行期间可以报告的一种情况，可以用正整数 表示。raise()函数发送（或抛出）一个信号，signal()函数设置特定信号的响 应。 标准定义了一个整数类型：sig_atomic_t，专门用于在处理信号时指定 原子对象。也就是说，更新原子类型是不可分割的过程。 标准提供的宏列于表B.5.18中，它们表示可能的信号，可用作raise()和 signal()的参数。当然，实现也可以添加更多的值。 表B.5.18 信 号 宏\nsignal()函数的第 2 个参数接受一个指向void函数的指针，该函数有一个 int类型的参数，也返回相同类型的指针。为响应一个信号而被调用的函数称 为信号处理器（signal handler）。标准定义了 3 个满足下面原型的宏： void (*funct)(int); 表B.5.19列出了这 3 种宏。 表B.5.19 void (*f)(int)宏\n如果产生了信号sig，而且 func指向一个函数（参见表B.5.20中signal()原 型），那么大多数情况下先调用 signal(sig, SIG_DFL)把信号重置为默认设 置，然后调用(*func)(sig)。可以执行返回语句或调用abort()、exit()或 longjmp()来结束func指向的信号处理函数。 表B.5.20 信 号 函 数\nB.5.13 对齐： stdalign.h （ C11 ） stdalign.h头文件定义了 4 个宏，用于确定和指定数据对象的对齐属性。 表B.5.21中列出了这些宏，其中前两个创建的别名与C++的用法兼容。 # 表B.5.21 void (*f)(int)宏 B.5.14 可变参数： stdarg.h stdarg.h 头文件提供一种方法定义参数数量可变的函数。这种函数的原 型有一个形参列表，列表中至少有一个形参后面跟有省略号： void f1(int n, \u0026hellip;); /* 有效 / int f2(int n, float x, int k, \u0026hellip;);/ 有效 / double f3(\u0026hellip;); / 无效 */ 在下面的表中，parmN是省略号前面的最后一个形参的标识符。在上面 的例子中，第 1 种情况的parmN为n，第 2 种情况的parmN为k。 头文件中声明了va_lis类型表示储存形参列表中省略号部分的形参数据 对象。表B.5.22中列出了 3 个带可变参数列表的函数中用到的宏。在使用这 些宏之前要声明一个va_list类型的对象。 表B.5.22 可变参数列表宏\nB.5.15 原子支持： stdatomic.h （ C11 ） stdatomic.h和threads.h头文件支持并发编程。并发编程的内容超过了本 书讨论的范围，简单地说，stdatomic.h 头文件提供了创建原子操作的宏。编 程社区使用原子这个术语是为了强调不可分割的特性。一个操作（如，把一 个结构赋给另一个结构）从编程层面上看是原子操作，但是从机器语言层面 上看是由多个步骤组成。如果程序被分成多个线程，那么其中的线程可能读 或修改另一个线程正在使用的数据。例如，可以想象给一个结构的多个成员 赋值，不同线程给不同成员赋值。有了stdatomic.h头文件，就能创建这些可 以看作是不可分割的操作，这样就能保证线程之间互不干扰。 B.5.16 布尔支持： stdbool.h （ C99 ） stdbool.h头文件定义了 4 个宏，如表B.5.23所列。 表B.5.23 stdbool.h宏\nB.5.17 通用定义： stddef.h 该头文件定义了一些类型和宏，如表B.5.24和表B.5.25所列。 表B.5.24 stddef.h类型 表B.5.25 stddef.h宏 示例 # #include \u0026lt;stddef.h\u0026gt; struct car { char brand[30]; char model[30]; double hp; double price; }; int main(void) { size_t into = offsetof(struct car, hp); /* hp成员的偏移量 */ \u0026hellip; B.5.18 整数类型： stdint.h stdint.h头文件中使用typedef工具创建整数类型名，指定整数的属性。 stdint.h头文件包含在inttypes.h中，后者提供输入/输出函数调用的宏。参考资 料VI的“扩展的整数类型”中介绍了这些类型的用法。\n1. 精确宽度类型 # stdint.h头文件中用一组typedef标识精确宽度的类型。表B.5.26列出了它 们的类型名和大小。然而，注意，并不是所有的系统都支持其中的所有类 型。 表B.5.26 确切宽度类型\n2. 最小宽度类型 # 最小宽度类型保证其类型的大小至少是某数量位。表B.5.27列出了最小 # 宽度类型，系统中一定会有这些类型。 # 表B.5.27 最小宽度类型 3. 最快最小宽度类型 # 在特定系统中，使用某些整数类型比其他整数类型更快。为此，stdint.h 也定义了最快最小宽度类型，如表B.5.28所列，系统中一定会有这些类型。 # 表B.5.28 最快最小宽度类型 4. 最大宽度类型 # stdint.h 头文件还定义了最大宽度类型。这种类型的变量可以储存系统 中的任意整数值，还要考虑符号。表B.5.29列出了这些类型。 表B.5.29 最大宽度类型\n5. 可储存指针值的整数类型 # stdint.h头文件中还包括表B.5.30中所列的两种整数类型，它们可以精确 地储存指针值。也就是说，如果把一个void *类型的值赋给这种类型的变 量，然后再把该类型的值赋回给指针，不会丢失任何信息。系统可能不支持 这类型。 表B.5.30 可储存指针值的整数类型\n6. 已定义的常量 # stdint.h头文件定义了一些常量，用于表示该头文件中所定义类型的限定 值。常量都根据类型命名，即用_MIN或_MAX代替类型名中的_t，然后把所 有字母大写即得到表示该类型最小值或最大值的常量名。例如，int32_t类型 的最小值是INT32_MIN、unit_fast16_t的最大值是UNIT_FAST16_MAX。表 B.5.31总结了这些常量以及与之相关的intptr_t、unitptr_t、intmax_t和uintmax_t 类型，其中的N表示位数。这些常量的值应等于或大于（除非指明了一定要 等于）所列的值。 表B.5.31 整 型 常 量\n该头文件还定义了一些别处定义的类型使用的常量，如表B.5.32所示。 # 表B.5.32 其他整型常量 7. 扩展的整型常量 # stdin.h头文件定义了一些宏用于指定各种扩展整数类型。从本质上看， 这种宏是底层类型（即在特定实现中表示扩展类型的基本类型）的强制转 换。 把类型名后面的_t 替换成_C，然后大写所有的字母就构成了一个宏 名。例如，使用表达式UNIT_LEAST64_C(1000)后， 1000 就是unit_least64_t 类型的常量。 B.5.19 标准 I/O 库： stdio.h ANSI C标准库包含一些与流相关联的标准I/O函数和stdio.h头文件。表 B.5.33列出了ANSI中这些函数的原型和简介（第 13 章详细介绍过其中的一些 函数）。stdio.h头文件定义了FILE类型、EOF和NULL的值、标准I/O流 （stdin、stdout和stderr）以及标准I/O库函数要用到的一些常量。 表B.5.33 C标准I/O函数\n续表\nB.5.20 通用工具： stdlib.h ANSI C标准库在stdlib.h头文件中定义了一些实用函数。该头文件定义 了一些类型，如表B.5.34所示。 表B.5.34 stdlib.h中声明的类型\nstdlib.h头文件定义的常量列于表B.5.35中。 表B.5.35 stdlib.h中定义的常量\n表B.5.36列出了stdlib.h中的函数原型。 表B.5.36 通 用 工 具\n续表\n续表\n续表\nB.5.21 _Noreturn ： stdnoreturn.h stdnoreturn.h定义了noreturn宏，该宏展开为_Noreturn。 B.5.22 处理字符串： string.h string.h库定义了size_t类型和空指针要使用的NULL宏。string.h头文件提 供了一些分析和操控字符串的函数，其中一些函数以更通用的方式处理内 存。表B.5.37列出了这些函数。 表B.5.37 字符串函数\n续表\nstrtok()函数的用法有点不寻常，下面演示一个简短的示例。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { char data[] = \u0026quot; C is\\t too#much\\nfun!\u0026quot;; const char tokseps[] = \u0026quot; \\t\\n#\u0026quot;;/* 分隔符 / char * pt; puts(data); pt = strtok(data,tokseps); / 首次调用 / while (pt) / 如果pt是NULL，则退出 / { puts (pt); / 显示记号 / pt = strtok(NULL, tokseps);/ 下一个记号 */ } return 0; } 下面是该示例的输出： C is too#much fun!\nC # is too much fun! B.5.23 通用类型数学： tgmath.h （ C99 ） math.h和complex.h库中有许多类型不同但功能相似的函数。例如,下面 6 个都是计算正弦的函数： double sin(double); float sinf(float); long double sinl(long double); double complex csin(double complex); float csinf(float complex); long double csinl(long double complex); tgmath.h 头文件定义了展开为通用调用的宏，即根据指定的参数类型调 用合适的函数。下面的代码演示了使用sin()宏时，展开为正弦函数的不同形 式： #include \u0026lt;tgmath.h\u0026gt; \u0026hellip; double dx, dy;\nfloat fx, fy; long double complex clx, cly; dy = sin(dx); // 展开为dy = sin(dx) （函数） fy = sin(fx); // 展开为fy = sinf(fx) cly = sin(clx); // 展开为cly = csinl(clyx) tgmath.h头文件为 3 类函数定义了通用宏。第 1 类由math.h和complex.h中定 义的 6 个函数的变式组成，用l和f后缀和c前缀，如前面的sin()函数所示。在 这种情况下，通用宏名与该函数double类型版本的函数名相同。 第 2 类由math.h头文件中定义的 3 个函数变式组成，使用l和f后缀，没有 对应的复数函数（如，erf()）。在这种情况下，宏名与没有后缀的函数名相 同，如erf()。使用带复数参数的这种宏的效果是未定义的。 第 3 类由complex.h头文件中定义的 3 个函数变式组成，使用l和f后缀，没 有对应的实数函数，如cimag()。使用带实数参数的这种宏的效果是未定义 的。 表B.5.38列出了一些通用宏函数。 表B.5.38 通用数学函数\n在C11以前，编写实现必须依赖扩展标准才能实现通用宏。但是使用 # C11新增的_Generic表达式可以直接实现。 B.5.24 线程： threads.h （ C11 ） threads.h和stdatomic.h头文件支持并发编程。这方面的内容超出了本书 讨论的范围，简而言之，该头文件支持程序执行多线程，原则上可以把多个 线程分配给多个处理器处理。 B.5.25 日期和时间： time.h time.h定义了 3 个宏。第 1 个宏是表示空指针的NULL，许多其他头文件中 也定义了这个宏。第 2 个宏是CLOCKS_PER_SEC，该宏除以clock()的返回值 得以秒为单位的时间值。第 3 个宏（C11）是TIME_UTC，这是一个正整型常 量，用于指定协调世界时 [1]（即UTC）。该宏是timespec_get()函数的一个 可选参数。 UTC是目前主要世界时间标准，作为互联网和万维网的普通标准，广泛 应用于航空、天气预报、同步计算机时钟等各领域。 time.h头文件中定义的类型列在表B.5.39中。 表B.5.39 time.h中定义的类型\ntimespec结构中至少有两个成员，如表B.5.40所列。 表B.5.40 timespec结构中的成员 日历类型的各组成部分被称为分解时间（broken-down time）。表B.5.41 列出了struct tm结构中所需的成员。 表B.5.41 struct tm结构中的成员\n日历时间（calendar time）表示当前的日期和时间，例如，可以是从 1900 年的第 1 秒开始经过的秒数。本地时间（local time）指的是本地时区的 日历时间。表B.5.42列出了一些时间函数。 表B.5.42 时 间 函 数\n续表 表B.5.43列出了strftime()函数中使用的转换说明。其中许多替换的值 （如，月份名）都取决于当前的本地化设置。 表B.5.43 strftime()函数中使用的转换说明\n续表\nB.5.26 统一码工具： uchar.h （ C11 ） C99 的 wchar.h 头文件提供两种途径支持大型字符集。C11 专门针对统 一码（Unicode）新增了适用于UTF-16和UTF-32编码的类型（见表 B.5.44）。 表B.5.44 uchar.h中声明的类型\n该头文件中还声明了一些多字节字符串与char16_t、char32_t格式相互转 换的函数（见表B.5.45）。 表B.5.45 宽字符与多字节转换函数\n续表 B.5.27 扩展的多字节字符和宽字符工具： wchar.h （ C99 ） 每种实现都有一个基本字符集，要求C的char类型足够宽，以便能处理 这个字符集。实现还要支持扩展的字符集，这些字符集中的字符可能需要多 字节来表示。可以把多字节字符与单字节字符一起储存在普通的 char 类型 数组，用特定的字节值指定多字节字符本身及其大小。如何解释多字节字符 取决于移位状态（shift state）。在最初的移位状态中，单字节字符保留其通 常的解释。特殊的多字节字符可以改变移位状态。除非显式改变特定的移位 状态，否则移位状态一直保持有效。 wchar_t类型提供另一种表示扩展字符的方法，该类型足够宽，可以表 示扩展字符集中任何成员的编码。用这种宽字符类型来表示字符时，可以把 单字符储存在wchar_t类型的变量中，把宽字符的字符串储存在wchar_t类型 的数组中。字符的宽字符表示和多字节字符表示不必相同，因为后者可能使 用前者并不使用的移位状态。 wchar.h 头文件提供了一些工具用于处理扩展字符的两种表示法。该头 文件中定义的类型列在表B.5.46中（其中有些类型也定义在其他的头文件 中）。 表B.5.46 wchar.h中定义的类型\nwchar.h头文件中还定义了一些宏，如表B.5.47所列。 表B.5.47 wchar.h中定义的宏 该库提供的输入/输出函数类似于stdio.h中的标准输入/输出函数。在标 准I/O函数返回EOF的情况中，对应的宽字符函数返回WEOF。表B.5.48中列 出了这些函数。 表B.5.48 宽字符I/O函数\n有一个宽字符I/O函数没有对应的标准I/O函数： # int fwide(FILE *stream, int mode)[2]; 如果mode为正，函数先尝试把形参表示的流指定为宽字符定向（wide- charaacter oriented）；如果 mode为负，函数先尝试把流指定为字节定向 （byte oriented）；如果 mode为 0 ，函数则不改变流的定向。该函数只有在 流最初无定向时才改变其定向。在以上所有的情况中，如果流是宽字符定 向，函数返回正值；如果流是字节定向，函数返回负值；如果流没有定向， 函数则返回 0 。 wchar.h 头文件参照 string.h，也提供了一些转换和控制字符串的函数。 一般而言，用 wcs 代替sting.h中的str标识符，这样wcstod()就是strtod()函数 的宽字符版本。表B.5.49列出了这些函数。\n表B.5.49 宽字符字符串工具 续表 该头文件还参照time.h头文件中的strtime()函数，声明了一个时间函数： size_t wcsftime(wchar_t * restrict s, size_t maxsize,const wchar_t * restrict format,\nconst struct tm * restrict timeptr); 除此之外，该头文件还声明了一些用于宽字符字符串和多字节字符相互 转换的函数，如表B.5.50所列。 表B.5.50 宽字节和多字节字符转换函数\n续表 B.5.28 宽字符分类和映射工具： wctype.h （ C99 ） wctype.h 库提供了一些与 ctype.h 中的字符函数类似的宽字符函数，以 及其他函数。wctype.h还定义了表B.5.51中列出的 3 种类型和宏。 表B.5.51 wctpe.h中定义的类型和宏\n在该库中，如果宽字符参数满足字符分类函数的条件时，函数返回真 # （非 0 ）。一般而言，因为单字节字符对应宽字符，所以如果 ctype.h 中对应 的函数返回真，宽字符函数也返回真。表 B.5.52 列出了这些函数。 表B.5.52 宽字节分类函数\n该库还包含两个可扩展的分类函数，因为它们使用当前本地化的 # LC_CTYPE值进行分类。表B.5.53列出了这些函数。 # 表B.5.53 可扩展的宽字符分类函数 wctype()函数的有效参数名即是宽字符分类函数名去掉 isw 前缀。例 如，wctype(\u0026ldquo;alpha\u0026rdquo;)表示的是 iswalpha()函数判断的字符类别。因此，调用 iswctype(wc, wctype(\u0026ldquo;alpha\u0026rdquo;))相当于调用iswalpha(wc)，唯一的区别是前者使 用LC_CTYPE类别进行分类。 该库还有 4 个与转换相关的函数。其中有两个函数分别与ctype.h库中 toupper()和tolower()相对应。第 3 个函数是一个可扩展的版本，通过本地化的 LC_CTYPE设置确定字符是大写还是小写。第 4 个函数为第 3 个函数提供合适 的分类参数。表B.5.54列出了这些函数。 表B.5.54 宽字符转换函数\nB.6 参考资料 VI ：扩展的整数类型 # 第 3 章介绍过，C99的inttypes.h头文件为不同的整数类型提供一套系统的 别名。这些名称与标准名称相比，能更清楚地描述类型的性质。例如，int类 型可能是 16 位、 32 位或 64 位，但是int32_t类型一定是 32 位。 更精确地说，inttypes.h头文件定义的一些宏可用于scanf()和printf()函数 中读写这些类型的整数。inttypes.h头文件包含的stdlib.h头文件提供实际的类 型定义。格式化宏可以与其他字符串拼接起来形成合适格式化的字符串。 该头文件中的类型都使用typedef定义。例如， 32 位系统的int可能使用这 样的定义： typedef int int32_t; 用#define指令定义转换说明。例如，使用之前定义的int32_t的系统可以 这样定义： #define PRId32 \u0026ldquo;d\u0026rdquo; // 输出说明符 #define SCNd32 \u0026ldquo;d\u0026rdquo; // 输入说明符 使用这些定义，可以声明扩展的整型变量、输入一个值和显示该值： int32_t cd_sales; // 32位整数类型 scanf(\u0026quot;%\u0026quot; SCNd32, \u0026amp;cd_sales); printf(\u0026ldquo;CD sales = %10\u0026rdquo; PRId32 \u0026quot; units\\n\u0026quot;, cd_sales); 如果需要，可以把字符串拼接起得到最终的格式字符串。因此，上面的 代码可以这样写： int cd_sales; // 32位整数类型\nscanf(\u0026quot;%d\u0026quot;, \u0026amp;cd_sales); printf(\u0026ldquo;CD sales = %10d units\\n\u0026rdquo;, cd_sales); 如果把原始代码移植到 16 位int的系统中，该系统可能把int32_t定义为 long，把PRId32定义为\u0026quot;ld\u0026quot;。但是，仍可以使用相同的代码，只要知道系统 使用的是 32 位整型即可。 该参考资料的其余部分列出了扩展类型、转换说明以及表示类型限制的 宏。 B.6.1 精确宽度类型 typedef标识了一组精确宽度的类型，通用形式是intN_t（有符号类型） 和uintN_t（无符号类型），其中N表示位数（即类型的宽度）。但是要注 意，不是所有的系统都支持所有的这些类型。例如，最小可用内存大小是 16 位的系统就不支持int8_t和uint8_t类型。格式宏可以使用d或i表示有符号类 型，所以PRIi8和SCNi8都有效。对于无符号类型，可以使用o、x或u以获 得%o、%x或%X转换说明来代替%u。例如，可以使用PRIX32以十六进制格 式打印uint32_t类型的值。表B.6.1列出了精确宽度类型、格式说明符和最小 值、最大值。 表B.6.1 精确宽度类型\nB.6.2 最小宽度类型 # 最小宽度类型保证一种类型的大小至少是某位。这些类型一定存在。例 # 如，不支持 8 位单元的系统可以把int_least_8定义为 16 位类型。表B.6.2列出 了最小宽度类型、格式说明符和最小值、最大值。 表B.6.2 最小宽度类型\nB.6.3 最快最小宽度类型 # 对于特定的系统，用特定的整型更快。例如，在某些实现中 # int_least16_t可能是short，但是系统在进行算术运算时用int类型会更快些。 因此，inttypes.h还定义了表示为某位数的最快类型。这些类型一定存在。在 某些情况下，可能并未明确指定哪种类型最快，此时系统会简单地选择其中 的一种。表B.6.3列出了最快最小宽度类型、格式说明符和最小值、最大 值。 表B.6.3 最快最小宽度类型\nB.6.4 最大宽度类型 # 有些情况下要使用最大整数类型，表B.6.4列出了这些类型。实际上， # 由于系统可能会提供比所需类型更大宽度的类型，因此这些类型的宽度可能 # 比long long或unsigned long long更大。 表B.6.4 最大宽度类型\nB.6.5 可储存指针值的整型 # inttypes.h头文件（通过包含stdint.h即可包含该头文件）定义了两种整数 类型，可精确地储存指针值，见表B.6.5。 表B.6.5 可储存指针值的整数类型\nB.6.6 扩展的整型常量 # 在整数后面加上L后缀可表示long类型的常量，如445566L。如何表示 int32_t类型的常量？要使用inttypes.h头文件中定义的宏。例如，表达式 INT32_C(445566)展开为一个int32_t类型的常量。从本质上看，这种宏相当 于把当前类型强制转换成底层类型，即特殊实现中表示int32_t类型的基本类 型。 宏名是把相应类型名中的_C 用_t 替换，再把名称中所有的字母大写。 例如，要把 1000 设置为unit_least64_t类型的常量，可以使用表达式 UNIT_LEAST64_C(1000)。\nB.7 参考资料 VII ：扩展字符支持 # C 语言最初并不是作为国际编程语言设计的，其字符的选择或多或少是 # 基于标准的美国键盘。但是，随着后来C在世界范围内越来越流行，不得不 # 扩展来支持不同且更大的字符集。这部分参考资料概括介绍了一些相关内 # 容。 # B.7.1 三字符序列 # 有些键盘没有C中使用的所有符号，因此C提供了一些由三个字符组成 # 的序列（即三字符序列）作为这些符号的替换表示。如表B.7.1所示。 # 表B.7.1 三字符序列 C替换了源代码文件中的这些三字符序列，即使它们在双引号中也是如 # 此。因此，下面的代码： # ??=include \u0026lt;stdio.h\u0026gt; ??=define LIM 100 int main() ??\u0026lt; int q??(LIM??); printf(\u0026#34;More to come.??/n\u0026#34;); ... ??\u0026gt; # 会变成这样： # #include \u0026lt;stdio.h\u0026gt; #define LIM 100 int main() { int q[LIM]; printf(\u0026ldquo;More to come.\\n\u0026rdquo;); \u0026hellip; } 当然，要在编译器中设置相关选项才能激活这个特性。 B.7.2 双字符 意识到三字符系统很笨拙，C99提供了双字符（digraph），可以使用它 们来替换某些标准C标点符号。 表B.7.2 双字符\n与三字符不同的是，不会替换双引号中的双字符。因此，下面的代码： # %:include \u0026lt;stdio.h\u0026gt; %:define LIM 100 int main() \u0026lt;% int q\u0026lt;:LIM:\u0026gt;; printf(\u0026ldquo;More to come.:\u0026gt;\u0026rdquo;); \u0026hellip; %\u0026gt; 会变成这样： #include \u0026lt;stdio.h\u0026gt; #define LIM 100 int main() { int q[LIM]; printf(\u0026ldquo;More to come.:\u0026gt;\u0026rdquo;); // :\u0026gt;是字符串的一部分 \u0026hellip; } // :\u0026gt;与 }相同 B.7.3 可选拼写： iso646.h 使用三字符序列可以把||运算符写成??!??!，这看上去比较混乱。C99 通 过iso646.h头文件（参考资料V中的表B.5.11）提供了可展开为运算符的宏。 C标准把这些宏称为可选拼写（alternative spelling）。 如果包含了iso646.h头文件，以下代码：\nif(x == M1 or x == M2) x and_eq 0XFF; 可展开为下面的代码： if(x == M1 || x == M2) x \u0026amp;= 0XFF; B.7.4 多字节字符 C 标准把多字节字符描述为一个或多个字节的序列，表示源环境或执行 环境中的扩展字符集成员。源环境指的是编写源代码的环境，执行环境指的 是用户运行已编译程序的环境。这两个环境不同。例如，可以在一个环境中 开发程序，在另一个环境中运行该程序。扩展字符集是C语言所需的基本字 符集的超集。 有些实现会提供扩展字符集，方便用户通过键盘输入与基本字符集不对 应的字符。这些字符可用于字符串字面量和字符常量中，也可出现在文件 中。有些实现会提供与基本字符集等效的多字节字符，可替换三字符和双字 符。 例如，德国的一个实现也许会允许用户在字符串中使用日耳曼元音变音 字符： puts(\u0026ldquo;eins zwei drei vier fünf\u0026rdquo;); 一般而言，程序可使用的扩展字符集因本地化设置而异。 B.7.5 通用字符名（ UCN ） 多字节字符可以用在字符串中，但是不能用在标识符中。C99新增了通 用字符名（UCN），允许用户在标识名中使用扩展字符集中的字符。系统扩 展了转义序列的概念，允许编码ISO/IEC 10646标准中的字符。该标准由国\n际标准化组织（ISO）和国际电工技术委员会（IEC）共同制定，为大量的 # 字符提供数值码。 10646 标准和统一码（Unicode）关系密切。 有两种形式的UCN序列。第 1 种形式是\\u hexquard，其中hexquard是一个 4 位的十六进制数序列（如，\\u00F6）。第 2 种形式是\\U hexquardhexquard， 如\\U0000AC01。因为十六进制每一位上的数对应 4 位，\\u形式可用于 16 位整 数表示的编码，\\U形式可用于 32 位整数表示的编码。 如果系统实现了UCN，而且包含了扩展字符集中所需的字符，就可以在 字符串、字符常量和标识符中使用UCN： wchar_t value\\u00F6\\u00F8 = L\u0026rsquo;\\u00f6\u0026rsquo;; 统一码和 ISO 10646 统一码为表示不同的字符集提供了一种解决方案，可以根据类型为大量 字符和符号制定标准的编号系统。例如，ASCII码被合并为统一码的子集， 因此美国拉丁字符（如A～Z）在这两个系统中的编码相同。但是，统一码 还合并了其他拉丁字符（如，欧洲语言中使用的一些字符）和其他语言中的 字符，包括希腊文、西里尔字母、希伯来文、切罗基文、阿拉伯文、泰文、 孟加拉文和形意文字（如中文和日文）。到目前为止，统一码表示的符号超 过了 110000 个，而且仍在发展中。欲了解更多细节，请查阅统一码联合站 点：www.unicode.org。 统一码为每个字符分配一个数字，这个数字称为代码点（code point）。典型的统一码代码点类似：U-222B。U表示该字符是统一字符， 222B是表示该字符的一个十六进制数，在这种情况下，表示积分号。 国际标准化组织（ISO）组建了一个团队开发ISO 10646和标准编码的多 语言文本。ISO 10646团队和统一码团队从 1991 年开始合作，一直保持两个 标准的相互协调。 B.7.6 宽字符\nC99为使用宽字符提供更多支持，通过wchar.h和wctype.h库包含了更多 大型字符集。这两个头文件把wchar_t定义为一种整型类型，其确切的类型 依赖实现。该类型用于储存扩展字符集中的字符，扩展字符集是是基本字符 集的超集。根据定义，char类型足够处理基本字符集，而wchar_t类型则需要 更多位才能储存更大范围的编码值。例如，char 可能是 8 位字节，wchar_t 可能是 16 位的 unsigned short。 用L前缀标识宽字符常量和字符串字面量，用%lc和%ls显示宽字符数 据： wchar_t wch = L\u0026rsquo;I\u0026rsquo;; wchar_t w_arr[20] = L\u0026quot;am wide!\u0026quot;; printf(\u0026quot;%lc %ls\\n\u0026quot;, wch, w_arr); 例如，如果把wchar_t实现为 2 字节单元，\u0026lsquo;I\u0026rsquo;的 1 字节编码应储存在wch的 低位字节。不是标准字符集中的字符可能需要两个字节储存字符编码。例 如，可以使用通用字符编码表示超出 char 类型范围的字符编码： wchar_t w = L\u0026rsquo;\\u00E2\u0026rsquo;; /* 16位编码值 */ 内含 wchar_t 类型值的数组可用于储存宽字符串，每个元素储存一个宽 字符编码。编码值为 0 的wchar_t值是空字符的wchar_t类型等价字符。该字 符被称为空宽字符（null wide character），用于表示宽字符串的结尾。 可以使用%lc和%ls读取宽字符： wchar_t wch1; wchar_t w_arr[20]; puts(\u0026ldquo;Enter your grade:\u0026rdquo;); scanf(\u0026quot;%lc\u0026quot;, \u0026amp;wch1);\nputs(\u0026ldquo;Enter your first name:\u0026rdquo;); scanf(\u0026quot;%ls\u0026quot;,w_arr); wchar_t头文件为宽字符提供更多支持，特别是提供了宽字符I/O函数、 宽字符转换函数和宽字符串控制函数。例如，可以用fwprintf()和wprintf()函 数输出，用fwscanf()和wscanf()函数输入。与一般输入/输出函数的主要区别 是，这些函数需要宽字符格式字符串，处理的是宽字符输入/输出流。例 如，下面的代码把信息作为宽字符显示： wchar_t * pw = L\u0026quot;Points to a wide-character string\u0026quot;; int dozen = 12; wprintf(L\u0026quot;Item %d: %ls\\n\u0026quot;, dozen, pw); 类似地，还有getwchar()、putwchar()、fgetws()和fputws()函数。wchar_t 头文件定义了一个WEOF宏，与EOF在面向字节的I/O中起的作用相同。该宏 要求其值是一个与任何有效字符都不对应的值。因为wchar_t类型的值都有 可能是有效字符，所以wchar_t库定义了一个wint_t类型，包含了所有wchar_t 类型的值和WEOF的值。 该库中还有与string.h库等价的函数。例如，wcscpy(ws1, ws2)把ws1指 定的宽字符串拷贝到ws2指向的宽字符数组中。类似地，wcscmp()函数比较 宽字符串，等等。 wctype.h头文件新增了字符分类函数，例如，如果iswdigit()函数的宽字 符参数是数字，则返回真；如果iswblank()函数的参数是空白，则返回真。 空白的标准值是空格和水平制表符，分别写作L\u0026rsquo;\u0026lsquo;和L\u0026rsquo;\\t\u0026rsquo;。 C11标准通过uchar.h头文件为宽字符提供更多支持，为匹配两种常用的 统一码格式，定义了两个新类型。第 1 种类型是char16_t，可储存一个 16 位编 码，是可用的最小无符号整数类型，用于hexquard UCN形式和统一码UTF-16 编码方案。\nchar16_t = \u0026lsquo;\\u00F6\u0026rsquo;; 第 2 种类型是char32_t，可储存一个 32 位编码，最小的可用无符号整数类 型，。可用于hexquard UCN形式和统一码UTF-32编码方案 char32_t = \u0026lsquo;\\U0000AC01\u0026rsquo;; 前缀u和U分别表示char16_t和char32_t字符串。 char16_t ws16[11] = u\u0026quot;Tannh\\u00E4user\u0026quot;; char32_t ws32[13] = U\u0026quot;caf\\U000000E9 au lait\u0026quot;; 注意，这两种类型比wchar_t类型更具体。例如，在一个系统中， wchar_t可以储存 32 位编码，但是在另一个系统中也许只能储存 16 位的编 码。另外，这两种新类型都与C++兼容。 B.7.7 宽字符和多字节字符 宽字符和多字节字符是处理扩展字符集的两种不同的方法。例如，多字 节字符可能是一个字节、两个字节、三个字节或更多字节，而所有的宽字符 都只有一个宽度。多字节字符可能使用移位状态（移位状态是一个字节，确 定如何解释后续字节）；而宽字符没有移位状态。可以把多字节字符的文件 读入使用标准输入函数的普通char类型数组，把宽字节的文件读入使用宽字 符输入函数的宽字节数组。 C99 在wchar.h库中提供了一些函数，用于多字节和宽字节之间的转换。 mbrtowc()函数把多字节字符转换为宽字符，wcrtomb()函数把宽字符转换为 多字节字符。类似地，mbstrtowcs()函数把多字节字符串转换为宽字节字符 串，wcstrtombs()函数把宽字节字符串转换为多字节字符串。 C11在uchar.h库中提供了一些函数，用于多字节和char16_t之间的转换， 以及多字节和char32_t之间的转换。\nB.8 参考资料 VIII ： C99/C11 数值计算增强 # 过去，FORTRAN是数值科学计算和工程计算的首选语言。C90使C的计 # 算方法更接近于FORTRAN。例如，float.h中使用的浮点特性规范都是基于 FORTRAN标准委员会开发的模型。C99和C11标准继续增强了C的计算能 力。例如，C99新增的变长数组（C11成为可选的特性），比传统的C数组更 符合FORTRAN的用法（如果实现不支持变长数组，C11指定了 __STDC_NO_VLA__宏的值为 1 ）。 B.8.1 IEC 浮点标准 国际电工技术委员会（IEC）已经发布了一套浮点计算的标准（IEC 60559 ）。该标 准包括了浮点数的格式、精度、NaN、无穷值、舍入规则、 转换、异常以及推荐的函数和算法等。C99纳入了该标准，将其作为C实现 浮点计算的指导标准。C99新增的大部分浮点工具（如，fenv.h头文件和一些 新的数学函数）都基于此。另外，float.h头文件定义了一些与IEC浮点模型 相关的宏。\n1. 浮点模型 下面简要介绍一下浮点模型。标准把浮点数x看作是一个基数的某次幂 乘以一个分数，而不是C语言的E记数法（例如，可以把876.54写成 0.87654E3）。正式的浮点表示更为复杂：\n简单地说，这种表示法把一个数表示为有效数（significand）与b的e次 幂的乘积。 下面是各部分的含义。 s代表符号（±1）。\nb代表基数。最常见的值是 2 ，因为浮点处理器通常使用二进制数学。 e代表整数指数（不要与自然对数中使用的数值常量e混淆），限制最小 值和最大值。这些值依赖于留出储存指数的位数。 fk代表基数为b时可能的数字。例如，基数为 2 时，可能的数字是 0 和 1 ； 在十六进制中，可能的数字是 0 ～F。 p代表精度，基数为b时，表示有效数的位数。其值受限于预留储存有效 数字的位数。 明白这种表示法的关键是理解float.h和fenv.h的内容。下面，举两个例子 解释内部如何表示浮点数。 首先，假设一个浮点数的基数b为 10 ，精度p为 5 。那么，根据上面的表 示法，24.51应写成：\n(+1)10^3 (2/10 + 4/100 + 5/1000 + 1/10000 + 0/100000) 假设计算机可储存十进制数（ 0 ～ 9 ），那么可以储存符号、指数 3 和 5 个 fk值： 2 、 4 、 5 、 1 、 0 （这里，f 1 是 2 ，f 2 是 4 ，等等）。因此，有效数是 0.24510，乘以 103 得24.51。 接下来，假设符号为正，基数b是 2 ，p是 7 （即，用 7 位二进制数表 示），指数是 5 ，待储存的有效数是 1011001 。下面，根据上面的公式构造该 数：\nx = (+1)2^5 (1/2 +0/4 + 1/8 + 1/16 + 0/32 + 0/64 + 1/128) = 32(1/2 +0/4 + 1/8 + 1/16 + 0/32 + 0/64 + 1/128) = 16 + 0 + 4 + 2 +0 + 0 + 1/4 = 22.25 float.h中的许多宏都与该浮点表示相关。例如，对于一个float类型的 值，表示基数的FLT_RADIX是b，表示有效数位数（基数为b时）的 FLT_MANT_DIG是p。\n2. 正常值和低于正常的值 正常浮点值（normalized floating-point value）的概念非常重要，下面简 要介绍一下。为简单起见，先假设系统使用十进制（b = FLT_RADIX = 10） 和浮点值的精度为 5 （p = FLT_MANT_DIG = 5）（标准要求的精度更高）。 考虑下面表示31.841的方式： 指数 = 3，有效数 = .31841（.31841E3） 指数 = 4，有效数 = .03184（.03184E4） 指数 = 5，有效数 = .00318（.00318E5） 显而易见，第 1 种方法精度最高，因为在有效数中使用了所有的 5 位可用 位。规范化浮点非零值是第 1 位有效位为非零的值，这也是通常储存浮点数 的方式。 现在，假设最小指数（FLT_MIN_EXP）是-10，那么最小的规范值是： 指数 = -10，有效数 = .10000（.10000E-10） 通常，乘以或除以 10 意味着使指数增大或减小，但是在这种情况下，如 果除以 10 ，却无法再减小指数。但是，可以改变有效数获得这种表示： 指数 = -10，有效数 = .01000（.01000E-10） 这个数被称为低于正常的（subnormal），因为该数并未使用有效数的 全精度。例如，0.12343E-10除以 10 得.01234E-10，损失了一位的信息。 对于这个特例，0.1000E-10 是最小的非零正常值（FLT_MIN），最小的 非零低于正常值是0.00001E-10（FLT_TRUE_MIN）。\nfloat.h中的宏FLT_HAS_SUBNURM、DBL_HAS_SUBNORM和 LDBL_HAS_SUBNORM表征实现如何处理低于正常的值。下面是这些宏可 能会用到的值及其含义： -1　不确定（尚未统一） 0　不存在（例如，实现可能会用 0 替换低于正常的值） 1　存在 math.h库提供一些方法，包括fpclassify()和isnormal()宏，可以识别程序 何时生成低于正常的值，这样会损失一些精度。\n3. 求值方案 float.h 中的宏 FLT_EVAL_METHOD 确定了实现采用何种浮点表达式的 求值方案，如下所示（有些实现还会提供其他负值选项）。 -1 不确定 0 对在所有浮点类型范围和精度内的操作、常量求值 1 对在 double 类型的精度内和 float、double 类型的范围内的操 作、常量求值，对 longdouble范围内的long double类型的操作、常量求值 2 对所有浮点类型范围内和long double类型精度内的操作和常 量求值 例如，假设程序中要把两个float类型的值相乘，并把乘积赋给第 3 个 float类型变量。对于选项 1 （即K\u0026amp;R C采用的方案），这两个float类型的值 将被扩展为double类型，使用double类型完成乘法计算，然后在赋值计算结 果时再把乘积转为float类型。\n如果选择 0 （即ANSI C采用的方案），实现将直接使用这两个float类型 的值相乘，然后赋值乘积。这样做比选项 1 快，但是会稍微损失一点精度。\n4. 舍入 float.h中的宏FLT_ROUNDS确定了系统如何处理舍入，其指定值所对应 的舍入方案如下所示。 -1　不确定 0　趋零截断 1　舍入到最接近的值 2　趋向正无穷 3　趋向负无穷 系统可以定义其他值，对应其他舍入方案。 一些系统提供控制舍入的方案，在这种情况下，fenv.h中的festround()函 数提供编程控制。 如果只是计算制作 37 个蛋糕需要多少面粉，这些不同的舍入方案可能并 不重要，但是对于金融和科学计算而言，这很重要。显然，把较高精度的浮 点值转换成较低精度值时需要使用舍入方案。例如，把double类型的计算结 果赋给float类型的变量。另外，在改变进制时，也会用到舍入方案。不同进 制下精确表示的分数不同。例如，考虑下面的代码： float x = 0.8; 在十进制下，8/10或4/5都可以精确表示0.8。但是大部分计算机系统都 以二进制储存结果，在二进制下，4/5表示为一个无限循环小数： 0.1100110011001100\u0026hellip;\n因此，在把0.8储存在x中时，将其舍入为一个近似值，其具体值取决于 使用的舍入方案。 尽管如此，有些实现可能不满足 IEC 60559 的要求。例如，底层硬件可 能无法满足要求。因此，C99定义了两个可用作预处理器指令的宏，检查实 现是否符合规范。第 1 个宏是_ STDC_IEC_559 ，如果实现遵循IEC 60559 浮点规范，该宏被定义为常量 1 。第 2 个宏是 STDC_IEC_559_COMPLEX _，如果实现遵循IEC 60559兼容复数运算，该 宏被定义为常量 1 。 如果实现中未定义这两个宏，则不能保证遵循IEC 60559。 B.8.2 fenv.h 头文件 fenv.h 头文件提供一些与浮点环境交互的方法。也就是说，允许用户设 置浮点控制模式值（该值管理如何执行浮点运算）并确定浮点状态标志（或 异常）的值（报告运算效果的信息）。例如，控制模式设置可指定舍入的方 案；如果运算出现浮点溢出则设置一个状态标志。设置状态标志的操作叫作 抛出异常。 状态标志和控制模式只有在硬件支持的前提下才能发挥作用。例如，如 果硬件没有这些选项，则无法更改舍入方案。 使用下面的编译指示开启支持： #pragma STDC FENV_ACCESS ON 这意味着程序到包含该编译指示的块末尾一直支持，或者如果该编译指 示是外部的，则支持到该文件或翻译单元的末尾。使用下面的编译指示关闭 支持： #pragma STDC FENV_ACCESS OFF 使用下面的编译指示可恢复编译器的默认设置，具体设置取决于实现：\n#pragma STDC FENV_ACCESS DEFAULT 如果涉及关键的浮点运算，这个功能非常重要。但是，一般用户使用的 程度有限，所以本附录不再深入讨论。 B.8.3 STDC FP_CONTRACT 编译指示 一些浮点数处理器可以把有多个运算符的浮点表达式合并成一个运算。 例如，处理器只需一步就求出下面表达式的值： x*y - z 这加快了运算速度，但是减少了运算的可预测性。STDC FP_CONTRACT 编译指示允许用户开启或关闭这个特性。默认状态取决于 实现。 为特定运算关闭合并特性，然后再开启，可以这样做： #pragma STDC FP_CONTRACT OFF val = x * y - z; #pragma STDC FP_CONTRACT ON B.8.4 math.h 库增补 大部分C90数学库中都声明了double类型参数和double类型返回值的函 数，例如： double sin(double); double sqrt(double); C99和C11库为所有这些函数都提供了float类型和long double类型的函 数。这些函数的名称由原来函数名加上f或l后缀构成，例如：\nfloat sinf(float); /* sin()的float版本 / long double sinl(long double); / sin()的long double版本 */ 有了这些不同精度的函数系列，用户可以根据具体情况选择最效率的类 型和函数组合。 C99还新增了一些科学、工程和数学运算中常用的函数。表B.5.16列出 了所有数学函数的double版本。在许多情况下，这些函数的返回值都可以使 用现有的函数计算得出，但是新函数计算得更快更精确。例如，loglp(x)表 示的值与与log(1 + x)相同，但是loglp(x)使用了不同的算法，对于较小的x值 而言计算更精确。因此，可以使用log()函数作普通运算，但是对于精确要求 较高且x值较小时，用loglp()函数更好。 除这些函数以外，数学库中还定义了一些常量和与数字分类、舍入相关 的函数。例如，可以把值分为无穷值、非数（NaN）、正常值、低于正常的 值、真零。[NaN是一个特别的值，用于表示一个不是数的值。例如， asin(2.0)返回NaN，因为定义了asin()函数的参数必须是-1～ 1 范围内的值。 低于正常的值是比使用全精度表示的最小值还要小的数。]还有一些专用的 比较函数，如果一个或多个参数是非正常值时，函数的行为与标准的关系运 算符不同。 使用C99的分类方案可以检测计算的规律性。例如，math.h中的 isnormal()宏，如果其参数是一个正常的数，则返回真。下面的代码使用该 宏在num不正常时结束循环： #include \u0026lt;math.h\u0026gt; // 为了使用isnormal() \u0026hellip; float num = 1.7e-19; float numprev = num;\nwhile (isnormal(num)) // 当num为全精度的float类型值 { numprev = num; num /= 13.7f; } 简而言之，数学库为更好地控制如何计算浮点数，提供了扩展支持。 B.8.5 对复数的支持 复数是有实部和虚部的数。实部是普通的实数，如浮点类型表示的数。 虚部表示一个虚数。虚数是-1的平方根的倍数。在数学中，复数通常写作类 似4.2 + 2.0i的形式，其中i表示-1的平方根。 C99支持 3 种复数类型（在C11中为可选）： float _Complex double _Complex long double _Compplex 例如，储存float _Complex类型的值时，使用与两个float类型元素的数组 相同的内存布局，实部值储存在第 1 个元素中，虚部值储存在第 2 个元素中。 C99和C11还支持下面 3 种虚类型： float _Imaginary double _Imaginary long double _Imaginary\n包含了complex.h头文件，就可以用complex代替_Complex，用imaginary 代替_Imaginary。 为复数类型定义的算术运算遵循一般的数学规则。例如，(a+bI) (c+dI)即是(ac-bd)+(bc+a*d)*I。 complex.h头文件定义了一些宏和接受复数参数并返回复数的函数。特 别是，宏I表示-1的平方根。因此，可以编写这样的代码： double complex c1 = 4.2 + 2.0 * I; float imaginary c2= -3.0 * I; C11提供了另一种方法，通过CMPLX()宏给复数赋值。例如，如果re和 im都是double类型的值，可以这样做： double complex c3 = CMPLX(re, im); 这种方法的目的是，宏在处理不常见的情况（如，im是无穷大或非数） 时比直接赋值好。 complex.h头文件提供了一些复数函数的原型，其中许多复数函数都有 对应math.h中的函数，其函数名即是对应函数名前加上c前缀。例如，csin() 返回其复数参数的复正弦。其他函数与特定的复数特性相关。例如，creal() 函数返回一个复数的实部，cimag()函数返回一个复数的虚部。也就是说， 给定一个double conplex类型的z，下面的代码为真： z = creal(z) + cimag(z) * I; 如果熟悉复数，需要使用复数，请详细阅读complex.h中的内容。 下面的示例演示了对复数的一些支持： // complex.c \u0026ndash; 复数\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;complex.h\u0026gt; void show_cmlx(complex double cv); int main(void) { complex double v1 = 4.0 + 3.0*I; double re, im; complex double v2; complex double sum, prod, conjug; printf(\u0026ldquo;Enter the real part of a complex number: \u0026ldquo;); scanf(\u0026quot;%lf\u0026rdquo;, \u0026amp;re); printf(\u0026ldquo;Enter the imaginary part of a complex number: \u0026ldquo;); scanf(\u0026quot;%lf\u0026rdquo;, \u0026amp;im); // CMPLX()是C11中的一个特性 // v2 = CMPLX(re, im); v2 = re + im * I; printf(\u0026ldquo;v1: \u0026ldquo;); show_cmlx(v1); putchar(\u0026rsquo;\\n\u0026rsquo;);\nprintf(\u0026ldquo;v2: \u0026ldquo;); show_cmlx(v2); putchar(\u0026rsquo;\\n\u0026rsquo;); sum = v1 + v2; prod = v1 * v2; conjug =conj(v1); printf(\u0026ldquo;sum: \u0026ldquo;); show_cmlx(sum); putchar(\u0026rsquo;\\n\u0026rsquo;); printf(\u0026ldquo;product: \u0026ldquo;); show_cmlx(prod); putchar(\u0026rsquo;\\n\u0026rsquo;); printf(\u0026ldquo;complex congjugate of v1: \u0026ldquo;); show_cmlx(conjug); putchar(\u0026rsquo;\\n\u0026rsquo;); return 0; } void show_cmlx(complex double cv) {\nprintf(\u0026rdquo;(%.2f, %.2fi)\u0026rdquo;, creal(cv), cimag(cv)); return; } 如果使用C++，会发现C++的complex头文件提供一种基于类的方式处理 复数，这与C的complex.h头文件使用的方法不同。\nB.9 参考资料 IX ： C 和 C++ 的区别 # 在很大程度上，C++是C的超集，这意味着一个有效的C程序也是一个 # 有效的C++程序。C和C++的主要区别是，C++支持许多附加特性。但是， # C++中有许多规则与 C 稍有不同。这些不同使得 C 程序作为C++程序编译时 # 可能以不同的方式运行或根本不能运行。本节着重讨论这些区别。如果使用 # C++的编译器编译C程序，就知道这些不同之处。虽然C和C++的区别对本书 # 的示例影响很小，但如果把C代码作为C++程序编译的话，会导致产生错误 # 的消息。 # C99标准的发布使得问题更加复杂，因为有些情况下使得C更接近 # C++。例如，C99标准允许在代码中的任意处进行声明，而且可以识别//注释 # 指示符。在其他方面，C99使其与C++的差异变大。例如，新增了变长数组 # 和关键字restrict。C11缩小了与C++的差异。例如，引进了char16_t类型，新 增了关键字_Alignas，新增了alignas宏与C++的关键字匹配。C11仍处于起步 阶段，许多编译器开发商甚至都没有完全支持C99。我们要了解C90、C99、 C11之间的区别，还要了解C++11与这些标准之间的区别，以及每个标准与C 标准之间的区别。这部分主要讨论C99、C11和C++之间的区别。当然， C++也正在发展，因此，C和C++的异同也在不断变化。 B.9.1 函数原型 在C++中，函数原型必不可少，但是在C中是可选的。这一区别在声明 一个函数时让函数名后面的圆括号为空，就可以看出来。在C中，空圆括号 说明这是前置原型，但是在C++中则说明该函数没有参数。也就是说，在 C++中，int slice();和int slice(void);相同。例如，下面旧风格的代码在C中可 以接受，但是在C++中会产生错误： int slice(); int main() {\n\u0026hellip; # slice(20, 50); } \u0026hellip; int slice(int a, int b) { \u0026hellip; } 在C中，编译器假定用户使用旧风格声明函数。在C++中，编译器假定 slice()与slice(void)相同，且未声明slice(int, int)函数。 另外，C++允许用户声明多个同名函数，只要它们的参数列表不同即 可。 B.9.2 char 常量 C把char常量视为int类型，而C++将其视为char类型。例如，考虑下面的 语句： char ch = \u0026lsquo;A\u0026rsquo;; 在C中，常量\u0026rsquo;A\u0026rsquo;被储存在int大小的内存块中，更精确地说，字符编码被 储存为一个int类型的值。相同的数值也储存在变量ch中，但是在ch中该值只 占内存的 1 字节。 在C++中，\u0026lsquo;A\u0026rsquo;和ch都占用 1 字节。它们的区别不会影响本书中的示例。 但是，有些C程序利用char常量被视为int类型这一特性，用字符来表示整数 值。例如，如果一个系统中的int是 4 字节，就可以这样编写C代码：\nint x = \u0026lsquo;ABCD\u0026rsquo;; /*对于int是 4 字节的系统，该语句出现在C程序中没问 题，但是出现在C++程序中会出错 */ \u0026lsquo;ABCD\u0026rsquo;表示一个 4 字节的int类型值，其中第 1 个字节储存A的字符编码， 第 2 个字节储存B的字符编码，以此类推。注意，\u0026lsquo;ABCD\u0026rsquo;和\u0026quot;ABCD\u0026quot;不同。前 者只是书写int类型值的一种方式，而后者是一个字符串，它对应一个 5 字节 内存块的地址。 考虑下面的代码： int x = \u0026lsquo;ABCD\u0026rsquo;; char c = \u0026lsquo;ABCD\u0026rsquo;; printf(\u0026quot;%d %d %c %c\\n\u0026rdquo;, x, \u0026lsquo;ABCD\u0026rsquo;, c, \u0026lsquo;ABCD\u0026rsquo;); 在我们的系统中，得到的输出如下： 1094861636 1094861636 D D 该例说明，如果把\u0026rsquo;ABCD\u0026rsquo;视为int类型，它是一个 4 字节的整数值。但 是，如果将其视为char类型，程序只使用最后一个字节。在我们的系统中， 尝试用%s转换说明打印\u0026rsquo;ABCD\u0026rsquo;会导致程序奔溃，因为\u0026rsquo;ABCD\u0026rsquo;的数值 （ 1094861636 ）已超出该类型可表示的范围。 可以这样使用的原因是C提供了一种方法可单独设置int类型中的每个字 节，因为每个字符都对应一个字节。但是，由于要依赖特定的字符编码，所 以更好的方法是使用十六进制的整型常量，因为每两位十六进制数对应一个 字节。第 15 章详细介绍过相关内容（C的早期版本不提供十六进制记法，这 也许是多字符常量技术首先得到发展的原因）。 B.9.3 const 限定符 在C中，全局的const具有外部链接，但是在C++中，具有内部链接。也 就是说，下面C++的声明：\nconst double PI = 3.14159; 相当于下面C中的声明： static const double PI = 3.14159; 假设这两条声明都在所有函数的外部。C++规则的意图是为了在头文件 更加方便地使用 const。如果const变量是内部链接，每个包含该头文件的文 件都会获得一份const变量的备份。如果const变量是外部链接，就必须在一 个文件中进行定义式声明，然后在其他文件中使用关键字 extern 进行引用式 声明。 顺带一提，C++可以使用关键字extern使一个const值具有外部链接。所 以两种语言都可以创建内部链接和外部链接的const变量。它们的区别在于 默认使用哪种链接。 另外，在C++中，可以用const来声明普通数组的大小： const int ARSIZE = 100; double loons[ARSIZE]; /* 在C++中，与double loons[100];相同 */ 当然，也可以在C99中使用相同的声明，不过这样的声明会创建一个变 长数组。 在C++中，可以使用const值来初始化其他const变量，但是在C中不能这 样做： const double RATE = 0.06; // C++和C都可以 const double STEP = 24.5; // C++和C都可以 const double LEVEL = RATE * STEP; // C++可以，C不可以 B.9.4 结构和联合\n声明一个有标记的结构或联合后，就可以在C++中使用这个标记作为类 # 型名： # struct duo { int a; int b; }; struct duo m; /* C和C++都可以 / duo n; / C不可以，C++可以*/ 结果是结构名会与变量名冲突。例如，下面的程序可作为C程序编译， 但是作为C++程序编译时会失败。因为C++把printf()语句中的duo解释成结构 类型而不是外部变量： #include \u0026lt;stdio.h\u0026gt; float duo = 100.3; int main(void) { struct duo { int a; int b;}; struct duo y = { 2, 4}; printf (\u0026quot;%f\\n\u0026rdquo;, duo); /* 在C中没问题，但是在C++不行 */ return 0;\n} # 在C和C++中，都可以在一个结构的内部声明另一个结构： # struct box { struct point {int x; int y; } upperleft; struct point lowerright; }; 在C中，随后可以使用任意使用这些结构，但是在C++中使用嵌套结构 时要使用一个特殊的符号： struct box ad; /* C和 C++都可以 / struct point dot; / C可以，C++不行 / box::point dot; / C不行，C++可以 / B.9.5 枚举 C++使用枚举比C严格。特别是，只能把enum常量赋给enum变量，然后 把变量与其他值作比较。不经过显式强制类型转换，不能把int类型值赋给 enum变量，而且也不能递增一个enum变量。下面的代码说明了这些问题： enum sample {sage, thyme, salt, pepper}; enum sample season; season = sage; / C和C++都可以 / season = 2; / 在C中会发出警告，在C++中是一个错误 */\nseason = (enum sample) 3; /* C和C++都可以*/ season++; /* C可以，在C++中是一个错误 / 另外，在C++中，不使用关键字enum也可以声明枚举变量： enum sample {sage, thyme, salt, pepper}; sample season; / C++可以，在C中不可以 / 与结构和联合的情况类似，如果一个变量和enum类型的同名会导致名 称冲突。 B.9.6 指向 void 的指针 C++可以把任意类型的指针赋给指向void的指针，这点与C相同。但是 不同的是，只有使用显式强制类型转换才能把指向void的指针赋给其他类型 的指针。下面的代码说明了这一点： int ar[5] = {4, 5, 6,7, 8}; int * pi; void * pv; pv = ar; / C和C++都可以 / pi = pv; / C可以，C++不可以 / pi = (int * ) pv; / C和C++都可以 */ C++与C的另一个区别是，C++可以把派生类对象的地址赋给基类指 针，但是在C中没有这里涉及的特性。 B.9.7 布尔类型\n在C++中，布尔类型是bool，而且ture和false都是关键字。在C中，布尔 类型是_Bool，但是要包含stdbool.h头文件才可以使用bool、true和false。 B.9.8 可选拼写 在C++中，可以用or来代替||，还有一些其他的可选拼写，它们都是关键 字。在C99和C11中，这些可选拼写都被定义为宏，要包含iso646.h才能使用 它们。 B.9.9 宽字符支持 在C++中，wchar_t是内置类型，而且wchar_t是关键字。在C99和C11 中，wchar_t类型被定义在多个头文件中（stddef.h、stdlib.h、wchar.h、 wctype.h）。与此类似，char16_t和char32_t都是C++11的关键字，但是在C11 中它们都定义在uchar.h头文件中。 C++通过iostream头文件提供宽字符I/O支持（wchar_t、char16_t和 char32_t），而 C99通过wchar.h头文件提供一种完全不同的I/O支持包。 B.9.10 复数类型 C++在complex头文件中提供一个复数类来支持复数类型。C有内置的复 数类型，并通过complex.h头文件来支持。这两种方法区别很大，不兼容。C 更关心数值计算社区提出的需求。 B.9.11 内联函数 C99支持了C++的内联函数特性。但是，C99的实现更加灵活。在 C++中，内联函数默认是内部链接。在 C++中，如果一个内联函数多次出现 在多个文件中，该函数的定义必须相同，而且要使用相同的语言记号。例 如，不允许在一个文件的定义中使用int类型形参，而在另一个文件的定义中 使用int32_t类型形参。即使用typedef把int32_t定义为int也不能这样做。但是 在C中可以这样做。另外，在第 15 章中介绍过，C允许混合使用内联定义和 外部定义，而C++不允许。\nB.9.12 C++11 中没有的 C99/C11 特性 # 虽然在过去C或多或少可以看作是C++的子集，但是C99标准增加了一 # 些C++没有的新特性。下面列出了一些只有C99/C11中才有的特性： # 指定初始化器； # 复合初始化器（Compound initializer）； 受限指针（Restricted pointer）（即，restric指针）； 变长数组； 伸缩型数组成员； 带可变数量参数的宏。 注意 以上所列只是在特定时期内的情况，随着时间的推移和 C、C++的不断 发展，列表中的项会有所增减。例如，C++14新增的一个特性就与C99的变 长数组类似。\n[1].文“Temps Universel Cordonné”也称为世界标准时间，简称而来。中国内地的时间与UTC，从英文“Coordinated Universal Time”/UTC的时差为+8，也法 就是UTC+8。——译者注 [2].——fwide()译者注函数用于设置流的定向，根据mode的不同值来执行不同的工作。\n"},{"id":1,"href":"/docs/Textbook/","title":"资料","section":"Docs","content":" 收录各类资料 # 如有侵权，请及时联系本人，以便后续删除 # "},{"id":2,"href":"/docs/Journal/access-speed/","title":"网站访问速度对照","section":"日志","content":" 网站访问速度对照 # 未配置CDN # Cloudflare CDN 免费方案 # Cloudflare for SaaS自选节点 # "},{"id":3,"href":"/docs/Documentation/","title":"文档","section":"Docs","content":" 收录各类文档 # 如有侵权，请及时联系本人，以便后续删除 # "},{"id":4,"href":"/docs/Fiction/","title":"小说","section":"Docs","content":" 收录各类小说 # 如有侵权，请及时联系本人，以便后续删除 # "},{"id":5,"href":"/docs/Fiction/%E5%88%80%E9%94%8B/","title":"刀锋 - 威廉·萨默赛特·毛姆","section":"小说","content":"《刀锋》\n译者序\n一把刀的锋刃很不容易越过；\n因此智者说得救之道是困难的。\n《迪托—奥义书》\n译者序\n威廉·萨默塞特·毛姆，英国现代著名小说家和剧作家，一八七四年一月生于巴黎英国大使馆。他的父亲劳伯特?奥蒙得?毛姆，当时在驻法英国大使馆任法律事务官。毛姆生下时，他父亲已有三个儿子，他是家庭中最小的成员。他八岁丧母，十岁丧父，因家中无人照顾，被送往坎特依叔父处居住。在他渡过英吉利海峡，第一次登上祖国的土地时，他简直不会讲什么英语。由于这个缘故，法语和法国文化一直影响着他。一八九七年，他因染上肺疾，被送往法国南方里维埃拉疗养，开始接触法国文学，特别是莫泊桑的作品。一八九一年，他去德国海德尔堡住了九个月，在大学里听过古谱?费希尔讲授叔本华的哲学和文学课；一八九二年，在伦敦圣托马斯医院学医；学医期间，曾赴伦敦兰贝斯贫民窟当了三个星期的助产士；这段经历使他动了写作的念头。一八九七年，他医科毕业，同时出版了他的第一部小说《兰贝斯的莉莎》。这部写贫民窟女子莉莎悲剧性结局的小说受到批评界的重视，特别是文坛耆宿艾德蒙?戈斯[注]的赞扬，使毛姆决心放弃行医，从事文学创作。\n他听了安德鲁?郎格[注]的错误劝告，为写历史小说而游历西班牙和意大利，但是，这期间写的小说和短篇很少成功。一九○三年回国后，他的剧本《正直的人》被戏剧学会搬上舞台，但并未引起重视。直到一九○七年，他的剧本才以《弗莱德理夫人》上演，首次获得成功；一九○八年，他竟有四部剧本同时在伦敦西城的剧院上演；伦敦的滑稽杂志《笨气》还为此登载了一幅漫画，画着莎士比亚看了墙上满贴着毛姆剧本上演的海报，带有恐惧的表情咬着拇指头。人们很容易会设想，经过这次意外成功，毛姆当会象肖伯纳一样以剧本写作为终生事业，但是，不然，他并没有放弃写小说的企图，而且在他的小说获得成功并在经济上使他得到生活保障之后，他于一九三三年反而放弃了剧本写作；然而，他不但从不反对自己的小说和短篇小说搬上银幕，而且还从中襄助。关于这一点，我们只能试行作这样的解释：一部小说或电影的成功取决于广大的读者或观众；评论家的毁誉可以起一点影响，但是，群众仍旧是决定性的。一个剧本的成功常要看上演时的卖座率，特别是第一晚演出后的舆论反映，而伦敦西城那些剧院的“第一晚”观众，也就是伦敦上流社会的交际界人士，一个剧本的生死，在相当大的程度上操在这类人的手里。毛姆的后半生，特别是在里维埃拉购买了一幢豪华住宅之后，虽则招待不少英国上层人士，甚至皇亲国戚，但对欧洲的上流交际界人士却有他的看法。他在《刀锋》中介绍醉心于欧洲交际社会生活的美国人艾略特?谈波登时，有这一段话：……以艾略特的机伶，决不会看不出那些应他邀请的人多只是混他一顿吃喝，有些是没脑子的，有些毫不足道。那些响亮的头衔引得他眼花缭乱，看不见一点他们的缺点。……这一切，归根结底，实起于一种狂热的浪漫思想；这使他在那些庸碌的小小法国公爵身上见到当年跟随圣路易到圣地去的十字军战士，在装腔作势、猎猎狐狸的英国伯爵身上见到他们在金锦原侍奉亨利八世的祖先。\n这一段话不妨说也代表了毛姆对这些上流社交人士的看法。他放弃戏剧的写作等于是对这些上流交际界的蔑视。\n一九一五年，毛姆的自传性小说《尘网》出版。一个在战争期间和他同住一卧室的达斯蒙德曾经亲眼看见毛姆审阅这部小说的校样；他把这部小说列为与班内特的《老妇故事》，海明威的《永别了，武器》，威尔斯的《吉普斯》同样经得起时间淘汰的现实主义小说；这个评价，除掉《永别了，武器》在时代上稍晚，不应列入外，对《尘网》是适当的，而且也为后来的许多评论家所承认。但是，后来竟有人认为《尘网》是毛姆唯一能在文学史上占一席地的小说，这就不对了。《尘网》虽然是在一次大战的第二年出版，但仍属于英国爱德华时代文学；它的构思是在一次大战前，但是，便在它问世的一九一五年，欧洲人对这次大战的认识和后来的认识是有很大的不同的。当时，英国人对战争的艰苦性大概认为与南非波尔战争差不多，不会动摇大英帝国的基础；法国尽管在作战开头时失利，但毕竟顶住了，绝不会料到这次战争对欧洲文明产生那样深远的影响。《尘网》是一部杰出小说，但不应视为毛姆的唯一代表作。毛姆应属于两次大战期间的代表作家，虽则他和海明威所代表的“迷惘的一代”有所不同。\n毛姆一生最喜欢游历。从他接受安德鲁?郎格的错误劝告开始，这个爱好一直持续到晚年，对他的写作生涯产生了无法估计的影响。在二十年代，他曾经漫游南海群岛，并在塔希提岛发现印象派画家高更画的窗板，回欧洲后便写了以高更为主角的《月亮和六便士》。他继续游历远东、美国、欧洲、北非等地，写的短篇小说、小说和游记都广受欢迎。二十年代末，他与结婚十年的妻子西里?威尔康姆离婚。\n一九二八年，在法国里维埃拉的法拉特角买下一幢曾属于比利时国王的别墅，继续写作。《寻欢作乐》以托马斯?哈代为蓝本，是他始终最喜爱的一部小说，但书中的主角却是一个随便与人发生关系的女子露西。我个人觉得它并不是一部成功的小说，但是，它的矛头所指，却是英国的那种清教徒的道德观。他对露西毫无指摘，但对书中那个预备为哈代写传的小说家（后来他承认是指与他同时的英国小说家休?沃波尔[注]）的讽刺，文笔却极为犀利。在书中，他还离开主题，和另一个小说家伊夫林?沃[注]争论用第一人称写小说的问题。沃认为用第一人称写小说是可鄙的，毛姆则认为人年事愈长，愈觉得对别人的理解不够，因此，只想从个人的角度来写自己所要写的人物。大约余怒未息，就在次年他出版了一部短篇小说集，即以《第一人称》为名。\n二次大战爆发后，毛姆由尼斯避难到英国，继而赴美国居住，直到战争结束后才返回里维埃拉的故居。在美国期间，他出版了《刀锋》（一九四四年四月，英国版晚三个月）；这是一部杰作，出版后不但受到广大读者欢迎，而且受到弗吉妮亚?伍尔芙夫人[注]那个严峻的批评家的称许。《总结》（一九三八）虽然带有自传性质，但主要是叙述他的相当实事求是但不随流俗的文学见解和人生哲学；这部书应和《一个作家的笔记本》（一九四四）作姊妹篇读。他死时九十一岁，造有一女。\n他的戏剧、小说和短篇小说有许多于他在世时都拍成电影；这在当代作家中也是少见的。\n由于童年在法国度过，青年时期在法国养过病，中年后又定居法国，并且经常旅行，毛姆可说是一个最没有英国气的英国作家。他的外祖母居孀之后，曾经带领两个女儿——大女儿就是毛姆的母亲——来法国以写小说和儿童文学谋生；毛姆好象不但继承了他外祖母的写作才能，而且继承了她的亲法国倾向。在《寻欢作乐》中，他曾经提到狄福、斯特恩、萨克雷、狄更斯、艾米丽?勃朗特和马塞尔?普鲁斯特这些小说家“在世时那样有名，但是，现在无疑已经被人忘却了”。这里面，除掉最后一个是法国人外，其余的都是英国小说家，而且是英国小说的半壁江山。\n他好象特别和狄更斯过不去。在《总结》中他写道，“现实主义是相对的。最现实主义的作家，由于兴趣的引导，常常歪曲自己的人物。他通过自己的眼睛看他们……才气越大，个性越强，他的人生图画越是光怪陆离。有时，我觉得，后代如果要知道今天的世界是什么样子，最好别去看那些独树一帜的作家，而去读那些平庸的作家，因为他们由于平庸，反而能把周围环境描写得更忠实。这些人我不想提他们的名，因为尽管后世肯定会欣赏他们，被标志为平庸总是不称心的事情。不过我觉得应当承认，人们在安东尼?特罗洛普的小说里，比在狄更斯的小说里更能看到真实的人生图画。”然而巴尔扎克、莫泊桑、司汤达对他的影响，他始终没有否认过。\n巴尔扎克的石子投入河中的比喻，他在《刀锋》中曾一再运用而不自觉。巴尔扎克小说中的一些人物，他提到时就象我们对《红楼梦》中的人物一样熟悉。他的短篇小说不但受莫泊桑的影响，而且为他赢得了“英国莫泊桑”的声誉。\n《刀锋》依旧是用第一人称写的，而且这个人干脆不再是作者惯用的阿辛登笔名，而是直接用了自己的真名实姓。小说写一个参加第一次大战的美国青年飞行员拉里?达雷尔。在军队中，拉里结识了一个爱尔兰好友：这人平时是那样一个生龙活虎般的置生死于度外的飞行员，但在一次遭遇战中，因趋救拉里而中弹牺牲。拉里因此对人生感到迷惘，弄不懂世界上为什么有恶和不幸（这也是毛姆在《总结》中提出过的）。复员后，拉里既不肯进大学，也不肯就业，一心想探求人生的终极。\n为此，他丢下未婚妻来到巴黎；两年后，和未婚妻解约，又从巴黎遍游世界各地，最后到了印度，找到了印度的吠陀经哲学。于是了悟人生，把自己的一点薄产分散给亲友，自己返回美国，当一个自食其力的出租汽车司机，打算隐身人海，以终天年。小说以拉里为中心，描绘了许多美国男女，有拉里的未婚妻，贪图物质享受的伊莎贝儿；有以买卖古董起家，一心想钻进上流交际社会的艾略特?谈波登；有头脑简单但心地忠厚的格雷?马图林，他原是百万富翁的独生子，但是一九二九年的经济大崩溃使他破了产，他是个只知道做生意发财的典型美国社会产物；有伊莎贝儿的同学，索菲?麦唐纳，因丈夫和儿子在车祸中丧命，被夫家放逐到巴黎来过着堕落的生活，终于被不逞之徒杀害；还有一个模特儿兼妓女的法国女子苏姗?鲁维埃，和拉里与作者都相识，最后和法国一个外地厂商结婚而得到生活保障。作者本人在书中也担任了一个重要角色；他既是演员，又是观众。背景多半是在法国，特别是巴黎。由于毛姆大半生是在法国度过的，而写作本书时，正因战争避地美国，所以写到巴黎时，特别流露出怀乡情绪，如写他在赴拉里约会之前，穿过卢森堡博物馆的公园时，描写园中游人的那一段回忆自己青年时期的描述，完全属于自叙性质，和小说毫无关系。又如第六章论述莱辛的《贝蕾妮丝》，都是离开主题发挥自己的文学见解。书中的主要角色除掉苏姗?鲁维埃外，全都是美国人，使人想起一句调侃美国人的谚语：“人死后进天堂，美国人死后去巴黎。”但是，他们最后都死的死了，回国的回国了，连苏姗?鲁维埃也嫁到外地去，如作者所说，“在我的生命中也消失了。”当然，这个小圈子里的人只占据作者生活的很少一部分，但我们仍不免兴一种落寞之感，仿佛作者是“珠箔飘灯独自归”。\n正如作者在小说中交代的，他这本书并不想“阐述所谓《奥义书》的哲学体系。”\n“我懂得太少了，但即使懂得很多，这也不是阐述《奥义书》的地方……我想的只是拉里。”在本书结尾时，他又说，“我是个俗人，是尘世中人；我只能对这类人中麟凤的光辉形象表示景慕，没法步他的后尘。”因此，他和克里斯朵夫?衣修午德[注]不同，并不打算向西方推荐吠陀经哲学，或者提倡人人都学拉里；单拿一点来说，不近女色，如果人人都象拉里那样奉行，岂不会造成灭种的灾祸！毛姆的道德观是如我国嵇康在《绝交书》中所主张的“四民有务，各得志为乐”。他把拉里捧得很高，但并不把艾略特?谈波登那个“大大的势利鬼”贬得很低。他对放浪形骸的索菲?麦唐纳只有同情，对当模特儿兼妓女的苏姗?鲁维埃能够有一个归宿感到欣幸，对头脑简单的格雷?马图林，在他的笔下绝少挖苦，而往往突出他的忠厚和慈爱，但对伊莎贝儿则毫不徇情地揭露她蓄意破坏索菲和拉里婚事的阴谋，尽管他很欣赏她的美，并且是她多年来的“知心”朋友。但他接着也写伊莎贝儿获悉拉里分散自己财产，并且返回美国预备当司机的消息后，伤心啜泣的情景，从而让读者自己对伊莎贝儿作出结论。不妨说，伊莎贝儿的用心是狠毒的，但是，她破坏的是一个本来不可能有好结果的婚姻，因为如果索菲连伊莎贝儿布置那点诱惑都抵御不了，拉里即使学会了瑜伽修道士的那点法力，能把她从自甘堕落的道路上拉得回转吗？\n尽管作者在本书开头声称，他几乎没有什么故事可述，但是，他仍旧充分运用了叙事的技巧，从而抓住读者的注意力。在翻译本书的过程中，我时常碰到这样的情形，即一面译，一面盘算着不知他对这种铺开的局面怎样收拾法。但是，使我佩服的是他笔头一转，很快就结束掉；例如在第二章末尾，当伊莎贝儿告诉作者自己和拉里解约的经过，以及作者给了伊莎贝儿忠告之后，他只用两三行文字就结束了他们精心策划的汉普顿宫之游：雨仍旧下个不停，我们认为不去看汉普顿宫那些华贵建筑，甚至伊丽莎白女王的床，伊莎贝儿也可以活下去，所以就坐车子回到伦敦。\n我想如果有个金圣叹的话，很可能在这一段后面插进一些双行批语：“随手收拾掉汉普顿宫，妙。盖汉普顿官之游不过是为了找个场合让伊莎贝儿能向作者倾吐胸臆，现在目的已达，再叙述作者领她游览汉普顿宫便是呆鸟矣。”\n但是，本书最成功的还是人物的塑造；不但几个主要人物写得非常成功，连些次要人物，如布雷德利太太，矿工考斯第，甚至土伦的警察局长，也都是有血有肉的人。小说从一九一九年开始，一直写到三十年代中期，人物的性格当然不可能没有发展和变化。索菲?麦唐纳和作者在芝加哥初次见到的腼腆少女判若两人，这不难做到；她自己的身世便是解释。伊莎贝儿经过嫁格雷后的纸醉金迷生活，继之以破产和二次来巴黎后依舅父艾略特居住，锻炼成她那样的尤物，作者是煞费了一番苦心的。艾略特?谈波登的变化基本上不大，只是一九二九年之后，排场变得阔绰了，但是，一直写到他临终前拿到爱德娜?诺维马里的请帖，亲自写那封口信之后，作者方才完成这幅社会名流的画像，真可以说是达到笔酣墨饱的地步。只有拉里?达雷尔自始至终好象变化不大，永远是那样一个闲云野鹤似的人物，使人疑心是不是取材自真实生活。可是，一九五九年，却被我无意中发现了拉里的蓝本，原来是剑桥大学新近逝世的哲学教授维特根斯坦。这位教授是奥地利人，在剑桥大学学工程学，偶然也研究一点哲学，听过罗素和摩尔的课，但颇能发挥自己的独特见解。\n第一次大战开始，维特根斯坦担任军官并论为俘虏；战后隐居奥国，当小学教师和修道院园丁。他的剑桥大学同学兰姆赛和布里斯威特在奥地利访求到他，力劝他重新把哲学抓起来，维特根斯坦于是跟当时的维也纳学派石里克等人稍稍往还；一九三○年，受聘为剑桥大学研究员。后来摩尔退休，维特根斯坦却继摩尔被任命为哲学教授。以一个外国人在英国的学术首府担当这个职务，可以说是殊荣，但维特根斯坦却引以为苦，经常劝他的学生不要在大学教书，尤其不能教哲学。一九四七年年纪不到六十就退职，一九五一年逝世。毛姆在一九四四年出版《刀锋》时，维特根斯坦还活着，所以作者在小说开头时说“书中角色的姓氏全都改过，并且务必写得使人认不出是谁，免得那些还活在世上的人看了不安。”但是，不管作者怎样改动，总有些蛛丝马迹可寻；举例说，小说开头叙述拉里在俱乐部图书室里死啃威廉?詹姆斯的《心理学原理》，而维特根斯坦讲课时绝不引用别的哲学家的话，但却时常提到威廉?詹姆斯；有一天，甚至告诉学生詹姆斯的《心理学原理》第××页讲的什么，使学生们听了都感觉诧异，这是一。其次，小说写拉里最后把自己的一点财产分散给人，维特根斯坦的父亲死后，留给他一笔很优渥的财产，维特根斯坦全拿来分给富有的亲朋，他的怪理由是富人得到才可以免受金钱的腐蚀，而小说中也没有提到拉里散金的对象是些什么人，这是二。还有，维特根斯坦平日绝少与人交往，凡是大学社交生活和哲学界各种活动都绝迹不参加，这和拉里不喜欢社交活动也有相似之处。根据这几方面的对照，再加上两人性格上的转变，都是因参加一次大战后开始的，可以断言小说中的拉里就是写的维特根斯坦。当然也有不尽相同之处，如拉里告诉伊莎贝儿他读希腊原文的《奥德修纪》所感到的兴奋，但是，维特根斯坦却是什么文学作品都不读，只看侦探小说。但是，毛姆在《总结》中曾讲过这样的话：“喜欢听故事和喜欢看跳舞和摹拟表演……同样是人性的自然倾向。\n从侦探小说的流行可以看出这种爱好至今不衰，连第一流的知识分子也看它们，当然并不当回事，可是的确看它们；为什么？还不是因为他们唯一放在眼里的那些心理的，教育的，精神分析的小说不能满足他们的这种特殊需要吗！”毛姆这段话里面的“第一流知识分子”原文是the most intellectual persons，所以不仅包括文学权威，也应包括其他学术权威在内。可以揣想，维特根斯坦喜欢看侦探小说，毛姆并不是不知道[注]；而小说第五章作者从爱德娜?诺维马里的女秘书那里为艾略特偷得请帖后，问女秘书她在化装跳舞会上预备穿什么服装时，她的回答是，“我亲爱的先生，我是个牧师的女儿，这种愚蠢的事，我留给上层阶级去做。当我看见《先驱报》和《邮报》的那些代表吃了一顿好宵夜并且喝了一瓶我们的第二等最好的香槟酒之后，我的责任就结束了。我将回到我的卧室关起门来看一本侦探小说。”\n这一点描绘，我认为也是从维特根斯坦身上移植过来的。最后，还有维特根斯坦在战后当的小学教师与修道院园丁工作，和拉里回美国后预备当的卡车司机和开出租汽车同样都是不求闻达的表现，毛姆只是把他的蓝本首尾倒置一下而已。\n毛姆从不讳言他小说中的人物是从真实生活取材的，所以我的这点考证——如果并没有被别人发现的话——并不足奇；问题倒是为什么毛姆挑中维特根斯坦这样一个人作为他小说的主角。《刀锋》出版于一九四四年，是他一九四○年来美国后的第一部小说。人们可以想象得出在他流寓美国期间，盘算和估量——特别是从大西洋彼岸——他所经历的两次大战之间这段时期，以他阅历之深，接触面之广，而选择了维特根斯坦，一定是经过反复考虑的。现在，我们可以看出，拉里这个人确是一次大战的产物，而他反映的时代——两次大战之间的时代——则是欧洲中心主义的黄昏时代。在这个时期，世界文化中心虽则仍在欧洲，而欧洲的文化中心，在毛姆看来，无疑在法国，但它已经不能给来此寻求人生真谛的人以满意的回答了。\n拉里在巴黎博览群书，学会了几种语言，但是，巴黎和法国只成为他的中途岛；他最后带回去的，既不是恩夏姆神甫要把他当迷途羔羊圈回去的天主教，也不是他想从波兰矿工考斯第口中探听的神秘主义，而是印度的吠陀经哲学。小说中无一语涉及纳粹的兴起，但是，小说反映的欧洲的精神空虚，已足够说明为什么纳粹主义能够乘虚而入了。\n小说不是历史，不需要反映一个时代的全貌，但它反映的那一部分，特别是其中的人物，必须给人以真实感，不能只是影子。有时候，由于文学修养差，欣赏不了作家所创造的人物，这情形是有的。我当学生时，对莎士比亚的黎耶王形象就不能欣赏，后来读了a．c．布雷德利[注]的《莎士比亚悲剧》才发现自己的文学修养不足。但是，有些名家笔下的人物，如最近我读到的狄更斯的《小杜丽》，就只能说是概念的产物了。毛姆的《刀锋》之所以可贵，就在于为我们提供了两次大战之间那个时期的一个人物画廊。\n周煦良 一九八○年十一月六日\n第一章 # 一 # 我以前写小说从没有象写这一本更感到惶惑过。我叫它做小说，只是因为除了小说以外，想不出能叫它做什么。故事是几乎没有可述的，结局既不是死，也不是结婚。死是一切的了结，所以是一个故事的总收场，但是，用结婚来结束也很合适；那些世俗的所谓大团圆，自命风雅的人也犯不着加以鄙弃。普通人有一种本能，总相信这么一来，一切该交代的都交代了。男的女的，不论经过怎样的悲欢离合，终于被撮合在一起，两性的生物功能已经完成，兴趣也就转移到未来的一代上去。可是，我写到末尾，还是使读者摸不着边际。我这本书只是追叙我过去认识的一个人，这人虽则和我非常接近，却要隔开很长的时间才碰一次面；他中间的经历我几乎毫无所知。要我杜撰些情节来补足这些脱漏，使故事读起来更加连贯，固然可以，可是，我无意于这样做。我只打算把自己知道的事情记下来而已。\n多年前，我写过一本小说叫《月亮和六便士》；在那本书里，我挑选了一个名画家保罗?高更[注]；关于这位法国艺术家的生平我知道得很少，只是倚仗一点事实的启示，使用小说家的权限，炮制了若干故事来写我创造的人物。在本书里，我一点不打算这样做。这里面丝毫没有杜撰。书中角色的姓氏全都改过，并且务必写得使人认不出是谁，免得那些还活在世上的人看了不安。我写的这人并不出名；也许他永远不会出名；也许他的生命一朝结束之后，这一生留在世界上的痕迹并不比石子投入河中留在水面上的痕迹为多。那时候，我这书倘使还有人读的话，就是由于它本身可能引起的兴趣了。但是，也许他替自己挑选的生活方式，和他性格里面所特有的坚定和驯良，在他同类中间的影响会日益加深，这样，可能在他去世长远以后，有人会恍悟这时代里曾经生活过一个很了不起的人物。那时候，人们就会看出我这本书写的是谁了，而那些想要稍微知道一点他早年身世的人，当可在书中找到些他们想要找的东西。我觉得这书虽有如我所说的种种不足之处，对于替我朋友作传的人，将不失为一本可资征引的书。\n书中的谈话，我并不要假充是逐字逐句的记载。在这类或其他场合下，人家的谈话我从不记录下来；可是与我有关的事情我都记得很清楚，所以，虽则是我写的，敢说很能忠实反映他们的谈话。适才说过，我丝毫没有杜撰；现在这句话要改正一下。就象希罗多德[注]以来的许多历史学家一样，我也有擅自增入的部分；故事里角色的谈话有些是我没有亲耳听见，而且也不可能听见的。我这种从权的理由和那些历史学家的理由一样，因为有些场合若只是重述一下，就会毫无生气，加进谈话要生动得多，真切得多。我要有人读我的书，所以只要写得人读得下去，我认为总可以做得。至于哪些地方是擅自增人的，明眼的读者自会一望而知，他要摈弃这些不读，完全听他自由。\n另一个理由使我从事这部作品时感到疑惧的，是这里面的主要人物都是美国人。\n了解人不是一件容易的事；我觉得一个人除掉他本国人以外，很难说真正了解什么人。因为人不论男男女女，都不仅仅是他们自身；他们也是自己出生的乡土，学步的农场或城市公寓，儿时玩的游戏，私下听来的山海经，吃的饭食，上的学校，关心的运动，吟哦的诗章，和信仰的上帝。这一切东西把他们造成现在这样，而这些东西都不是道听途说就可以了解的，你非得和那些人生活过。要了解这些，你就得是这些。正由于你离开观察不能了解一个对于你是异域的人，要在书中刻划得真切就难了。连亨利?詹姆斯[注]那样一个精细的观察家，在英国住了四十年，也没有能创造出一个十足英国气的英国人来。至于我，几篇短篇小说除外，从没有打算写过本国以外的人；短篇小说里敢于写外国人的缘故，是因为短篇的人物只要一点粗枝大叶；你写个轮廓，细微的地方全可以由读者自己去补充。也许有人要问，既然我能把保罗?高更变做一个英国人，这本书里的人物为什么不可以照做。我的回答很简单：就是不能。那一来，他们就不成其为他们那样的人了。我并不作为他们是美国人眼中的美国人；他们是一个英国人眼中的美国人，连他们的语言特点我都没有打算仿效。英国作家在这方面闯的乱子和美国作家打算模仿英国人说的英语时闯的乱子一样多。俚语是最坑人的东西。亨利?詹姆斯在他的英国故事里经常要用俚语，可是总不象一个英国人说的那样，因此不但不能取得他所企求的俚低效果，反而时常使英国人读来感到突兀和怪不舒服。\n二 # 一九一九那一年，我起身到远东去，路过芝加哥；为了某种和本书无关的原因，在那边住了有两三个星期之久。不久以前，我出版了一部成功的小说，所以在当时也算是新闻人物，一到芝加哥，就有记者来访问。第二天早上，电话铃响、我去接电话。\n“我是艾略特?谈波登。”\n“艾略特，我还以为你在巴黎呢。”\n“不，我回来看看家姐的。我们找你今天来玩。跟我们一起吃午饭。”\n“好极了。”\n他把时间和地址告诉我。\n我认识艾略特：谈波登已经有十五年。他这时已是将近六旬的人，一表人才i高个儿，眉目清秀，鬈发又多又乌，微带花白，恰好衬出他那堂堂的仪表。他穿着一直考究，普通的买自夏费商店，可是衣服鞋帽总要在伦敦买。在巴黎塞纳河南岸时髦的圣纪劳姆街上有一所公寓。不喜欢他的人说他是古董客人，可是这是诬蔑，他极其痛恨。他有眼光，又有学问，也不否认在已往的年头他刚在巴黎住下时，曾经帮助那些要买画的收藏家出过主意；后来在他的交游中听到有些中落的英法贵族想要卖掉一张精品，碰巧他知道美国博物馆的某某理事正在访求这类大画家的优秀作品时，自然乐得给双方拉拢一下。法国有许多旧家，英国也有些，有时迫于境遇，不得不把一口比尔[注]签名的橱柜或者一张奇彭代尔[注]手制的书桌割爱，但是不愿意声张出去，碰到他这样博雅而彬彬有礼的人能够把事情办得一点不露痕迹，正是求之不得。听到这话的人自然而然想到艾略特会在这些交易上捞些好处，但都是深有教养的人，谁也不愿意提。刻薄的人硬说他公寓里的东西全都是出售的，说他每次名酒好莱请美国阔佬们吃一顿午饭之后，他那些值钱的画总有一两张不见了，不然就是一口细工精嵌的橱柜换成一口漆的。等到有人问他怎么某一件东西不见了，他就花言巧语地说，那个他觉得还不上品，因此拿去换了一件更好的。接着又说，尽瞧见一样东西真腻味。\n“nons autres americians，他先调一句法文，“我们美国人就欢喜换花样。\n这既是我们的短处，也是我们强过人的地方。”\n巴黎的有些美国太太，自称晓得他的底细的，说他的家道原来很穷，所以起居能够那样阔绰，只是由于他为人非常精明的缘故。我不清楚他究竟有多少钱，可是那位公爵头衔的房东在他这所公寓上却着实收他一笔房租。公寓里的陈设又是那样名贵：墙壁上挂的都是法国大画家的作品，瓦托[注]啊，弗拉戈纳尔[注]啊，克洛德?洛兰[注]啊，等等；镶木地板上炫耀着萨冯内里埃和奥比松[注]的地毯；客厅里摆了一套路易十五时代精工细雕的家具，制作之精，如他自称的，说不定就是当年蓬帕杜夫人[注]的香闺中物。反正他并不用设法赚钱，就能生活起居有他认为上流人士应有的那种派头。至于他过去通过什么途径才能达到这样，你假如是明白人的话，最好还是别提，除非你有意要和他断绝往来。他既然在物质上不用操心，就一心一意追求他一生中最大的愿望起来，换句话说，社会交际。他初到欧洲时，还是个拿着介绍信去见名流的年轻人，后来和英国法国那些中落的大家发生商业关系，这就奠定了他先前取得的社会地位。本人在弗吉尼亚州原是旧家，母系方面还可以追溯到一位在独立宣言上署过名的祖先，这点家世使他拿着信去见那些有头衔的美国太太时，很受人看得起。人缘好，人又神气，跳舞跳得不错，打枪不算坏，网球很好，什么宴会里都少不了他。鲜花和高价钱的大盒巧克力，任意买来送人；虽则很少请客，请起客来，倒也别致有趣。那些阔太太们被他带着上一趟苏荷区的异国情调饭馆，或者拉丁区的小酒店，都觉得很好玩。替人效劳，随时随地都来；你要是请他做一件事，不管多么厌烦，没有不高高兴兴替你做的。碰到年纪大点的女人，总是曲尽心意去博她们的欢心，所以不久在许多豪贵人家都渴得很熟。为人实在太好讲话了，假如有人失约，你临时拉他来凑数，他毫不介意就来，而且让他坐在一位顶讨厌的老太婆旁边，保管还会替你敷衍得有说有笑。\n两三年工夫，在伦敦和巴黎，所有一个年轻美国人攀得上的朋友，他都攀上了；巴黎他是长住，伦敦是每年游宴季末期去，还有就是在初秋时拜访一转乡间别墅。\n那些早先把他引进社交界的太太们，看到他的交游竟如此广，很觉得诧异。感想是分两方面：一方面是高兴她们抬举的这个年轻小伙子居然有偌大的成功，另一方面，则有点着恼，怎么和他混得很熟的人，和自己的交情只是一点浮面。虽则他对待她们照旧很客气，很肯效劳，这些人总不好受，觉得他利用她们做了社交上的垫脚石。\n她们担心他是个势利鬼，当然他是个势利鬼，他是个大大的势利鬼，他势利得毫不顾旁人齿冷。哪一家请客，他想厕身被请之列，或是哪一位大名鼎鼎但是有名难缠的老阔寡妇，他想拉拢点关系，就什么都做得出来：钉子照碰，冷言冷语照吃，下不了面子的地方照下得去。在这方面，他可以说是不屈不挠。只要眼睛落在什么上面，他就象植物学家寻求一株异种兰花一样，洪水、地震、瘴热、敌意的土人，什么危险都去冒，非弄到手不肯罢休。一九一四年的大战给他提供最后的机会；战事一爆发，他就去参加一个救护队，先后在佛兰德[注]和阿尔良战区都服务过；一年后回来，佩起一枚红勋章，在巴黎红十字会弄了一个位置。那时候，他手头已很宽裕，要人支持的慈善事业，他都慷慨捐助。任何铺张扬厉的善举，他必竭尽自己的博雅知识和办事才能来襄助一切。巴黎两家最高贵的俱乐部，他都做了会员。法兰西那些最煊赫的妇女提起他来总是“那个好艾略特”。他终于发迹了。\n三 # 我最初认识艾略特的时候，自己还不过是个平常的年轻作家，他也不把我放在眼里。他从不忘记一张脸，所以不论在哪里碰到，总是很客气地和我拉手，但是，无意和我结交；假如我在歌剧院里看见他，比方说，和他坐在一起的是一位显贵，他就会装作没有看见我。可是，那时我写的剧本碰巧获得相当出人意料的成功，所以，不久我就看出艾略特对我稍微亲热起来。有一天我收到一封短柬，约我到克拉里奇饭店吃午饭，那是一家旅馆，他到伦敦就住在那里。客人并不多，也不怎么出色，我有个感觉，好象他在试探我在交际上成不成。可是，从那时起，我自己的成功也给我添了不少新朋友，因此，和艾略特碰面的机会也多起来。之后不久，我上巴黎去度秋天，住了几个星期，在一个双方都认识的朋友家里又碰见了。他问我住在哪里，一两天后，又寄来一张午饭请帖，这次是在他自己的公寓里。我到了一看，没料到客人竟是相当出色，肚子里暗笑。我知道，以他那样烂熟世故，明知道在英国社交界我这样一个作家并不稀奇，但是，在法国这儿，一个人只要是作家就会被人另眼相看，所以我也了不起了。这以后好多年，我们的交往都相当亲密，不过从没有真正成为朋友。我怀疑艾略特?谈波登会和任何人成为朋友。他对别人的一切，除了他的社会地位外，全不发生兴趣。不论我偶尔来巴黎，或是他在伦敦，他请客少一个人，或者逼得要招待旅游的美国人时，总要请我去。这些人，我疑惑有些是他的老主顾，有些是拿介绍信来谒见他的、素昧生平的人。他一生中就是在这些地方受罪。他觉得应酬总得应酬一下，但是，不愿意介绍他们和他那些阔朋友见面。\n最好的打发办法当然是请吃晚饭，再去看戏，可是这往往很困难，因为他每晚都有应酬，而且早在三个星期前全约好了；就算能做到那样，料想那些人未必就此满足。\n他因为我是个作家，而且没有什么大关系，就毫不介意把他这些苦恼告诉我。\n“美国那些人写介绍信真是太不替别人着想了。并不是说把这些人介绍给我，我不高兴见，不过，我觉得没有理由叫我的朋友跟我受罪。”\n他给他们买了大玫瑰花篮和大盒的巧克力糖送去，借此补救一下，可是，有时候还得请吃饭。就在这种时候，他先告诉我一番话，然后又天真地邀请我赴他筹备的这类宴会。\n他们极其想见见你，”信上这样捧我。“某太太是个很有文学修养的妇女，你写的书她一个一个字都读过了。”\n某太太后来就会告诉我，她读了我的《裴林先生和特雷尔先生》非常喜欢，而且祝贺我的《软体动物》剧本演出成功，头一本书的作者是休?沃波尔，后一书的作者是哈伯特?亨利?戴维斯[注]。\n四 # 如果我描写的艾略特?谈波登使读者觉得他是个卑鄙小人，那实在是冤枉他。\n在某一点上，他可以称得上法国人说的serviable：这个词，以我所知，在英语里还找不到适当字眼。词典上有serviceable，古义是指肯帮助人，施惠，厚道。这恰恰就是艾略特。他为人慷慨；虽则在他早期的社会活动中，那种送花、送糖、送礼的豪举无疑有他的用心，到后来没有这种必要时，他还是照做。送东西给人，他觉得很好受。他顶好客；雇的厨师比起巴黎的哪一家来都不差，而且在他那儿用饭，准会吃到最早的时鲜菜。他的酒十足证明他是个品酒的内行。诚然，他挑的客人都是视他们的社会地位而定，不一定是佳客，可是，他至少总罗致一两个能说会笑的客人，因此，他的宴会差不多总是很有意思。有人在背后嘲笑他，说他是个龌龊小人；尽管这样说，他请起客来，还是高高兴兴照去。他的法语说得流利正确，轻重音一点不含糊。他曾经费了很大气力把英语说得象英国人那样，你得有一对很尖锐的耳朵才能捉住他一个美国音。他极其健谈，只是你得设法使他不提那些公爵和公爵夫人z但是，即使谈到这些公爵和公爵夫人时，他也能使人解颐，特别是单独和你在一起时，反正他现在的地位已经是不容置疑了。他有一张顶逗人的刻薄嘴，而这些王公贵人的丑史秽闻又没有一件不吹到他耳朵里的。x公主最近的孩子的父亲是谁，y侯爵的情妇是哪一个，我全是从他那里听来的。敢说连马塞尔?普鲁斯特[注]知道的显贵秘闻也赶不上艾略特知道的那样多。\n在巴黎时，我时常跟他一起吃午饭，有时在他公寓里，有时在饭馆子里。我喜欢逛古董铺，偶尔也买些，不过看看居多，而艾略特总是兴冲冲陪我去。他懂，对于艺术品也真心爱好。我想巴黎这类铺子他没有一家不认识，而且老板个个都是熟人。他最爱杀价；每次我们出发时，他总叮嘱我：“要是你有什么东西想买，自己不要问。丢个眼色给我，底下的由我来。”\n他顶得意的事就是替我弄到一件我看中的东西，价钱只抵要价的一半，看他讲价真是好要子。他会争论，哄骗，发脾气，想法叫卖方心软，嘲弄他，挑剔毛病，吓唬不再踏进人家店门，叹气，耸肩膀，正言规劝，满脸怒容朝外走，到最后争到他出的价钱时，惨然的样子摇摇头，好象无可奈何只好屈服一样。然后低低用英语跟我说：“买下来。加倍的价钱都还是便宜。”\n艾略特是个热心的天主教徒：他在巴黎住下不久，就碰见一位神父。那人出名的会说人皈依，过去多少相信异端的迷途羔羊都被他圈了回来。他饭局最多，人有名的善于辞令。他的教务活动只限于富贵人家。虽则出身寒微，多少高门大户都尊为座上客。这样一个人，艾略特见了当然动了念头。他偷偷告诉一位新近被这位神父说服改教的美国阔太太，说他家里虽则一直奉的圣公会派，他本人却是对天主教向往已久。有一天晚上，这位太太请他吃饭，跟这位神父见见；就只他们三个，神父是谈笑风生。女主人把话兜到天主教上去，神父谈得非常热烈，丝毫不迂腐，虽则是教中人，就象一个见过世面的人同另一个见过世面的人谈话一样。艾略特发现神父十分知道他的为人，有点受宠若惊。\n“范多姆公爵夫人上回还跟我谈起你，她觉得你看事情顶清楚。”\n艾略特快活得红光满面，公爵夫人他是进谒过，可是，从没有想到她会对他动一下脑筋。神父心性广阔，见解摩登，态度宽容，一番关于天主教的议论谈得既高明又温和。他把天主教会说得使艾略特听来很象一个任何有教养的人如果不加入就对不起自己的高尚俱乐部。六个月后，艾略特就人了教。这样一改宗，再加上在天主教方面的慷慨布施，那几家以前进不去的人家大门也被他敲开了。\n也许他放弃祖传的宗教，动机并不纯正，可是改宗以后，倒的确诚心诚意。每星期要到第一流人士光顾的教堂去做弥撒，过些时就去神父那里忏悔，隔两年总要朝一次罗马。久而久之，教廷因他虔诚，派了他御前侍卫，又见他孜孜克尽职守，奖给他圣墓勋章。说实在话，他在天主教方面的事业和他在世俗方面的事业，可算一样成功。\n我时常问自己，以他这样一个聪明、和蔼、学识优长的人怎么会被势利蒙着心眼儿。他不是暴发户。父亲在南方一个大学当过校长，祖父是相当有名的神学家。\n以艾略特的机伶，决不会看不出那些应他邀请的人多只是混他一顿吃喝，有些是没脑子的，有些毫不足道。那些响亮的头衔引得他眼花缭乱，看不见一点他们的缺点。\n我只能这样猜想，跟这些家世绵邈的人过从亲密，做这些人家妇女的近臣，给他一种永不厌烦的胜利感；而且这一切，归根结底，实起于一种狂热的浪漫思想；这使他在那些庸碌的小小法国公爵身上见到当年跟随圣路易[注]到圣地去的十字军战士，在装腔作势、猎猎狐狸的英国伯爵身上见到他们在金锦原[注]侍奉亨利八世的祖先。\n跟这些人在一起，他觉得就象生活在天地广阔的英勇古代里一样。我想他翻阅戈沙年鉴[注]时，看见一个姓氏接一个姓氏地使他回想起年代悠远的战争，史册上的攻城战和著名的决斗，外交上的诡诈和王侯们的私情，他的心就会热得跳起来。总而言之，这就是艾略特’谈波登。\n五 # 我预备洗个脸，梳一下头发，再去赴艾略特约的饭局；正忙着时，旅馆里人打电话上来，说他在楼下等我。我有点诧异，可是一收拾好，就下楼去。\n我们握手时，他说：“我想我自己来接你要安全些。我不清楚你对芝加哥到底有多熟。”\n他这种感觉，我看出好些住在国外多年的美国人都有；他们心目中仿佛美国是个很难走甚至危险的地方，你不能随随便便让一个欧洲人单独去闯。\n“还早，我们不妨走一段路，”他提议。\n外面微有寒意，可是，天上一丝云都没有，活动活动筋骨倒不错。\n我们走着路时，艾略特说：“我想你会见家姐之前，顶好先知道一点她的为人，她有一两次住在巴黎我那里过，不过，我记得你那时不在，你知道，今天人并不多，就是家姐和她的女儿伊莎贝儿和格雷戈里?布拉巴宗。\n“是那个室内装饰家吗？”我问。\n“对了，家姐的屋子精透了，伊莎贝儿和我都劝她重新装修一下，我刚巧听见布拉巴宗在芝加哥，所以就叫家姐请他今天来吃午饭，当然，他不是怎么一个上等人，但是很行，玛丽?奥利芬特的拉尼堡，圣厄茨家的圣克莱门特?塔尔伯特府，都是他装饰的。公爵夫人极其喜欢他。你可以看看路易莎的屋子，我永远不懂得，她这么多年怎么住得下去，不过说起这个来，她怎么能在芝加哥住下去，我也永远不懂得。”\n我从他嘴里得知布雷德利太太是个寡妇，三个孩子，两儿一女，不过儿子年纪大得多，而且都已结婚，有一个在菲律宾政府里做事，有一个，象他父亲过去那样，在外交界服务，现在人在阿根廷都城。布太太的丈夫过去宦历甚广，在罗马做了几年一等秘书，后来又派到南美洲西岸的一个小共和国当专员，人就是死在那边。\n艾略特继续讲下去，“他去世之后，我要路易莎把芝加哥的宅子卖掉，可是，她不忍心。布家这所宅子买下来已有了年代，他们是伊利诺斯一个顶旧的旧家。一八三九年从弗吉尼亚原籍迁来这里，在现在离芝加哥六十英里的地方置下田产，目前还保留着。”艾略特迟疑一下，看看我吃不吃他这一套。“我想你也许会说他家早先是种田的，不过，我不晓得你可知道，在上世纪中叶的时候，中西部开始开发，不少弗吉尼亚的人，好人家的子弟，你晓得都被无名的诱惑打动，离开了丰衣足食的乡土。我姐丈的父亲切斯特?布雷德利看出芝加哥有它的前途，来这里进了一家法律事务所，反正他赚的钱也够儿辈吃用的了。”\n艾略特的话虽如此说，从他的神情可以看出，那位已经去世的切斯特?布雷德利离开他祖传的华屋良田，来进律师事务所，原因并不那样简单，不过，从他攒聚了一笔家财上看来，总还值得。后来有一回布太太拿几张乡下她所谓“老家”的照片给我看，艾略特就不很快活；照片上面我见到的是一所不大不小的宅子，有美丽的小花园，可是仓房，牛棚，猪厩都隔开只有一箭之地，四周是一片荒芜的平畴。\n我不由想到，切斯特?布雷德利先生丢下这儿到城市里去找出路，并不是没有成算的。\n过了一会，我们叫了一辆出租汽车。车子把我们开到一所褐色砂石房子面前，房子窄而高，要拾上一串陡峻的石级才到大门。并排是一列房屋，在湖滨道过来的一条街上，房屋外表就是在那天明媚的秋光里也还是阴沉沉的，我不懂得一个人对这样的房子会有什么好感。开门的是个高壮的、一头白发的黑人管家，把我们引进客厅。我们走进时，布雷德利太太从椅子上站起来，艾略特给我引见。她年轻时当是个美丽的女子，眉眼虽则粗一点，却生得不错，眼睛很美。可是那张几乎完全不施脂粉的姜黄脸，肌肉已经松弛下来，显见她和中年发胖的战斗是失败了。我猜她还不肯服输，因为她坐下时，腰杆在硬背椅子上撑得笔直；的确，穿着她那受罪的铠甲一般的紧身衣，这样要比坐在有软垫的椅子上舒服得多。她穿的一件青色衣服，上面满织的花，高领子，鲸鱼骨撑得硬硬的。一头漂亮的白发，烫成波浪纹，紧紧贴在头上，发式做得极其复杂。她请的另一位客人还没有到，我们一面等，一面东拉西扯的谈。\n“艾略特告诉我，你是走南路来的，”布太太说。“你在罗马歇了没有？”\n“歇的，我在那边住了一个星期。”\n“亲爱的玛格丽达王后好吗？”\n我被她这个问题弄得很诧异，只好回答说我不知道。\n“哦，你没有去看她？真是个好女人，我们在罗马的时候，待我们真好。布雷德利先生那时是使馆的一等秘书。你干吗不去看她？你难道是跟艾略特一样的坏蛋，连奎林纳宫都进不去吗？”\n一当然不是，”我笑着说。“事实是我并不认识她。”\n“不认识？”布太太说，好象信不了似的。“为什么不认识？”\n“告诉你实在话，作家们一般并不跟国王王后厮熟。”\n“可是，她是个顶可爱的女人，”布太太好言劝我，好象不认识这位王后完全是我不屑似的。“我敢保你会喜欢她。”\n这时候门开了，管家把格雷戈里?布拉巴宗领进来。\n格雷戈里?布拉巴宗，空有一个好名姓，并不是个浪漫人物[注]。这人长得矮而胖；除掉耳朵旁边和后颈有一圈黑鬈发外，头秃得就象只鸡蛋；满脸红光，看去就象要裂成一大堆臭汗一样，骨碌碌的乌眼珠，多肉的嘴唇，厚厚的下巴。他是英国人，我有时在伦敦落拓不羁人士的宴会里碰见他。人很热闹，开心，总看见他咧着嘴笑，可是，你不用是一个出色的人物评判者，就可以看出他和人家那种嘻嘻哈哈的亲密不过是一种遮盖，这里面还有很精明的生意经。多年来，他在伦敦都是最成功的屋内装饰家。他有一副很洪亮动人的嗓子，和一双小而肥的富于表情的手。\n只要来一套动人的姿势，一大串兴奋的字眼，他就能推动一个踟蹰不决的主顾的想象力，使人简直没法拒绝那在他好象是一份盛情的交易。\n管家重又托了一盘鸡尾酒进来。\n“我们不等伊莎贝儿了，”布太太拿起一杯酒时说。\n“她到哪儿去了？”艾略特问。\n“跟拉里打高尔夫去的。说她也许要晚一点。”\n艾略特转向我说，“拉里是劳伦斯?达雷尔。伊莎贝儿算跟他订婚了。”\n我说，“艾略特，我不知道你喝鸡尾酒。”\n“我不喝，”他一面忿然回答，一面呷着手里的酒，“可是，在这个禁酒的野蛮国度里，你有什么办法？”他叹口气，“巴黎有些人家现在也预备这东西了，环交通把好习惯都搅糟了。”\n“简直胡扯淡，艾略特，”布太太说。\n她的口气相当温和，然而坚决，使我不由而然觉得她是个有个性的女人；我并且从她看艾略特那种信然自得的神情，可以猜出她丝毫没有把他当作了不起。我肚子里寻思，不知她把格雷戈里?布拉巴宗看作是哪一等人。布拉巴宗进来时，我就看见他用内行的眼光把屋子里扫一下，两道浓眉不知不觉抬了起来。这的确是间奇怪的屋子。壁纸、窗帘布、椅垫、椅套，全是一式的图案；壁上厚重金镜框里挂的油画，显然是布家人在罗马时买的。拉斐尔[注]派的圣母，基多?里尼[注]派的圣母，苏卡吕厄[注]派的风景，庞厄尼[注]派的古迹。还有他们住在北京时的纪念品，雕得都满的海梅桌子，巨大的景泰蓝花瓶，还有些是从智利或者秘鲁买来的，硬石刻的胖人儿，陶制的瓶子。一张奇彭代尔的书桌。一只嵌术细工的玻璃橱。灯罩用白绸做的，不知道哪个鲁莽画家在上面画了些穿瓦托式装束的牧羊男女。屋子看上去真使人作呕，然而不懂什么缘故，却还顺眼。这里有一种安逸的，住了人的气氛，使你觉得这许多荒乎其唐的大杂烩自有它的道理。所有这一切凑合不上的东西都属于同一类，因为它们是布太太生活的一部分。\n我们才喝完鸡尾酒，门开处，进来一个女孩子，后面跟着一个男子。\n“我们迟了没有？”她问。“我把拉里带回来。可有他吃的吗？”\n“想来有吧，”布太太笑着说。“你按下铃，叫尤金添、位子。”\n“他才替我们开门的。我已经告诉他了。”\n“这是我的女儿伊莎贝儿，”布太太转身向我说。“这是劳伦斯?达雷尔。”\n伊莎贝儿赶快跟我握一下手，来不及地就转向布拉巴宗。\n“你是布拉巴宗先生吗？我真渴想见你。你替克莱曼婷?多默装饰的屋子我真喜欢。这屋子糟不糟？我好多年来都想法叫妈收拾一下，现在你来芝加哥，真是我们的机会到了。老实告诉我，你觉得这屋子怎样？”\n我知道布拉巴宗死也不会说。他很快张了布太太一眼，可是她脸上泰然自若，一点看不出什么。他断定伊莎贝儿是重要人物，就发出一声狂笑。\n“我敢说这屋子很舒服，种种都很好，”他说，“不过，你要是直截了当问我的话，那么我觉得确乎相当的糟。”\n伊莎贝儿长得高高的，椭圆脸，直鼻梁，俊俏的眼睛，丰满的嘴，这一切看来都是布家的特征。人秀气，不过胖一点，大约是年龄关系，等她长大一点就会苗条起来，一双有力的长得很好的手，不过也嫌肥一点；短裙子露出的小腿也嫌肥。皮肤生得好，颜色红红的，和适才的运动以及开敞篷车回来都不无关系。人容光焕发，充满活力。十足的健康体质，嬉皮笑脸的高兴派头，对生活的满足，和从内心里流露出来的幸福感，使人看了心花儿都开。那种自如若堂的风度，不管艾略特多么文雅，和她一比都不免有点俗气。布太太那张惨白而有皱纹的脸在她的朝气衬托下，看去简直疲惫和衰老了。\n我们下楼去吃饭。布拉巴宗一看见饭厅，眼睛就眯起来。壁上糊的暗红纸，算是冒充花布，挂些脸色阴沉死板的男女肖像，画得糟透糟透。这些人都是去世的那位布雷德利先生的近系祖先。他自己也在上面，一撮浓上须，僵直的身体穿着礼服和白粉浆的领子。一张布太太的像，是九十年代一个法国画家的手笔，挂在壁炉上面，穿着灰青缎子的晚服，颈上珠串，发际一颗钻石星，一只满戴珠宝的手捏一条编织领巾，画得连针脚都一一可数，另一只手随随便便拿一柄鸵鸟羽扇子。屋内家具是黑桶木的，简直笨重不堪。\n大家坐下时，伊莎贝儿问布拉巴宗，“你觉得这个怎么样？”\n“我敢说一定花了不少钱，”他答。\n“的确，”布太太说。“这是布雷德利先生的父亲送我们的婚礼，被我们带着跑遍了全世界。里斯本啊，北京啊，基多啊，罗马啊。亲爱的玛格丽达王后非常艳羡它。”\n“假如是你的，你把它怎么办？”伊莎贝儿问布拉巴宗，可是，不等他回答，艾略特就替他说了。\n“烧掉，”他说。\n三个人开始讨论怎样装饰这屋子起来。艾略特力主路易十五的装璜，伊莎贝儿则要一张僧院式的餐桌和一套意大利式椅子。布拉巴宗认为奇彭代尔比较适合布太太的性格。\n他转身看着艾略特，“你当然认识奥利芬特公爵夫人的？”\n“玛丽吗？顶熟的朋友。”\n“她要我装饰餐厅，我一见到她的人，就决定乔治二世。”\n“你真对。上次在她那儿吃饭，我就注意到。雅极了。”\n话就这样谈下去，布太太只听他们讲，你猜不出她肚子里想些什么。我讲话很少，伊莎贝儿的年轻朋友拉里（我忘记了他姓什么）简直一言不发。他坐在我对面的布拉巴宗和艾略特之间，我不时看他一眼。他年纪看去很轻，和艾略特差不多高，六英尺不到一点，瘦，而且四肢长得很松弛。顶讨人喜欢相的一个孩子，不漂亮，也不丑陋，相当的腼腆，一点没有出色的地方。我觉得怪有意思的倒是，虽则进屋子来之后记得他没有说上五六句话，人却非常自如，而且奇怪的是，尽管不开口，好象也在参加谈话。我注意到他的手很长，可是，就他的身个论，不能算大，形状看上去很美，同时又有力。我想画家一定高兴画这双手。他体格比较瘦，但是，看去并不文弱，相反地，敢说顽健。一张脸宁静庄重，晒得黝黑，要不是这样就看不出什么血色；五官端正，但并不出众。颧骨相当高，庭穴四进。深棕色的头发，微微鬈曲。眼睛看上去比原来的要大，因为陷在眼窝里很深，睫毛则又波又长。眼珠的颜色很特别，不是伊莎贝儿和她母亲，舅舅共有的那种浓栗色，非常之深，虹彩和瞳子差不多是一个颜色，这给他的眼睛以一种特别的光芒。他有一种动人的潇洒风度，看得出为什么伊莎贝儿对他倾心。她的眼光不时落到他身上一下，从她的神情里我好象看出不但有爱，而且有喜欢。两人的眼光碰上时，他眼睛里含有一种温情，看去非常之美。没有比看见年轻人相爱更动人的了，这使我这个已届中年的人艳羡他们，同时，不懂得什么缘故，感到难受。这很愚蠢，因为以我所知，是没有什么可以影响到他们的幸福的；两人的境遇都宽裕，你想不出什么理由说他们结不了婚，而且结婚后不能一直幸福地生活下去。\n伊莎贝儿，艾略特和布拉巴宗继续往下讲怎样重新装饰屋子，想逼出布太太一句话来，承认是得想个办法，可是，她只蔼然微笑。\n“你们不要逼我。我得空下来自己想过。”她转身向那男孩子说，“拉里，你对这一切怎么看法？”\n他向桌子四周环顾一下，眼中露出微笑。\n“我觉得做不做都无所谓，”他说。\n“你这个狗蛋，拉里，”伊莎贝儿叫出来。“我还特地关照你给我们撑腰的。”\n“假如路易莎伯母满意她原来的那些，做什么要换掉？”\n他发的问题非常在点子上，而且很合乎情理，我不禁笑出来。他看看我，自己也笑了。\n“而且请你嘴不要咧得那个鬼相，你自以为讲了一句非常俏皮的话，我觉得很蠢，”伊莎贝儿说。\n可是他的嘴咧得更大了，这时我注意到他的牙齿长得又小又白又整齐。他望着伊莎贝儿的神情，不知怎样，使她脸红起来，呼吸也急促了。我假如没有弄错的话，那么，她就是疯狂地在爱着他，可是不知道什么缘故，好象她对他的情意里面还有一种母性的爱。这在这样一个年轻女孩子身上有点令人意想不到。她嘴边微带笑意，重又向布拉巴宗殷勤起来。\n“别睬他。他非常之蠢，完全没有受过教育。他什么东西都不懂，只懂得飞行。”\n一飞行？一我说。\n“他大战时是空军。”\n“我还以为他那时年纪轻着，不会参军。”\n“他年纪是轻，着实太轻了。他淘气之极。溜出学校，跑到加拿大；说了一大堆谎话，人家真的相信他是十八岁，这样就进了空军。停战时，他还在法国作战呢。”\n“你把你母亲的客人缠死了，伊莎贝儿，”拉里说。\n“我从小就认识他，他回来时穿一身军装，外套上挂那么漂亮的奖章，非常好看，所以，我就这么坐在他门口阶沿上，缠得他一刻不能安静，只好答应跟我结婚了。那时候，竞争可真激烈。”\n“真的吗，伊莎贝儿，”她母亲说。\n拉里身子伸过来向我说：“我希望你一个字也不要信她。伊莎贝儿不是什么坏女孩子，可是个说谎大家。”\n吃完午饭，艾略特和我不久就告辞。我先前告诉他打算去博物馆看看画，他说他带我去。我不大愿意有人跟我去逛博物馆，可是，没有法子说我喜欢一个人去，只好让他陪我。路上我们谈起伊莎贝儿和拉里。\n我说，“看见两个年轻人这样相爱，怪有意思。”\n“他们结婚的确太早一点。”\n“为什么？趁年纪轻时恋爱、结婚，要有意思得多。”\n“别胡闹。她十九岁，他不过刚满二十。他还没有职业。自己有点小进项，三千块一年，路易莎告诉我的；而路易莎也不是怎样富裕。她的收入只够她自己花。”\n“那么，他可以找个事做。”\n“就是呀。他不想找事。他好象很满意这样晃膀子。”\n“我敢说他在战争中一定吃了不少苦头。也许想休息一下。”\n“他休息已有一年。这总够长了。”\n“我觉得他象是个很不错的孩子。”\n“哦，我对他毫无成见。他的门第以及其他种种都很好。父亲原籍是巴尔的摩；过去是耶鲁大学罗曼语副教授，总之大致如此。母亲是费城教友派的一个老旧家。”\n“你口口声声过去，难不成他父母都去世了么？”\n“是的，他母亲生孩子亡故，父亲约在十二年前去世。他是他父亲的老同学抚养大的。那人是麻汾的一个医生。路易莎跟伊莎贝儿就是这样才认识他的。”\n“麻汾在哪儿？”\n“布家的产业在麻汾。路易莎总在那边度夏。她看见这孩子可怜。纳尔逊医生是个独身汉，怎样带孩子连初步的常识都不知道。路易莎力主把这孩子送到圣保罗堂去，圣诞节时她总接他出来过节。”艾略特法国式地耸一下肩膀。“我想她当初总该见到会是这样的结果了。”\n这时，我们已走到博物馆，心思就转到绘画上去。艾略特的识见又令我倾倒一番。他领着我在那些屋子里转来转去，仿佛我是一群旅游家似的。讲起那些画来，连任何美术教授都不能比他更使人获益。我决定独自再来一次，那时自己可以随便逛逛，所以现在由他说去。过了一会，他看一下表。\n“我们走吧，”他说。“我在博物馆里从不待过一个钟点。这样还得看一个人的欣赏力熬得了熬不了。我们改天再来看完它。”\n分手时，我满口道谢。也许走开后我变得聪明一点，可是确很恼火。\n我和布太太告别时，她告诉我第二天伊莎贝儿要请她几位年轻朋友来家吃晚饭；我要是愿意来的话，那些孩子们走后，我还可以跟艾略特谈谈。\n“你等于救救他，”她接着说。“他在外国待得太久了，到这儿觉得百不如意；简直找不到一个跟他合得来的人。”\n我接受了；在博物馆门口台阶上两人分手时，艾略特告诉我，他很高兴我答应下来。\n“在这座大城里，我就象迷失了的灵魂，”他说。“我答应路易莎跟她住六个星期，我们自从一九一二年后彼此就没有见过，可是，我盼望回巴黎真象度日如年。\n巴黎是世界上唯一文明人能住得下去的地方。我亲爱的朋友，你知道他们这儿把我看作什么？看作一个怪物。真是野蛮的人。”\n我大笑走了。\n六 # 第二天傍晚时分，我一个人去赴约。事前艾略特打电话来，要来接我，被我推掉，居然平安到达布太太家。因为有人来访，我耽搁了一下，到得稍为晏点。上楼时，听见客厅里人声嘈杂，我以为客人一定很多，不料连我通共不过十二个人。布太太穿一身绿缎子衣服，戴一串细珠项链，非常富丽。艾略特的晚礼服式样做得极好，那种潇洒派头，看上去只有他才配；和我握手时，各种阿拉伯香水气味都冲进我鼻孔里来。他把一位身材高大的人介绍给我；那人一张红红的脸，穿着晚礼服，样子怪不舒服。他叫纳尔逊医生，可是，我当时听到丝毫没有感觉。其他客人都是伊莎贝儿的朋友，不过，那些名字才听到就被我忘掉。女子都年轻貌美，男子都少年英俊。那些人我全没有什么印象，只有一个男孩子，还是因为他的身材特别高大的缘故。他一定有六英尺三四英寸高，而且肩膀宽阔。伊莎贝儿穿着得极美，白绸子衣服曳着长裙，正好这着她的肥腿；从衣服的式样上看出她有发育得很丰满的胸脯；光膀子稍嫌肥一点，可是颈项很美。人兴高采烈，明眸四射。毫无疑问是个很美很可爱的女子，但是看得出如果不当心的话，人就会胖得过头。\n席间，我坐在布太太和一位腼腆的女子之间；她看去比余下的人还要年轻。我们坐下来时，布太太为要使谈话容易进行起见，特地讲给我听，说她的祖父母就住在麻汾，而且伊莎贝儿和她从前是同学；她的名字，我从旁人口中听到，叫索菲，姓什么可不知道。席问，大家尽情笑谑，人人都大声说话，笑声很多。这些人好象都非常之熟。我不跟女主人周旋时，就设法和邻座的那个女孩子攀谈，可是并不怎样顺利。她比其余的人都要沉默些。人不算美，但是，脸长得很趣，鼻尖微翘，阔嘴，蓝里带绿的眼珠，赭黄色的头发，式样梳得很简单。人瘦，胸部几乎象男孩子一样平坦。大家寻开心时，她也笑，可是，态度显得有点勉强，使人觉得她并不如表面那样真正感到好笑。我猜想她是在尽力敷衍；也弄不懂她是否人有点笨，还只是过分腼腆。我起先和她的几次攀谈都没有谈下去，后来无话可说，就请她告诉我席间这些人是谁。\n“啊，纳尔逊医生你总认识吧，”她说，指指坐在布太太对面的那个中年人。\n“他是拉里的保护人。我们在麻汾都是请他看病。人很聪明，发明了许多飞机零件，可是没有人理会。他没有发明可做时，就喝酒。”\n她讲话时淡蓝色眼睛里闪出一丝光彩，我不由而然觉得这孩子肚子里并不如初看上去那样没有货色。接着她把那些年轻人的名字一一告诉我，他的父母是谁，若是男子的话，从前进过什么大学，现在做什么事，都没有什么出色的。\n“她很可爱，”或者，“他高尔夫打得很好。”\n“那个浓眉毛的大个子是谁？”\n“哪个？哦，那是格雷?马图林。他父亲在麻汾河边有一所大房子，是我们里面的百万富翁。我们都以他为荣，他把我们的身价都抬高了。马图林，霍布斯，雷纳，史密斯这些人。他是芝加哥顶顶有钱的人之一，格雷又是个独养儿子。”\n她讲到这一连串阔人的名字时，故意加上些逗人的刻薄字眼，使我好奇地瞟了她一眼；她张见，脸红了起来。\n“你把马图林先生再讲点给我听。”\n“没有什么可讲的。他很有钱，人人都尊敬他。在麻汾替我们盖了一所教堂，还捐了一百万给芝加哥大学。”\n“他儿子长得挺漂亮。”\n“他不错。你决想不到他祖父是个爱尔兰水手，祖母是饭店里一个瑞典女跑堂的。”\n格雷?马图林的相貌不能算漂亮，不过动人。人看去很粗野，毫不修饰；鼻子短而扁，多肉的嘴唇，红红的爱尔兰肤色；长了一头黑发，又光又柔。浓浓的眉毛，下面衬着一双明亮的蓝眼睛。虽则身个高大，四肢五官倒也相称。假如脱掉衣服，一定是个很健美的男性胴体。看来力气想必很大，那种雄赳赳的样子给人印象颇为深刻。拉里就坐在他身边，和他一比，拉里虽则不过比他矮三四英寸，却显得孱弱多了。\n“喜欢他的人真多，”我腼腆的邻座说。“我知道有好几个女孩子都在排命追他，就差要动刀子。可是她们一点指望没有。”\n“为什么没有呢？”\n“你一点都不知道吗？”\n“我怎么会知道。”\n“他爱伊莎贝儿爱到了极点，人就象疯了一样，而伊莎贝儿却爱上拉里。”\n“他干吗不竞争一下？”\n“拉里是他顶好的朋友。”\n“我敢说，这一来事情可麻烦了。”\n“的确，要是你象格雷那样义气的话。”\n我拿不准她这话的意思是当真，还是带有讥讽。她的态度一点不莽撞，也不直率或者冒失，然而，我有个印象，觉得她并不缺乏幽默，也不缺乏精明。我猜不出她这样和我谈着话，肚子里会想些什么，可是，这一点我知道永远也不会弄清楚。\n她摆明不大信得过自己，我想她大概是个独生女，过去和比她年纪大得多的人过孤寂的生活太久了。她有种幽娴贞静的派头，使人觉得很惹疼，可是，如果我猜她以前过了很久的孤独生活是事实的话，看来她对于和她一起生活的人一定默默观察过，而且对他们都有一定的看法。我们上了年纪的人很少觉察到年轻人对我们的判断多么无情，然而又多么深刻。我又瞧瞧她那蓝里带绿的眼睛。\n“你多大了？”\n“十七岁。”\n“你看书吗？”我大胆问她。\n可是，她还没有回答，布太太为了尽女主人的责任，已经拿话和我搭上。我还没有对付掉她，晚饭已经完毕。那些年轻人立刻走得不知去向，剩下我们四个人，就到楼上客厅里去坐。\n我很诧异今天自己也在被邀请之列，因为他们闲谈一会之后，就谈起一桩恐怕他们一定愿意背着人谈的事来。我拿不定主意是否要避点嫌疑，抬起脚来走掉，还是以局外人的身份，当一个对于他们有益的旁观者。争论的问题是拉里为什么不肯就业，这太奇怪了，后来又集中到马图林先生答应在他的公司里给拉里一个职位，马图林先生就是适才晚饭时同席的男孩子的父亲。这是一个很好的机会，只要人能于勤快，拉里在一定时间内就可以赚一大笔钱。小马图林急于要他接受。\n我记不清楚他们所有的谈话，不过谈话的内容却清清楚楚在脑子里。拉里从法国回来时，他的保护人纳尔逊医生劝他进大学，可是他拒绝了。这也是人情之常，先闲散一个时候；他吃了不少苦，而且两次受伤，虽则不算太重。纳尔逊医生认为他对战争的余悸还没有消除，能够休息些日子直到完全恢复正常，也好。可是，几个星期一拖就是几个月，现在离他退伍时已经有一年多了。他在空军里面混得好象不错，回来在芝加哥很谈得上嘴，因此，好几位商界人士都要罗致他。他谢谢他们，但是拒绝了。也不说什么原因，只说他自己对于做什么还没有打定主意。他和伊莎贝儿订了婚。这事布太太也不诧异，因为两人耳鬓厮磨已有多年；布太太知道伊莎贝儿爱他；她本人也喜欢他，而且觉得他会使伊莎贝儿幸福。\n“她的性格比拉里强，她可以弥补他的短处。”\n尽管两人年纪都这么轻，布太太却愿意他们立刻结婚，不过拉里总要就业才成。\n他自己有点钱，可是即使有比这多上十倍的钱，她还是要坚持这一点。照我猜想，她同艾略特想问纳尔逊医生的就是拉里打算做什么。他们想要纳尔逊医生用他的影响使拉里接受马图林先生给他的职位。\n“你们知道我从来就管不了拉里，”他说，“便在做孩子时，他就独行其是。”\n“我知道，你完全纵容他。他会变得那样好，真可以说是奇迹。”\n纳尔逊医生酒已经喝了不少，不乐意地看她一眼，一张红红的脸又红了一点起来。\n“我很忙，我自己也有事情要过问。当初我收留他的缘故，是因为他无处可去。\n他父亲又是我的一个朋友。这孩子是不容易管教的。”\n“我不懂你怎么可以讲这样的话，”布太太尖刻地回答，“他的性情很温和。”\n“这孩子从不跟你吵嘴，可是完全我行我素；你气极时，他就说声对不起，由你咆哮去，请问你怎样对付？他要是我自己的儿子，我就可以打得。但是，这样一个举目无亲的孩子，他父亲把他托孤给我，以为我会待他好的，我总不能打吧？”\n”这全是驴头不对马嘴，”艾略特说，人有点儿发毛，“目前的情形是这样，他游手好闲的时间算得上长了；他现在有一个就业的机会，眼看可以赚很多的钱；他如果要娶伊莎贝儿，就得接受。”\n“他总该懂得目前世界上，”布太太插嘴说，“一个人总得做事。他现在已经强壮得和好人一样。我们都知道，南北战争之后，有些人回来从不做事。他们是家庭的累赘，而且对社会毫无益处。”\n后来我开口了。\n“可是，他拒绝那些人给他找的事时，提出什么理由呢？”\n“没有，只说那些事他不喜欢。”\n“可是，有什么事是他要做的呢？”\n“摆明没有。”\n纳尔逊医生给自己又倒上一杯柠檬威士忌，喝了一大口，然后看看他的两个朋友。\n“你们要不要听我讲讲我的印象？我不敢说我看人没有错，不过，至少行了三十多年的医，我想总懂得一点。这次战争使拉里变了。他回来时已经不是他走时那样的人。也不是说他年纪大了一点。他不知道碰上什么事情，连性格都变了。”\n“碰上什么事情呢？”我问。\n“我可不知道。他对自己的战争经历总是讳莫如深。”纳尔逊医生转向布太太，“路易莎，他可跟你谈过他的经历吗？”\n她摇摇头。\n“没有。他初回来时，我们总设法要他告诉我们一点他的出生人死经历，可是，他总是那样笑笑，说没有什么可谈的。连伊莎贝儿他都没有告诉过。她屡次问他，可是一点没有问出什么来。”\n话就这样不痛不痒地谈下去，不久，纳尔逊医生看看表，说他得走了。我准备跟他一同走，但是，艾略特硬把我留下。纳尔逊医生走后，布太太向我打招呼，说拿这些私事麻烦我，恐怕我一定觉得腻味。\n“不过，你知道，这的确是我的一件心事，”她最后说。\n“毛姆先生人很谨慎，路易莎，你有什么事只管告诉他。我并不觉得鲍勃[注]?纳尔逊和拉里怎样亲密，不过，有些事路易莎跟我都觉得顶好不要跟他提。”\n“艾略特。”\n“你告诉他不少了，何不把其余的也告诉他。我不知道晚饭时你可留意到格雷?马图林没有？”\n“他那样高大，怎么会不注意到他？”\n“他也是追求伊莎贝儿的一个。拉里不在的时候，他一直非常之殷勤。她也喜欢格雷。假如战争再拖长一点，她很可能就嫁给格雷。格雷跟她求过婚。她没有接受，也没有拒绝。路易莎猜她是不愿意在拉里回来之前有所决定。”\n“格雷为什么不去参战呢？”\n“他因为踢足球心脏用力过度，严重是不严重，可是陆军不肯收他。总之，等到拉里回来，他就一点机会也没有了。伊莎贝儿毅然决然把他摔掉。”\n我不懂得对这件事应当怎么说，所以不开口。艾略特继续说下去，以他那样的堂堂仪表和牛津口音，足可以当一名外交部的高级官员。\n“当然，拉里是个好孩子，而且他私自溜了去参加空军也是十足的壮举，不过，我看人还相当在行……”他微笑一下，说了一句我听到他唯一暗示到他在古董生意上发了财的话，“否则，我现在就不会拥有一笔数额相当大的金边股票[注]。我的意见是拉里永远不会有什么出息，钱，地位，都说不上。格雷?马图林就全然不同了。有个很好的爱尔兰家声。祖上有一位是当主教的，一个戏剧家，还有几个出名的军人和学者。”\n“你怎么知道这些的？”我问。\n“人就是这样知道，”他若无其事地回答。“说句老实话，那一天在俱乐部里我碰巧翻一下美国名人字典，恰恰撞见这个姓氏。”\n我觉得犯不着多事，把晚饭时我的邻座告诉我的话告诉他，说马图林的祖父母是穷爱尔兰水手和瑞典女跑堂的。艾略特又说下去c“我们都认识亨利?马图林多年。是个顶好的人，而且很富有。格雷正踏进芝加哥最好的一家经纪人商号。哪一个不买他的账。他想娶伊莎贝儿；替她着想，不能不说是一门很好的亲事。我自己完全赞成，而且我知道路易莎也赞成。”\n“艾略特，你离开美国太久了。”布太太说，勉强地一笑。“你忘记在这个国家里，女孩子并不因为她们母亲或者舅舅赞成她们的婚姻就结婚的。”\n“这并不值得骄傲，路易莎。”艾略特尖刻地说。“根据我三十年的经验，我可以告诉你，一件婚事把地位，财产，双方的处境都考虑到，要比爱情的结合好十倍。说来说去，法国总是世界上唯一的文明国家了。在法，国，伊莎贝儿会毫不迟疑嫁给格雷；往后再过一两个年头，假如她愿意的话，可以把拉里当作她的情人，格雷可以置一所豪华公寓，养一个女明星，这样就皆大欢喜了。”\n布太太并不傻；她看看自己兄弟暗自好笑。\n“艾略特，碍事的是纽约的剧团每年只到这儿来演一个时期。格雷那所豪华公寓里的娇娘能够住多久，谁也说不准。这肯定对大家都不方便，是不是？”\n艾略特笑了。\n“格雷可以在纽约的证券交易所里弄一个经纪人的位置。说道地话，人在美国除了住纽约以外，我看不出能住在哪儿。”\n这以后不久我就离开了，可是，走之自前，我简直个懂得，艾略特为什么忽然问我可愿意和他一起吃午饭，会会马图林父子。\n“美国的商界人士中，亨利是最好的典型，”他说。“我觉得你应该见见。他替我们经管产业已经有多年了。”\n我并不怎么特别想见这个人，可是没有理由拒绝他，所以说很愿意。\n七 # 有人介绍我在芝加哥逗留期间加入一家俱乐部。俱乐部里有个很好的阅览室；赴筵的次晨，我去那里翻阅一两种大学刊物，因为这些刊物除掉长期订阅外，不大容易碰得见。时间还早，阅览室里只有一个人，坐在大皮椅子里在出神看书。我很诧异看见这人就是拉里。在这样一个地方，他可以说是我最不指望撞见的人。我走近时，他抬起头看，认识是我，做出要站起来的样子。\n“别起身，”我说，接着几乎是随口问他，“你看什么？”\n“一本书，”他说，微笑一下，可是那一笑非常动人，连他回话里那种顶撞的口吻都毫不使人生气了。\n他把书合上，用他那种特殊的没有光彩的眼睛望着我，举起来给我看书名。\n“你昨晚玩得好吗？”我问。\n“痛快极了，五点钟才回的家。”\n“那么你这么早到这儿来，又这样精神，真不容易。”\n”我常来这儿。一般在这个时候总是由我独占。”\n“我不打搅你。”\n“你并不打搅我，”他说，又笑一下，这时候，我才觉出他能够笑得极其可爱，并不是那种漂亮的、闪电似的笑，而是好象含有一种内在的光华，把他的脸都照明了。他坐的地方是用书架围成的一个角落，在他旁边还有一把椅子。他把手放在椅子靠手上说，“你坐一会吗？”\n“好的。”\n他把手里拿的书递给我。\n“我就看这个。”\n我看看，原来是威廉?詹姆斯[注]的《心理学原理》。这当然是部名著，在心理学史上很重要，而且书写得极其流畅；不过一个年轻人，一个飞行员，头一天还跳舞跳到早上五点钟，我决没有想到他手里会有这样一本书。\n“你为什么要看这个？”我问。\n“我的知识太浅了。”\n“你年纪还轻着呢，”我笑着说。\n他好一会没有说话，我渐渐觉得窘起来，正打算站起身去找我要找的杂志。可是，我觉得他仿佛要讲什么话似的。他眼睛视若无睹，脸色严肃而紧张，象在沉思。\n我候着他；心里很想知道是怎么一回事。当他开口时，那就象继续适才的谈话一样，井不感到中间长久的沉默。\n“我从法国回来时，他们都要我进大学。我不能。经历过那些事情，我觉得没法子回到学校去。反正我在中学也没有学到东西。我觉得我没法子参加一个一年级大学生的生活。他们不会喜欢我，我也不愿勉强自己做自己不想做的事。而且我不相信那些教师能教给我想要知道的东西。”\n“当然，我知道这事与我不相干，”我说，“不过，我并不觉得你对。我想我懂得你的意思，我也懂得一个人参加了两年战争之后，在开头一两年里当那种受人欣羡的普通大学生，是相当腻味的。我不相信他们会不喜欢你。美国大学我不大熟悉，可是，我相信美国的大学生和英国的也差不多，也许粗卤一点，稍为倾向于胡闹，可是，整个儿说来，还是些规矩懂事的孩子；我敢说，你假如不想过他们那种生活，只要稍微使一点手腕，他们总可以让你过你自己的生活。我的弟兄都读过剑桥，我就没有。有过一个机会，可是，我拒绝了。我要到外面来混。后来我一直都懊恼。我想进了大学可以使我少做多少错事。在有经验的老师指导下，你可以学得快得多。你假如没有一个人指导，就会糟蹋掉许多时间，走冤枉路。”\n“你也许是对的。我并不在乎做错事。也许在那许多死胡同的一条胡同里，可以找到适合我目的的东西呢。”\n“你的目的是什么呢？”\n他踌躇一下。\n“正是啊，我还不大清楚。”\n我没有开口，因为这句话好象没有什么可以回答的。我这个人从年轻时起就有个明确目标在脑子里，颇有点觉得不耐烦；可是，我责备自己；我有个感觉，只能说是直觉，好象这孩子灵魂里在模模糊糊追求一种东西，是不是属于一种半明半昧的观念，抑是一种隐隐约约的情绪，我也说不出，而这种追求却使他整个的人得不到宁息，逼着他，连他自己也不知道要向哪儿去找。他莫明其妙地激起我的同情。\n我从来没有听他多说话过，现在才觉察到他说起话来极其好听，那声音非常之醉人，就象仙丹。想到这一点，再加上他那迷人的笑，和富于表情的黑眼珠，我很能了解伊莎贝儿为什么爱他。他确乎有种惹人爱的地方。他转过头来，毫不忸怩地望着我，但是，眼睛里有一种表情，象在打量我，又象是好笑。\n“昨天晚上我们全走开去跳舞时，你们谈到我的吧？我这猜得对不对？”\n“有这么一个时候。”\n“我想他们硬把鲍勃大叔邀来，就是这个缘故。他顶恨出门。”\n“象是有人给你找了一个很好的事。”\n“一个顶好的事。”\n“你干不干呢？”\n“不见得。”\n“为什么不？”\n“我不想干。”\n这与我毫不相干，我实在是多事，可是我有个感觉，好象正因为我是个局外人，而且来自外国，所以拉里觉得同我谈谈没有关系。\n“你知道，一个人什么都做不了时，他就成了作家。”我吃吃笑了。\n“我没有才能。”\n“那么，你要做什么呢？”\n他向我来了一下他那明媚迷人的微笑。\n“晃膀子，”他说。\n我只好笑了。\n“我觉得，芝加哥并不是做这种事的顶好的地方，”我说，“不管啦，让你看书吧。我想去翻一下《耶鲁季刊》。”\n我站起来。等到我离开阅览室时，拉里还在出神看威廉?詹姆斯的那部书。我独自在俱乐部里用了午饭，因为阅览室里静，又回到那里去抽雪茄，这样消磨了个把钟点，看书写信。我很诧异看见拉里还在一心看他的书。那神气好象我走开后，他就没有动过。等到我约莫四点钟的时候走开，他还在那里。他这种明显的聚精会神能力，很使人吃惊。他既没有留意到我走，也没有留意到我来。下午我有各种事要做，直到应当换衣服去赴晚宴时，才回旅馆，回来的路上，忽然被一时的好奇心驱使，又走进俱乐部一次，到阅览室里看看。那时候，室内已有不少的人，看报啊，等等。拉里还是坐在那张椅子里，全神贯注在那本书上。怪！\n八 # 第二天，艾略特邀我在巴玛大厦午餐，会会老马图林和他的儿子。就只我们四个人。亨利?马图林也是个大个子，差不多和他儿子一样高大，一张红红的脸，满是肉，大下巴，同样带有挑斗性的塌鼻子，可是，眼睛比儿子的小，不那样蓝，极其狡猾。虽则年纪至多不过五十开外一点，看上去要老十年，头发已经稀得很厉害，而且全白了；初看上去，并不给人好感。他好象多年来自己混得很不错。我得到的印象是一个残酷、精明、能干的人，这种人在生意经上面是毫无慈悲可言的；开头时说话很少，我觉得他在打量我。我当然看出艾略特在他的眼中只是个可笑的人。\n格雷温和恭敬，几乎一句话不说，倘若不是艾略特的交际手腕老到，尽是滔滔不绝讲些闲话，彼此间就得僵着。我猜他过去和那些中西部商人做交易，一定获得不少经验，那些人不用花言巧语笼络，决不肯花那样惊人的价钱买一张旧名家的画的。\n不久，马图林先生慢慢高兴起来，也说了两句话。这才显出他并不象表面那样俗气，而且的确还有点冷隽的幽默感。有这么一会，谈话转到证券股票上去。我发见艾略特讲到这上面时头头是道，并不觉得诧异，因为我一向知道他为人尽管那样荒唐，可一点不傻。就在这时候，马图林先生说道：“今天早上我收到格雷的朋友拉里?达雷尔一封信。”\n“爹，你没有同我讲么，”格雷说。\n马图林先生向我说：“你认识拉里吧？”我点点头。“格雷硬要我在公司里安排他一个位置。他们是好朋友。格雷对他佩服得五体投地。”\n“他怎么说的，爹？”\n“他谢谢我，说他很知道这对于他这样的人是极好的机会。他详详细细把这件事情想过，最后认定自己不够我的期望，想想与其那样，还不如不接受的好。”\n“他这人真蠢，”艾略特说。\n“的确，”马图林先生说。\n“真正对不起，爹，”格雷说。“我和拉里假如能一块儿做事，够多美。”\n“你可以把马领到水边，你可没法使他喝水。”\n马图林先生说这话看看儿子，狡猾的眼光温和下来。我这才发现这寡情的商人还有其另一面；他简直疼这个大块头儿子。他又向我说：“你知道这孩子星期天在场子上打两盘让点赛，赢了我七点和六点。我真能够拿球棒把他脑子析出来。算起来还是我亲自教他打高尔夫的。”\n他满脸得意的样子，我渐渐喜欢他起来。\n“爹，我的运气太好了。”\n“一点也不是运气。你把球从洞里打出来，落下来离洞口只有六英寸远，这难道是运气？三十五码远不多也不少，就是那一球。明年我要叫他去参加业余锦标比赛。”\n“我没有法子抽出时间来。”\n“我是你的老板，是不是？”\n“我难道不知道？迟到写字间一分钟，你发那样的脾气。”\n马图林先生吃吃笑了。\n“他想把我说成是个专制魔王，”他向我说。“你别信他。我就是我的行业，和我合伙的人都不行，而我又重视我这行业。我叫这孩子先从最下级做起，指望他慢慢升上来代替我时，他就会对付得了。这是很大的责任，我这个行业，有些主顾的投资交给我管总有三十年了，他们信任我。跟你说句实在话，我宁可把自己的钱淌掉，不愿意看他们蚀本。”\n格雷笑了。\n“前几天，一个老小姐来，要把一千块钱投资在一个什么野鸡事业上，说是她的牧师劝她的，他就不肯替她办。她坚决要做，他就大发雷霆，弄得她哭着出了门。\n后来他又去会见那牧师，把牧师也着实收拾了一顿。”\n“人家把我们做经纪人的总说得不成东西。可是，经纪人里面也有分别。我不要人家蚀本，我要人家赚钱，可是，他们那种做法，多数的人会使你觉得他们在世界上的一个目的，就是使自己一文不名。”\n马图林父子辞去，回写字间。我们离开时，艾略特问我，“你觉得他怎么样？”\n“我总高兴碰见新型的人物。我觉得父子之间的感情相当感动人。敢说英国不大碰得见这种情况。”\n“他顶喜欢这孩子。这人真是个怪物，说他那些主顾的话全是真的。他手里有几百个老太婆、退伍军人、牧师，他们的储蓄都交给他经营。要是我，就会觉得不值得找这许多麻烦，可是，他很自负有这许多人信任他。不过碰到大生意，而且有厚利可图时，任何人都比不上他残酷和忍心。那是一点慈悲也没有的。非要他的一磅肉[注]不行，几乎没什么拦得了他。你把他的脾气搅翻，他不但要叫你倾家荡产，而且事后还要大乐特乐。”\n回到家，艾略特告诉布太太拉里回绝了亨利?马图林。伊莎贝儿正眼女友一块午餐。她进来时，姐弟还谈着这件事，就告诉了她。从艾略特的话里，我觉得他很费了一番唇舌。虽则他自己十年来一点工作不做，虽则他用以攒聚一笔富裕家财的工作也毫不艰苦，他却坚持工商业是人类生存必备的条件。拉里是一个极其平常的青年，毫无社会地位，他没有什么理由不遵从他本国共同遵从的习惯。在艾略特这样有眼光的人看来，美国显然正在走上一个空前的繁荣时代。拉里现在有个人门的机会，只要他勤勤恳恳，孜孜不息去做，也许到四十岁的时候，就抵得上几个百万富翁。那时候，他要是愿意歇手，做个寓公，或者在巴黎杜布瓦大街该一所公寓，或者在都兰置一所府第，他艾略特就没有话说。可是，布太太的话更直截了当，更无答辩的余地。\n“他要是爱你的话，就应当准备为你工作。”\n我不知道伊莎贝儿对这些话怎样一个回答，可是，她相当的见机，看得出她这些长辈都有着他们的理。她认识的那些年轻男子，哪一个不在学习就业，或者已经在一家公司里忙碌起来，拉里总不能指望靠他在空军里的卓越成绩吃一辈子。战争已经结束，人人都厌恶透顶，恨不能赶快忘记掉，愈快愈好。大家商量之后，伊莎贝儿答应把这件事情和拉里爽爽快快讲个明白。布太太想出一个主意，叫伊莎贝儿找拉里给她开车到麻汾去。布太太正预备定制客厅里的新窗帘，一张量好的尺寸单被她丢掉，所以要叫伊莎贝儿再去量一下。\n“鲍勃?纳尔逊会留你们吃午饭，”她说。\n“我有个更好的计较在此，”艾略特说。“你给他们准备一个食物篮子，让他们在廊沿上吃野餐，饭后他们就可以谈。”\n“这倒怪好玩的，”伊莎贝儿说。\n“再没有比舒舒服服吃一顿野餐更乐的了，”艾略特机灵地说。“老迪泽公爵夫人常跟我说，就是顶桀骛不驯的男人在这种场合也变得能说服了。你替他们的午饭预备什么吃的？”\n“蛋荷包[注]，跟一块鸡三明治。”\n“胡说，你要野餐，就不能不有肥肝酱。开头你得给他们咖喱虾仁，后来是鸡脯冻，衬上生菜心色拉，这得由我亲自动手。肥肝酱之后，随你的便，你要是尊重美国习惯的话，就来一个苹果排。”\n“我给他们蛋荷包和一块鸡三明治，艾略特，”布太太拿定主意说。\n“那么，你记着我的话，事情一定不成，那只能怪你自己。”\n“舅舅，拉里吃得很少，”伊莎贝儿说，“而且他吃什么都不知道。”\n“我希望你不要以为这是他的优点，蠢孩子，”她舅舅回答。\n可是布太太说给他们什么东西吃，他们那天就吃的那些东西。后来艾略特告诉我这次出游的结果时，他非常法国派地耸耸肩膀。\n“我告诉他们一定不会成功。我央求路易莎放一瓶蒙特拉夕酒，我在战前送给她的，她不听我话。用热水瓶装了一瓶咖啡，此外什么没有带。你能指望什么呢？”\n当时的情形好象是布太太和艾略特单独坐在客厅里，这时候车子到了门口停下，伊莎贝儿进屋子来。天刚黑，窗帘拉上。艾略特躺在圈椅里，在炉边看一本小说，布太太做一块刺花，预备当这火屏用。伊莎贝儿没有进来，上楼进了自己卧室。艾略特从眼镜上面望望他姐姐。\n“我想她脱掉帽子就会下来，”她说。\n可是，伊莎贝儿并没有下来。已经过了好几分钟。\n“也许人倦了，或者躺着呢。”\n“你难道没有希望拉里跟进来。”\n“艾略特，别惹人生气。”\n“好吧，反正是你的事，不是我的事。”\n他又看书，布太太继续做花。但是，半小时之后，她突然站起来。\n“我想，还是上去看看她怎样了。假如休息，我就不惊动她。”\n她离开屋子，可是，一会儿就下来了。\n“她哭过了。拉里要到巴黎去，去两年。她答应等他。”\n“他为什么要到巴黎去？”\n“问我没有用，艾略特，我不晓得。她什么都不肯告诉我。她说她了解，不愿意阻挡他。我跟她说，‘他如果打算丢下你两年，对你的爱也就有限了。’她说，‘我没有办法。事实是我非常之爱他。’我说，‘甚至于今天这样之后，还爱他？’她说，‘今天使我比往常更加爱他，而且，妈，他的确爱我，我敢肯定。’”\n艾略特想了一会。\n“那么两年之后怎样呢？”\n“我告诉你我不知道，艾略特。”\n“你认不认为这事非常之不如意？”\n“非常。”\n“这里只有一件事可以说，就是他们的年纪都还轻。等上两年对谁也没有妨碍。\n在这两年里头，什么事都会发生。”\n两人商量之后，都同意最好不要去惊动伊莎贝儿。那天晚上，他们本来要出去吃晚饭。\n“我不想叫她难受，”布太太说。“人家如果看见她眼睛完全肿起来，一定会奇怪。”\n但是，第二天午饭之后——就只家里三个人用饭——布太太又提起这件事，可是，从伊莎贝儿嘴里一点问不出什么来。\n“妈，除掉已经告诉你的之外，实在没有什么可以告诉你的，”她说。\n“可是，他要去巴黎做什么呢？”\n伊莎贝儿微笑一下，因为她知道自己的回答在她母亲听来一定不通情理之至。\n“晃膀子。”\n“晃膀子？你这话怎么讲？”\n“就是他告诉我的。”\n“我真是受不了你。你如果还有点脾气的话，当时当地就会跟他解约。他简直耍你。”\n伊莎贝儿看看她左手戴的戒指。\n“我有什么办法呢？我爱他。”\n后来，艾略特参加进来了。他拿出他有名的权术来谈这问题。“并不摆出我是她的舅舅，老兄，而是象一个世情洞达的人和一个没有经验的女孩谈话。”可是，他的成绩比布太太也好不了多少。我的印象是伊莎贝儿叫他别管闲事。当然话说得很有礼貌，但意思毫不含糊。艾略特是在当天稍晚一点把一切经过告诉我的，就在黑石旅馆我自己的小起坐间里。\n“当然路易莎是不错的，”他又说。“这事非常之不痛快，可是，让年轻人自己去找婚姻对象，除了相互爱慕之外，什么也不问，这种事情是必然碰上的。我跟路易莎说不要去愁它；我觉得这事不会变得如她设想的那样糟。拉里不在跟前，小格雷守在这儿——你说，结果不是摆明在那里；否则的话，我就是一点不懂得人情世故了。一个人在十八岁时情感非常热烈；但是不能持久。”\n“你真是洞悉世情，艾略特，”我微笑说。\n“我的拉罗什富科[注]总算没有白读。你知道芝加哥是怎样一个地方；他们天天见面。一个女孩子有一个男孩子这样对她钟情当然高兴；等到她知道她的那些女朋友里面没有一个不心甘情愿要嫁给他时——那么，我问你，从人情上讲，她是不是要把每一个人都挤掉呢？我是说，这就象有人家请你的客，明知道去了一定腻味得受不了，而且唯一的吃喝只是柠檬水和饼干，然而你还是去，因为你知道你顶好的朋友都恨不得爬了去，但是没有一个被请的。”\n“拉里几时走？”\n“不知道。我想大约还没有决定。”艾略特从口袋里掏出一个又长又薄的、白金和黄金合镇的烟盒子，掏出一支埃及烟。发第玛，吉士，骆驼，好运道，[注]都不是他抽的。他微笑望着我，一脸的鬼心眼儿。“当然我不想跟路易莎这样说，可是，告诉你倒不碍事；我肚子里却同情这年轻的小伙子。我想他打仗时见识过一下巴黎，这是世界上唯一适合文明人居住的城市，他着了迷，我一点不怪他。他年纪轻，我敢肯定他要在开始家庭生活以前，尽情荒唐一下。很自然，很正当。我要照拂他，把他介绍给那些合适的人。他风度不错，再由我指点一二，就很可以见得人；我敢保带他看看美国人很少有机会看到的法国生活的另一面。老兄，你相信我的话，一般美国人进天国远比他进圣日尔曼大街容易得多。他二十岁，人又风趣。我想我大约能够给他找一个年纪大一点的女人。这会使他成熟。我总觉得，青年男子能做一个上了相当年纪女子的情人，是再好没有的教育。当然，假如这女子是我想象的那种人，一个妇女界名流，你懂吧，这就会使他在巴黎立刻有了地位。”\n“你把这话告诉了布太太吗？”我微笑着问。\n艾略特吃吃笑了。\n“我的老哥，我假如有什么地方值得自负的话，那就是我的权术。我没有告诉她。她不会了解的，可怜的女人。我在有些事情上永远不懂得路易莎，这也是一件；她虽则半辈子都在外交界混，而且世界上一半的首都住了过来，可仍旧是个不可救药的美国人。”\n九 # 那天晚上，我到湖滨道一所大厦去赴宴。房子全是石砌的，看去好象当初的建筑师本来打算盖一座中世纪城堡，后来中途改变主意，决定改建为一幢瑞士木屋。\n那天是个大宴会，我走进那巨大而奢华的客厅时，满眼都是些石像，棕榈，架灯，古画，和挨挨碰碰的家具。还好至少有几个人是认识的。亨利?马图林给我介绍了他的骨瘦如柴的老婆，搽得一脸脂粉。还有布太太和伊莎贝儿，我都问了好。伊莎贝儿穿一身红绸子衣服，和她的浓栗色头发、深褐色眼睛很配。她看上去兴致很好，没有人会猜到她不久以前还呕了气来。围着她的有两三个年轻人，格雷也是一个，她正和他们谈笑。晚饭时，她坐在另一桌，看不见她。饭后，我们男人都慢腾腾地喝咖啡，呷酒，抽雪茄，好久好久才回到客厅里来。这时我总算找到一个机会和她说话。我跟她不熟，没法子把艾略特告诉我的那些直接向她说，可是，有些事我觉得告诉她之后，她也许会高兴。\n“那天在俱乐部里我碰见你的男朋友，”我随随便便说。\n“哦，是吗？”\n她说话时也象我一样随便，可是，看得出立刻警觉起来，眼睛在张望，而且我能看出里面带有恐惧。\n“他在阅览室里看书；那样的专心，我真是意想不到。我十点钟过一点进去时，他在看书；我吃完午饭，回阅览室时，他还在看书；我出外吃晚饭，路过俱乐部进去看看时，他仍旧在看书。敢说他足足有十个钟点坐在椅子里没有动过。”\n“他看的什么？”\n“威廉?詹姆斯的《心理学原理》。”\n她眼睛垂了下去，使我没法知道她听了我这番话后是什么滋味，可是，我有点觉察到，好象她既迷惑不解，又松了一口气。这时主人跑来拉我去打桥牌，等到牌局散时，伊莎贝儿和她母亲已经走了。\n十 # 两天之后，我去向布太太和艾略特辞行，碰到他们正在喝茶。伊莎贝儿随后也来了。我们谈到我未来的远东之行，我并且谢谢他们对我在芝加哥逗留期间的殷勤招待；坐了适当一段时间之后，我便起身告辞。\n“我陪你走到药房那儿，”伊莎贝儿说。“我刚想起有点东西要买。”\n布太太最后叮咛的话是：“你下次看见亲爱的玛格丽达王后时，替我问候好吗？”\n我再也不打算否认我认识这位尊贵的女人了，就随口答应一定做到。\n到了马路上时，伊莎贝儿带着微笑斜瞥我一眼。\n“你可想喝一杯冰淇淋苏打？”她问。\n“未始不可以，”我小心地回答。\n当我们向药房[注]走去时，伊莎贝儿始终没有说话；我本来没有话，所以也不做声。进了药房，我们找一张桌子坐下，椅背和椅子腿都用铁条扭成，坐着怪不舒服。我叫了两杯冰淇淋苏打。柜台那边有个人在买东西；别的桌子坐着有两三对客人，但是，都忙着谈自己的事情，所以等于只有我们两个。我点起一支香烟等着，伊莎贝儿则显得非常惬意地吸着长麦管。我看出她有点紧张。\n“我想跟你谈谈，”她平空讲了一句。\n“我猜到是，”我微笑说。\n有这么半晌，她沉吟地望着我。\n“前天晚上，你在萨特恩韦特家为什么谈到拉里那件事情？”\n“我想你也许感觉兴趣。我觉得你可能不完全懂得他说的晃膀子是什么意思。”\n“艾略特舅舅真会搬弄是非。当他说要上黑石旅馆找你谈谈时，我就知道他要把所有的事情告诉你了。”\n“你知道，我认识他多年。他就喜欢谈论别人的事情。”\n“他是这样，”她微笑说。可是，笑只是一刹那。她目不转睛地望着我，眼睛里神情很严肃。“你觉得拉里怎样？”\n“我只见过他三次，人好象很不错。”\n“就这么些吗？”\n她的声音有点窘。\n“不，不完全如此。我怎么说呢；你知道，我跟他太不熟悉了。当然，他很讨人喜欢。他有一种谦虚、和蔼、温柔的地方，很吸引人。年纪这样轻，可是，人很有主意；跟我在这里见到的别的男孩子全不一样。”\n我就是这样支支吾吾地想把自己脑子里还没有怎样弄清楚的印象表达为语言；我这样说时，伊莎贝儿凝神看着我。我讲完之后，她轻轻叹了一口气，仿佛放下心来。然后对我嫣然一笑，几乎带点顽皮。\n“艾略特舅舅说他时常对你的观察力感到诧异。他说什么都逃不过你的眼睛，但是，你作为一个作家的最大长处是你有常识。”\n“我能够想出比这更可贵的长处，”我淡然说。“例如才气。”\n“你知道，我找不到一个人商议这件事情。妈只能从她自己的角度看问题。她要我的未来生活得到保证。”\n“这是很自然的事，可不是？”\n“艾略特舅舅只看社会地位。我自己的朋友，我是指那些和我年纪相仿的人，认为拉里没有出息。这使我很难受。”\n“当然。”\n“并不是说他们待他不好。谁也没法对拉里不好。可是，他们看不起他；老是拿他开玩笑，使他们恼火的是他好象并不在乎。他只是笑笑。你知道事情现在弄成什么样子？”\n“我只知道艾略特告诉我的那些。”\n“我可不可以把我们那天上麻汾去的情形一五一十地告诉你？”\n“当然可以。”\n下面的叙述一部分是根据伊莎贝儿当时谈话的回忆，一部分是根据我的想象改写的。可是，她和拉里的谈话很长，敢说要比我现在打算叙述的要多得多。就如同人们在这类场合通常做的那样，恐怕他们不但讲了许多不相干的话，而且反复讲了许多同样的话。\n那天伊莎贝儿醒来，看见天气很好，就打个电话给拉里，告诉他说，她母亲有点事情要她到麻汾去一趟，叫他开汽车送她去。她除掉她母亲关照尤金准备的一热水瓶咖啡外，又慎重地在篮子里放进一水瓶的马地尼鸡尾酒。拉里新近买了一部双人跑车，很得意。他是个开车快手，开的速度使两人都非常开心。到达之后，伊莎贝儿量了调换窗帘的尺寸，教拉里记下。后来就在廊沿上把午餐摆出来。廊沿上什么风都吹不到，小阳春天气的太阳晒得很舒服。那幢房子造在一条土路边上，和新英格兰那些旧式的木屋比起来，一点不漂亮，顶多只能说得上宽敞舒适，可是从廊沿上望出去的景色却还悦目，一座红色的大谷仓，黑屋顶，一丛老树，再过去是一片一眼望不到头的褐色田野。景色是单调的，可是，阳光和秋深的温暖色调，在那一天却给它添上一种亲切的娇美。展现在你面前的那片寥廓里，有一种欢乐。冬天这里一定寒冷荒凉，夏天可能炎蒸逼人，可是，在这个季节却使人感到异样兴奋，因为宽阔的景色逗得人从内心里感到冲动。\n他们就象健康的年轻男女一样，一顿午饭吃得很开心，而且很高兴能够两个人在一起。伊莎贝儿把咖啡倒出来，拉里点上烟斗。\n“现在爽快谈吧，心肝，”他说，眼睛里带着好笑的神气。\n伊莎贝儿吃了一惊。\n“爽快谈什么？”她尽量装出不懂的样子。\n拉里扑哧笑了一声。\n“亲爱的，你难道把我当作十足的傻瓜？你母亲要是不知道客厅里窗帘的尺寸，就把我的头砍掉。这不是你要我开车子送你下来的理由。”\n伊莎贝儿这时已经镇定下来，对他明媚地笑了一下。\n“可能是因为我觉得我们两个人单独在一起玩一天很有意思。”\n“可能，不过，我觉得事情不是这样。我的猜想是，艾略特舅舅已经告诉你，我谢绝了亨利?马图林给我的事情。”\n他说得很愉快，也很轻松；伊莎贝儿觉得用这种口吻谈下去倒也方便。\n“格雷一定感到非常失望。他觉得有你跟他在一个写字间里太妙了。你总有一天要找个工作做，而且时间拖得越久，就越难找。”\n他抽着烟斗望着她，温柔地微笑着，使她弄不清他究竟是认真，还是在开玩笑。\n“你知道，我有个看法，觉得我这一生还可以多做点事情，不能够光卖股票。”\n“那么好吧。你就去进律师事务所，或者去学医。”\n“不，这两件事我都不想做。”\n“那么，你想做什么呢？”\n“晃膀子，”他泰然回答。\n“唉，拉里，别胡扯。这件事情，关系太大了。”\n她的声音有点发抖，眼睛里含着泪水。\n“心肝，别哭。我不想弄得你不开心。”\n他走过来，坐在她身边，用胳臂搂着她。他的声音里含有一种柔情，使她伤心起来，眼泪再也忍不住了。可是，她擦干眼泪，嘴边勉强装出一点微笑。\n“你尽管说你不想弄得我不开心。你就是弄得我不开心。你知道，我爱你。”\n“我也爱你，伊莎贝儿。”\n她深深叹了一口气；然后挣脱他的胳臂，坐开一点。\n“人总要讲道理。一个人总得工作，拉里。这是一个做人的问题。我们国家还很年轻，一个人有责任参加国家的各种活动。亨利?马图林在前两天还讲过，我们正开始一个新的时代，这将使过去时代的成就看上去就象几个小钱一样。他说，他看不出我们的进步会有个完，而且他深信到了一九三○年，我们将成为世界上最富和最大的国家。你认不认为这太叫人兴奋了？”\n“是叫人兴奋。”\n“年轻人从来没有碰到这样好的机会过。我会认为你将以参加目前这些工作为荣呢。这是了不起的惊天动地的事情。”\n他轻松地笑了。\n“我敢说你是对的。那些阿穆尔和斯威夫特公司将会做出更多更好的肉罐头，那些麦考密克公司将会造出更多更好的收割机，亨利?福特将会造出更多更好的汽车。而且人人都会变得愈来愈有钱。”\n“为什么不可以？”\n“正如你说的，为什么不可以？不过，碰巧我对钱不感觉兴趣。”\n伊莎贝儿咯咯笑了。\n“亲爱的，别象傻子一样说话。一个人没有钱就不能生活。”\n“我有了一点钱。这就使我有机会做我想做的事情。”\n“晃膀子吗？”\n“对，”他微笑回答。\n“跟你真难说话，拉里，”她叹口气。\n“对不起，我并不是故意要这样。”\n“你是故意。”\n他摇摇头，人沉默了一会，在想心思。等到他终于开口时，他的话使伊莎贝儿听了一惊。\n“死者死去时那样子看上去多么死啊！”\n“你这话究竟是什么意思？”她问，人有点着慌。\n“就是这个意思，”他向她苦笑一下。“当你一个人飞上天时，你有许多时间思索。你会有许多怪想法。”\n“哪些想法？”\n“模糊的。不连贯的。纷乱的，”他笑着说。\n伊莎贝儿把这话盘算一下。\n“你觉得不觉得，如果你找一个工作，这些想法说不定自己会理出个头绪来，那时候你就会知道是怎么回事了。”\n“这个我也想过。我想到说不定跟一个木匠或者去一个汽车修理站做工。”\n“唉，拉里，人家会当作你发疯呢。”\n“这有关系吗？”\n“对我说，是的。”\n两个人重又沉默下来。后来是伊莎贝儿先开口。她叹了口气。\n“你跟你去法国以前完全是两个人。”\n“这并不奇怪。你知道当时我碰上许多事情。”\n“你举个例子看。”\n“噢，不过是些通常的琐事。我在空军里最要好的朋友为了救我的性命，牺牲了。我对这事一直觉得很难过。”\n“跟我谈谈，拉里。”\n他望着她，眼睛显出非常痛苦的神气。\n“还是不谈的好。归根到底，这只是一件小小的不幸事故。”\n伊莎贝儿本来富于感情，眼泪又江起来。\n“你苦恼吗，亲爱的？”\n“并不，”他微笑回答。“唯一使我苦恼的是我使你这样苦恼。”他抓着她的手，坚实有力的手抵着她的手时，给她一种非常友善亲惬之感，使她不得不咬着嘴唇，不让自己哭出来。他沉重地说，“除非我对一些事情有了一定看法，我将永远得不到平静。”他又迟疑一下。“这很难用语言表达，你才想说出来，就感到尴尬。\n你跟自己说：‘我算是老几，要在这个、那个和别的事情上动脑筋？也许这只是因为我是狂妄之徒。按照老一套行事，随遇而安，会不会好些呢？’接着，你就想到一个在一小时以前还是个有说有笑、充满生气的人，直挺挺躺在那里；就是这样残酷，这样没有意义。你没法子不问自己，人生究竟是为了什么，人生究竟有没有意义，还仅仅是盲目命运造成的一出胡里胡涂的悲剧。”\n拉里讲话的音调非常之美，说说停停，就好象是强迫自己说出自己不愿意说的话，然而是这样沉痛真挚，使人听了不由得不感动：伊莎贝儿等了半晌，然后不由自主地说：“你出门去走一趟会不会好些？”\n她问这话时心沉了下来。拉里等了好久方才回答。\n“我也这样想。你竭力想要不理会社会舆论，可是，这不容易。当社会舆论对你是敌对时，你心里也变得敌对起来，这样你就得不到平静。”\n“那么，你为什么不走呢？”\n“唔，是为了你。”\n“亲爱的，让我们相互不要做假。目前我在你的生活里并没有地位。”\n“这是不是说，你不想和我保持订婚关系呢？”\n她颤抖的嘴唇勉强装出微笑。\n”不，胡说，我的意思是我愿意等。”\n“也许要一年，也许两年。”\n“没有关系。可能会短些。你打算上哪儿去呢？”\n他凝神望着她，仿佛想要看到她内心深处似的。她微笑着，以此掩饰自己紊乱的心情。\n“我想先上巴黎。那边我一个人不认识。不会有什么人干涉我。我在部队里休假时，去过巴黎几次。我不懂得什么缘故，可是，我有个想法，觉得到了那边，我头脑里一切昏昏糊糊的思想都会得到澄清。那是个怪地方，使你感到你在那边能够把自己要想的事情想个透。我想在巴黎也许可以找到我要走的路。”\n“如果万一你找不到呢？”\n他吃吃笑了。\n“那样我就回到我们美国的十足实际的人生观上来，承认这事行不通，并且回到芝加哥，有什么事情做什么事情。”\n这次谈话给伊莎贝儿的刺激太大了，她告诉我时还不免有点动心；讲完之后，她可怜相地望着我。\n“你觉得我做得对吗？”\n“我认为你不但做了你唯一能够做的事，而且觉得你非常之厚道、宽宏、体贴。”\n“我爱他，我要他快乐。你知道，在某一点上，我对他走并不感觉难受。我要他离开这个不友好的环境，不但为了他，也为了我自己。我不能怪那些人说他不会有什么出息；我恨他们，然而我内心里一直怀着恐惧，觉得他们对。可是，你不要说我体贴。他在追求什么，我一点体会不到。”\n“也许你感情上体会到，理智上体会不到，”我微笑说。“为什么你不立刻和他结婚，跟他一起到巴黎去？”\n她眼睛里微微露出笑意。\n“我没有比这件事情更愿意的了，可是我不能。你知道，我的确认为他没有我要好过得多，尽管我非常不愿意承认这一点。如果纳尔逊医生的话说得对，他的病是一种慢性惊恐症，那么，新环境和新兴趣就会将他医好；等到他的精神状态恢复平衡之后，他就会回到芝加哥来，象正常人一样做生意。我不想嫁一个游手好闲的人。”\n伊莎贝儿从小的教养方式使她接受灌输给她的那些原则。她并不想到钱，因为她从来就不曾尝到没有她眼前这一切的滋味，可是，她本能地感到钱的重要性。钱意味着权势和社会地位。人应当赚钱是天经地义的事；他的一生显然应当放在这上面。\n“你不理解拉里，我并不奇怪，”我说，“因为我敢肯定他自己也不理解自己。\n他不肯谈他的打算，可能是因为自己也弄不清是些什么打算。你记着，我跟他简直不熟，这仅仅是臆测：他有没有可能在寻找什么，但是，寻的什么他并不知道，甚至有没有他都没有把握，会不会呢？也许他在大战中的有些遭遇，姑且不问是些什么遭遇，使他的心情平静不下来。你认不认为，他可能在追求一种虚无缥缈的理想——就象天文学家在寻找一颗只有数学计算说明其存在的星体一样？”\n“我觉得有件什么东西在使他苦脑。”\n“是他的灵魂吗？可能他对自己感到害怕。可能他对自己心灵的眼睛迷迷糊糊看到的境界是否真实，自己都没有把握。”\n“他有时候使我觉得他非常古怪；他给我一个印象，就象是个梦游者在个陌生地方突然醒过来，摸不清身在何处似的。大战前他人非常正常。他最可爱的地方是对生活的热爱。人吊儿郎当的，兴致总是那么好，跟他在一起真是开心；他的为人既可爱，又可笑。是什么使他变得这样厉害？”\n“我也说不了。有时候，一件小事情对一个人就会有很大的影响，那要看他当时的处境和心情。我有一次在全圣节那一天，法国人称做的死者节，到一个村庄的教堂去做弥撒，那个村子在德国人第一次向法国进军时曾经被骚扰过。教堂里挤满了军人和戴孝的女人，教堂墓园里是一排排木制的小十字架。当悲惨而庄严的弥撒在进行时，女人都哭了，男人也哭了。我当时有个感觉，仿佛那些睡在小十字架下面的人可能比那些活人要好受些，我把这个感想告诉一个朋友，他问我这是什么意思。我没法解释，而且看出他认为我是个十足的傻瓜。我还记得，在一次战斗之后，一群死掉的法国士兵重重叠叠地堆在一起，看上去就象是一个破了产的木偶剧团胡乱丢在垃圾角落里的许多木偶，因为它们已经不能再派用场了。当时我想到的就是拉里告诉你的那句话：死者死去时的样子看上去多么死啊！”\n我不想给读者一个印象，好象我要把拉里大战中那件使他极端不能平静的遭遇搞得神秘化，到适当时候，再加以揭露。我想他跟任何人都没有谈过。可是，他在多年之后，却告诉了一个我和他都相识的女子，苏姗?鲁维埃，关于那个救了他性命而牺牲了的年轻空军情况。苏姗转告了我，所以，我只能根据第二手材料重述事情的经过。我是根据苏姗的法语转译过来的。拉里显然和他的小分队里另一个男孩子结下很深的友谊。苏姗只知道拉里用以称呼他的带有讽刺性的绰号。\n“他是个红头发的小家伙，爱尔兰人。我们经常叫他帕特西，”拉里告诉苏姗，“而且比我认识的任何人都更加精力充沛。哎，简直是生龙活虎一般。他长了一张古怪的脸，笑起来也是那副怪样子，人家只要看见他，就忍不住要笑出来。他是个横冲直撞的家伙，什么想入非非的事都做得出；上级经常把他叫去臭骂一顿。人从来不懂得什么叫害怕，作战时差一点儿就送掉性命，他却笑得嘴咧得多大的，就象这是世界上最好笑的事情一样。可是，他是个天生的飞行员，在天上时，非常沉着和警觉。他教给我不少东西。他比我年纪大一点，把我看作是他的小弟弟；这的确有点滑稽，因为我比他要高出六英寸，如果动起手来，我可以随便一拳就把他打倒。\n有一次，在巴黎，他吃醉了酒，真的把他打倒过。\n“我参加空军小分队时，人有点不够振作而且怕自己做不出成绩来，他总是跟我讲些好话，加强我的自信心。他对战争的看法很怪，对德国鬼子一点没有敌意；可是，他喜欢打架，和德国鬼子打仗，他从心眼里快活。打下他们一架飞机，在他看来，等于和德国人开了一次天大的玩笑。人老脸皮厚的，一点没有管束，一点不知轻重，可是，有那么一点真挚的地方，使你没有法子不喜欢他。在你身上会随便把钱花光，也会把你的钱随便花光。如果你觉得寂寞，或者想家，或者害怕，象我有时候那样，他就会看出来，一张丑陋的小脸，这时就会满堆着笑，说些打中你心坎的话，使你心情恢复过来。”\n拉里抽他的烟斗，苏姗等他继续说下去。\n“我们时常打假报告，使我们能够一同出去休假；我们一到了巴黎，他人就野了。我们玩得真是开心啊。我们在三月初旬计算要有一个时候假期，那是在一九一八年，我们预先定下计划。不管什么事情，我们都打算尝试一下。走前一天，队里叫我们飞到敌方上空侦察，把我们看到的情况写一个报告。突然间，我们碰上几架德国飞机，我们还没有弄清是怎么回事，就已经干了起来。其中一架在我后面追来，可是我先得了手。我回头看看它会不会摔下去，就在这时，我从眼角里瞄到另一架飞机钉着我的尾巴。我低冲躲开它，可是，它一转眼就追上我，我想这一下可完了；后来，我看见帕特西就象一道闪电似的向它冲下来，把所有的弹药都对准它放。它们吃不消溜走了，我们也回到阵地。我的飞机给打得遍体鳞伤，我侥幸着陆了。帕特西比我先着陆。我下了飞机时，他们刚把他抬出飞机。他躺在地上，人们在等待救护车开来。他看见我时，咧开嘴笑了。\n“‘我打掉了那个钉着你尾巴的讨厌鬼，’他说。\n“‘你怎么啦，帕特西？’我问。\n“‘哦，没有关系。他打中我的胳臂。’“他脸色惨白。突然间，脸上显出一种古怪神情。他这才恍悟出自己要死了，而死的可能性在他脑子里从来就没有转过。他们还没有来得及拦他，他已经坐了起来，笑了一声。\n“‘呀，我他妈的，’他说。\n“他倒下死了。不过二十二岁。他本来预备战后回爱尔兰和一个姑娘结婚的。”\n我和伊莎贝儿谈话的第二天，就离开芝加哥上旧金山，在那边再坐船去远东。\n第二章 # 一 # 一直到第二年六月底，艾略特来到伦敦，我才和他重又见面。我问他拉里究竟去了巴黎没有；他告诉我去了。艾略特对他很是恼火，使我听了暗笑。\n“我对这孩子本来抱有同情，他要在巴黎住上两年，我也不能怪他，我而且准备拉他一把。我告诉他，一到巴黎，就通知我，可是，直到路易莎写信告诉我他在巴黎时，我才知道他来了。我由美国旅行社转给他一封信——这通信地址是路易莎告诉我的——叫他上我家来吃晚饭，好和几个我认为他应当认识的人见见面；我想先让他见见那批法美籍的人，爱米丽?德?蒙塔杜尔和格拉西?德?夏托加亚尔等，你知道，他回信怎么说？他说，他很抱歉，不能够来，而且他没有带晚礼服。”\n艾略特眼睛盯着我望，指望这点吐露能引起我的震动。当他看见我处之泰然时，眉毛抬了起来，很不屑的样子。\n“他的回信写在一张乌七八糟的信纸上，上面印有拉丁区一家咖啡馆的名字；我写回信给他，要他把他的住址告诉我。我觉得，为了伊莎贝儿的缘故，我非得帮助他一下不可；我想也许他脸嫩吧——我的意思是说我就不相信一个正常的年轻人到巴黎来会不带晚礼服的，而且不管怎样说，巴黎的服装店也还过得去：所以，我就邀他来吃午饭，而且说客人不多，可是，你相信不相信，他不但不理会我要求他把住址告诉我，仍旧是美国旅行社转，而且说他从来不吃午饭。这一来，我可把他没有办法了。”\n“下知道他究竟在干些什么？”\n“不知道，而且告诉你老实话，我也不想知道。恐怕他是个极端没有出息的青年人，我认为伊莎贝儿嫁给他，是个大错。说到底，如果他过的是正常生活，我在里茨酒吧间或者富凯饭店或者什么地方总该会碰见他。”\n这些时髦地方，有时候我自己也去，但是，别的地方也去。就在这一年的秋初，我上马赛去，预备乘法邮公司的船上新加坡，碰巧在巴黎呆了几天。有一天傍晚，我和几个朋友在蒙帕纳司区吃过晚饭，一同去多姆咖啡店喝杯啤酒。我四面看看，不久就瞧见拉里一个人靠着一张大理石的桌子，坐在拥挤的走廊上。他在悠然望着来往行人；闷热的白天过后，那些行人正在享受晚凉。我丢下我的朋友向他走去。\n拉里看见我，脸上露出笑容。他请我坐下，可是，我说，我还有朋友在一起，不能多留。\n“我只想问候你好不好，”我说。\n“你住在巴黎吗？”他问。\n“只有几天工夫。”\n“明天跟我吃午饭好吗？”\n“我还以为你不吃午饭呢？”\n他咯咯笑了。\n“你见过艾略特了。我一般不吃，没有时间吃，所以，我只吃一杯牛奶和一块烧饼。可是，我很想跟你一起吃午饭。”\n“好的。”\n我们约好隔天在多姆见面，先喝杯酒开胃，然后在蒙帕纳司大街上找个馆子吃饭。我回到我的朋友那里，坐着谈天。当我再望望拉里时，他已经走了。\n二 # 第二天上午，我过得很开心。我去卢森堡博物馆[注]花了一个小时看了几张我喜欢的画，然后，在园子里闲逛，追忆着我的青年时代。什么都没有变。那些沿着沙砾小径一对对走着，热烈地讨论那些使他们兴奋的作家的，很可能就是当年那些学生。那些在保姆的监视目光下滚着铁环的儿童，很可能就是当年那些保姆和儿童。\n那些晒着太阳、看着早报的老人，很可能就是当年那些老人。那些戴着孝，坐在公共长凳上，相互谈着食品价格和佣人弊病的，很可能就是当年那些中年妇女。后来我去奥台翁剧院，看看走廊上陈列的新书，而且看见那些青年人和我三十年前一样，在穿着长罩衫侍役的不耐烦目光下，尽量多看一点他们买不起的书。后来我懒懒散散穿过那些亲切而阴沉的小街到了蒙帕纳司大街，再走到多姆咖啡馆。拉里在等我。\n我们喝了一杯酒，就沿着马路找到一家可以在室外进餐的馆子。\n拉里可能比我上次见到他时要苍白些，这使他陷在眼窝里的一双黑眼睛颜色更加深了；可是人还是那么自如，这在一个年纪这样轻的人很是稀奇，而且笑得还是那么天真。我注意到他的法语讲得很流利，重音很好；向他表示祝贺。\n“你知道，我以前懂得一点法语，”他解释说。“路易莎伯母给伊莎贝儿聘的一位家庭教师是法国人，他们在麻汾时总要叫我们始终跟她讲法语。”\n我问他喜欢不喜欢巴黎。\n“很喜欢。”\n“你住在蒙帕纳司吗？”\n“是的，”他迟疑了一下才回答；我理解这是因为他不愿意把自己的确切住址告诉我。\n“艾略特对你只告诉他一个由美国旅行社转的地址相当不高兴。”\n拉里笑笑，但是，没有回答。\n“你成天干些什么呢？”\n“晃膀子。”\n“看书吗？”\n“是的，看书。”\n“你可听到伊莎贝儿的消息没有？”\n“有时候。我们两人都不大欢喜写信。她在芝加哥玩得很开心。明年她要来和艾略特住些时候。”\n“那对你不是很好吗？”\n“我敢说伊莎贝儿从来就没有到过巴黎。带她去逛一定很有意思。”\n他急于想知道我的中国之行怎么样，我告诉他时，他凝神听着；可是当我想使他谈谈自己时，却没有能达到目的。他的嘴非常之紧，使我只能得出一个结论，就是他约我和他吃午饭，只是因为他喜欢我陪陪他。我虽然高兴，但是，有点迷惑不解。才吃完咖啡，他就叫开帐。付了帐，他就站起身来。\n“啊，我得走了，”他说。\n我们分了手。我比以前对他的情况并不知道得更多一点。我没有再见过他。\n三 # 一直到第二年春天，我才重到巴黎；那时，布太太和伊莎贝儿已经比她们原先计划的时间早一点到达，在艾略特家里住了下来。这中间隔了有好几个星期，因此，我又得运用想象，把这段时间内的经过补叙一下。她们在瑟堡上的岸，艾略特一直非常体贴，亲自去迎接她们。海关检查以后，三个人上了火车；艾略特等火车开动，才相当得意地告诉她们，他雇了一个很好的身边使唤的女仆照应她们。布太太说这完全没有必要，因为她们并不需要女仆，艾略特对她很不客气。\n“不要一到就叫人不耐烦，路易莎。一个人没有女佣人就见不了人，我雇下安托瓦内特不但为了你们，也为了我自己。你们穿得不讲究，我也没面子。”\n他看了她们穿的衣服，一眼不屑的神气。\n“当然你们要买点新衣服。我想来想去，认为只有夏内尔服装店最合适。”\n“我以前总是上沃思服装店，”布太太说。\n她这话等于白说，因为艾略特根本不睬。\n“我跟夏内尔当面讲过，而且替你们约好下午三点钟。还有帽子。当然在勒布买。”\n“我不想花上一大笔钱，艾略特。”\n“我知道。我打算全部费用由我来付。你非得给我挣面子不可。哦，路易莎，我已经为你安排了几次宴会，而且告诉我的法国朋友，说迈隆当过大使；这个，如果他活得长一点，是准会当上的；这样给人的印象要好些。我想这件事不会有人问起，不过我还是预先给你打下招呼的好。”\n“你真可笑，艾略特。”\n“不，我并不。我懂得世情。我知道一个大使的孤孀要比一个专员的孤孀有身份。”\n火车开进北站，伊莎贝儿站在窗口，这时喊了出来。\n“拉里来了。”\n火车才停，伊莎贝儿就跳下车，迎着拉里跑去。他张开胳臂抱着她。\n“他怎么知道你们来的？”艾略特酸溜溜地问姐姐。\n“伊莎贝儿在船上给他发了个电报。”\n布太太很亲热地吻了拉里，艾略特伸出一只不带劲的手让他握一下。时间已是晚上十点。\n“舅舅，拉里明天能不能来吃午饭？”伊莎贝儿叫，她和拉里胳臂套着胳臂，脸色急切，眼睛里闪着光。\n“我很荣幸，不过，拉里通知过我，他不吃午饭。”\n“他明天会吃的，是不是，拉里？”\n“是的，”他微笑说。\n“那么请你明天一点钟光临。”\n他重又伸出手来，想要打发他走，可是拉里老脸厚皮地向他咧着嘴笑。\n“我要帮助搬行李，还要给你们叫辆汽车。”\n“我的车子在等着，我的佣人会照顾行李，”艾略特岸然说。\n“好极了。那我们就可以走了。车子坐得下的话，我预备送你们到门口。”\n“对的，送送我们，拉里，”伊莎贝儿说。\n两人一同沿月台走去，布太太和艾略特跟在后面。艾略特一张冷冰冰的脸，很不以为然的样子。\n“quelles mauieres，”[注]他自言自语；在某种情况下，他觉得讲法语能够更有力地表达他的情绪。\n第二天上午十一点钟，艾略特盥洗完毕——因为他起身较晚——给他姐姐写了一张便条，叫佣人约瑟夫和女仆安托瓦内特送去，约她到书房来谈话。布太太来了之后，他小心把门关上，拿一支香烟装在一根非常之长的玛瑙烟嘴上点起来，并且坐下。\n“难道伊莎贝儿和拉里还算订婚吗？”他问。\n“我知道的是这样。”\n“我对这个年轻人可没有什么好话可以奉告。”接着他就告诉她，他是怎样准备把拉里拉进社交界，以及他计划以一种适当和得体的方式使他取得地位。“我甚至于替他留心到一处底层住房，这恰恰就是他需要的。是小德?雷泰侯爵的房子，他要分租出去，因为他被派到驻马德里的大使馆任职。”\n但是，拉里谢绝了艾略特的那些邀请；根据他这种表现，显然他不需要艾略特的任何帮助。\n“如果你不想利用巴黎能够给你的机会，你上巴黎来又为了什么呢，我真弄不懂。我不知道他干些什么。他好象什么人都不认识。你知道他住在哪儿吗？”\n“我们知道的唯一通信地址就是美国旅行社转。”\n“就象个旅行推销员或者度假期的教师。我有把握说，他在蒙马特尔[注]的一间画室里跟一个下流女人同居着。”\n“胡说八道，艾略特。”\n“他把自己的住处搞得这样神秘，而且拒绝和他同样身份的人来往，除了这，还会有什么别的解释？”\n“这不象拉里的为人。而且昨天晚上，你可看出他仍旧象过去一样爱伊莎贝儿。\n他不可能这样做假。”\n艾略特耸耸肩膀，意思是告诉他姐姐，男人是花样百出的。\n“格雷?马图林怎样？还在追吗？”\n“只要伊莎贝儿要他，他立刻就可以跟她结婚。”\n接着，布太太告诉艾略特，为什么她们比原订的计划提早来欧洲。她发现自己的健康不好，医生告诉她是糖尿病。病情并不严重，只要饮食小心，适当地服用胰岛素，完全有理由活上好多年，可是，她在获悉自己得了这种不治之症之后，急切想看见伊莎贝儿的婚事能够解决。母女两个谈过这件事。伊莎贝儿很懂事理，同意如果拉里在巴黎住了两年之后，不遵照原议回到芝加哥，并且找个工作做，那就只有一条办法，和他解约。可是，布太太觉得要等到约定的时间，然后去巴黎把拉里象个逃犯一样抓回本国，有损个人的尊严。她感到伊莎贝儿这样一来会弄得很失面子。但是，母女两个上欧洲歇夏却是很自然的事，而且伊莎贝儿还是在孩提时到过巴黎，后来就没有去过。她们逛了巴黎之后，可以找一处海滨让布太太养病，再从那边去奥地利的蒂罗尔山区住一个时期，然后从容不迫地穿过意大利。布太太有意约拉里陪她们去，让他和伊莎贝儿看看相隔这么久之后，两人的感情有没有变。拉里经过这次放荡之后，愿意不愿意承担生活责任，到时候自会明白。\n“亨利?马图林对拉里拒绝他给他的事情很不痛快，但是，格雷跟父亲说通了，所以只要他回芝加哥，立刻就可以有工作。”\n“格雷人好。”\n“当然，”布太太叹口气。“我知道他会使伊莎贝儿幸福。”\n艾略特然后告诉布太太他替她们安排了一些什么宴会。明天他要请很多人来吃午饭，在周末举行一次排场很阔的晚宴。他还要带她们去参加夏托?加亚尔家的招待会，而且替她们弄到两张罗思柴尔德[注]家即将举行的舞会请帖。\n“拉里你总要请吧？”\n“他告诉我他没有晚礼服，”艾略特不屑地说。\n“不管，你照样请他。归根结蒂，这孩子并不环。冷淡他对他没有好处，只会使伊莎贝儿更加固执己见。”\n“当然，你要我请我就请。”\n拉里在约定的时间来吃午饭。艾略特的礼貌本来很周到，对他特别客气。做到这样并不难，原因是拉里很开心而且兴致极好，只有比艾略特脾气坏得多的人才会不喜欢他。谈话都是谈的芝加哥和那边双方都认识的朋友，弄得艾略特除掉摆出一副和蔼样子，装得对这些他认为毫无社会地位的人感觉兴趣外，没有别的事可做。\n听他们谈他并不在乎；老实说，听着他们谈这一对年轻人订婚了，那一对年轻人结婚了，另外一对年轻人离婚了，使他觉得相当可怜。谁听说过这些人来？他可知道美丽的小德?克兰尚侯爵夫人曾经服毒自杀过，原因是她的情人德?科龙贝亲王抛弃她，娶了个南美洲百万富翁的女儿。这种事情才是值得谈的。他看看拉里，不由得不承认他有种异常吸引人的地方；他的陷进的、颜色深得出奇的眼睛，高颧骨，苍白的皮肤和灵活的嘴，使艾略特联想起波提切利[注]的一幅画像，想到如果给他穿上那个时代的服装，看上去一定充满浪漫气息。他记得自己曾经打算把拉里拉拢给一位著名的法国女人过，同时想到星期六晚宴邀请了玛丽?路易丝?德?弗洛里蒙，自己狡狯地笑了。这个女人是交游广阔和私德败环兼而有之。她年纪四十岁，看上去却要年轻十年；纳蒂埃[注]曾经替她的一个女祖先画过一张像，这张像就是通过艾略特本人的关系挂在美国的一个大博物馆里。玛丽生得就和她这个女祖先同样娇艳，而她在性生活方面的口味极大，好象永远不能满足似的。艾略特决定让拉里坐在她身边。他知道玛丽会很快使拉里懂得她的意图。他还请了英国大使馆的一位年轻的侍从武官，认为伊莎贝儿说不定欢喜他。伊莎贝儿很美，而且这人是个英国人，家财豪富，伊莎贝儿没有财产也没有关系。午饭一上来，喝的是上等蒙特拉夕酒，继之以好的波尔多酒，喝得艾略特浑陶陶的；他悠然自得地想着那些展示在他眼前的许多可能性。如果事态的发展象他估计的那样，亲爱的路易莎就没有什么可焦急的了。她对他总是有点不以为然，可怜的人儿，她太闭塞了；可是他喜欢她。\n凭他这样一个见过大世面的人，替她把各事安排妥当，对他说来，也是一件称心的事情。\n为了不浪费时间，艾略特安排好一吃完午饭就带路易莎母女去看衣服，所以大家才站起来，艾略特就用他最擅长的辞令通知拉里他应当走了，可是，同时，又亲亲热热地敦促他参加自己安排的两次盛大宴会。他根本不用费这么大的事，因为拉里很轻快地全答应了。\n但是，艾略特的计划失败了。拉里来参加晚宴时，穿了一套很象样的晚餐服，艾略特看见松了一口气，因为他有点担心，怕他穿了那次午饭时那样一身蓝哗叽来。\n晚饭后，艾略特把玛丽?德?弗洛里蒙拉到角落里，问她对他的年轻美国朋友觉得怎样。\n“他眼睛很美，牙齿也长得好。”\n“就这些吗？我让他坐在你身边，因为我认为他恰好是你的一点小吃。”\n她疑惑地望着他。\n“他告诉我已经跟你的漂亮外甥女订婚了。”\nvoyons，ma chere，[注]一个男孩子属于另一个女子，这件事决不会妨碍你把他从那个女子手里抢走，只要您能够做到。”\n“你要我做的就是这个吗？哼，我可不打算替你做这种卑鄙勾当，我可怜的艾略特。一艾略特笑了一声。\n“我猜想，你这话意味着你试过了，但是，发现不成功。”\n“艾略特，我喜欢你的是你的品德就象个妓院老板。你不要他要你的外甥女。\n为什么？他有教养，而且很讨人喜欢。可是他实在太纯洁了。我敢说他一点没有疑心到我的用意。”\n“你应当表示得露骨些，亲爱的朋友。”\n“我有足够的经验，知道什么时候我在浪费时间。事实是，他的眼睛里只有你的小伊莎贝儿，而且我这话只跟你一人说，她比我讨便宜的是年轻二十岁。而且人很可爱。”\n“你喜欢她的衣服吗？我亲自给她挑的。”\n“很美，也很合适。不过，当然她不帅。”\n艾略特把这话认为是对他的鉴定，他可不能轻易放过，非得戳她一下不可。他亲切地笑了一下。\n“亲爱的朋友，一个人非得活到你的成熟年龄，才能象你这样帅。”\n德?弗洛里蒙夫人手里挥的是一根大头棒，而不是一把短剑。她的反击使艾略特的弗吉尼亚血液沸腾起来。\n“我可以肯定，在你们那个帮匪横行的贵国里（votre beau pays dapaches）他们决不会错过这样微妙、这样模仿不了的东西的。”\n虽则德?弗洛里蒙夫人挑眼儿，艾略特其余的朋友对伊莎贝儿，对拉里，都很喜欢。他们喜欢伊莎贝儿的青春美，喜欢她那样健康，那样精力充沛；他们喜欢拉里的生动外表，彬彬有礼，和淡淡的带有讽刺的幽默。两个人的法语都讲得流利准确，这一点很讨便宜。布太太由于在外交界生活多年，法语尽管说得正确，可是，带有美国土音，而且自己满不在乎。艾略特对他们是盛席款待。伊莎贝儿对自己的新衣服新帽子很满意，对艾略特安排的那些乐事全都觉得有趣，对自己和拉里在一起感到快活，认为从来没有玩得这样开心过。\n四 # 艾略特认为，早饭只能跟陌不相识的人一起吃，而且只在不得已时才这样做，因此，布太太和伊莎贝儿都逼得只好在自己卧房里吃早饭；布太太有点不大愿意，伊莎贝儿则丝毫不觉得什么。可是，伊莎贝儿醒来后，有时候告诉安托瓦内特——就是艾略特给她们雇的那个高贵女佣人——把她的牛奶咖啡送到她母亲房间里，俾能一面喝咖啡，一面和母亲谈天。她现在整天没得空，这是她一天中间唯一能够和母亲单独在一起的时刻。就是在这样一个早晨，母女到达巴黎将近一个月的光景，伊莎贝儿告诉母亲头一天晚上怎样玩的，讲她和拉里大部分时间都带着一群朋友逛那些夜总会；讲完之后，布太太就向她提出那个自从来到巴黎之后心里一直想要问的问题。\n“他几时回芝加哥呢？”\n“不知道。他没有谈到过。”\n“你没有问他吗？”\n“没有。”\n“你是不是有点怕问？”\n“不是，当然不是。”\n布太太倚在软榻的靠背上，穿着艾略特坚持要给她买的时髦晨服，修着指甲。\n“你们两个人单独在一起时，成天谈些什么？”\n“我们并不成天在谈。在一起就很好。你知道，拉里一直都比较沉默。我们谈话时，大都是我在讲话。”\n“他平时干些什么？”\n“我也弄不清楚；只觉得没有什么了不起的事。我想他日子过得很好。”\n“还有他住在哪里？”\n“这个，我也不知道。”\n“他好象很讳莫如深，是不是？”\n伊莎贝儿点起一支香烟，当她从鼻孔里呼出一缕烟时，静静地望着她母亲。\n“你这话究竟是什么意思，妈？”\n“你舅舅认为他租了一所公寓，跟一个女人同居。”\n伊莎贝儿扑哧笑了起来。\n“你相信吗，妈？”\n“不，老实说我不相信。”布太太望着自己的指甲在转念头。“你可曾跟他谈过芝加哥呢？”\n“谈过，谈得很多。”\n“他可曾有过什么表示打算回去呢？”\n“说不上有。”\n“他到今年十月已经离开芝加哥两年了。”\n“我知道。”\n“这是你的事情，乖乖，你认为怎样做对，就怎样做。可是，尽在拖并不能解决问题。”她盯着女儿望，但是，伊莎贝儿避开母亲的眼光。布太太疼爱地向她微笑。“你还是去洗澡吧，否则，午饭要迟到了。”\n“我要跟拉里去吃午饭。在拉丁区一个什么地方。”\n“好好玩吧。”\n一小时后，拉里来接她。他们雇了一辆汽车上圣米歇尔桥，漫步走上行人拥挤的圣米歇尔大街，找到一家外表象样的咖啡馆。他们在走廊上坐下，叫了两杯迪博内[注]。后来又叫了一辆汽车去一家饭馆，伊莎贝儿胃口极好，拉里给她叫的那些好吃的菜她都吃得很香。她喜欢看那些和他们挨肩擦背坐在一起的人，因为这地方很挤；看见他们显然对食物感到那样强烈的兴趣，自己都笑了；可是，她最最开心的是和拉里单独找一张小台子坐着。她爱看自己兴孜孜地啦呱着时他眼睛里的喜悦神情。这样自由自在和他在一起使她感到心醉。可是，在她脑子的角落里却隐隐约约有种不安，因为虽则他看上去也很自在，她觉得与其说是由于有她，还不如说是由于喜欢这种环境。她母亲早上说的话有点打动了她，现在虽则毫不用心地聊着天，却留心看着他的每一个表情。他和离开芝加哥时并不完全一样，但是，说不出哪儿变了。他的样子和她记得的他同样年轻，同样坦率，只是神情变了；并不是说变得更加严肃了；他的脸色静下来时一直是严肃的，而且有一种安静的神情，是她以前没有见到过的；就好象解决了自己的什么问题，因而从来没有感到象现在这样心安理得过。\n两人吃完午饭之后，他建议上卢森堡博物馆逛一转。\n“不，我不想去看那些画。”\n“好吧，那就去花园里坐坐。”\n“不，这个我也不想。我要去看看你住在哪里。”\n“没什么可看的，我住在旅馆里一个很蹩脚的小房间。”\n“艾略特舅舅说你住一所公寓，跟一个画家的模特儿发生了不正常的关系。”\n”那么，你就亲自去看看。”他大笑说，“从这里去只有几步路。我们可以走过去。”\n他带着她穿过一些狭隘的、弯弯曲曲的街道，尽管从街两边的高房子中间可以望见一抹青天，但仍旧很寒伧相，走了一会儿之后，就在一家门面很不象样的小旅馆门口站住。\n“我们到了。”\n伊莎贝儿随着他走进一间狭窄的厅堂，厅堂的一边有一张书桌，书桌后面坐了一个人，没穿上衣，只穿一件细黑黄条子相间的背心，围一条很脏的围裙，在看报纸。拉里向他要钥匙，那人从身后格子架里把钥匙交给他，同时好奇地瞥了伊莎贝儿一眼，又转为会意的假笑。显然他认为伊莎贝儿去拉里的房间不是干规矩事情的。\n他们爬上两串楼梯，楼梯上铺的破旧的红地毯，拉里打开自己的房门，伊莎贝儿走进一间有两扇窗户的小房间。窗子望出去是街对面的灰色公寓，公寓底层是一家文具店。房内放一张单人床，床旁边一只床头柜，一口大衣柜镶着一面大镜子，一张装了垫子但是椅背笔直的圈椅，两扇窗子之间放一张桌子，桌子上有架打字机，一些纸张和好几本书。壁炉板上堆放了些纸面装订的书。\n“你坐圈椅，椅子不大舒服，可是，这是我拿得出的最好的了。”\n他另外拉了一张椅子，自己坐下。\n“你就是住在这儿吗？”伊莎贝儿问。\n他看见她脸上的神情，吃吃笑了。\n“就在这儿，我自从到巴黎来，一直就住在这儿。”\n“可是为什么呢？”\n“方便，这儿靠近国家图书馆和巴黎大学。”他指指她没有注意到的一扇门，“这里有个浴间，我可以在这儿吃早饭，晚饭一般就在我们吃午饭的那一家吃。”\n“这太肮脏了。”\n“不，我觉得不错，我只要这样子。”\n“可是，这儿住的是些什么人呢？”\n“噢，我不清楚。上面阁楼住了几个学生。两三个在政府机关里做事的老单身汉和一个奥台翁剧院的退休女演员；唯一的另外一个有浴室的房间，住着一个包身的女人，她的男朋友每隔一个星期的星期四来看她；恐怕还有些暂住的客人。这地方很安静，很规矩。”\n伊莎贝儿弄得相当尴尬，而且由于知道拉里已经看出来并且在笑她，有点存心找岔儿。\n“桌子上那本大书是什么？”她问。\n“哪个？噢，那是我的希腊字典。”\n“你的什么？”她叫。\n“没有关系，不会咬你的。”\n“你在学希腊文吗？”\n“对。”\n“为什么？”\n“我想到要学一点。”\n他望着她时，眼睛里带着微笑，她也对他回笑。\n“你可觉得不妨告诉告诉我，你到了巴黎之后，这两年，做了些什么事情？”\n“我看了很多书。一天总要看上八小时到十小时。我去巴黎大学听过课。我认为，我已经把法国文学里所有的重要作品都看了，我而且能看拉丁文，至少能看拉丁散文，差不多跟我看法文一样没有困难。当然，希腊文要难些。可是我有一个很好的教师。在你来到巴黎之前，我每星期经常有三个晚上去他那里补习。”\n“这样会有什么结果呢？”\n“获得知识。地微笑说。\n“这好象不大实际。”\n“也许不太实际，另一方面，也许很实际。总之非常之有趣。你决计想象不到读《奥德修纪》的原文时多么令人兴奋。使你感到仿佛你只要踞起脚伸出手来，天上的星星就能碰到似的。”\n他从椅子上站起来，就象兴奋得控制不住自己，在小房间内来回走着。\n“前一两个月我看了斯宾诺莎[注]。我不敢说我已经十分懂得，可是感到非常振奋。就象乘一架飞机降落在巍峨群山中的一片高原上。四围万籁俱寂，而且空气非常清新，象佳酿一样沁人心脾：自己感觉到象个百万富翁。”\n“你几时回芝加哥？”\n“芝加哥？不知道。我就没有想过。”\n“你说过，如果你两年之后，找不到你要找的东西，你就放弃不干吗？”\n“我现在不能回去。我刚要人门：看见广大的精神领域在我面前展开，向我招手，我急切要去那里旅行。”\n“你希望在那边找到什么呢？”\n“我那些问题的答案。”\n他瞥她一眼，简直有点顽皮。如果不是因为她和他这样熟悉，她说不定认为他在开玩笑。“我想弄清楚上帝究竟有，还是没有。我想弄清楚为什么世界上会有恶。\n我想要知道我的灵魂是不是不灭，还是我死后一切都完了。”\n伊莎贝儿倒抽一口冷气。听见拉里讲这些事情，她觉得怪不舒服，幸亏他谈得非常随便，声调就和平时讲话一样，使她还能不露出窘相。\n“可是，拉里，”她微笑说，“人们几千年来都在问这些问题；如果能够回答的话，肯定答案早已有了。”\n拉里笑了一声。\n“你笑得就好象我说了什么蠢话似的，”她生气说。\n“没有这个意思。我认为，你说得很在点子上。可是，另一方面，你也不妨说，既然人们对这些问题问了几千年，那么，他们就没法不问这些问题，而且不得不继续问下去。还有，你说没有人找到过答案，这话并不正确。答案比问题还要多，而且不少的人都给这些问题找到完全满意的答案。例如鲁斯布鲁克[注]那个老头儿。”\n”他是谁？”\n“哦，只是巴黎大学一个我不认识的人。”拉里随口口答。\n伊莎贝儿不懂得他是什么意思，但他继续往下说。\n“这话听上去非常之幼稚。这些事情使大学里二年级学生感到兴奋，但是，离开大学后就忘掉的。他们得养家活口。”\n“我不怪他们，你知道，我幸亏还有点钱可以过活。如果没有的话，我也只好象别人那样设法去赚钱了。”\n“你难道把钱一点不放在眼里吗？”\n“是的，”他笑着说。\n“你觉得自己在这些事情上还要搞多久呢？”\n“我也说不了。五年。十年。”\n“这以后呢？你预备把这种智慧派什么用处呢？”\n“我如果有了智慧，我想我当不难懂得怎样派它的用处。”\n伊莎贝儿两只手激动地勒在一起，身子从椅子上探出来。\n“你完全错了，拉里。你是个美国人，这儿不是你安身立命的地方。你安身立命的地方是美国。”\n“等我搞好了，我就回去。”\n“可是，你要错过很多机会。我们正在经历着一个世界从来没有经历过的宏伟时代，你怎么能忍心坐在这死气沉沉的地方一动不动呢？欧洲完蛋了。我们是世界上最伟大，最强大的民族。我们正在一日千里地前进。我们什么都有。你有责任参加国家的发展事业。你忘记了，你不知道美国今天的生活多么使人惊心动魄。你有把握说你不参加这种建国大业，是因为你没有勇气去担当目前面临着每一个美国人的重任吗？唉，我知道你多多少少也在工作，但这恰恰是逃避责任，可不是？这难道不恰恰是一种积极的偷懒吗？如果人人都象你这样畏缩不前，美国会弄成什么样子？”\n“你很苛刻，心肝，”他笑着说。“我的回答是，并不是每个人都有和我一样的感受。对他们说，这也许是运气，多数人都准备按常规行事；你忘记的是，我想学习就跟——就跟格雷想要挣一大笔钱一样热烈。难道我想花几年工夫教育自己真就是背叛祖国吗？也许我学成以后，将有一点人家高兴要的东西拿出来。当然这要看，可是，如果我失败了，我也不比一个人做生意而没有赚到钱更不如些。”\n“那么我呢？我难道对你一点不重要？”\n“你对我非常重要。我要你嫁给我。”\n“几时呢？十年之内吗？”\n“不。现在。越快越好。”\n“靠什么呢？妈没有什么奁资给我。而且，她有也不肯。她会认为，这样鼓励你游手好闲是错的。”\n“我不要你母亲的什么奁资，”拉里说。“我有三千块一年。这在巴黎很够用了。我们可以有一所小公寓和一个做全天的女佣人。我们会生活得非常开心，心肝。”\n“可是，拉里，三千块一年是没法子生活的。”\n“当然能够。很多人钱比这少得多也能生活。”\n“可是，我不愿意靠一年三千块钱生活。我没有理由要这样。”\n“我过去只要一半的钱也就生活下来了。”\n“可你，是怎么过的！”\n她看一下那间寒伧的小房间，厌恶地耸下肩膀。\n“这就是说，我储蓄了一点钱。我们可以上卡普里岛[注]去度蜜月，秋。天我们再去希腊。我渴想看看希腊。你记得我们过去不是时常谈到一同周游世界吗？”\n“我当然想旅行。但不是这样旅行。我不愿意坐二等舱，也不愿意住三等旅馆，连个浴间都没有，吃饭都在小饭店里。”\n“去年十月，我就是这样上意大利去的。玩得真开心。我们可以靠三千块一年把全世界都跑到。”\n“可是，我要有孩子，拉里。”\n“这没有关系。我们把孩子一起带了去。”\n“你真蠢，”她大笑说。“你知道有个孩子要花多少钱？维娥莱?托姆林森去年生了一个孩子，她尽量节省，还花了两千五百块。还有你知道雇一个保姆要多少钱？”她脑子里想到一连串的事情，变得愈来愈激动了。“你一点不实际。你不懂得你要求我的是什么。我年轻。我要找乐子。我要做别人家都做的事情。我要参加宴会，参加跳舞会，我要打高尔夫球和骑马。我要穿好衣服。你可懂得一个女孩子不能穿得跟她一起的那些人一样好，是什么滋味？拉里，你可知道买你朋友穿厌了的；日衣服穿，和感到人家可怜你送你一件新衣服，是什么滋味？我甚至于连去一家象样的理发店做做头发也做不起。我不要坐电车和公共汽车到处跑；我要有我自己的汽车。你想，你在图书馆里看书，我成天干的什么？逛马路，看橱窗，还是坐在卢森堡博物馆的花园里留心自己孩子不要闯祸？我们连朋友都不会有。”\n“唉，伊莎贝儿，”他打断她。\n“不会是我过去来往的那些朋友。是啊，艾略特舅舅的朋友有时候会看他的面子请我们一次，但是，我们去不了，因为我没有象样的衣服穿，而且我们不会去，因为我们回请不起。我不想认识一大堆上不了台盘的、不修边幅的人。我要生活，拉里。”她突然感到他眼睛里有种神情，虽则盯着她望时永远是那样温柔，但是，带有一点好笑。“你觉得我愚蠢，是不是？你觉得我罗嗦而且蛮不讲理。”\n“不，我并不。我觉得你说的这些都很自然。”\n他背对着壁炉站着，她站起来，走到他跟前，和他面对面。\n“拉里，如果你一个铜子没有，可是，找到一个收入三千块的工作，我会毫不迟疑就嫁给你。我会替你烧饭，收拾床铺，我会不在乎我穿的什么衣服，我会什么都不在乎，我会认为这样非常之有意思，因为我知道这只是一个时间问题，你总会有钱的。可是，现在这样结婚，意味着我一辈子要过这种肮脏的牛马不如的生活，什么指望都没有。这等于说，我要苦挨苦挣一辈子。而为的什么呢？为了使你能够成年累月地给你说的自己都解决不了的问题找答案。这太不象话了。一个人应当工作。他生到世界上来就为的这个，他就是这样造福社会的。”\n“总之，他有责任在芝加哥安顿下来，进亨利?马图林的投资公司。你认为劝说我的朋友买亨利?马图林感兴趣的股票，我会大大造福社会吗？”\n“掮客总是要有的，这样养家活口完全没有什么不体面，不光彩的地方。”\n“你把巴黎有一般收入的人的生活形容得一塌糊涂。你知道，实际上并不如此。\n人们用不着上夏内尔服装店，仍旧可以穿着得很好。而且所有有趣的人并不住在凯旋门附近和福煦大道上。事实上，有趣的人简直不住在那儿，因为有趣的人一般钱都不多。我在这儿认识不少的人，画家，作家，学生，法国人，英国人，美国人，什么样式的人都有，我认为你会觉得这些人比艾略特的那些性情毛躁的侯爵夫人和目中无人的公爵夫人有趣多了。你脑筋动得快，而且富于幽默感。听他们一面吃晚饭，一面针锋相对地谈话，你一定很欣赏，尽管喝的只是普通的葡萄酒，而且你用不着有个男管家和两个手下人伺候你。”\n“别胡扯，拉里。当然我会欣赏。你知道我并不势利。我很喜欢会见有趣的人。”\n“是的，穿着夏内尔服装店的衣服。你想他们看见你这副打扮会不会认为你是来视察贫民窟的呢？他们不会舒服，你也不会舒服，而且你除了事后告诉爱米丽?德?蒙塔杜尔和格拉茜?德?夏托加亚尔，说你在拉丁区碰到一群怪里怪气的不修边幅的人，觉得非常好玩之外，别无收获。”\n伊莎贝儿微微耸一下肩膀。\n“我敢说你讲得对。他们不是和我一起长大的那种人。他们跟我没有一点共同之处。”\n“你这话指的什么？”\n“还是我开头讲的话。从我记事以来，我一直就住在芝加哥。我的朋友全都在芝加哥。我的兴趣全在芝加哥。我在芝加哥过得很习惯。这是我的乡土，也是你的乡土。妈现在有病，而且她的病永远不会好了。我就是想离开她也不能离开她。”\n“这是不是说除非我回到芝加哥去，你就不想嫁给我呢？”\n伊莎贝儿蜘橱了一下。她爱拉里。她要嫁给他。她的整个身心都爱着他。她知道他也要她。她不相信到了摊牌时他不会软下来。她害怕，可是她不得不冒一下险。\n“对的，拉里，我就是这个意思。”\n他在壁炉板上划了一根火柴[注]——那种给你的鼻孔装满辛辣气味的旧式法国硫磺火柴——点起他的烟斗后，掠过她，走到一扇窗子前面站着。他向窗外望，沉默了很长一段时间，就象永远没有个完似的。她仍旧站在原来面对着他站着的地方，照着壁炉板上的镜子，但是，看不见自己。她的心乒乒乓乓地跳着，而且感到害怕，他终于转过身来。\n“我真想能够使你懂得，我向你建议的生活要比你想象的任何生活都要充实得多。我真希望能够使你懂得精神的生活多么令人兴奋，经验多么丰富。它是没有止境的。它是极端幸福的生活。只有一件事同它相似，那就是当你一个人坐着飞机飞到天上，越飞越高，越飞越高，只有无限的空间包围着你，你沉醉在无边无际的空间里。你是那样的欢乐，使你对世界上任何权力和荣誉都视若敝屣。前几天，我读了笛卡儿[注]那样的痛快，文雅，流畅。天哪！”\n“可是，拉里，”她急腔急调地打断他，“你难道看不出你在要求我做一件我做不来的事情，是我不感兴趣而且不想感兴趣的事情吗？我对你讲过不知道多少遍了，我只是一个平常的、正常的女孩子，我现在二十岁，再过十年我就老了，我要及时行乐。唉，拉里，我的确非常爱你。所有这些全都是无聊的玩意儿。它不会使你有什么出息的。为了你自己，我求求你放弃它。拉里，做个好样的，做一个男人应做的事情。人家都在分秒必争地干，你却在浪费宝贵光阴。拉里，你要是爱我的话，你就不会为了一个梦想而抛弃我。你已经荒唐过了。跟我们回美国去吧。”\n“我不能。这对我说来等于自杀。这等于出卖我的灵魂。”\n“唉，拉里，为什么这样说话？那些歇斯底里的肉麻当有趣的女人就是这样说的。这有什么意义呢？毫无意义，毫无，毫无。”\n“这恰恰就是我的感受，”他答道，夹着眼睛。\n“你怎么可以笑呢？你可意识到，这是一个极其严肃的问题。我们正站在十字路口，我们现在的决定将会影响我们的一生。”\n“我知道。请你相信我，我是在非常严肃地对待。”\n她叹了口气。\n“跟你讲正经话你不听，那有什么可说的。”\n“可是，我不认为这是正经。我认为，你讲的从头到尾都是荒唐透顶的东西。”\n“我？”如果不是因为她当时心里非常难过，她就会哈哈大笑。“可怜的拉里，你就象个疯子。”\n她慢慢把手上戴的订婚戒指褪了下来，放在掌心里，对着它瞧。那是一粒四四方方的红宝石，用细白金嵌的戒指，她一直都很喜欢。\n“你假如爱我，就不应当使我这样不快乐。”\n“我的确爱你。不幸的是，一个人想要做自己认为对的事情，却免不了要使别人不快乐。”\n她把放着红宝石戒指的手伸出来，颤抖的嘴唇勉强显出微笑。\n“还你，拉里。”\n“我没有用。你留着作为我们友谊的纪念好不好？你可以把它戴在小拇指上。\n我们的友谊不需要中止，是不是？”\n“我会永远关心你，拉里。”\n“那么就留着。我也将永远喜欢你。”\n她迟疑了一下，然后把戒指套在右手的小拇指上。\n“太大了。”\n“你可以改装一下。我们上里茨酒吧间去喝杯酒。”\n“好。”\n她对这件事解决得这样容易，感到有点诧异。她没有哭。除掉她不会跟拉里结婚外，好象什么都没有改变。她简直相信不了什么都完结了，结束了。她对两人没有大吵大闹有点不甘心。这件事就这样平心静气谈妥了，就仿佛他们刚才谈的是租房子的事情一样。她觉得自己上了当，但同时微微有种满意的感觉，因为两个人的表现都非常文明。她真想知道拉里究竟是什么一种心情。可是，这始终没法知道；他那张吸引人的脸，那双深色的眼睛，她知道只是一种面具，因为尽管她认识他许多年，却猜不透他。她本来把帽子脱掉，放在床上；现在站在镜子前面，把帽子戴上。\n“我只是问着玩，”她说，一面把头发抹抹平，“你原来打算跟我解约吗？”\n“没有。”\n“我想也许可以使你不背包袱。”他没有回答。她转过身来，嘴边露出轻松的微笑。“现在好走了。”\n拉里把身后的门锁上。当他把钥匙交给坐在写字台那儿的人时，那人带着狡狯的神情会意地望着他们。伊莎贝儿当然猜出这人当作他们在干苟且的事儿。\n“我敢说这个家伙对我的贞操是打问号的，”她说。\n他们雇了一辆汽车到里茨喝了一杯酒，谈些不相干的事情，丝毫不显得拘束，就象两个天天见面的老朋友一样。尽管拉里天生不大说话，伊莎贝儿话却很多，老是有一搭没一塔地聊，而且她决心不让相互之间变得沉默下来，弄得没有话说。她不想使拉里觉得她恨他，她的自尊心又逼使她装得使拉里不会疑心她伤心和不快乐。\n过了一会，她就建议他送她回去。当他把汽车开到门口让她下车时，她轻松地向他说：“不要忘记你明天跟我们吃午饭。”\n“杀头也不会忘记。”\n她让他吻了自己的面颊，穿过车道门进去了。\n五 # 伊莎贝儿走进客厅时，看见有几个客人已经在喝茶。有两个是住在巴黎的美国妇女，穿着非常考究，脖子上围着珠串，手上戴着钻石手镯，手指上套着价值昂贵的戒指。虽则有一个的头发用散沫花染成棕红色，另一个的金色头发很不自然，两个人却非常之象。同样涂了油膏的睫毛，同样搽得鲜红的嘴唇，同样抹了胭脂的面颊，同样经过刻苦锻炼保持着的苗条身材，同样清晰如削的五官，同样如饥似渴的彷徨的眼神；你没法不意识到她们的生活就是为了保持自己的徐娘风韵在拚命挣扎。\n她们鼓着响亮的喉咙东拉西扯地谈着，一刻也不肯停，象是担心只消有片刻的沉默，机器就会停摆，而那个代表她们一切的人为建筑就会土崩瓦解一样。还有一个美国大使馆的秘书，人温和沉默，因为他一句话也插不进，看上去很有点派头；一个矮小的黑皮肤的罗马尼亚王子，总是那样卑躬屈膝，两只又小又玲珑的黑眼睛，一张刮得很光的黑黑的脸，老是看见他来不及地站起来送茶，递蛋糕，或者给人点香烟，对那些在座的人总是厚颜无耻地竭尽恭维的能事。他这样子做是在偿还过去从这些巴结对象获得的晚餐，以及今后希望获得的晚餐。\n布太太坐在那里，为了讨好艾略特，比她平常喝茶时穿得讲究。她以惯常的礼貌但是相当淡漠的神情，泰然执行着主妇的任务。她对自己兄弟的这些客人有什么想法，我只能想象。我和她从来没有混熟过，而且她是个什么都放在肚子里的女人。\n她人并不笨；在外国的首都住了那么多年，见过不少形形色色的人，想来会根据自己很生土长的弗吉尼亚小城市标准，对这些人作出自己的精明结论。恐怕她看着这些人的滑稽样子时，会感到相当好笑，而且敢说她对这些人的神气活现的派头，和对一本小说里人物的哀愁和苦痛同样无动于衷，因为她从一开始就知道小说的结局是圆满的（否则她就不会去看它）。巴黎、罗马、北京对她的美国气息毫无影响，就如同艾略特的虔诚天主教信仰对她的坦率但并无不便的长老会宗教毫无影响一样。\n伊莎贝儿的青春、活力和健康美给这种浮华气氛带来一股新鲜空气。她就象个新的尘世女神冲了进来。罗马尼亚王子慌不迭地站起来替她拉过一张椅子，而且做了一大堆手势竭力恭维。两个美国女人一面尖着嗓子很和蔼地跟她讲话，一面上上下下打量她，仔细瞧她的衣服，拿自己和伊莎贝儿的锦绣年华对照，可能心里起一种落漠感。美国外交官看见伊莎贝儿使这两个女人看去多么空虚和惟淬，独自在微笑。可是，伊莎贝儿却觉得她们很有派头；她喜欢她们的华丽衣服和昂贵珠串，而且对她们矫揉造作的姿态感到一丝妒意。她盘算自己会不会有一天变得这样雍容华贵。当然那个小罗马尼亚人很可笑，不过，也相当讨人喜欢，就算他讲的那些好听的话是言不由衷，听听也不坏。她进来时打断的谈话现在又恢复了，而且谈得是那样起劲，那样深信不疑，好象她们谈的事情都是值得谈的，使你简直认为她们谈的话有道理。她们谈自己参加过的宴会，和预备参加的宴会。她们搬弄最近的丑事秽闻。她们把自己的朋友毁得体无完肤。她们从这个大人物谈到那个大人物。她们好象什么人都认识；什么秘密都知道。她们几乎是气也不换地提到最近上演的话剧，最时新的妇女服装设计师，最时新的人像画家，最近上台的首相的最近情妇。人们会当作她们没有一件事情不知道。听得伊莎贝儿都呆了。她觉得，这一切都非常文明。这的确是生活。这使她有种置身其中的惊喜感。这是真的。场合简直太合适了。\n宽敞的房间，地板上铺的萨冯内里埃地毯，华丽的镶了木板的墙壁挂的那些美丽的画，坐的那些精工细雕的椅子，细工镶嵌的橱柜和茶几，每一件都够得上进博物馆：布置这间房间花的钱抵得上一笔财产，可是值得。她从没有象现在这样感到它的美，布置得这样妥帖，因为旅馆里那个寒伧的小房间，那张铁床，她坐的那张硬帮帮的不舒适的椅子，那个拉里认为没有什么不好的房间，还鲜明地印在她脑子里。可说是空空如也，又丧气，又可怕。她想起时不由打了个寒噤。\n客人散了，只剩下伊莎贝儿和她母亲和艾略特三个人。\n艾略特送那两个可怜的满脸脂粉的美国贱货出门回来。“有意思的女人，”他说，“她们才在巴黎住下时，我就认识她们了。做梦也没有想到她们会变得象现在这样漂亮。我们女子的适应能力真是可惊。你简直看不出她们是美国人，而且是中西部来的。”\n布太太眉毛抬了起来，也不言语，只把艾略特看了一眼，可是，以艾略特的机灵哪有不懂得的。\n“谁也没法子这样说你，我可怜的路易莎，”他半讥讽半亲热地说。“不过，天知道，你过去是完全做得到的。”\n布太太的嘴嘟了起来。\n“恐怕我使你感到非常失望，艾略特，不过，告诉你实在话，我对自己现在这样非常之满意。”\n“tons les gouts dans la nature[注]，”艾略特叽咕了一句法文。\n“我想我应当告诉你们，我已经和拉里解约了。”伊莎贝儿说。\n“喷，喷，”艾略特叫出来。“这一来，我明天请的午饭可糟了。这样短短的时间，叫我哪儿再找一个人呢？”\n“噢，午饭他还是来吃的。”\n“在你跟他解约之后？这好象不大合乎习惯。”\n伊莎贝儿咯咯笑了。她眼睛盯着艾略特望，因为她知道，她母亲的眼睛正盯着自己望，而她不愿意和她眼睛碰上。\n“我们没有吵嘴。我们今天下午谈了一次话，认为我们订婚是个错误。他不想回美国去；他要留在巴黎，他说他要去希腊。”\n“这是为什么？希腊又没有社交活动。事实上，我对希腊艺术从来就不大看在眼里。有些古希腊的东西有那么一点颓废的魅力，还可以看得。可是，菲狄阿斯[注]：不行，不行。”\n“你看着我，伊莎贝儿，”布太太说。\n伊莎贝儿转过头来，唇边微带笑意望着母亲。布太太把女儿仔细看了一眼，可是，只哼了一声。这孩子没有哭过，这一点她能看出；她的神情很泰然自若。\n“我觉得你解约得好，伊莎贝儿，”艾略特说。“我原来想竭力成全这件事，可是，我一直认为，这个婚姻不对头。他实在配不上你，而且他在巴黎的所作所为很清楚表明他决不会有什么出息。以你的漂亮和你的关系，你可以找一个比他好得多的对象。我觉得，你这件事情做得很有见识。”\n布太太瞟了女儿一眼，看得出有点担心。\n“你不是为了我解约吧，伊莎贝儿？”\n伊莎贝儿断然摇摇头。\n“不是，亲爱的，我完全是自愿做的。”\n六 # 那时候，我已经从东方回来，正在伦敦住一个时期。大约在上述事件发生之后两个星期光景，艾略特一天早上打电话给我。我听见他的声音并不奇怪，因为他的习惯总是在游宴季节到了尾声时来英国玩乐一下。他告诉我，布太太和伊莎贝儿和他一起来了，如果我今天傍晚六点钟过来喝杯酒，她们一定很高兴看见我。他们当然住在克拉里奇饭店。当时我的寓所离那儿并不远，所以我踱过公园巷，穿过美菲亚区那些安静、高贵的街道到了克拉里奇饭店。艾略特就住在他平时住的一套房间。\n室内镶的是褐色木头壁板，就象雪茄烟盒子的那种木头，陈设既文静又豪华。侍役领我进来时，艾略特只有一个人在屋里。布太太和伊莎贝儿上街去买东西，眼看就要回来。他告诉我，伊莎贝儿和拉里解约了。\n艾略特对于在什么处境下应该怎样做人，有他自己的浪漫和高度保守的看法。\n他对这两个年轻人的行为很看不惯。拉里不但在解约后的第二天来吃午饭，而且做得就好象自己地位一点没有改变似的。他和平日一样随和，一样彬彬有礼，一样安静愉快。对待伊莎贝儿还是和他过去对待她一样亲亲热热的。他看上去既不感觉窘，也不心烦意乱，也不垂头丧气。伊莎贝儿也不象有心思的样子，人很快活，笑得照样轻松，照样嘻嘻哈哈地打趣，仿佛并不曾在自己一生中刚刚作了一项重大决定；而且肯定是忍痛的决定。艾略特弄得丈二金刚摸不着头脑。他从侧面听到他们一言半语的谈话，打听到他们丝毫没有意思要取消以前讲定的那些约会；所以一得空他就找姐姐谈这件事。\n“这不成话，”他说。“他们不能够仍旧象订婚一样两个人到处跑，拉里实在应当懂得一点分寸。而且，这样会毁掉伊莎贝儿的机会。小福塞林根，那个英国大使馆的男孩子，显然很中意她；他有钱，而且社会关系很不错；如果他知道伊莎贝儿已经解约，可能会向她求婚，这我一点不奇怪。我觉得你应当跟她谈一下。”\n“亲爱的，伊莎贝儿二十岁了，她有套办法能够婉婉转转告诉你不要管她的事情。这使我一直很难对付。”\n“那么，你就是太娇纵她了，路易莎，再说，这是你应管的事情。”\n“在这件事情上，你跟她的看法肯定不一样。”\n“路易莎，你叫人简直不能容忍。”\n“我可怜的艾略特，你假如有个成年的女儿的话，你就会发现她比一头抗拒的小公牛还要难管。至于她内心里想的什么，你还是装作她认为的那种头脑简单的老糊涂虫好得多。我几乎可以肯定她就是这样看你的。”\n“可是，你不是跟她谈过这件事吗？”\n“我打算谈。她大笑，告诉我实在没有什么可说的。”\n“她难过吗？”\n“我也不知道。我只知道她吃得很香，睡得就象个孩子。”\n“哼，你记着我的话，如果你听任他们这样搞下去，总有一天两个人会溜掉，跟谁也不说一声就结婚了。”\n布太太忍不住笑了。\n“这一点你尽可放心，在我们现在呆的这个国家里，不正常的男女关系有一切方便，结婚则到处会碰壁。”\n“很对，结婚是严肃的事情，家庭的保障和国家的稳定全系在这上面。但是，婚姻只有在婚姻之外的关系得到容忍，并且得到认可时，才会保持其尊严。娼妓，可怜的路易莎——”\n“得了，艾略特，”布太太打断他。“你对不正常男女关系的社会价值观和道德价值观，我一点不感觉兴趣。”\n就在这时候，艾略特提出一个阻止伊莎贝儿和拉里往来的计划，因为他对这种越轨的的行动太看不人眼了。巴黎的游宴季节已到尾声，所有的上流人士都准备先上海边或者多维尔，然后去他们在图兰、昂懦或者布列达尼半岛的祖传宫堡度夏。\n艾略特通常都是在六月底去伦敦，可是，他的家族感很强，对姐姐和伊莎贝儿的感情又很真实；他原来打算，只要她们愿意，即使巴黎象样的人走光了，他也可以完全自我牺牲继续留下来。但是，现在他发现自己的处境很合心意，既能够尽量为别人着想，同时又于自己方便。他向布太太建议，三个人立刻一同上伦敦去，因为伦敦那边游宴季节正处在高潮，而且新的兴趣和新的朋友将会使伊莎贝儿的心情不再缠在这种不幸的遭遇上。据报载，那位专治糖尿病的有名专家这时就在英国首都，布太太正好找他诊治，这样就可以为他们匆促离开巴黎找到合理的解释；伊莎贝儿即使不愿离开，也说不出口了。布太太同意这个计划。她弄不懂的是伊莎贝儿。伊莎贝儿是不是如她表面那样一点不在乎，还是心里痛苦、气愤或者伤心，但是，故意装得硬挣，好掩盖自己的内心痛苦，布太太也肯定不了。她只能同意艾略特的说法，看见新朋友和新地方，对伊莎贝儿有好处。\n艾略特忙着去打电话。那天，伊莎贝儿正和拉里一同去逛凡尔赛宫；她回家时，艾略特已经各事就绪，就告诉她已经替她母亲约好那位有名的医生看病，时间在三天以后；他而且在克拉里奇饭店定下一套房间，因此，后天就要动身。当艾略特有点沾沾自喜地把这个消息告诉伊莎贝儿时，布太太留心察看女儿，但见她神色不动。\n“啊，亲爱的，我很高兴你能够去看那个医生，”她以平素那种急腔急调的派头叫出来。“当然你不能错过这个机会。而且上伦敦走一趟太有意思了。我们在那里要呆多久？”\n“再回巴黎就没有意思了，”艾略特说，“因为一个礼拜之内，这里的人都要走光了。我要你们跟我在克拉里奇饭店住完这个夏天。七月里总有些很好的舞会，当然还有温布尔登网球赛[注]。这以后，还有古德伍德的赛马和考斯的赛船。我肯定埃林厄姆家会欢迎我们坐他们的帆船去看考斯船赛，班托克家在古德伍德赛马时总举行一次很大的宴会。”\n伊莎贝儿看上去很高兴，布太太心放下来了。伊莎贝儿好象把拉里根本不放在心上。\n艾略特才跟我讲完这些，母女两个就走了进来。我有一年又大半年没见到她们，布太太比以前消瘦一点，而且脸色更加苍白了；人样子很疲倦，气色很坏。可是，伊莎贝儿却是容光焕发，红红的脸色，深褐色的头发，亮晶晶的深栗色眼睛，白净皮肤，给人一种深刻的青春感，好象单是觉得自己活着，就很快活；看到这些，你不禁会高兴得笑出来。她使我产生一个相当荒唐的看法，仿佛她是一只金黄的熟透了的梨子，又香又甜，只等你来吃。她身上发出温暖，使你觉得只要伸出手来就能够感到舒适。人比我上次看见时高了一点；是不是因为穿了高跟鞋的缘故，还是那个聪明的裁缝把她的衣眼剪裁得把她的年轻的丰满体型给遮盖了，我也说不出。她的举止有自幼从事户外运动的女孩子的那种潇洒风度。总之，从性的角度看，她已经是一个非常诱人的少女。我是她母亲的话，会认为她应当赶快结婚才是。\n我很高兴有这个机会能答谢我在芝加哥时布太太对我的招待。所以请她们三位晚上一同去看戏；还安排请她们吃一次午饭。\n“你还是现在就约定的好，老朋友，”艾略特说。“我已经通知一些朋友，我们到了伦敦，敢说一两天之内，我们这个季节的时间全要排满了。”\n我懂得艾略特这话的意思是说他们没有时间和我这样的人在一起，不禁大笑。\n艾略特看了我一眼，神情有点傲慢。\n“可是，当然你下午六点钟来时，一般都会找到我们，我们也很高兴看见你，”\n他婉转地说，可是，他的用意显然是要我明白，作为一个作家，自己的地位并不高。\n但是，瓦片也会翻身。\n“你一定要跟圣奥尔弗德家碰碰头，”我说。“听说他们打算卖掉他家的那张康斯特布尔[注]的索尔兹伯里教堂。”\n“我眼下不想买什么画。”\n“我知道，可是你说不定可以帮他们处理掉。”\n艾略特的眼睛恶狠狠地看着我。\n“亲爱的朋友，英国人是一个伟大的民族，可是，他们从来就画不好，而且永远画不好。我对英国画派不感兴趣。”\n七 # 这以后的四个星期中，我很少见到艾略特和布太太母女。他真给她们挣面子。\n这一个星期他带她们去苏塞克斯一个豪华人家去度周末，另一个周末又带她们去威尔特郡一个更豪华的人家。他带她们坐在皇家包厢作为温莎王室一个年轻公主的客人看歌剧；带她们和些大人物一起吃午饭，吃晚饭。伊莎贝儿参加了几次舞会。艾略特在克拉里奇饭店招待一批批的客人，这些人的名字在第二天的报纸上登得很显眼。他在西罗饭店和大使饭店招待夜餐会。事实上，所有应当做的事情他都做了，艾略特这些为了使伊莎贝儿玩得开心而安排的纸醉金迷场合，伊莎贝儿要避免玩得眼花缭乱，非得有一副复杂得多的头脑不可。艾略特可以自吹自擂，说他费了这么大的劲，没有一点自私动机，完全是为了伊莎贝儿能忘掉这次不幸的恋爱事情；但是，我看出他对自己能让姐姐亲眼看见他和那些名人，那些时髦人物多么地熟悉，也颇感满意。他是一个很不错的主人，而且喜欢卖弄他那一套交际手腕。\n我也被邀请去参加一两次艾略特的宴会，有时候还在下午六点钟去克拉里奇饭店看望他们一下。我看见伊莎贝儿被一些在御林军里的穿漂亮衣服的高大年轻人，和外交部的一些穿着差一点的头面整洁的年轻人包围着。就是在这种场合，伊莎贝儿把我拉到一边。\n“我想求你一件事，”她说。“你可记得那天傍晚我们上药房吃冰淇淋苏打的事吗？”\n“清清楚楚。”\n“那次你很够朋友。你肯不肯再够朋友一次？”\n“我总尽力而为。”\n“我想跟你谈一件事。能不能哪天我们一同吃午饭？”\n“随便你哪一天。”\n“找个清静一点的地方。”\n“坐车子到汉普顿宫会，在那边吃午饭，你说怎样？那些园子目前应当是花事最盛的时候，而且你可以看看伊丽莎白女王的床。”\n这个建议她很中意，我们就约定了日期。可是，到了那一天，原来晴暖的天气忽然变了；阴沉沉的天，还落着小雨。我打电话问伊莎贝儿是不是还是在城里吃午饭。\n“我们将没法坐在花园里，而且那些画会非常之暗，一点看不出什么。”\n“我在花园里坐得多啦，而且对名画看得腻味透了。我们反正去吧。”\n“好的。”\n我去接她，两个人坐了汽车下去。我知道有一家小旅馆，饭菜还过得去，所以就一直开到那边。伊莎贝儿在路上和平日一样兴致勃勃地谈她参加的宴会和碰见的人。她玩得很开心，可是，她对自己结识的那些形形色色人物的评论，使我感到她很精明，而且有些荒唐可笑的事情一眼就看出来。由于天气不好，游客绝迹，所以餐厅等于被我们两个独占。这家旅馆以家常的英国莱最拿手，所以我们点了一块好羊腿，外加绿豌豆和新马铃薯，加上大盆烤的苹果排浇上德文郡奶油[注]；再来一大杯淡啤酒，一顿午餐的确吃得很好。吃完以后，我建议上那边空咖啡室去，因为软圈椅可以坐得舒适点。咖啡室里很冷，但是壁炉里煤和木柴都已放好，所以我擦一根火柴生了火。火焰使寒伧的房间亲切得多了。\n“行了，”我说。“现在告诉我，你要跟我谈什么事。”\n“和上次一样，”她吃吃笑了起来。“拉里。”\n“我猜是如此。”\n“你知道我们已经解约了。”\n“艾略特告诉了我。”\n“妈妈放心了，艾略特很开心。”\n她迟疑了一下，然后开始把她和拉里的那次谈话告诉我，这我已经尽量忠实地向读者交代过了。读者也许会诧异，她为什么要跟我这样的人交浅而言深。我和她见面敢说顶多只有十次，而且除掉药房那一次外，从来就没有单独在一起过。这事并不奇怪。单拿一点来说，正如任何作家都会告诉你一样，有些人跟别人不会讲的事情，的确会告诉一个作家。我不懂得这是什么缘故，要么是因为读了他们一两本书以后，他们对这个作家特别感觉亲切；还可能他们使自己戏剧化了，把自己看作是小说中的人物，因此愿意象他杜撰的那些人物一样向他推心置腹。还有，我觉得伊莎贝儿认为我喜欢拉里和她，他们的年轻使我很动心，并且对他们的不幸处境感到同情。她不能指望艾略特好心听她的诉说，因为拉里有过一个年轻人少有的进入社交界的好机会，但是他糟蹋掉了；对于这样一个年轻人，艾略特是不愿意动脑筋的。她母亲也帮助不了她。布太太有她自己的崇高原则和世故。她的世故使她认定，你假如要在这个世界上混得好，你就得接受这个世界的一套，而且不去做别人明白指出的那种不牢靠的事情。她的崇高原则使她相信一个人的责任就是在一个企业里找一项工作做，靠自己的努力找机会赚上一笔钱，按照符合自己地位的生活标准养家活口，使儿子们受到适当教育，俾能在长大成人之后清清白白地生活，并在死后使自己的妻子衣食无忧。\n伊莎贝儿记性很好。那次时间很长的谈话的许多重要关节，她全都紧记着。我一直等她讲完，都不吭气听着，她只有一次打断自己话头问我一个问题。\n“卢斯代尔是谁？”\n“卢斯代尔？他是荷兰的一个风景画家。怎么？”\n她告诉我拉里曾经提到他。他说卢斯代尔至少对他提出的问题找到一个答案，她并且重述了她问拉里这是什么人时，拉里给她的轻描淡写的回答。\n“你想他是什么意思？”\n我忽然灵机一动。\n“你想他会不会是说的鲁斯布鲁克？”\n“也许是。他是什么人？”\n“是一个生活在十四世纪的佛兰芒神秘主义者。”\n“噢，”她带着失望说。\n伊莎贝儿一点不懂得这里的道理，但是，我却懂得一点。这是我第一次对拉里心里盘算的问题发现一点迹象，所以，当伊莎贝儿继续谈她的经过时，我虽则仍旧凝神在听，可是，一半心思却忙着研究拉里提到这个人可能意味着什么。我不想小题大做，因为可能他提起这位狂热的导师的名字只是作为争辩的理由；也可能有它的用意，但是，没有被伊莎贝儿听出来。当他回答伊莎贝儿的问题，说鲁斯布鲁克是他在中学时一个不认识的同学，他显然是不想伊莎贝儿追问下去。\n“你说这一切算什么？”她讲完之后问我。\n我等了一会才回答。\n“你可记得他曾经说过要晃膀子？如果他这话是当真，他指的晃膀子可能要花费很大的气力。”\n“我肯定他这话是真的。可是，你难道看不出，如果他把这么多气力放在什么有出息的工作上，他就可以有一笔很可观的收入。”\n“有些人生性就是那样古怪。那些犯罪的人苦心经营的结果只是把自己送进监狱，可是，才从监狱里放出来，他们立刻又重新做起，结果又进了监狱。如果他们把这么多的勤奋、机巧、智谋和刻苦放在正经事业上，他们准会生活得很富裕，而且占据重要的职位。但是，他们的生性就是这样。他们就喜欢犯罪。”\n“可怜的拉里，”她吃吃笑起来。“你难道打算说他学希腊文是准备抢一家银行吗？”\n我也笑了。\n“不，我不是这个意思。我打算告诉你的是，有些人对做某一件事情具有那样强烈的欲望，连自己也刹不住车，他们非做不可。为了满足内心的渴望，他们什么都可以牺牲。”\n“连爱他们的人都可以牺牲？”\n“是啊。”\n“这除了明显的自私外，还能是什么？”\n“我也不懂，”我微笑说。\n“拉里学习死语言能有什么用处？”\n“有些人对知识有种无所为而为的欲望。这不是什么下流的欲望。”\n“如果你不预备派知识的用场，知识又有什么好处。”\n“也许他就是如此。也许单单有了知识就是满足，正如艺术家能创造一件艺术品就认为满足一样。也可能知识是为了进一步追求什么的准备。”\n“他如果要的是知识，他为什么复员之后不去进大学？纳尔逊医生和妈就是这样劝他的。”\n“我在芝加哥时跟他谈过。学位对他没有用处。我觉察到他对自己要什么有他的具体想法，而且觉得在大学里得不到。你知道，在治学上有合群的狼，也有单身的狼。我认为拉里是那种除了走自己道路没有别的路好走的人。”\n“我记得有次问他想不想写书。他大笑，说他没有东西可写。”\n“这是我听到的不肯写作的最站不住的理由，”我微笑说。\n伊莎贝儿做了个不耐烦的姿势。她连最温和的调侃都没有心肠听了。\n“我弄不懂的是为什么他要变成这个样子。大战以前，他和别人并没有两样。\n说来你不相信，可是，他网球打得很好，而且高尔夫也打得很不错。他经常做我们其余的人做的那些事情。他是一个正常的孩子，而且我们没有任何理由设想他不会成为一个完全正常的男人。说到底话，你是个小说家，你应当能够解释。”\n“人性是这样极端复杂，我有什么资格来解释？”\n“今天我要跟你谈谈，就是为了这个，”她接着说，根本不理会我那句话。\n“你不开心吗？”\n“不，并不完全是不开心。拉里不在时，我很好；但是跟他在一起时，我就感觉非常软弱。现在只是一种难受，就象你好几个月没有骑马，骑马跑一次长途之后身上感到发酸那样；它并不痛苦，也并不使人忍受不了，但是使你感觉到；我会熬过的。我只恨拉里把自己的生活糟蹋成这样。”\n“也许他不会。他开始走的是一条悠长艰苦的道路，可是，他最后也许会找到他要找的东西。”\n“那是什么呢？”\n“你难道没有想到过？从他告诉你的那些话看来，他表示得相当明显。上帝。”\n“上帝[注]！”她叫出来。可是，她这一句是表示极端诧异的惊叹语。我们用了同一字眼，但是，意义却完全两样，使我们对这里的喜剧效果全都不由而然地笑了。但是，伊莎贝儿立刻又严肃起来，我而且觉得她的整个表情带有一种恐惧。\n“你怎么会想到这个？”\n“我只是猜想。可是，你要我告诉你我作为一个小说家是怎样看法。不幸的是，你一点不知道他在大战时碰上了什么事情深深打动了他。我觉得，他的感触是完全出乎他的意料的。我在想，不管拉里碰上了什么，总之，这事使他有种人生无常和痛苦感，同时，觉得世界上的罪恶和痛苦准有一种补救办法。”\n我看得出伊莎贝儿不喜欢我把谈话兜到这上面来。这使她觉得坐立不安。\n“这一切都非常之不正常，是不是？我们得承认眼前的现实。人活在世界上就是要把生活过得好。”\n“你大概是对的。”\n“老老实实说，我只是一个非常正常的普通女孩子。我要过得开心。”\n“看上去你们两个人的气息完全合不到一块去。你在结婚之前能够发现这一点，非常之好。”\n“我要结婚，而且有孩子，而且生活得——”\n“按照慈悲的上帝高兴给你安排的那样生活，”我打断她，并向她微笑。\n“是啊，而且这也没有什么不对，可不是？这样的生活很快乐，我是完全满意的。”\n“你们就象两个朋友要一起去度假期，可是，一个要爬格陵兰的雪山，另一个要到印度的珊瑚礁去钓鱼。显然这是办不到的。”\n“不管怎样，我说不定会在格陵兰的雪山上弄到一件海豹皮大衣，而印度的珊瑚礁恐怕很难说有什么鱼可以钓到。”\n“那还得看。”\n“你为什么这样说呢？”她问，眉头有点皱。“你自始至终好象肚子里藏了什么话不说似的。当然我知道我并不是这出戏里的主角。拉里是主角。他是理想家，他在做一个美丽的梦，而且即使这个梦不会实现，能做这样的梦也是令人心醉的。\n我担任的是那种狠心的、势利的、讲究实际的角色。通常的人是不大同情的，是不是？可是，你忘掉倒霉的是我。拉里会我行我素，遨游天地间，我只得紧紧跟在他后面苦挨苦挣地过日子。我要生活。”\n“这个我一点没有忘掉。多年前，当我还年轻的时候，我认识一个医生，而且是一个很不错的医生，可是他并不开业。他许多年来都埋头在大英博物馆的图书馆里，每隔一段很长时间，就写一大本既不象科学又不象哲学的书，由于没有人要看，只好自费印了出来。他在逝世前写了四五本这样的书，没有任何价值。他有个儿子进军界，可是，他没有钱送他进桑赫斯特军事学院，只好去当一名普通兵士，大战时阵亡了。他还有个女儿；长得很美，我对她相当倾心。她去演戏，可是没有天才，只好认倒霉到外省去转，在些二流剧团里演配角，挣的钱少得可怜。他的妻子操了多年的单调而肮脏的苦活，终于健康顶不住，病倒了，那女孩子只好回家来看护母亲，代替母亲做她母亲做不动的苦活。碰壁，碰壁，再碰壁，生命白白浪费，落得个一场空。当你决定离开常轨行事时，这是一种赌博。许多人被点了名，但是，当选的寥寥无几。”\n“妈和艾略特舅舅赞成我这样做。你也赞成吗？”\n“亲爱的，这对你有什么关系？我对你几乎可以说是个陌生的人。”\n“我把你看作是一个无所偏袒的观察者，”她说时嫣然一笑。“我很想征得你的同意。你真的认为我做得对吗？”\n“我认为你为你自己做得对，”我说，深信她不会觉察到我的回答里有丝毫的区别。\n“那么，为什么我总感到过意不去呢？”\n“真的吗？”\n她点点头，她嘴边仍带着微笑，可是变得有点象苦笑了。\n“我知道这只是起码知识。我知道任何懂道理的人都会认为我做了唯7一应当做的事情。我知道从任何实际的立场看，从人情世故的角度看，从普通的常识看，从是非的立场看，我做得都是对的。然而，在我的内心深处，我总感到一种不安，觉得我如果好一点，我如果不斤斤计较利害一点，比较不自私些，比较高尚些，我就会和拉里结婚，并且过他的那种生活。如果我真的爱他，我就会把世界不放在眼里。”\n“你也可以把话倒转来说。如果他真的爱你，他就会毫不踟蹰照你的意思行事。”\n“我跟自己也这样说过。可是，没有用处。我想女人和男人不同，女人天生是要牺牲自己的。”她吃吃笑了。“路得和异乡麦田[注]和那一类的事情。”\n“你为什么不大胆试一下？”\n我们的谈话一直都很轻松，几乎象在随便谈论双方都认识，但是跟我们关系并不密切的一些人的事情；伊莎贝儿甚至于向我叙述她跟拉里的那次谈话时，谈得也很凤趣，有时还夹一点诙谐，就好象不要我把她的话太当真似的。可是，现在她的脸色变了。\n“我怕。”\n有这么半晌，我们两个都没有开口。我从头一直凉到脚，就象我碰到深刻而真实的人类情感时会起的那种古怪反应。我觉得吃不消，而且相当震骇。\n“你非常之爱他吗？”我终于问了她一句。\n“我不知道，我对他很不耐烦，我对他很恼火。我一直在想他。”\n我们重又沉默下来。我不知道怎样说是好，我们坐的咖啡室很小，厚厚的花边窗帘遮着外面的光线。糊着黄大理石花纹壁纸的墙壁上挂些陈旧的游猎印刷品。再加上那些桃花心术的家具，寒伧相的皮椅子和一股霉味，给人一种古怪的感觉，仿佛是狄更斯小说里的咖啡室似的。我拿起火钳拨拨火，加上些煤。伊莎贝儿突然开口说道：“你知道我原来以为到了摊牌的时候，他会屈服。我知道他很软弱。”\n“软弱？”我叫出来。“你怎么会有这种想法？一个人由于决心要走自己的道路，能够一年不理会所有的亲友的反对……”\n“过去只要我叫他做什么，他就做什么。我能够把他玩于股掌之上。在我们做的那些事情上，他从来不当头儿。只是跟着大伙儿一起转。”\n我点起一根香烟，看着我喷出的烟圈。烟圈变得越来越大，最后在空气中消失。\n“妈和艾略特都认为我这事之后仍旧若无其事地跟他出去到处近，很不对头，但是，我并不放在心上。我一直到最后都认为他会屈服的。我一直相信不了，当他的蠢脑袋意识到我讲的话算数时，他不会让步。”她迟疑一下，带着顽皮的恶意向我一笑。“如果我告诉你一件事情，你会不会大吃一惊？”\n“我想肯定不会。”\n“在我们决定来伦敦之后，我去看了拉里，问他我们能不能一同消磨我在巴黎的最后一晚。当我告诉家里人时，艾略特舅舅说这非常之不得体，妈说她觉得没有必要。妈说没有必要，意思就是说她对这件事完全不赞成。艾略特舅舅问我这是什么意思，我说，我们打算找个地方吃晚饭，然后去逛那些夜总会。他告诉妈说，她应当禁止我去。妈说，‘如果我禁止你去，你会听吗？’我说，‘不，亲爱的，绝对不听。’她就说，‘这就是我原来设想的，既然如此，我禁止你去好象没有什么意思了。’”\n“你母亲好象是个非常通情达理的女人。”\n“我敢说很少有什么事情逃得过她的眼睛的。拉里来接我时，我到她房间里跟她说再见。我稍微打扮了一下；你知道，在巴黎非得如此不可，不然的话看上去就太象光着身子了；当她看见我穿的那些衣服时，她把我从头到脚看了一遍，使我很局促不安，觉得她相当敏锐地看出我心里的打算。可是，她什么也没有说，只是吻了我一下，说她希望我玩得开心。”\n“你打算干什么呢？”\n伊莎贝儿疑惑地望着我，就象决定不了自己究竟坦自到什么程度。\n“我敢说我看上去很不错，而且这是我的最后机会。拉里在马克昔姆饭店定了一张桌子。我们点了很多好菜，所有我特别喜欢吃的东西都点了，还喝了香槟。我们杂七杂八地谈，至少我是这样，而且引得拉里大笑。我喜欢他的一件事情是，我总能够使他开心。我们跳了舞。跳舞跳够了以后，我们就上马德里堡[注]，在那边碰到几个我们相识的人，就加入他们一起；我们又喝了香槟。后来我们又去阿凯西亚。拉里舞跳得很好，而且我们步调很合。又是热，又是酒，又是音乐——我有点飘飘然起来。我觉得毫不在乎。我和拉里脸儿相偎地跳着，我知道他要我。天知道，我也要他啊。我有了一个想法。我觉得这个想法一直就在我脑子里。我想我要把他带回家，只要带回家，嗯，那个不可避免的事情一定会不可避免地发生。”\n“我要说，你这样措辞再微妙不过了。”\n“我的房间离艾略特舅舅的房间和妈的房间有一段路，因此我认为没有危险。\n等我们回到美国之后，我想我就写信告诉他我怀孕了。他那时就只好回来和我结婚，而且只要能把他弄回去，我敢说使他留在美国并不难，特别是妈在生病。‘我以前怎么没有想到这个，我这个蠢货，’我跟自己说。‘这一来，当然什么都解决了。’音乐停下来时，我仍旧在那里让他搂着我。后来我说时间晚了，明天中午我们还要上火车，所以我们还是走吧。我们乘了一辆出租汽车。我紧紧偎着他，他用胳臂搂着我，而且吻了我。他吻了我，吻了我——啊，简直是登天。车子开到门口，好象只有一刹那的工夫。拉里付掉车钱。\n“‘我走回去。’他说。\n“汽车隆隆开走，我拿胳臂搂着他的头颈。\n“‘上来再喝一杯酒，好吗？’我说。\n“‘行，如果你要我的话。’他说。\n“他已经揿了门铃，这时门开出来。我们进门时，他把电灯扭开。我看看他的眼睛；眼睛的神情是那样信任，那样诚实，那样——那样天真无邪；他显然一点没觉察到我在设下一个圈套；我觉得，我不能对他玩这样的卑鄙手段。这就象把孩子手里的糖拿掉。你知道我怎样做的。我说，‘呀，也许你还是不上去的好。妈今天晚上不大好。如果她已经睡了，我可不想吵醒她。晚安。’我仰起脸让他吻了我，把他推出门。事情就这样完结。”\n“你懊恼吗？”我问。\n“也不高兴，也不懊恼。我只是自己做不了主。并不是我要这样；只是一时冲动，使我没法子不这样做。”她勉强一笑。“我想你会说这是我的性格的好的一面。”\n“我想你可以这样说。”\n“那么我的好的一面只好自食其果了。我相信将来它会小心点。”\n我们的谈话实际上就这样结束。伊莎贝儿对自己能够无拘无束地跟人谈话也许相当感到慰藉，可是，我能给她的只是这一点点。我觉得自己没有能尽到责任，想讲几句话使她多少感到舒服一点。\n“你知道，一个人在恋爱，而且事情弄得全然不对头时，心里总是非常难受，而且好象永远不能摆脱似的。可是，你会诧异的是，海在这上面很起作用。”\n“这话怎么讲？”\n“爱情是个很不行的水手，你坐一次船，它就憔悴了。当你和拉里之间隔开一座大西洋时，你会意想不到地发现，在启程以前，好象无法忍受的苦痛，也变得轻微了。”\n“这是你的经验之谈吗？”\n“这是一个曾经沧海的人的经验体会。我在爱情上碰了钉子，感到痛苦时，就立刻去搭上一只大海轮。”\n雨仍旧下个不停，我们认为不去看汉普顿宫那些华贵建筑，甚至伊丽莎白女王的床，伊莎贝儿也可以活下去，所以就坐车子回到伦敦。这以后我还见过伊莎贝儿两三面，但是，都有别人在场。后来我在伦敦住够了一个时期，就上蒂罗尔山区去了。\n第三章 # 一 # 这以后，我总有十年没有再见到伊莎贝儿和拉里。艾略特还是经常见到，而且由于某种原因——这我以后再交代——比以前见面的机会的确更多了。我不时从他口中得知伊莎贝儿的近况。可是关于拉里，他一点讲不出来。\n“以我所知，他仍旧住在巴黎，可是，我不大可能碰到他。我们交游的圈子不一样。”他又接上一句，有点心安理得的样子。“非常遗憾的是，他会堕落到这种地步。他是好好人家出身，我敢说，如果他把事情交给我来安排，我总可以使他混出一点名堂来。反正对伊莎贝儿说，她总算幸免了。”\n我的交游并不限于艾略特认识的那些人；我在巴黎认识的有些人，艾略特说不定认为很不象样。巴黎我虽然时常经过，但是呆的时间都不太长；也曾问过里面某些人可曾碰见拉里，或者听到他的消息没有；有几个和他偶然相识，但是，都谈不上和他有深交，所以谁也没法告诉我拉里的情况。我去他常吃晚饭的那家饭馆，但是，发现他已经好久不去，所以都认为他一定走了。我在蒙帕纳司大街那些咖啡店里也从来没有看见过他，这些咖啡店是住在附近的人总会去的。\n拉里在伊莎贝儿离开巴黎之后，原来的打算是去希腊，但是他放弃了。他的实际行踪多年后才由他亲口告诉我，但是，为了把事情尽量按照时间顺序排列，读起来方便些，我还是现在来叙述的好。他整个夏天都住在巴黎，一直工作到秋深。\n“那时我觉得需要把书本子放一下，”他说。“我一天看八小时到十小时的书，这样已经有两年了。所以我就到一家煤矿去做工。”\n“你到那儿去？”我叫出来。\n他看见我这样诧异，笑了起来。\n“我认为从事几个月体力劳动对我有好处；这会使我有时间把自己的思想理理清楚，使自己平静下来。”\n我没有开口；我不知道这是否拉里采取这一意外步骤的唯一理由，还是和伊莎贝儿拒绝和他结婚也有关系。事实是，我就不知道他对伊莎贝儿的爱有多深。大多数人在恋爱的时候会想出各种理由说服自己，认为照自己的意旨行事是唯一合理的举动。我想不幸的婚姻那么多，就是这个原因。他们就象那些把自己的事情交给一个明知道是坏蛋的人去管一样；由于这个坏蛋和自己很好，他们就不愿意相信一个坏蛋首先是坏蛋，然后才是朋友，而且坚决认为这个人尽管对人不老实，对自己决不会如此。拉里不肯为了伊莎贝儿牺牲自己选择的生活，是相当坚强的，但是，失掉伊莎贝儿可能比他自己预料的要更加不能忍受。可能他就和我们多数人一样，又要吃饼子，又要留着看。\n“哼，你讲吧，”我说。\n“我把我的书和衣服放在两只箱子里，交给美国旅行社保管。然后把一套替换的衣服和些内衣打了一个包，就动身了。我的希腊文教师有个妹妹嫁给朗斯附近一家煤矿的经理，所以写了一封信介绍我去见他。你知道朗斯吗？”\n“不知道。”\n“在法国北部，离比利时边界不远。我在那边只住了一晚，就在车站旅馆，第二天坐当地的火车去了煤矿那边。你去过煤矿村吗？”\n“在英国。”\n“啊，我想大约是差不多的。有煤矿，有经理的房子，一排排矮小的三层楼房，全是一个样，完全一个样，单调得使你看了心情非常抑郁。有一座新近造的、怪模怪样的教堂，还有几家酒吧间。我到达时，天气又阴又冷，而且下着毛毛雨。我到了经理的办公室，把信交给他。经理是个矮胖子，两颊红红的，看上去象是个贫嘴的家伙。矿上正缺乏工人，许多矿工在大战中都牺牲了，有不少波兰人在这儿做工，敢说有二三百名。他问了我一二个问题，他不喜欢我是个美国人，好象觉得这里面有鬼，可是，他舅爷的信上说我很好，而且他反正愿意用我。他要给我一个地面上的工作，可是，我告诉他我想到矿下面去干活。他说，如果我没有做惯，会觉得人吃不消，但是，我告诉他，我早有准备，这样，他就说，我可以做一个矿工的助手。\n这其实是男孩子做的，不过，男孩子也不够周转。这人很不错，他问我有没有找过房子，当我告诉他还没有去找时，他就拿一张纸条子写了个地名，说我如果拿这个纸条子去，那个房子的女人就会给我一个地方睡。她是个寡妇，丈夫是矿工，大战中阵亡了，两个儿子都在矿上做工。\n“我拿了包，离开经理室，找到那所房子，一个身材高大的女人来开门，头发已经花白，一双乌黑的大眼睛；眉眼长得不错，过去有一个时候一定好看过；如果不是因为门牙少掉两个，她也不至于象现在这样憔悴。她告诉我没有房间，但是，她租给一个波兰人的房间里有二张床，我可以睡那一张空床。她的两个儿子睡在楼上的一个房间，另外一间她自己睡。她给我看的那个房间在楼下，我想原来大概是作为起坐间的；我很愿意能够单独有间房间，不过，我想还是不要罗嗦吧；外面的毛毛雨已经渐渐沥沥下起来，而且我的衣服打湿了。我不想再跑别的地方，把衣服淋得湿透。所以，我说这样行，就住了下来。他们把厨房当起坐间，厨房里有两张摇摇晃晃的圈椅。院子里有个堆煤的棚，也用来作浴室。两个男孩子和那个波兰人已经跟他们吃过午饭，但是，她说，我可以跟她在中午一起吃饭。这以后，我就坐在厨房里抽烟，她一面做家事，一面跟我谈她的身世和家庭情况。早班做完，别的人陆续回来，先是那个波兰人，后来是两个男孩子。波兰人穿过厨房，当房东太太告诉他，我要和他睡一个房间时，只跟我点一下头，并不开口，从壁炉架上拿起一只大水壶到煤棚里洗脸去了。两个男孩子都是高个子，尽管脸上有煤污，看上去还很漂亮，而且好象愿意跟我要好。他们把我看作是个怪物，因为我是美国人。一个男孩子十九岁，解除军役不过几个月，另一个十八岁。\n“波兰人回来了，两个男孩子就去洗刷。波兰人的姓是那种很难叫的波兰姓氏，可是他们都叫他考斯第。一个大家伙，比我要高出两三英寸，长得又长又壮；一张苍白肥胖的脸，鼻子短而宽，大嘴；蓝眼睛，由于没有能把眉毛和睫毛上面的煤灰洗掉，看上去就象化了妆一样。黑睫毛把眼珠的蓝颜色衬得简直令人骇异；是个丑陋肮脏的家伙。两个男孩子换了衣服出去了。波兰人继续坐在厨房里抽烟斗，看报。\n我口袋里有本书，所以拿了出来，也开始看书。我注意到他有一两次张我一眼，不久便放下报纸。\n“‘你看的什么？’他问。\n“我把书递给他，让他自己看。是一本《克里夫斯公主》[注]，我在巴黎火车站买的，因为本子小，可以放在衣袋里。他看看书，又看看我，有点奇怪，就把书还我。我看出他嘴边露出讽刺的微笑。\n“‘你觉得好看吗？’“‘我觉得很有意思——甚至很引人入胜。’“‘我在华沙上学时读过。看得我腻味死了。’他法文讲得很好，一点波兰口音也没有。‘现在我除掉报纸和侦探小说外，什么都不看。’“杜克娄克太太——这就是我们房东太太的名字——一只眼睛瞄着火上在烧的晚饭吃的汤，一面靠着桌子补袜子。她告诉考斯第，我是煤矿经理介绍来的，并且把我认为可以告诉她的话重述一遍。他一面听，一面拍着烟斗，一双雪亮的蓝眼睛瞅着我，眼光严厉而精细。他问了我几个关于我的问题。当我告诉他我从来没有在煤矿上做过工时，他嘴角露出讽刺的微笑。\n“‘你不知道自己来做什么。一个人只要有别的工作可做，决不肯上煤矿来工作。不过这是你的事情，肯定有你的理由。你在巴黎住在哪里？’“我告诉他住在哪里。\n“‘有一个时期，我每年都要去巴黎一趟，不过，都是在那些大街上选。你到过拉吕饭店没有？那是我最喜欢会的馆子。’“这使我有点诧异，因为你知道，这馆子并不便宜。”\n“一点不便宜。”\n“我想他看出我有点诧异，因为他嘴边又露出那种讽刺的微笑。可是，他显然觉得并不需要进一步解释。我们东聊聊，西聊聊，后来两个男孩子回来了。我们一同吃晚饭。吃完晚饭，考斯第问我可高兴和他上小酒店去喝杯啤酒。小酒店只是一间相当大的房间，房间的一头是酒吧间，另外有几张大理石面的桌子，四周围放些木椅。有一架自动钢琴，有人放进一个硬币，钢琴正放着舞曲。除掉我们坐的那张桌子外，只有三张桌子坐有人。考斯第问我可会打比陆。我曾经跟我的那些学生朋友学过，所以说会打；他就建议我们赌谁会啤酒账。我同意，他叫人把纸牌拿来。\n我输了一杯啤酒，接着又输掉一杯啤酒。后来他建议我们赌现钱。他拿的牌好，我的运气很坏。不过赌的输赢不大，我只输了几个法郎。这一赢加上啤酒使他的兴致高了，他就谈起来，从他的谈吐和举止，我不久就看出他是个受过教育的人。当他重又谈到巴黎时，他就问我可认识某某，某某，某某，就是路易莎伯母和伊莎贝儿住在艾略特家里时我碰见的那些美国女人。他好象比我跟这些人熟悉得多，我弄不懂他怎么会落到现在这样。时间并不晚，可是，我们天一亮就得起来。\n“‘走之前，我们再喝一杯啤酒吧，’考斯第说。\n“他一面呷着啤酒，一面用他精细的小眼睛瞄着我。我知道他当时使我联想起的什么，是一个坏脾气的猪猡。\n“‘你为什么到这个混蛋的煤矿来做工？’他问我。\n“‘体验一下。’“‘你是个傻瓜，小伙子，’他说。\n““那么，你为什么在这儿做工呢？’“他耸耸自己厚实而臃肿的肩膀。\n“‘我做孩子时就进了贵族军事学校，我父亲是沙皇下面的一个将军，上次大战时我是骑兵军官。我受不了皮尔苏斯基[注]。我们策划杀死他，可是有人出卖了我们。我们的人凡是被他捉到的，都被枪毙。我总算来得及越过边境s这时我只有参加法国军团，或者到煤矿上做工的两条路。这两件坏事，我选择了后一件坏得少些的。’“我已经告诉过考斯第，我预备在煤矿上做什么工作，他当时没有说什么，可是，现在他把胳膊肘搁在大理石台面上，跟我说道：“‘你试试把我的手摊开看。’“我懂得这是一种老式的角力，所以摊开手掌抵着他的手掌。他笑了。‘几个星期之后，你的手可不会这样软了。’我使尽力气推，可是，他的力气非常之大，简直动不了他；他慢慢地把我的手推回去，一直推到桌子下面。\n“‘你相当有力气，’他总算没有笑我。‘没有多少人能够顶得住这样久的。\n你听我说，我的助手很不行，他是个矮小的法国人，连个虱子的力气也没有。明天你跟我来，我跟工头说叫你做我的助手。’“‘我很愿意，’我说。‘你看他肯吗？’“‘要点人情。你拿得出五十个法郎吗？’“他把手伸出来，我从皮夹子里拿出一张钞票给他。两个人回家睡觉。我劳累了一整天，睡得象猪一样。”\n“你可觉得煤矿的活不好干吗？”我问拉里。\n“开头干得人腰酸背痛，”他咧开嘴笑了一下。“考斯第和工头一起干活，我当考斯第的助手。那时候，考斯第干活的地方只有旅馆浴室那样大小，而且进去时要通过一条很低的隧道，只能手足齐用爬进去。里面热得象火炉，我们干活时只穿一条裤子。考斯第那个又胖又白的上半身看了叫人极其厌恶，就象只无大不大的蜒蚰。在那么狭窄的一点地方，气刀的声音吵得人耳朵都聋了。我手的活是把他劈下来的煤块装满一篮子，再把篮子拖到隧道口，等地下煤车隔段时间开来时，把它装上，煤车再开到电梯那边。这是我平生碰到的唯一的一个煤矿，所以不知道一般的做法是不是都是如此。这好象是很起码的操作法，可是这活儿却他妈的非常吃力。\n做了半个工的时候，我们坐下来休息，吃午饭，抽烟。做完一天之后，我并不难受，而且洗个澡真是开心。我当作我的脚永远不会干净似的，黑得就象墨水。当然我的手划破了，而且酸痛得厉害，但是长好了。我对工作慢慢习惯起来。”\n“你坚持了多久呢？”\n“这个活我只做了几个星期。那些把煤装到电梯那边的煤车，是用一辆拖拉机拖的，司机不大懂机器，引擎经常出毛病。有一次他没法子开动车子，而且好象想不出一点办法。我相当会修机器，所以把机器检查一下，半小时之内，就把车子修好了。工头告诉了经理，经理把我找了去，问我可懂得开车子。结果他就叫我担任司机；当然工作是单调的，但是轻松，而且由于引擎没有再出什么毛病，他们对我都很喜欢。\n“考斯第对我离开他恨得要死。他和我很配合，而且跟我搞习惯了。我同他成天一起工作，吃完晚饭一起上小酒店，睡一个房间，当然和他熟悉。他是个怪家伙。\n这种人你一定会喜欢。他不跟波兰人来往，波兰人去的咖啡馆我们也不去。他总忘记不了自己是贵族，而且当过骑兵军官，所以，他把那些波兰人都看成狗屎。波兰人当然恨他，但是，一点没有办法；他壮得就象条公牛，打起架来，不管有刀子没有刀子，五六个人一齐上也胜不了他。可是，我照样认识了几个波兰人；他们告诉我，他在一个漂亮的骑兵分队里当过军官是真的，但是，为了政治原因离开波兰，则是说谎。他是因为打牌作弊，被人捉住，从华沙军官俱乐部里被赶出来，并且解职的。他们叮咛我不要跟他打牌；说他碰见他们都有点怯，因为他们太熟悉他的底子。谁都不肯跟他打牌。\n“我打牌一直输给他，你知道，不过输得不多，只有几个法郎，而且他赢了以后，总要争着会酒账，所以实在算不了什么。我认为，自己只是运气不好，或者牌打得没有他好的缘故。可是，在那些人告诉我之后，我的眼睛就留神起来，而且百分之百肯定他在作弊，可是，你知道，我怎么也看不出他是怎样作弊的。哎，他真是聪明。我知道他根本不可能永远拿到好牌。我就象个山猫盯着他看。他就象狐狸一样狡猾，而且我猜想，他已经看出我对他提防起来。有一天晚上，我们玩了一会牌之后，他带着相当残酷而讽刺的微笑——这是他懂得的唯一笑法——望着我说：“‘要不要我变两个戏法给你看？’“他把纸牌拿过去，叫我说一张牌，然后洗了牌，叫我随便取一张；我取了一张看时，就是我说的那一张。他又变了两个戏法，然后问我打不打扑克。我说会打，他就发给我几张牌。我一看，手里的牌是四个a一个k。\n“‘你拿到这副牌总会押上很多的钱吧，是不是？’他问我。\n“‘我会把所有的钱都押上去，’我答。\n“‘傻瓜。’他把自己手里的牌摊给我看，是同花顺子。他是怎么搞的，我不知道。他看到我大为惊讶，哈哈大笑。‘我假如不是个规矩人，我就会使你到现在连老婆都输掉。’“‘现在你也没有吃亏，’我笑着说。\n“‘小意思。连在拉吕吃顿晚饭都不够。’“我们每晚仍继续打牌，而且打得很高兴。我得到的结论是，他作弊与其说是为了钱，还不如说是为了寻乐于。他对自己能够愚弄我感到一种异样的满足，而且我觉得，他发现我明知道他在作弊却看不出他是怎样作的，感到好笑之至。\n”可是，这只是他的一方面，而使我感觉兴趣的却是他的另一方面。我简直无法把这两方面调和起来。虽则他自夸除掉报纸和侦探小说以外，什么都不看，但他实在是个有文化的人。人很健谈，谈起话来刻薄、严峻、讥诮，但是，听他谈话，常使人笑不可抑。他是个虔诚的天主教徒，床头挂一个十字架，星期天经常去做弥撒。星期六晚上总要喝醉酒。我们去的那家小酒店，星期六总是挨挨挤挤的人，室内烟雾弥漫。有的是带了家人来的沉静的中年矿工，有的是成群结队的吵吵闹闹的年轻人，有的汗污满面围着桌子一面打比陆，一面大声叫唤，他们的老婆则坐得稍后一点看着。这些人和这些声音对考斯第产生一种古怪的影响；他会变得严肃并且谈起神秘主义来——在许多你想象不到的问题中间，偏偏会谈这个。我当时对神秘主义毫无所知，只是在巴黎读过一篇梅特林克论鲁斯布鲁克的文章。可是，考斯第却谈到柏鲁丁诺[注]、雅典最高法院法官德尼[注]、鞋匠约考白?波伊姆[注]和梅斯特?艾克哈特[注]。听这样一个被自己的世界开除出来的大块头和游民，带着讽刺、怨恨和绝望的口气谈万物的本性，谈与上帝结合后的极乐境界，简直是匪夷所思。这些我都从来没有听过，弄得我又莫名其妙，又兴奋。我就象一个躺在黑房间里但是醒在床上的人，忽然看见窗帘上透进一道光线，心里知道只要拉开窗帘，眼前就会展开一片晨光朗照的原野似的。可是，在他清醒的时候，我想要逗他谈谈这个问题，他就会对我大发脾气，恶狠狠地望着我。\n“‘我连自己讲的什么都不知道，怎么会知道自己谈些什么？’他打断我。\n“可是，我知道他在扯谎。他完全知道自己谈些什么。他懂得很多。当然他当时是吃醉了，可是，他眼睛的神情，他那张丑陋脸上心旷神怡的表情，并不仅仅是吃了酒的缘故。这里面很有道理。他第一次这样跟我谈时，有些话我始终不能忘记，因为我听了觉得骇然。他说，世界并不是上帝创造的，因为无不能变为有；世界是永恒的一种表现；这还罢了，可是，他接着又说，恶和善一样，都是神性的直接表现。坐在那个肮脏吵闹的咖啡馆里，加上自动钢琴伴奏着舞曲，听着他讲这些话，真给人一种古怪的感觉。”\n二 # 为了使读者休息一下，我在这里另起一节，但是，这样做只是为了读者的方便；拉里的谈话并没有中断过。我不妨借这个机会说，拉里谈得很从容，时常小心选择他的字眼。虽则我并不自命把这些谈话记录得完全无误，可是，我不但竭力重述了他的谈话内容，而且也复制了他的谈话风度。他的声音清脆，具有一种音乐美，听上去很受用；他谈话时，不作任何手势，只抽着烟斗，有时停下来把烟斗重新点一下，盯着你望，深色的眼睛里带有一种讨喜的，往往是古怪的表情。\n“后来春天来了。在那片平坦而荒凉的乡间，春天来得很晚，仍旧是阴雨和寒冷；可是，有时候，也会有一天晴暖，使人不想离开地面，坐着摇摇晃晃的电梯钻到一百英尺下面的地球肚里去，里面挤满了穿着煤污工人裤的矿工。春天固然是春天，但是，在那片污浊的原野上，春天来得很羞涩，就象拿不准会不会受到人们欢迎似的。它象朵黄水仙，或者百合花，开在贫民区住房窗沿上的一只盆子里，使你弄不懂它在那儿做什么。星期天早晨，我们躺在床上——因为我们星期天早上总是起身很晚——我在看书，考斯第望着外面蓝天，对我说：“‘我要离开这儿。你可要跟我一起走？’“我知道有许多波兰人夏天都回波兰参加割麦子，不过，时令还早，而考斯第波兰是回不去的。\n“‘你上哪儿去？’我问。\n“‘流浪。穿过比利时到德国，再沿莱茵河走。我们可以在农场上找到工作，把一个夏天混掉。’“我毫不迟疑就决定了。\n“‘这听上去不错，’我说。\n“第二天，我们就去告诉工头我们不干了。我找到一个人愿意拿一只背包和我换皮包。我把不需要的和背不动的衣服送给杜克娄克太太的小儿子，因为他的身材和我差不多。考斯第留下一只口袋，把些要用的东西打一只背包，就在第二天老太婆给我们喝了咖啡之后出发了。\n“我们一点不着忙，因为我们至少要等到庄稼可以收割的时候才能找到一处农场干活，所以，两个人懒懒散散地由那慕尔和列日穿过法国和比利时，然后经由亚琛进入德国境内。每天顶多走十英里或十二英里路；遇到一个村子看上去不错，就住了下来。总有一个客栈之类的地方可以过夜，总有一家酒店可以吃到饭，喝到啤酒。整个说来，天气都很好。在煤矿里于了好几个月的活之后，能够跑到野外来，的确开心。敢说我从来就没有体会到一片绿茵看上去有这样好看，一棵树还没有长出叶子，但是树枝笼罩着一层淡绿色薄雾有多么的美好。考斯第开始教起我德语来，我而且相信他的德语和法语讲得一样好。我们一路行来，他就会告诉我经过我们面前的那些形形色色的东西德文叫什么，一头牛，一匹马，一个人等等，后来又叫我复述简单的德文句子；就这样把时间消磨掉。等到我们进入德国境内时，我至少已经能够跟人家要我要的东西了。\n“科隆并不完全是顺路，可是考斯第坚决要去那里，他说是为了那一万一千殉道修女[注]。等我们到了科隆时，他去酗酒胡闹。我有三天没见到他；等他回到那有点象工人宿舍的房间时，脸色非常阴沉，原来他和人家打了架，眼睛打青了，嘴唇也划了一道口子。那相貌可不怎么好看，我可以告诉你，他睡了二十四小时，后来我们就沿着莱茵河流域向达姆施塔特出发；他说那一带乡间很好，我们很有机会找到工作。\n“我从来没有这样痛快过。天气仍旧很好，我们漫步穿过小镇和村落；碰到有什么可看的，就停下来看看。只要有地方可以过夜，就住下来；有一两次，睡在稻草堆上。吃饭在路旁的客店里吃，等到我们到达酿葡萄酒的乡间时，就不喝啤酒，喝起葡萄酒来；在客店喝酒时，就跟店里那些人交朋友。考斯第有一种粗野的快活派头，使那些人对他很信任；他会跟他们打司卡特，那是一种德国的牌戏。玩牌时，他会偷牌，可是人脾气好，而且讲些他们欣赏得了的下流笑话，所以那些人输给他那几个大钱也不介意。我和他们练习讲德语；在科隆时我买了一小本英德会话语法，进步得很快。到了晚上，考斯第喝了两大盅白葡萄酒之后，就会以一种古怪的病态方式谈论从逃避孤独而找到孤独，谈灵魂的黑夜，谈造物和主宰合为一体的极乐境界。可是到了清早，当我们穿行在明媚的乡野，草上还沾着露水时，我想要他再告诉我一点，他却变得非常生气，几乎要动手打我。\n“‘住口，你这合材，’他说。‘你要知道这些无聊的事儿做什么？来，让我们学德文。’“一个拳头就象汽锤而且说打就打的人，你跟他有什么争辩头。我曾经看见他发过火。我知道他可以把我打昏过去，把我丢在水沟里，而且用不着我提，他就会在我昏倒时把我的口袋掏光。我对他这个人简直摸不透。当葡萄酒打开他的话匣子，他谈到至高无上的主宰时，他会避开平时讲的那些粗野下流话，犹如脱掉在煤矿里穿的煤污工人裤一样；他会谈得很文雅，甚至很有口才。我敢肯定他并没有弄虚作假。不知道我是怎样会想起的，但是，我多少有种想法，好象他从事煤矿上那种辛苦的非人劳动是为了折磨自己的血肉之躯。好象他憎恨自己那个巨大的臃肿不灵的身体，要给他罪受；他的诈欺行为，他的仇恨，他的残酷，都是他的意志对——唉，我不知道你会称它做什么——他的意志对一种根深蒂固的神圣本能的反抗，对自己渴求上帝的欲望的反抗，那个使他害怕同时又使他困惑的上帝。\n“我们并不赶时间，春天差不多快过去了，树木全长得青枝绿叶的。葡萄园里的葡萄开始灌浆。我们总尽量沿土路走，现在路上的灰尘大了起来。我们已到了达姆施达特附近，考斯第说我们还是找个工做吧。我们的钱快用光了。我口袋里还有半打旅行支票，可是，我拿定主意只要能够不用，还是不用。当我们看见一家看去还不错的村舍时，我们就停下来，问他们要不要两个帮工。我要说我们的外表并不怎样讨人喜欢；身上又是灰尘，又是汗，又是肮脏。考斯第样子象个大流氓，我的样子想来也好不了多少。我们几次三番被人拒绝了。有一个地方的农夫说，他愿意雇用考斯第，但是不能用我；考斯第说我们是好朋友，不能分开。我叫他去，可是他不肯。我很诧异。我知道考斯第喜欢我，虽则我想不出是什么缘故，因为我现在已经对他没有用处了，但是，我决计没有想到他喜欢我到这种地步，会为我而拒绝工作。当我们走开后，我感到有点良心责备，因为我并不真正喜欢他，事实上，我觉得他相当可厌，但是，当我想要说几句话，表示我对他这样做感到高兴时，他把我臭骂了一顿。\n“但是，我们总算时来运转了。我们刚穿过一处坐落在低谷中的村子，就望见一幢单独的村舍，外表还不错。我们敲敲门，一个女人来开门。我们象平时一样问她可要帮工的，说我们不要工钱，只要有饭吃，有地方住就行，想不到她并没有请我们吃闭门羹，而是叫我们等一下。她向屋子里面叫人，不久就出来一个男人。这人把我们仔细打量一下，问我们从哪儿来的。他要我们把证件给他看，看到我是美国人时，把我又瞪了一眼。他好象不大高兴这一点，但仍旧请我们进去，并且喝杯葡萄酒；他把我们带到厨房，三个人一同坐下。那女人端来一大盅酒和几只杯子。\n他告诉我们，他雇的帮工被公牛抵伤了，现在在医院里，要等到庄稼收割之后才能复工。战争里死了那么多人，余下的人又都进了莱茵河沿岸兴起的那些工厂做工去了，现在找帮工他妈的可真不容易。这个我们知道，而且早已算计到了。总而言之，他说他可以雇用我们。房子里地方很大，可是，我想他大约不愿意我们住在家里；不管怎样，他告诉我们稻草棚上面有两张床，我们就在那里睡。\n“农场上的活不重。牛要喂食，还有猪也要喂食；机器很不灵，我们得好好收拾一下；但是，我还是有点空闲。我喜欢那些芳香的草坪，傍晚时常常到处闲逛，通想，日子过得很不错。\n“这家人家姓贝克尔，有老贝克尔，他的妻子，他的寡媳和孙儿女。贝克尔年近五十，肥硕的身躯，花白头发；他在大战时参过军，腿上受了伤，现在走起路来还是一拐一拐的。腿上的伤使他很痛苦，只能靠喝酒解痛；睡觉前总是喝得醉醺醺的。考斯第和他相处得很好，晚饭后，时常一起上酒店，打司卡特，大喝其酒。贝克尔太太原是婢女。他们把她从孤儿院里领出来，贝克尔在妻子死后不久就娶了她。\n她比贝克尔年纪小一大截，也还有点姿色，长得丰满，两扬红红的，浅色的头发，有股风骚劲儿。考斯第不久就看出这里面有点花头的结论。我告诉他不要当傻瓜。\n我们有个好工作，可不愿意丢掉。他只是嘲笑我；说贝克尔满足不了她，而且是她自己在要。我知道叫他规规矩矩是白说，但还是关照他当心点；贝克尔可能看不出他的企图，但是还有他的媳妇。你逃不脱她的眼睛。\n“爱丽——就是那个媳妇的名字——是个又高又壮的年轻女人，只有二十来岁，黑眼睛，黑头发，一张长方的阴沉沉的脸。她仍旧营自己在凡尔登阵亡的丈夫戴着孝。是个虔诚教徒，每逢星期天早晨，都要步行到村子里去做早弥撒，下午又要跑去做晚祷。她有三个孩子，其中一个是遗腹子；吃饭时除掉骂孩子外，从不开口。\n她在农场上只做少量的活，多数的时间都花在带孩子上，晚上总是一个人坐在起坐间里开门看小说，这样哪个孩子哭她就能听到。两个女人感情很坏。爱丽看不起贝克尔太太，因为她是个弃儿，做过佣人，而且对于她是一家的主妇，能够发号施令痛恨之至。\n“爱丽是个富庶农夫的女儿，嫁过来时带了一大笔奁资。她并没有在村里上学，而是上的最邻近的斯温根堡镇的一个女子体育学校，受到很好的教育。可怜的贝克尔太太十四岁就到了农场，能够看书写字在她已经很不错了。两个女人关系搞不好，这是另一个原因。爱丽一有机会就卖弄她的知识，贝克尔太太气得满脸通红，就问有知识对于一个农夫的妻子有什么用。于是，爱丽就会看着自己用钢链绕在手腕上的死去丈夫的身份牌，对着贝克尔太太愠怒的脸恶狠狠地说：“‘不是一个农夫的妻子。只是一个农夫的寡妇，一个把生命献给国家的英雄的寡妇。’“可怜的老贝克尔为了使她们不要吵嘴，只好把农活搁下来。”\n”可是，他们对你怎样看法呢？”我打断拉里的话。\n“哦，他们当作我是从美国军队里逃出来的，弄得回不了美国，回去就得坐牢。\n我不愿意跟贝克尔和考斯第上酒店去喝酒，他们认为就是这个缘故。他们觉得我不愿引起人们注意，弄得村警来盘问我。当爱丽得知我打算学德文时，她就把自己的旧课本拿出来，说要教我。因此，晚饭后，她就和我走进起坐间，把贝克尔太太丢在厨房里；我读给她听，她改正我的读音，并设法使我懂得那些我不认识的单词。\n我猜想她这样做与其说是帮助我，还不如说是摆点颜色给贝克尔太太看。\n“考斯第这一向一直都在设法勾引贝克尔太太，但是没有进展。她是一个快活的、嘻嘻哈哈的女人，很随便地和他一起揶揄说笑，考斯第对女人很有他的一套。\n我猜她知道考斯第的用心，而且敢说自己感到得意，但是，当考斯第开始拧她时，她却教他放规矩些，并且掴了他耳光。我敢打赌，那一记打得很重。”\n拉里有点迟疑，有点不好意思地笑了一下。\n“我从来不是那种认为女人在追我的人，可是，我感到——嗯，贝克尔太太看中了我。这使我很不舒服。单拿一点说，她比我大得多，而且老贝克尔一直对我们很尊重。吃饭时，贝克尔太太管分菜，我没法不感到她给我的菜总比给别人的多一点。我总觉得，她在找机会同我单独在一起。她会以一种我想你会称做的挑战姿态向我微笑，曾经问我可有女朋友，并且说一个年轻人在这种乡下，一定因为找不到女朋友而感到苦闷。这类事情你是懂得的。我只有三件衬衫，而且都穿得很破了。\n有一次，她说我穿得这样破烂真丢脸，要我把衬衫拿来让她给我缝缝补补。爱丽听到了，因此，下一次她和我单独在一起时，就说我如果有什么东西要补的，让她来补。我说没有关系。可是，一两天后，我发觉我的袜子洞全补好了，衬衫也打上补钉，放在阁楼上我放东西的长凳上，但是，不知道是她们哪一个做的。当然，我并不把贝克尔太太放在心上；她是个忠厚女人，我觉得这可能只是她的母性表现；但是，有一天，考斯第跟我说：“‘你听着，她要的不是我而是你。我一点指望也没有。’“‘别胡说八道，’我跟他说。‘她大可以做我的母亲。’“‘这有什么关系？你只管追她，老弟，我不会碍你的事。她可能不那么年轻，但是身体长得很不错。’“‘不要胡说。’“‘你迟疑做什么？不要因为我的缘故，我希望。我是个哲学家，我懂得此处不着那处着。我不怪她。你年轻，我也年轻过来。青春是稍纵即逝的。’“考斯第这样把稳，我并不高兴，我不愿意相信有这种事情。我不知道怎样对付这种局面是好，后来，我追溯了当时曾经触动我的许多事情，爱丽讲的那些我没有怎样留意的话。可是，现在我懂了，我有把握说爱丽也知道是怎么回事。贝克尔太太和我单独在厨房里时，爱丽会突然跑进来。我有个印象好象她在监视我们。我很不喜欢，觉得她想要当场提着我们。我知道她恨贝克尔太太，只要有点风吹草动，她就闹出来。当然我知道她没法子抓到我们的把柄，但是，这个女人的心眼儿很坏，说不定会编出一套谎话来灌输给老贝克尔。我不懂得怎样对付，只好假装我是个大傻瓜，一点领会不了这个女人的用心所在。我在农场上过得很快活，干活也干得很开心，不想在收割之前就离开。”\n我不由得笑起来。我可以想象得出拉里当时的模样，穿着补过的衬衫和短裤，脸和脖子被莱茵河的太阳晒得黝黑，灵活而瘦削的身体，一双深色眼睛嵌在田进的眼窝里。我可以有把握说，他这副相貌会使贝克尔太太这样白皙、这样胸部丰满的主妇欲火中烧起来。\n“那么，后来怎样呢？”我问。\n“是啊，夏天一天天过去。我们象牛马一样干着活。割掉麦子，堆起麦子。后来樱桃熟了。考斯第和我爬梯子摘樱桃，两个女人把樱桃装进大箩筐，由老贝克尔送到斯温根堡镇上卖掉。后来我们又割裸麦。当然始终还要照顾牲口。我们总是天没亮就起来，一直干到天黑才歇手。我想贝克尔太太已经看出我这人没有指望，把我放弃了；我总是保持和她若即若离，但是，尽量不得罪她。晚上，我已经非常瞌睡，谈不上读什么德文；吃完晚饭就回到阁楼上去，往床上一倒。贝克尔和考斯第大都上村里的酒店，可是考斯第回来时，我已经酣呼大睡了。阁楼上很热，我睡觉时总脱得赤条条的。\n“有一天夜里，我被弄醒了。开头我弄不清是怎么回事；我半睡半醒，我感到一只热呼呼的手捂着我的嘴，这才发觉有人和我睡在一起。我把手挪开，接着就有一张嘴抚着我的嘴，两只胳臂抱着我，我感到贝克尔太太的两只大奶于抵着我的身体。\n“‘不要响，’她低声说。\n“她身体紧紧抵着我，用又热又丰满的嘴唇吻我，两只手不住摸我的身体，两条大腿夹在我大腿中间。”\n拉里停下来，我吃吃笑了。\n“你怎么办呢？”\n他不属地笑一下，甚至脸有点红起来。\n“我有什么办法？我能够听见考斯第在我旁边的床上鼾声很大。这是约瑟的处境[注]，而且我过去一直觉得有点可笑。我只有二十三岁。我不能闹出来，把她赶走。我也不想使她伤心；只好依她。\n“后来她溜下我的床，轻手轻脚下了阁楼。我可以告诉你，我深深叹了口气，心放了下来。你知道，我吓坏了。‘天哪，’我说，‘真险！’我想贝克尔很可能吃得大醉回来，昏昏沉沉睡了，可是，他们睡一个床，说不定他会醒来，看见自己老婆不在床上。还有爱丽。她总是说睡得不好。如果她醒着，她就会听见贝克尔太太下楼走出屋子。接着我忽然想起一件事情来。贝克尔太太和我睡在一起时，我觉得有块铜片碰到我的身体。当时我没有注意到，你知道在这种情况下，人们一般都不注意这些事情的，我而且一直没有盘算到他妈的这是什么。现在我想起来了。当时我坐在床沿上，正在盘算这一切事情的后果而且发愁时，忽然吓了一大跳，人站了起来。那个铜片是爱丽丈夫的身份牌，被爱丽一直缠在手腕上的，所以和我睡在一起的并不是贝克尔太太，而是爱丽。”\n我哈哈大笑，笑得不可开交。\n“你可能觉得好笑，”拉里说。“我可不觉得。”\n“现在你回想一下当时的情景，是不是认为这件事情有点滑稽味道吗？”\n拉里嘴边勉强露出微笑。\n“也许。可是这事情弄得非常尴尬。我不知道这会引起什么后果。我不喜欢爱丽。我觉得她是个顶讨厌的女人。”\n“可是，你怎么会把她当作另外一个呢？”\n“那时屋子里漆黑。她除了叫我不要作声外，一句话也没说。她们两个身材都高大。我认为贝克尔太太看上了我。从没有想到爱丽会把我放在心上。她总是想念自己的丈夫。我点起一支香烟盘算当时的情形，越想越不高兴。看来最好的办法是离开这儿。\n”我时常恨考斯第不容易叫醒。在煤矿上时，我总要死扯活拉把他叫起来，使他不至于迟到。可是，现在我倒很感谢他睡得这样沉了。我点灯穿上衣服，把衣物打在背包里——我的东西不多，所以一会儿就打好了——把胳臂套在背带里。只穿袜子穿过阁楼，一直到楼梯下面才穿鞋，把手里的灯吹熄。夜很黑，没有月亮，可是，我识得大路，到了大路上就向村子的方向走去。我走得很快，因为我打算在有人走动之前穿过村子。这儿离斯温根堡只有十二英里，我到达时，刚开始有人走动。\n这次夜路我永远不会忘记。路上除了我的脚步声外，一点声音没有，只偶尔从农场那边传来一声鸡叫。后来天上露出一点既不是亮又不是黑的鱼肚白，接着，是晨曦微露，太阳出来，鸟儿全开始歌唱起来。还有那绿油油的田野、草地和树林，田里的小麦，被清晨的宁静光线照得金里泛银。我在斯温根堡喝了一杯咖啡，吃了一只小面包，然后上邮局打了一个电报给美国旅行社，叫他们把我的衣服和书寄到波恩去。”\n“为什么到波恩？”我打断他。\n“我们沿莱茵河步行时在那里耽搁过，我很中意那个城市。我喜欢阳光照在屋顶上和河上面的那种情调，那些小街，那些别墅、花园、栗子树的大道和大学的洛可可式[注]建筑。当时，我就想到在那儿待一个时候倒不坏。可是，我觉得在到达那里之前，该把外表收拾得象样一点。我的样子就象个流浪汉，敢说我如果找到一处供应膳宿的人家，要租赁一间房，人家不会信得过我，所以我坐了火车上法兰克福，去买了一只皮包和一些衣服。我在波恩断断续续住了有一年光景。”\n“你这番经历使你有什么收获呢？我的意思是说在煤矿上和在农场上。”\n“有，”拉里点头微笑着。\n可是，他没有告诉我是哪些收获，而且那时候我已经很熟悉他的为人，他愿意告诉你时，就告诉你，他不愿意告诉你时，就会半开玩笑地把你的问题支开，再问他也是白费。我得提醒读者，这一切都是在十年之后他才告诉我的。在这以前，也就是我和他重又碰面之前，我一直就不知道他的行踪，或者他在干什么。拿我来说，他等于死了一样。如果不是由于我和艾略特的交往，经常使我得悉伊莎贝儿的生活经过、从而想起拉里，我肯定早已忘掉有这个人了。\n三 # 伊莎贝儿和拉里解约后的第二年六月初，就和格雷?马图林结婚了。这时候，巴黎的游宴季节正处在高潮，艾略特有很多的盛大宴会要参加，当然不愿意离开，可是他的家族感情非常之强，对这种在他认为是履行社会责任的事，他决不能不管。\n伊莎贝儿两个哥哥，供职的地点都太远，没法离开，所以只好由艾略特作一次不愉快的旅行，上芝加哥做伊莎贝儿的主婚人。他想起那些法国贵族都是穿着盛装上断头台的，所以特地上伦敦订做一套新晨礼服，一件青灰色双排钮扣的大衣和一顶丝绒大礼帽。回到巴黎来时，他请我来看他穿上这套衣装的派头。他选定他认为婚礼应当打的淡灰色领带，弄得他平日别在领带上的珍珠别针一点不显眼，正感到恼火。\n我建议他改用他那支翡翠和钻石的别针。\n”我如果是客人——那可以，”他说。“但是，处在我要担任的主婚人地位，我的确觉得珠子是一种象征。”\n他对这门亲事很高兴，认为从各方面看，都符合他的标准；谈起来时，就象个居孀的公爵夫人对于拉罗什富科家的幼子和蒙莫朗西家的女儿门当户对的结婚，谈得津津有味。为了明白表示自己的满意，他不惜重金买了一张纳蒂埃的法国王室公主的一幅精美画像，预备带去作为婚礼。\n亨利?马图林好象给这对年轻夫妇在阿斯特街买下一幢房子，使他们靠近布太太家，同时离开自己在湖滨道的宫殿式府第也不太远。说也凑巧，而且我疑心这里面有艾略特做了手脚，在买下这幢房子时格雷戈里?布拉巴宗恰好在芝加哥，因此，房子的内部装饰就交给了他。当艾略特返回欧洲，放弃了巴黎的游宴季不参加而直接到了伦敦时，他带来了一些屋内装饰的照片。格雷戈里?布拉巴宗放手大干了一场。客厅和餐厅完全是乔治二世风格，非常华贵。书房是格雷将来的窝；格雷戈里是靠慕尼黑的阿马连堡宫一间屋子给他的启发来装饰的；除掉没有地方放书籍外，可以说无懈可击。至于卧室，把双人床除外，格雷戈里给这对年轻美国夫妇装饰得太舒适了，违法王路易十五在这里会见他的蓬帕杜夫人也会同样满意，但是，伊莎贝儿的浴室连路易十五见到也会大开眼界；全是玻璃——墙壁、天花板、浴缸——墙上有许多银色的鱼在金色的水草中游来游去。\n“当然，房子不大，”艾略特说，“但是，亨利告诉我，屋内的装修花了他十万块。对某些人说来，简直是一笔财产。”\n婚礼是在圣公会教会所能做到的范围内极尽铺张的能事中举行的。\n“不象巴黎圣母院的那种婚礼，”他心安理得地告诉我，“但是，就新教的婚礼来说，总算有气派。”\n报纸的报道很象样，艾略特随便把些剪报扔给我看。他给我看伊莎贝儿和格雷的结婚照片，伊莎贝儿穿着新娘服装，个子很高但是漂亮，格雷虽然块头大，但是，身材长得不坏，穿着礼服稍微有点不太自如。还有一张新婚夫妇和伴娘们的照片，一张和布太太、艾略特一起拍的照片，布太太穿一件华贵的衣服，艾略特拿着新丝绒大礼帽的派头可以算一绝。我问他布太太身体怎样。\n“体重减少了许多，而且我觉得她的脸色不大好看，但是人倒精神。当然整个婚事使她很累，不过，现在事情办完，她总可以休息一下了。”\n一年后，伊莎贝儿生了一个女儿，根据当时的风气，她给她取名叫琼；隔了两年，又生了一个女儿，又根据当时风气，取名普丽西拉。\n亨利?马图林一个合伙的人死了，另外两个在压力下不久也退休了，所以，这个一直由他独断独行的企业，现在完全归他所有。他长期以来抱的野心既然实现，就叫格雷跟他合伙。生意从来没有这样兴旺过。\n“他们赚钱就象随手捞似的，老兄，”艾略特告诉我。“怎么，格雷才。十五岁，已经赚五万块一年了，而且这只是开头。美国的富源真是没有个完。这不是暂时的繁荣，而是一个伟大国家的正常发展。”\n他的胸臆装满了一种少见的爱国热情。\n“亨利?马图林不会永远活下去，高血压，你懂吗？格雷到了四十岁时，总会有二千万元。了不起，老兄，了不起。”\n艾略特和姐姐经常保持通信，年去年来，不时把他姐姐告诉他的一些事情告诉我。格雷和伊莎贝儿过得很快乐，而且两个孩子都可爱。他们的生活方式使艾略特深感满意，认为完全适合他们的地位；请客的场面阔透，人家请他们也是如此；艾略特非常满意地告诉我，说他们三个月里没有一次两个人单独在一起吃过晚饭。这种纸醉金迷生活国马图林太太的逝世打断了一下——就是那个脸色苍白、高颧骨的女人，当初亨利?马图林娶她是为了自己在芝加哥能有点地位，因为他父亲当初来到芝加哥时不过是个乡下佬。为了纪念马图林太太，小两口儿有一年工夫请客顶多只请六个人。\n”我一直说八个人是最合适的，”艾略特说，拿定主意从乐观的角度来看待这件事。“这样比较亲切，谈话全照应得到，人数又够得上象个宴会。”\n格雷在妻子身上很肯花钱。生头一个孩子时，他给了伊莎贝儿一只方钻石戒指；生第二个孩子时，送了她一件黑貂皮大衣。由于太忙，他很少离开芝加哥，但是，只要能够放几天假，他们都要到亨利?马图林在麻汾的那幢大房子去度假日。亨利对儿子非常钟爱，有求必应，有一次圣诞节，在南卡罗来纳州买了一处农场，使他能在射猎季节时去打两个星期的野鸭子。\n“当然，我们的商业巨头跟意大利文艺复兴时期靠商业发财的那些伟大的艺术倡导人很相似。例如，美第奇家族。两个法国国王并不认为娶这家望族的女儿有失身份，我预见到有一天欧洲的贵族也会向我们的金元公主求婚的。雪莱是怎样说的？\n‘世界的伟大时代将重新开始，黄金的年头要回转来。’”\n多年来，布太太和艾略特的投资都交给亨利?马图林管，姐弟对他的眼光很信任，而且有十足的理由这样做。亨利从来不考虑做投机，把他们的钱都放在可靠的股票上，但是，由于股票的价值大大增长，他们发现自己有限的那点财产却增加得很可观，使他们又惊又喜。艾略特告诉我，他不用动一只指头，眼下一九二六年已经有他在一九一八年的财产的两倍。他现在六十五岁，头花发白，脸上有皱纹，眼睛下面有眼包，但是仍不服老；身材依然瘦削，而且和过去一样腰杆笔挺；在烟酒上向来有节制，而且很注意外表。只要他能够有伦敦最好的栽缝给他做衣服，有自己的特约理发师为他理发修面，有推拿的人天天早上来使他的优美身形保持常态，他决不听任自己的身体受到时光的摧残。他早已忘记自己曾经沦为商贾之流，总倾向于暗示自己早年曾经在外交界做过事，但是从不明白说出，因为他人并不笨，决不会讲一句难免会被人戳穿的谎言。我得承认，如果我有机会描写一位大使的话，我毫不迟疑会选上艾略特做我的蓝本。\n但是，世道在变。当初把艾略特提拔进社交界的那些仍然活着的伟大妇女，年事已经很高。那些英国的贵族夫人，在她们的爵爷去世后，只得把府邸让给媳妇，自己住进切尔登南的小别墅或者摄政公园一带的普通房屋。斯达福德府改为博物馆[注]，古松府成了一个机构的办事处，德文郡府在出卖。艾略特在考斯常坐的帆船转了手。眼下当道的那些时髦人物觉得艾略特这样大年纪的人没有用。他们嫌他烦不过，而且可笑。他们仍旧愿意参加他在克拉里奇饭店招待的盛大午宴，可是，艾略特相当机伶，知道他们来是为了相互之间碰头，而不是来看他。过去请帖散在写字台上随便他挑选的情形，现在已经没有了；他常常弄得只好在自己旅馆的套间里一个人吃晚饭，这种丢脸事情他很不愿意有人知道。英国有地位的女子，由于一件风流事件遭到交际界抵制之后，就对艺术感觉兴趣起来，在自己身边罗致一些画家、作家和音乐家。艾略特太心高气傲了，可不愿意丢这样的脸。\n“遗产税和战争暴发户把英国交际界毁了，”他告诉我。“人们好象对于和什么人来往全不在乎。伦敦的裁缝和鞋帽匠还是不错的，敢说我活在世上时还会如此，但是，除掉这些，伦敦已经完了。老兄，你可知道圣艾尔斯家用女人伺候饭桌吗？”\n这话是他和我吃完午宴一同从卡登府胡同走出来时讲的。那天的午宴上发生了一桩不幸事件。我们的尊贵主人藏画很有名，一个叫保罗?巴顿的年轻美国人第一次上这儿来，表示想看看这些藏画。\n“你是不是有张提香[注]？”\n“我们从前有过。现在在美国了。一个犹太佬出了一大笔钱买它，而我们那时候手头他妈的正非常之紧，所以老爵爷就卖掉了。”\n我注意到艾略特耳朵竖了起来，对这位谈笑自若的侯爷恶狠狠看了一眼，就猜到当初原是他买下这张画的。他听到自己这个出身在弗吉尼亚而且祖先在独立宣言上签过名的后裔被人家这样奚落，简直气炸了。他有生以来从没有受过这样的羞辱。\n更使人受不了的是，他对保罗?巴顿一向就深恶痛绝。这人年纪虽轻，在大战后不久就到了伦敦。二十三岁，白白的皮肤，长得很漂亮，人有风趣，舞跳得非常之好，并且很有钱。他带了一封信来见艾略特，艾略特天生是个好心肠，就介绍他认识自己的那些形形色色的朋友。这样还不满足，还给了他一些宝贵的忠告，教他怎样做人。他根据自己已往的经验指给他看，只要对老太婆献些小殷勤，对名流的谈话，不管怎样腻味，你都洗耳恭听，便是一个举目无亲的人也能钻进社交界。\n可是，保罗?巴顿进的社交界和二十年前艾略特?谈波登辛辛苦苦钻进的社交界，完全是两个世界。这个世界一心只顾自己享乐。保罗?巴顿的豪兴、漂亮仪表和翩翩风度在几个星期之内就达到艾略特花了多年刻苦和决心所达到的程度。不久他就不需要艾略特的帮助，而且并不想法子遮盖这一事实，两人碰面时，巴顿还是很讨喜，可是，那种随随便便的派头，使这个年纪大的人非常生气。艾略特请的客人并不是根据自己喜欢不喜欢，而是看他们能不能使宴会开得好。由于巴顿的人缘不错，所以艾略特每星期请午宴时，仍旧邀他；但是，这个成功的年轻人一般都有约会，而且有一两次在最后五分钟时诉他的台。这样的事情艾略特自己过去做得太多了，明知道这是因为另外的一家请客，比艾略特的宴会更有吸引力。\n“我也不要求你相信我的话，”艾略特气嘘嘘地跟我说，“可是，这是千真万确的事，我看见他时，他总要强过我。我。提香，提香，”他连话都说不连贯。\n“就是有张提香，他也对面不识。”\n我从来没有看见艾略特气成这个样子过。我猜想他所以发火是因为他认为保罗?巴顿问起这张画是出于恶意；他不知道怎样打听出艾略特买了这张画，就想利用这位高贵主人的回答拿艾略特开一次玩笑。\n“他是一个卑鄙无耻的势利小人，世界上我最深恶痛绝的就是势利。要不是我，他什么都谈不上。你可想得到，他父亲是打办公室家具的。办公室家具。”这几个字他讲得特别不屑。“我告诉人家，他在美国是个提不上嘴的人，出身非常寒微，但是，他们好象并不在乎。你记着我的话，老兄。英国交际界整个儿完了，就象渡渡鸟[注]。”\n艾略特认为，法国的情形也不大炒。他年轻时候的那些伟大妇女，如果还活着的话，都把时间花在打桥牌（他最讨厌的一种牌戏）、做祈祷和带领孙子孙女上面。\n开厂的人，阿根廷人，智利人，和丈夫分居或者离了婚的美国妇女，住在贵族派头的华丽大厦，请起客来，竭尽豪华之能事，可是，艾略特在他们的宴会上碰到的都是法语发音鄙俗的政客，吃相难看的新闻记者，甚至演员，气得他直骂。名门望族的小儿子娶开店人家的女儿并不认为是丢脸。诚然，巴黎是热闹的，但是，这种热闹多么寒伧啊！那些年轻人一味疯狂地追求享乐，都认为再没有比在一家乌烟瘴气的小夜总会，喝一百法郎一瓶的香槟酒，挤在城里不三不四的人里面跳舞跳到天亮五点钟，更有意思的了。烟气、热气、嘈杂声，闹得艾略特头都痛了。这不是他三十年前所认为的精神家园的巴黎。这不是善良的美国人死后进入的巴黎[注]。\n四 # 可是艾略特有个预感。一个知道内情的人提醒他，里维埃拉[注]就要重新成为贵族和时髦人物的游乐地。过去由于在教廷供职，他从罗马回来，或者拜访了戛纳他那些朋友的乡村别墅之后，总要在蒙特卡洛的巴黎饭店住上几天，所以对这一带海滨相当熟悉。不过，那都在冬天，近来却听到传说，认为这地方也是个很不错的消夏胜地。那些大旅馆夏天仍旧开着；夏季的游客都一一列在巴黎的《先锋报》交际栏上，艾略特看到他们的熟悉名字甚中下怀。\n“我有点吃不消这个世界，”他说。“我现在已经到了偌大年纪，很想享受享受山水乐趣。”\n这话好象讲得很含糊。其实并不是那么一回事。艾略特一直认为，山水是社交生活的障碍；那些人眼面前摆着一只摄政时代的衣柜或者一张瓦托的画不去欣赏，却要费那么大的事去游山玩水，这种人他最受不了。当时他手头正好有一大笔现金。\n亨利?马图林一方面因儿子力劝，一力面看见他那些做证券交易的朋友转眼成为巨富，很是恼火，终于向潮流屈服了；他逐渐放弃自己的陈旧保守主义，认为自己没有什么理由不可以插一手。他写信给艾略特，说他仍旧和过去一样反对赌博，但是，这并不是赌博，这只证实了他对国家无穷尽资源的信仰。他的乐观主义是根据常识来的。他看不出有什么事情能够阻止美国进步。最后，他又说，他替亲爱的路易莎?布雷德利在最低价时买进若干硬股票，而且很高兴告诉艾略特，她现在已经赚了两万元了。最后，他说，如果艾略特想要赚点零钱，让他根据自己的眼光行事，保管不会使他失望。艾略特总喜欢引用陈词说调，说他就是抵御不了诱惑；其结果是，从那时候起，《先锋报》和他的早饭一起送进来时，多年来他都是先翻交际栏，现在却首先注意证券市场的报道了。亨利?马图林代表他做的那些交易非常成功，所以，艾略特现在手边足足有五万块不费吹灰之力得来的现款。\n他决定把这笔钱取出来，在里维埃拉买一所房子。作为一个避世的逋逃薮，他选择了昂第布。这地方在戛纳和蒙特卡洛之间占有一种战略地位，他可以很方便地从这里到上述两处去；昂第布不久就成为时髦社会的中心，他选择这个地方是出于天意，抑是靠本能的指引，谁也说不出。住在一个带园子的乡村别墅里，有一种近郊的庸俗气息，使艾略特这种凡事苛求的人很有反感，所以，他在旧城临海的地方买了两幢房子，并成一幢，安装上暖气、浴间和卫生设备，这都是美国的先例强加给一个顽梗的大陆的。当时正时兴酸洗，所以他把古老的普罗旺斯家具全都酸洗过，再用现代纺织品蒙上——很慎重地迁就现代风尚——将屋子陈设起来。他对毕加索[注]和布拉克[注]这类画家仍然不愿意接受——”不成样子，老兄，不成样子”——认为这些人大都是某些走入魔道的热心家哄起来的，但是，对于印象派画家终于觉得未始不可以兼收并蓄一下，所以墙上挂了些美丽的画。我记得有一张人们在河里划船的莫奈[注]，一张毕沙罗[注]画的塞纳河的码头和桥，一张高更的塔希提岛风景，和一张勒努瓦[注]画的少女侧像，黄头发从背上披下来，很令人着迷。等到房子装修完工，真是焕然一新，赏心悦目，不同凡响而又朴素无华，而这种朴素却是教人一看就知道不耗费巨资是办不到的。\n这以后就开始了艾略特一生最煌赫的时期。他把自己在巴黎的名厨师带下来，不久人们便公认他家里的菜在里维埃拉首屈一指。他的管家和佣人一律穿上白衣眼，肩膀上钉上金带子；请起客来非常豪华，但是，从不搞到庸俗的地步。沿地中海海岸从欧洲来的王公贵族几乎俯拾即是。有些是因为爱上了那儿的气候，有些是逃亡在外，有些是由于过去在国内弄得声名狼藉，或者门第不当的婚姻，使他们觉得住在国外比较方便。这些里面有俄国的罗曼诺夫皇族，奥地利的哈司布格王族，西班牙的波旁王族，两个西西里王族和帕尔马王族；有温莎王室的公主；有布拉干萨王室的公主；有瑞典的王族和希腊的王族；艾略特都招待他们。有从奥地利、意大利、西班牙、俄罗斯、比利时来的没有王室血统的王子和公主，公爵和公爵夫人，侯爵和侯爵夫人，艾略特都招待他们。冬季，瑞典国王和丹麦国王来海滨小住，西班牙的阿丰索也不时地来匆匆一游，艾略特也招待他们。我对他向这些高贵人物鞠躬的派头一直非常钦佩，因为他既能够彬彬有礼，同时又保持一个据称是人类生来平等的国家的公民的那种独立姿态。\n我经过这些年的东奔西走，这时刚好在弗拉特角买了一所房子，因此和艾略特时常见面。我在他眼中很荣幸地已经升得很高，所以，他有时候也请我参加他的最盛大的宴会。\n“来帮帮我的忙吧，老朋友，”他会说。“当然我跟你一样知道，皇族破坏宴会的气氛。可是，别的人却想见见他们，而且我觉得应当对这些可怜的人儿稍稍关顾一下。（不过，天知道，他们是不配的。他们是世界上最忘恩负义的人；）他们要利用你，而当他们不再需要利用你时，就会把你当作穿破的衬衫一样扔掉；他们会从你手里接受无数恩惠，但是，里面没有一个会走到马路对面替你做一点点事情。”\n艾略特费了很大苦心和当地的上级官员搞好关系，因此区长和教区主教和主教的总教士时常成为他的座上客。主教在进教会之前是个骑兵军官，大战时并且指挥过一个骑兵团。他是一个脸色红红的、身材高大的人，讲话故意学军队里的那种粗鲁丽率直的派头，他的那位严峻、颜色枯槁的总教士常常手脚发麻，生怕主教会说出什么下流话来。他带着不以为然的微笑听着自己上级讲他那些喜欢的故事。可是，主教管理自己的教区非常能干，他在布道台上的口才很感动人，就象他在午餐席上的打趣同样使人解颐一样。他称许艾略特对教会的虔诚布施，喜欢艾略特那样和气和艾略特招待他的好酒好菜；两个人成了好朋友。所以，艾略特很可以自鸣得意，说他在这两个世界里都混得不错，而且如果按照我的大胆说法，在上帝和魔鬼之间摆得很平。\n艾略特对自己的房子甚为得意，急于想让自己的姐姐看见；他总觉得布太太对他的称许里面带有保留味道，很想让她看看自己现在生活起居的派头，看看和他交好的那些朋友。这是对她的保留的最具体回答。她将没法不承认他渴得很好。他写信给布太太邀他和格雷和伊莎贝儿一同来，不是住在他家里，因为家里没有地方，而是作为他的客人住在附近的“角上旅馆”。布太太回信说，她已经过了旅行年龄，因为健康欠佳，想想还是待在家里的好；反正格雷在芝加哥也脱不了身；生意很发达，他赚了很多的钱，非得待下去不可。艾略特跟姐姐感情很深，这封信使他慌张起来。他写信问伊莎贝儿。伊莎贝儿回了一个电报，说母亲身体虽然很不好，每星期得卧床一天，但目前还没有危险，老实说，如果当心一点，说不定还会活上好多年；可是，格雷倒需要休息，而且有他父亲在芝加哥照应着，他大可以出来度一个假期；今年不行了，明年她和格雷将来欧洲一行。\n一九二九年十月二十三日，纽约的证券市场崩溃了。\n五 # 我当时在伦敦；开头我们在英国的人并不意识到情形会那么严重，也不懂得它的后果是那样地不可收拾。拿我自己来说，虽然对损失了相当大的一笔钱感到着恼，但是，损失的大部分是票面利润，等到局势澄清以后，我发现自己的现款并不减少。\n我知道艾略特过去在投机生意上赌得很大，很担心他会跌得眼青鼻肿，可是，一直到我们两个都回到里维埃拉度圣诞节时，我方才看见他。他告诉我，亨利?马图林死了，格雷破产了。\n我对生意经一点不懂，敢说我根据艾略特告诉我的关于这些事情的叙述，读起来有点儿乱。在我看来，他们的公司所以碰上那样大的灾难，一半要怪亨利?马图林的固执，一半要怪格雷的急躁。亨利?马图林开头不相信崩溃的严重性，反而自以为这是纽约掮客的阴谋，想要偷外省掮客的鸡，因此咬紧牙关拿出大笔的钱来支撑市场。他对芝加哥的掮客们听任自己被纽约那些环蛋吓得屁滚尿流，非常生气。\n他的那些小户头，有固定收入的寡妇，退休的军官等等，过去听他的忠告，从来没有损失过一个铜板，这件事他一直引以自豪，现在为了不使他们受到损失，就自己掏腰包来弥补他们的空头账。他说，他准备破产，他可以重新挣一笔家财，但是，如果让那些信任他的人变成赤脚，他就永远抬不起头来做人。他自以为慷慨豪爽；其实是狂妄。他的巨大家财溶化掉了，一天晚上，他发了心脏病。他已经六十多岁，而且一直工作过度，玩乐过度，饮食过度；经过几个钟点的痛苦，他就因冠状动脉血栓形成死掉了。\n剩下格雷一个人对付这个局面。他额外做了大量的投机，但是，没有他父亲的知识，自己陷入极大的困难。他要摆脱困境的努力失败了，银行不肯给他贷款；交易所里老一辈的人告诉他，唯一的办法就是宣告失败。”余下的事情我也不大清楚。\n好象他没法偿还自己的债务，因此宣告破产；他自己的房子早已抵押出去，乐得把房子交给受押户；他父亲在湖滨道的房子和在麻汾的房子都三文不值二文卖掉；伊莎贝儿卖掉自己的首饰；他们唯一剩下的财产是在南卡罗来纳州的农场，这是过户在伊莎贝儿名下的，可是找不到买主。格雷赤脚了。\n“你怎么样，艾略特？”我问。\n“噢，我毫无怨言，”他轻松地回答。“上帝对弱者是仁慈的。”\n我没有再问下去，因为他的经济情况与我无关，可是，不管他遭受什么损失，想来和我们一样都吃了苦的。\n不景气对里维埃拉的打击，开头并不严重。听说有两三个人的损失很大，许多别墅冬天都没有开放，有几所挂起牌子出售。旅馆住不满，蒙特卡洛的赌场埋怨今年冬天的生意清淡。一直到两年之后，里维埃拉才感受到这次飓风的影响。这时候，一个地产商告诉我，从土伦到意大利边界的地中海沿岸，大大小小总有四万八千处房地产要出售。赌场的股票跌得很低。大旅馆减价，想多吸引一些顾客，但是没有收效。唯一看得见的外国人是那些一直都穷得不能再穷的人，他们没有花钱是因为无钱可花。开店的全都大失所望。但是，艾略特并不象许多人那样，既不辞退他的佣人，也不减少他们的工资。他继续用好酒好菜招待那些王公贵族，还买了一辆崭新的大汽车，是从美国进口的，为这辆汽车付了很大一笔关税。主教组织的给失业家庭施舍饭菜的善举，艾略特都慷慨捐款。事实上，他生活得就好象从来没有发生过危机，而且东半球并没有被危机冲得立足不定似的。\n我碰巧发现这里的原因：艾略特现在除掉一年一度去伦敦两个星期做衣服外，已经不去英国了，但是他仍旧每年秋天带着佣人去巴黎在自己的公寓里住三个月，还有五月和六月，因为在这个时期艾略特的那些朋友不上里维埃拉来。他喜欢里维埃拉的夏天，一部分是由于有海水浴，但是，我觉得主要是因为炎热使他有机会穿上五颜六色的衣服来纵容一下自己，而这是他为了体统逼得一直避免的。这时候，他会穿上颜色鲜艳的裤子，红的，蓝的，绿的或者黄的，同时穿上色调相反的汗衫；紫红的，淡紫的，紫褐色的或者杂色的，并且接受人们对这套装束所要求的恭维，嘴边露出一点鄙薄的神情，就象一个女演员听见人家说她扮演一个新角色时演得非常成功一样。\n那年春天我在遣返弗拉特角途中，在巴黎待了一天，邀艾略特和我一同吃午饭。\n我们在里茨饭店的酒吧间碰头。这地方已经不再挤满了美国来的寻乐子的大学生，而是象一个戏剧家在一出不成功的戏第一晚上演后那样受到冷落。我们喝了一杯鸡尾酒——这个大西洋对岸传来的习惯，艾略特终于向它妥协了——就叫午饭。吃完午饭，他建议一同去逛逛古玩店；虽则我告诉他我没有钱花在古玩上，但仍旧很高兴陪他去。我们步行穿过旺多姆广场，他问我可介意跟他到夏费服装店去一下；他在那家店里定做了一点衣服，想问问做好没有。看来他好象定做了几件汗衫和一些衬裤，并且把自己姓名的缩写字母绣在上面。汗衫还没有做好，可是社裤好了，店员问他要不要看。\n“看看吧，”他说，就在店员去拿衬裤的同时，他接着又向我说了一句，“我叫他们给我定制了我自己的图案。”\n衬裤拿来了，和我时常在麦西服装店买的一个样子，只不过是绸子的，但是，引起我注意的是在那个e．t．[注]两个交错的字母上面是一个男爵的冠饰。我没有言语。\n“很好，很好，”艾略特说。“等汗衫做好，一同给我送去。”\n我们离开铺子；艾略特走开时，带着微笑向我说。\n“你注意到那个冠饰吗？告诉你老实话，我拉你上夏费来时，已经忘记掉这件事情。我记得我还没有机会告诉你，教皇陛下给我恢复了我的古老家族头衔。”\n“你的什么？”我问，客气中带有骇异。\n艾略特不以为然的神气把眉毛抬了一下。\n“你不知道吗？我在母系方面是德?劳里亚男爵的后代，他是随从菲力普二世到英国来，并且娶了玛丽王后的一个贵嫔。”\n“我们的老朋友嗜杀的玛丽吗？”\n“我认为这是相信异端的人叫她的，”艾略特回答，口气很不自然。“恐怕我没有告诉过你，一九二九年九月我是在罗马过的。我觉得去罗马是件头痛的事，因为罗马在这时候当然没有什么人，可是，幸亏我的责任感超过我追求世俗享乐的欲望。我在梵蒂冈的朋友告诉我，经济大崩溃就要来到，坚决劝我把所有的美国股票全卖掉。天主教会拥有两千年之久的智慧，所以我毫不迟疑。我打电报给亨利?马图林把我所有的股票卖掉，买进金子，我并且打电报给路易莎叫她照做。亨利?马图林回电问我是不是疯了，并且说除非我用电报再发出我的指示，他决不卖出。我立刻回电给他，口气极其坚决，叫他立即照办，并在办好后打电报告诉我。可怜的路易莎没有听我的话，因此吃了苦头。”\n“原来大崩溃来时，你坐得很舒服呢。”\n“这是我们美国语言，我看你还是尽量不用的好，可是，这句话用来形容我的情形倒非常恰当。我一点没有损失；事实上，我还捞了一点你会叫作的油水。过了一个时期以后，我只花了很少一点钱就把原来卖掉的那些股票全买回来了；由于这一切只能形容为上帝的直接干预，我觉得我也应当做点事情来报答上帝。”\n“噢，那么，你是怎样报答的呢？”\n“嗯，你知道领袖[注]在庞廷尼沼地收回了大片的土地，他们告诉我，说教皇陛下对那边的居民缺少一个做礼拜的地方甚感焦灼。因此别的不多说了，我就造了一座小小的罗马风格的教堂，和我在普罗旺斯看到的一座一式一样。教堂造得非常道地，我自己要说，简直是个宝。它是献给圣马丁的，因为我的运气很好，刚好被我买到了一扇有关圣马丁事迹的古染色玻璃窗，上面的圣马丁正把他的袍子一剖为二，把半边袍子给了一个赤身露体的乞丐；由于这里的象征非常恰当，所以我买了下来，装在高祭坛上面。”\n我没有打断艾略特的话，问他在圣马丁的著名行动和他的行动之间有什么相似之处，因为他不过靠了及时卖掉股票赚了一笔钱，现在把些铜子角票剔了出来酬谢上帝，就象给代理人佣金似的。不过，对我这样的俗人来说，象征手法时常是隐晦的。艾略特又继续说：“当我有幸把这张照片呈献给教皇看时，他很夸奖，说他一眼就看出我是个很有眼光的人，并且说，他很高兴在这个世风日下的时代能碰到一个既忠于教会，又具有这样难得的艺术修养的人。这是一次难忘的经验，老兄，难忘的经验。但这以后不久，当教会通知我，教皇很高兴赐给我一个爵位，我比谁都感到诧异。作为一个美国公民，我觉得不用这个头衔要谦虚些，当然除非在梵蒂冈，那是非用不可的。\n我而且禁止我的约瑟夫称呼我‘男爵先生’，我相信你也会尊重我对你的信任。我不想把这件事情声张出去。但是，我不愿意使教皇觉得我不珍贵他给我的这项荣誉，所以我把冠饰绣在我个人的衬衣上，这完全是出于对他的尊敬。我不妨告诉你，我对于把我的头衔藏在美国公民的文静内衣上面，感到一种谦虚的骄傲。”\n我们分手了。艾略特告诉我，他将于六月底到里维埃拉来。他没有来得了。他刚刚准备好把佣人从巴黎转过来，自己坐着汽车逍逍闹闹开着，俾能在到达时各事都已就绪，就在这时，他接到伊莎贝儿的电报，说她母亲突然病重。艾略特，如我以前说过的，不但跟姐姐要好，而且家族观念很强。他从瑟堡搭第一条船出发，从纽约到了芝加哥。他写信告诉我，布太太病得很厉害，瘦得使他见了吓了一跳。她可能活上几个星期，甚至几个月，可是不管怎样，他觉得自己有个痛苦的责任给她送终。他说，芝加哥的高温比他预计的容易忍受得多，但是，缺乏象样的交际括动他只是勉强容忍，原因是在这种时刻他反正没有心思参加。他说，他看到自己国人对经济萧条的反应，感到失望；他原来指望他们对这场灾祸更看得开些。再没有比勇敢忍受别人的灾难更容易的了；鉴于这一点，我觉得，艾略特既然有生以来从没有象现在这样富有过，恐怕根本没有资格对别人要求这样严。最后，他请我带信给他的几个朋友，并且请我务必记着向所有碰见的人解释，为什么他的房子今年夏天没有开放。\n这以后不到一个月，我又接到他的信，告诉我布太太死了。信写得很诚恳动人。\n我早就认为尽管他为人势利，而且有许多荒唐做作的地方，他还是一个好心的、多情的和诚实的人；如果不是这样，我就决计想不到他会表现得这样得体、真实和单纯。信中告诉我，布太太身后的情况看来相当没有头绪。她的大儿子是个外交官，现在由于驻日大使离任，正在东京担任代办，当然无法离开职守。二儿子谈波登在我初认识布家时，原在菲律宾群岛，后来已调回华盛顿，并在国务院担任要职。他在母亲病危时，曾经带着妻子来到芝加哥，但是，安葬之后，非得立刻回首都不可。\n由于这些情形，艾略特觉得自己只得留在美国把事情料理好。布太太把财产乎均分给三个孩子，可是，看上去，她在一九二九年经济大崩溃时，损失不轻。所幸他们在麻沙的农场找到了一个买主。艾略特在信中把农场说成是亲爱的路易莎的乡间住宅。\n他写道，“一个人家弄到要卖掉自己祖传的房子，总是伤心的，不过，近年来，我看见我的许多英国朋友逼得这样做的太多了，所以，我觉得我的两个外甥和伊莎贝儿必须以同样的勇气和淡泊接受这种不可避免的后果。noblesse oblige！[注]他们也很幸运能处理掉布太太在芝加哥的房子。原来早就有人打算把布太太住了一幢的那排房屋拆掉，改建一座大公寓，但是，布太太非常顽固，坚决要死在自己住的房子里，所以，这个计划始终没有实现。布太太一断气，立刻就有掮客跑来出了一笔价钱，布家立刻就接受了。可是，尽管如此，伊莎贝儿还是不够开销。\n大崩溃之后，格雷曾经设法找工作，即使在那些顶过风暴的掮客的写字间里当个职员也行，可是，总不成功。他找他的老朋友们要点事情做，不管地位多小，也不管薪金多么低，但是没有用。过去他企图避兔那场最后使他冲家的灾难时，曾经作过疯狂的挣扎；再加上焦虑的压力，以及后来的屈辱，他的神经终于崩溃了。他开始患一种剧烈的头痛病，整整二十四小时之内一点不能动弹。头痛停止以后，人就象块湿抹布一样垮了。伊莎贝儿觉得只有带着他和孩子到南卡罗来纳州那边农场上去住，等格雷健康恢复再说。这个农场当初靠出产的大米，一年就可以有十万元进项，但是，多年来只是一片沼泽地和橡树林的荒野，只对喜欢打野鸭的人有用，找不到一个买主。他们从大崩溃之后就住在那边，现在仍旧打算回去，等国内情形好转，格雷能找到职业时再作计较。\n“我不许他们这样做，”艾略特在信上写道，“怎么，他们就象猪猡一样生活着，伊莎贝儿没有一个女佣人；孩子没有家庭教师，只有两个黑种女人照顾她们。\n所以，我把巴黎的公寓让给他们住，等到这个荒唐国家的情形改变之后再说。我要给他们弄几个佣人，事实上，我厨房里的女佣人菜就烧得不错。我预备把她留给他们，我可以另外找个人代替她，这并不难。我预备由我来负担全部开销，伊莎贝儿的那一点点收入让她买点衣服，或者用在家庭的小乐味上。这当然意味着我的大部分时间要在里维埃拉过掉，因此，老兄，我希望能够比过去和你更多地见面。照伦敦和巴黎现在这种情形，老实说，我住在里维埃拉要习惯得多。这是惟一我能碰见讲我自己语言的人的地方。我要说，我有时还会上巴黎去住上几天，不过就是去巴黎，我也毫不在乎在里茨饭店挤一下。我很高兴我总算使格雷和伊莎贝儿接受了我的要求，现在只等把必要的事情料理好，就带他们来。家具和油画（很蹩脚，老兄，而且真伪难辨）再下个星期可以拍卖掉。目前，由于我觉得在老房子里住到最后一刻会使他们伤心，所以把他们带到德莱克饭店来跟我住在一起。等我们到了巴黎之后，把他们安顿好，我再来里维埃拉。别忘记替我向你的皇家邻居问好。”\n谁能够否认艾略特这个最大的势利鬼，也是最仁慈、最体贴、最慷慨的人呢！\n第四章 # 一 # 艾略特把马图林一家安顿在左岸自己那所宽大的公寓里之后，就在年尾回里维埃拉去了。他这幢房子是为了适应自己的方便而设计的，容纳不下一个四口之家，所以，即使他自己愿意，也没法留他们和自己住在一起。我想他对此并不难受。他完全意识到人家请客，一个人要比总是伴随着一个外甥女和外甥女婿受欢迎得多；而他自己的那些出色的小宴会（他在这件事情上往往煞费苦心），如果每次家里非要有两个人参加不可的话，那是无法安排的。\n“对他们来说，在巴黎定居下来，习惯一下文明生活，只有好。还有，两个女孩子年龄也不小，该上学了，我而且打听到离我的公寓不远，有一所学校敢说是很上等的。”\n由于这个原因，我直到次年春天方才见到伊莎贝儿。那时候，我由于某项工作需要，得在巴黎呆上好几个星期，所以在离旺多姆广场不远的一家旅馆租了两间房间。这家旅馆我是常住的，不但因为方便，还因为它有一种情调。那是一所大房子围着一个大院落，被人开设为旅店将近二百年了。浴室根本谈不上讲究，抽水马桶更不能使人满意；卧室里都是铁床，漆成白色，那些老式的白床罩和有镜子的巨大衣橱，式样都很寒伧；但是，起坐室里的家具却是古色古香。长沙发和圈椅都是拿破仑第三时代的那种华而不实的货色，不过，尽管谈不上舒适，看上去却还花花绿绿，很好看。坐在这间屋子里，人仿佛生活在法国那些伟大的小说家时代似的。我望着玻璃罩子里的帝国式时钟，就会想到一个头发梳成小发卷，穿荷叶边衣裳的美丽女子，当初说不定在一面望着时钟的长针，一面等候着拉斯第耶克登门拜访；这个拉斯第耶克就是巴尔扎克在小说里写的那个向上爬成性的人。巴尔扎克一部小说接一部小说从他的微贱出身开始一直写到他最后的荣华富贵，把他的一生都包括进去了。还有比安松医生对巴尔扎克是那样真实的一个人物，以至于巴尔扎克临死时还说，“只有比安松医生能够救我”；说不定当年他也会走进这间房间，替一位阔寡妇按脉搏、看舌头；这位阔寡妇是从外省来到巴黎找律师商议一件诉讼案子，生了点小毛小病而请医生的。在那张写字台前，可能坐着一个穿撑裙的钟情女子，头发对中分开，在那里给她的负心情人写一封热情的信，也可能坐着一个性情暴躁的老头儿，穿一件绿礼服大衣，围一条硬领巾，在字斟句酌地写一封愤怒的信给他挥霍无度的儿子。\n我到达的第二天，就打电话给伊莎贝儿，问她如果我五点钟来，能不能请我喝杯茶。我和她已经十年不见。一个脸色庄重的管家把我领进客厅时，她正在看一本法国小说，立刻站起身，握着我的双手，热情而妩媚地微笑，向我问好。我和她过去见面顶多不过十一二次，而且只有两次单独在一起，可是，她使我立刻觉得我们是老朋友，而不是泛泛之交。过去的十年，已经缩小一个年轻女子和一个中年男子之间的鸿沟，我不再觉得我们的年龄是那样悬殊了。她以一个见过世面女子的不露痕迹的奉承对待我，好象我和她的年龄相仿，所以不到五分钟，我们就谈得很体己，很没有拘束起来，就象我们从小就在一起玩，经常见面，从没有间断过似的。她已经学会了一种随便，落落大方和泰然自若的派头。\n可是，使我最感吃惊的是她外貌的变化。我记忆中的她是一个美丽的、肌肉丰满的女子，使人担心她会发胖。我不知道她是否意识到这一点而采取了勇敢措施来减轻自己的体重，还是生育孩子偶然碰上了一个可喜后果；不管怎样说，总之她现在的身材非常苗条，可以说完全合乎理想。眼前的服装风气又突出了这一点。她穿了一身黑；我一眼看出她的绸衣服既不太朴素，也不太华丽，是在巴黎一家最讲究的服装店定制的，而她穿在身上却是那样满不在乎，那样若无其事，犹如她天生就是应当穿考究衣服的。十年前，尽管有艾略特替她出主意，她的衣服总有点不够文静，而且穿在身上老是不十分自如。现在玛丽?路易丝?德?弗洛里蒙可不能再说她不帅了。她从头到脚一直到涂成桃红色的指甲尖都帅。她变得更加清秀了。我还发觉她的鼻梁是我看见的女子中长得最直、最美的。不论在前额上或者在她淡褐色的眼睛下面，都看不见一丝皱纹，而且皮肤虽则不象少女时期那样光彩焕发，但是仍旧非常细腻；所以能这样，不用说是和使用化妆品以及面部按摩分不开的，但是这一来却使她的皮肤显得滋润光滑，简直动人。修削的双颊淡淡抹点胭脂，唇膏也不涂得太浓。浓栗色的头发按照当时的风尚剪得很短，并且烫过。手上没有戴戒指，我想起艾略特告诉过我，她把首饰都卖掉了；一双手，虽则特别小，但是长得很好。\n在那些年代里，女人白天衣服都穿得很短，我能看见她着淡黄长丝袜的腿很美，又长，又瘦削。许多漂亮女子就坏在腿长得不够好看。伊莎贝儿的腿，在她当闺女时，本来是使人最看不上眼的，现在却变得异常好看了。事实上，过去她吸引人是靠健康活泼和精神饱满，现在却由一个漂亮女孩子变为一个美妇人了。至于她的美貌有多少靠的是艺术、锻炼和皮肉吃苦，似乎是无所谓的。总之，结果是极端令人满意就行了。很可能她这种绰约风姿和娴雅举止，着实花了一番苦心，但是看上去却非常自然。我有个想法，觉得她在巴黎住的这四个月，给她多年来惨淡经营的这件艺术品进行了一次最后的加工。艾略特，即便拿出他最苛刻的条件来衡量，也不得不赞许她；我本来不是一个难以取悦的人，当然被她迷住了。\n格雷上毛特芳丹打高尔夫去了，可是，伊莎贝儿告诉我，他马上就会回来。\n“而且你得看看我的两个女儿。她们上杜伊勒里公园去玩，可是，快回家了。\n孩子们很可爱。”\n我们东拉西扯地谈。她喜欢巴黎的生活，而且住在艾略特的公寓里很舒服。艾略特在离开他们之前，曾经把他认为他们会喜欢的一些朋友介绍给他们，所以他们现在已经有一批人过从得很开心了。艾略特总是逼着他们象他过去惯常做的那样，广为交际。\n“你知道，我们生活得就象阔人一样，而事实上，我们是穷光蛋。想到这里，我真好笑死了。”\n“真弄到这样糟吗？”\n她咯咯笑了，这使我想起十年前我觉得非常可爱的那种轻松愉快的笑。\n“格雷是一文不名；我的收入几乎完全同拉里要和我结婚而我不肯的时候拉里的收入相等；那时候，我觉得我们没法子靠这点钱生活下去，而现在我又多了两个孩子。相当可笑，是不是？”\n“我很高兴你认为这件事情可笑。”\n“你知道拉里的情况吗？”\n“我吗？没有。在你上一次离开巴黎之前，我就没有看见过他。他熟悉的人里面，有几个我还算认识，而且的确问过他们拉里的情况，不过，那是多年以前的事了。没有人知道一点点他的情形。他就这么不见了。”\n“我们认识芝加哥拉里有存款的那家银行的经理；他告诉我们，他偶尔会收到拉里从什么怪地方开来的一张支票。中国啊，缅甸啊，印度啊。他好象在到处跑。”\n我毫不踟蹰地把到了嘴边的一句话问了出来。说到底，你如果想知道一点什么的话，最好的办法就是问。\n“你现在可想到早该和他结婚吗？”\n她眯眯地笑了。\n“我跟格雷结婚很幸福。他是一个好得不能再好的丈夫。你知道，一直到大崩溃到来之前，我们都过得开心之至。我们喜欢同一样的人，而且喜欢做同一样的事。\n他待我真好。有人对你倾倒备至总是好受的事；而且他现在爱我就如同我们刚结婚时一样。他觉得我是世界上最了不起的女子。你无法想象他多么的温柔和体贴。在穿的、戴的、用的方面，他大方得简直到了荒唐的程度；你晓得，他认为没有什么我不配享受的。我们结婚这么多年，他从来没有对我讲过一句不体贴或者严厉的话。\n我真是太幸运了。”\n我肚子里想，她是不是认为这就是回答了我的问题。我换了话题。\n“谈谈你的两个小女儿。”\n我说话时，门铃响了。\n“她们来了。你自己看吧。”\n不一会，两个孩子就进来了，后面跟着保姆。伊莎贝儿先给我介绍大的一个，琼，然后介绍小的，普丽西拉。每个人和我握手时都略为蹬一下，表示礼貌。她们一个八岁，一个六岁，个子都不算矮；伊莎贝儿当然是高的，格雷我记得是个大块头；不过两个孩子也只是象一般儿童那样好看。她们看上去很孱弱；长了父亲的黑头发，母亲的淡栗色眼睛；在生人面前并不害羞，都兴冲冲地告诉母亲在公园里做的事情。她们的眼睛盯上伊莎贝儿的厨师为吃茶准备的精美糕点，不过，我们还没有动过。当她们母亲准许每个人挑一块吃时，两个人在选择哪一块上都显得有点为难起来。看见她们对自己母亲表现的那种明显感情很好受；三个人扯在一起形成一幅很动人的图画。当她们吃完自己选择的那块糕点之后，伊莎贝儿便打发她们走，两个孩子没有吭一声就出去了。我的印象是，伊莎贝儿把孩子教育得很听话。\n孩子们走后，我讲了些对孩子母亲通常讲的话，伊莎贝儿听了我那些恭维话显然很高兴，但是，有点儿不放在心上。我问她格雷可喜欢巴黎。\n“相当喜欢。艾略特舅舅留下一辆汽车给我们，所以他几乎能够每天都去打高尔夫球；他并且加入了旅行家俱乐部，在那边打桥牌。当然，艾略特舅舅让出这所公寓把我们养起来，是雪中送炭。格雷人完全垮了，而且现在仍旧发那种可怕的头痛病。他现在即使谋到一个职位，也干不了；这当然使他很着急。他要工作，觉得自己应当工作，想到不能工作使他感到低人一等。你知道，他认为做一个男人就应当工作；如果不能工作，那还不如死掉的好。他不能容忍自己成为一个多余的人；我只是解劝他，说休息和换一下环境会使他恢复正常，才把他拉到巴黎来的。可是，我知道，生活不上轨道他是不会快乐的。”\n“恐怕在过去这两年多时间里，你们的日子可够受的。”\n“嗯，你知道，崩溃才开始时，我简直相信不了。说是我们会垮掉，我认为是不可想象的事。我能够理解到别的人会垮掉，但是，说我们会垮掉——哼，那简直是不可能的事。我一直认为，到了最后，总会来点什么运气之类使我们得救。后来，打击终于落到了我们头上，我觉得没法再活下去，觉得简直没法正视未来的日子，太黑暗了。有两个星期，我简直不是人受的；天哪，什么都得放弃掉，知道以后再没有什么欢乐可言，一切我喜欢做的事情都没有我的份儿，真是可怕——后来两个星期过去了，我说：‘唉，滚他妈的，我决计不再去想它了，’告诉你真话，我从此就没有想过。我一点点都不懊恼，当时我是得乐且乐，现在完了，就完了罢。”\n“摆明的，住在上等住宅区的一座豪华公寓里，有一个能干的管家，一个菜烧得很好的厨师，不要自己花一个钱，还可以给自己的瘦骨头穿上夏内尔定制的衣服，破产的痛苦是容易忍受的，是不是？”\n“不是夏内尔，是朗万，”她吃吃笑了。“我看出你十年来没有怎么变。你这个鬼灵精，想来是不会相信我的话的，不过我接受艾略特舅舅的好意是为了格雷和两个孩子，这一点我倒是有把握的。靠了我每年的两千八百块的收入，我们在农场上可以过得很好，我们会种稻子、黑麦、玉米和养猪。说到底，我是生在伊利诺斯的一个农场并且在那边长大的。”\n“也不妨这样讲，”我微笑说，明知道她实际上是出生在纽约的一家高级妇产科医院里的。\n这时候格雷走进来了。十二年前，我确实只和他见过两三面，可是，我看见过他的结婚照片（艾略特把照片装上漂亮的镜架，和瑞典国王、西班牙王后、德?吉斯公爵签名的那些照片一同放在钢琴上面），他的样子我记得很清楚。见面时，我吓了一跳。他的鬓角秃得很厉害。头上还有一小块秃顶，脸养得肥肥的，红红的，重下巴。多年来讲究酒食的结果使他的体重大大增加，只是由于个儿高大，才使他不至于成为一个十足的胖子。可是，最引起我注意的是，他那双眼睛的神情。我完全记得当初他前途无量，一点不用操心的时候，一双深蓝色眼睛里的那种无忧无虑的坦率；如今我好象在这双眼睛里看见一种无名的沮丧，而且即使我不知道事情经过，恐怕我也不难猜到是什么意外事故摧毁了他对自己以及对世界秩序的信心。我觉得他有一种自卑感，就象做了坏事，虽则不是出于有意，但是感到羞愧。很明显，他垮了。他很有礼貌地欣然向我问好，而且的确象老朋友见面时一样，显得很高兴，但是，我的印象却是他的这种开心样子只是做惯的一套，嘴里嚷的和内心的感受毫无共同之处。\n佣人送来了酒，他给我们调了鸡尾酒。他打了两轮高尔夫球，自己觉得很满意；谈他碰到一只难进的洞时他是怎样解决的，讲得相当噜苏仔细，伊莎贝儿好象听得津津有味。过了几分钟后，我和他们约好一个日子吃晚饭和看戏，就告辞了。\n二 # 我逐渐养成一个习惯，每天下午做完一天工作之后，就去看望伊莎贝儿，一个星期总有三四次。这时候，她大都一个人在家，很高兴有人来聊天。艾略特给她介绍的那些人，比她的年纪要大得多，我而且发现她很少有什么和她年纪相仿的朋友。\n我自己的朋友在晚饭之前大都很忙，我而且觉得与其去我的俱乐部，和那些并不怎样欢迎外人插进来的没好气的法国人打桥牌，还不如跟伊莎贝儿聊聊好受些。她那种把我当作和她年纪相当的人的妩媚派头，使得我们谈起话来很随便；我们相互笑谑，欢笑，打趣，有时候谈我们自己，有时候谈我们共同的朋友，有时候谈书，谈画，所以时间很开心就消磨掉了。我生性有个缺点：对不好看的相貌永远看不惯；一个朋友的性格不管多么善良，即使多年来时常过从，也不能使我看见他的环牙齿或者歪鼻子感到顺眼；另一方面，我对朋友的标致相貌却永远感到喜欢，而且尽管交往了二十年之久，我对于长得象样的额头或者线条柔和的颧骨仍旧喜欢看。因此，我每次看见伊莎贝儿时，对她那张完美的椭圆脸型，凝脂似的皮肤，栗色眼睛里的明快神情，总会重新感到一点心旷神怡。\n后来发生了一件意想不到的事。\n三 # 在所有大城市里，总存在着许多自给自足的集团，相互不通音问；它们是一个大世界里的许多小世界，各各过着自己的生活，只有成员和成员之间交往过从；每个小世界是一个孤岛，中间隔着无法通航的海峡。根据我的经验，没有一个城市比巴黎更加是这样了。在巴黎，上流社会很少让外界人进得去的；政客们把自己局限在他们生活糜烂的圈子里；大大小小的资产阶级相互来往；作家和作家聚集在一起（在安德烈?纪德[注]的日记里，有一点很突出：他好象除掉那些跟他从事一样职业的人以外，很少和什么人接近的），画家和画家亲近，音乐家和音乐家交游。伦敦也是同样情形，不过不是那么显著；在伦敦，同一类的人不大聚集在一起，而且有这么十几家人家的宴会席上，你可以同时碰见一个公爵夫人，一个女演员，一个画家，一个议员，一个律师，一个服装设计师和一个作家。\n我在生活上的遭遇，使我在不同的时间里，在巴黎差不多所有这些小世界里都呆过一个短暂时间，甚至圣日尔曼大街那个关闭社会（通过艾略特）也进去过；但是，我最喜欢的是以蒙帕纳司大街为干线的那个小社会，比起以现在叫做福煦大道为中心的那个甄别很严的小圈子，比起常去拉吕饭店和巴黎咖啡馆的那一批不管国别的人士，比起蒙马特尔区那群喧闹而破烂的寻欢作乐的人来，都还要喜欢。在我是个青年时，我曾经在贝尔福狮子咖啡馆附近的一个小公寓里住过一年，公寓在六层楼，从上面可以了望那片公墓[注]，眼界非常开阔。蒙帕纳司在我眼中仍旧具有当初它特有的那种外省乡镇的安静气息。当我经过阴暗而狭窄的奥德萨街时，我会感到一阵惆怅，想起当初我们经常聚餐的那家简陋饭店。我们里面有画家，雕刻家，插图家，除掉阿诺德?班内特[注]偶尔来来外，我是唯一的作家；我们会坐得很晚，兴奋地、荒谬地、愤怒地讨论绘画和文学。现在沿着蒙帕纳司大街走去，看着那些和我当年一样的青年人，并且替自己杜撰些关于他们的故事，对我仍旧是一种乐趣。\n当我没有事情可做时，我就叫一辆汽车去老多姆咖啡店坐坐。它已经不再象当年那样，为放荡不羁的艺术家包下来的集会场所；邻近的小商贩常会上这儿来，而塞纳河对岸的陌生人也会跑来，企图看一看那个已经不复存在的世界。当然，学生们仍旧来这里，还有画家和作家，但多半是外国人；当你坐在咖啡店里听周围的人谈论时，你听到的俄语、西班牙语、德语和英语和你听到的法语一样多。可是，我有个感觉，好象他们谈论的东西跟我们四十年前谈论的东西大致一样，只是他们现在谈的是毕加索而不是马奈[注]，是安德烈?布雷东[注]而不是纪尧姆?阿波利内尔[注]而已。我真向往他们啊。\n我来到巴黎两个星期之后，有一天晚上，坐在多姆咖啡店里；由于露台上人挤，我只得在前排找一张桌子坐下。天气晴暖。悬铃树正要冒叶子，空气中有巴黎所特有的那种闲散、轻松和欢快的情趣。我觉得很平静，不是由于疲乏，而是由于畅快。\n忽然间，有个男子在我面前走过，停下来向我咧开嘴笑，露出一口雪白的牙齿，说声：“哈罗！”我瞠眼望着他。这人又高又瘦，没有戴帽子，乱蓬蓬的深棕色头发，早就应当剪了；上嘴唇和后腮全被浓密的棕色胡须掩盖起来；前额和头颈晒得黑黑的；穿一件破衬衫，没有打领带，一件穿得很旧的棕色上褂，灰色裤子也破烂得不成样子。他象个乞丐，我有十足的把握从来没有见过他。我断定他是那种没出息的人流落在巴黎，存心等他编一套落难的故事，骗我几个法郎去吃顿晚饭和找个地方过夜。他站在我的面前，两手插在口袋里，露出白牙齿，深棕色的眼睛显出好笑的神气。\n“你不记得我了？”他说。\n“我有生以来从没有见过你。”\n我准备给他二十法郎，可是，我不准备放过他胡说什么我们见过。\n“拉里，”他说。\n“老天啊！请坐。”他吃吃笑了，向前走一步，在我桌子的空椅子上坐下。\n“喝杯酒。”我招呼侍役。“你脸上这样胡子拉碴的，怎能指望我认得你呢？”\n侍役来了，他要了橘子水。现在我再看看他。想起他眼睛的那种特别神情是由于虹膜和瞳孔的颜色一样黑，使眼睛看上去既强烈又没有光彩。\n“你在巴黎呆多久了？”我问。\n“一个月。”\n“预备呆下去吗？”\n“住一个时候。”\n当我问这些问题时，脑子里却不停地盘算。我注意到他的裤脚管已经毛了，上褂靠肘腕那儿也有些洞。他的样子和我过去在东方那些港口碰见的贫民一样寒伧。\n在那些日子里，人们是很容易联想到不景气的，所以我盘算是不是一九二九年的经济大崩溃使他变得赤贫了。想到这里，我很不好受，可是，我向来不喜欢兜三绕四的，所以就开门见山问他：“你是不是没法子混了？”\n“没有，我很好，你怎么会想到这上面？”\n“哦，你看上去好象三天没有吃饭的样子，而且你穿的衣服只配扔到垃圾箱里。”\n“有这么糟吗？我从来没有想到过。事实是我本来打算置办些零碎东西，不过，我好象从来就没有能兑过现。”\n我觉得他害臊或者放不下架子，但是，我认为犯不着容忍他这一套胡说。\n“别傻了，拉里。我不是个富翁，但是，我也不穷。如果你缺少钱用的话，让我借几千法郎给你。不会搞垮我的。”\n他哈哈大笑。\n“多谢，不过，我并不缺少钱用。我的钱尽够我花的了。”\n“大崩溃之后还是这样吗？”\n“哦，大崩溃并不影响我。我所有的钱都买了政府公债。我不知道这些是不是跌价了。我从来没有打听过。只知道山姆大叔[注]仍象往常一样规矩，继续付利息。\n事实上，过去几年中我的用度极小，所以手里的现钱一直很可观呢。”\n“那么，你是从哪里来的呢？”\n“印度。”\n“哦，我是听说你去过那里。伊莎贝儿告诉我的。她显然认识你在芝加哥的银行的经理。”\n“伊莎贝儿？你是几时看见她的？”\n“昨天。”\n“她难不成在巴黎吗？”\n“她的确在巴黎。就住在艾略特?谈波登的公寓里。”\n“这太有意思了。我真愿意看看她。”\n当我们这样交谈时，我虽则相当留神观察他的眼睛，可是，除掉通常的诧异和高兴之外，并没有察觉出什么更加复杂的心情。\n“格雷也住在那里，你知道他们结婚了。”\n“是啊，鲍勃大叔——纳尔逊医生，我的保护人——写信告诉我的，可是他几年前死了。”\n我想起这可能是他和芝加哥以及他在芝加哥那些朋友之间的唯一联系，现在这条线断了，他很可能对这几年发生的事情毫无所知。我告诉他，伊莎贝儿生了两个女儿，亨利?马图林和路易莎?布雷德利都死了；告诉他格雷完全破产和艾略特的慷慨行为。\n“艾略特也在巴黎吗？”\n“不在。”\n四十年来，艾略特第一次不在巴黎过春天。尽管样子看上去还年轻，他已经是七十岁的人了。人上了这样年纪，总有些时候感到疲倦和不舒适。他除掉散步外，别的锻炼逐渐都放弃掉。他对自己的健康很不放心，他的医生一个星期来看他两次，在两边屁股上轮流打针，皮下注射一种当时流行的针剂。每次吃饭，不论在家里或者在外面，他总要从口袋里掏出个小金盒子，取出一粒药片吞下去，就象履行宗教仪式一样郑重其事。他的医生劝他去蒙特卡地尼疗养，那是意大利北部的一个水疗场；这以后他建议去威尼斯寻找一个制作适合放在他的罗马式教堂里的圣水盘。他对巴黎的兴趣已经大不如前了，原因是他觉得巴黎的社交生活一年不如一年。他不喜欢年纪大的人，而且非常痛恨人家请客时碰见的都是和他一样年纪的人，但是，年轻人他又觉得语言无味。装修他建造的这座教堂现在成了他生活中主要的兴趣；在这上面，他可以放开手买，以满足自己对艺术品的那种根深蒂固的热爱，同时感到心安理得，觉得是在颂扬上帝。他曾经在罗马物色到一座蜜黄色石头砌的早期祭坛，并在佛罗伦萨花了六个月时间的讨价还价，买下一块锡耶纳[注]派的三联雕刻放在祭坛上面。\n后来拉里问我格雷喜欢不喜欢巴黎。\n“恐怕他有点不知如何是好的。”\n我试行向他描绘格雷给我的印象。他一面听，一面眼睛紧紧盯着我的脸看，一眨也不眨，象在沉思；这使我觉得——连我也不懂得是什么缘故——他不是用耳朵，而是用一种内在的、更灵敏的器官在听。这很古怪，而且叫人不舒服。\n“不过，你会亲眼看见的，”我讲完时说。\n“是啊，我很愿意去看他们。我想电话簿上会找到他们的住址。”\n“可是，如果你不想把他们吓得灵魂出窍，并且使两个孩子叫得象着魔一样，我想你还是去剪个头，把胡子刮刮。”\n他笑了。\n“我也想到过。没有道理使自己这样刺眼。”\n“既然你这样说，也不妨给自己买一套新衣服。”\n“我想我是有点破烂相。当我快要离开印度时，我发现只剩下身上这一套衣服。”\n他看看我穿的衣服，问我是哪一家裁缝做的。我告诉了他，不过附带告诉他这家铺子在伦敦，所以纵使知道，也派不上多大用场。这个问题丢下之后，我就重新谈起格雷和伊莎贝儿来。\n“我时常和他们见面，”我说。“他们一块儿过得很快乐。我从没有机会单独和格雷谈话过，不过，敢说他反正不会跟我谈到伊莎贝儿。可是，我知道他对她的爱情很专。他静下来时，脸色相当难看，眼睛里带有一种迷惘，可是，当他看见伊莎贝儿时，就会显出一种温柔恩爱的神情，相当感动人。我有个想法，在他们出事的那些日子里，她从头到尾都象岩石一样和他站在一起，所以他永远不会忘记她待他的好处。你会发现伊莎贝儿变了。”我没有告诉他，伊莎贝儿从来没有象她现在这样美丽过。他未见得能识别得出当初那个好看的高个儿女孩子，怎样变成这样极端文雅娇艳的女子。有的男人对于艺术给女性美的加工是痛恨的。“她待格雷很好。\n尽了最大的力量帮助他恢复自信。”\n可是，时间已经晏了；我问拉里要不要和我到大街上去一同吃晚饭。\n“不，我不想吃，谢谢，”他答。“我得走了。”\n他站起身，很和气地点个头，三脚两步到了人行道上。\n四 # 第二天，我看见格雷和伊莎贝儿，就告诉他们我碰见拉里。他们和我昨天一样感到出乎意料。\n“看见他太好了，”伊莎贝儿说。“让我们立刻去看他。”\n我这才想起自己忘记问他住在哪里。伊莎贝儿把我狠狠收拾一顿。\n“我即使问他，恐怕他也不会告诉我，”我一面笑，一面抗议说。“这很可能跟我的潜意识有关系。你可记得他从来不喜欢告诉人他住在哪里。这是他的怪解之一。他随时都可以走进来。”\n“这倒象他的为人，”格雷说。“便是在过去，你也拿不准会在你指望的地方找到他。他今天在这儿，明天就不见了。你明明看见他在房间里，过会儿想要过去招呼他一下，可是，你转过身去时，他已经失踪了。”\n“他一直是个顶叫人恼火的家伙，”伊莎贝儿说。“这是无法否认的。看来我们只好等他高兴的时候大驾光临了。”\n那天他没有来，第二天也没有来，第三天也没有来。伊莎贝儿硬说是我编出来使他们怄气的。我向她保证没有，并且想出些理由来说明他不来的原因。但是，这些理由不大讲得通。我自己心里盘算，他是不是经过重新考虑，决定不见格雷和伊莎贝儿，并且离开巴黎到什么别的地方游荡去了。我已经觉得他从来不在什么地方扎根，只要有了一条他认为是良好的理由，或者自己一时高兴，他就会随时抬起脚来走掉。\n他终于来了。那是个下雨天，格雷没有去毛特芳丹打球。我们三个人都在一起，伊莎贝儿和我在喝茶，格雷呷着一杯威士忌掺贝里埃[注]；这当儿，管家开了门，拉里踱了进来。伊莎贝儿叫了一声立刻站起来，投人他的怀抱，吻他的两颊。格雷的一张红红胖胖的脸比平时更红了，热烈地拉他的手。\n“嘻，真高兴看见你，拉里，”他说，声音激动得有点咽着。\n伊莎贝儿咬着嘴唇，看出她在硬忍着没有哭出来。\n“喝杯酒，老兄，”格雷摇摇晃晃地说。\n两个人看见这个流浪汉如此地高兴，深深打动了我。拉里看见自己在他们心里这样重，一定很好受，他快乐地笑着。可是，在我看来，他仍然十分冷静。他注意到桌上的茶具。\n“我喝杯茶吧，”他说。\n“嘘嘘，你不想喝茶，”格雷叫出来。“让我们开瓶香槟酒。”\n“我喜欢茶，”拉里微笑说。\n他的镇定对这对夫妇产生了一种可能是他预期的效果。两人都平静下来，但是，仍旧带着喜悦的眼光望着他。我这话并不意味着说他以冷冰冰的僵硬态度来回答人家的由衷热情；相反，他显得非常之有礼貌和可爱；不过从他的眉宇之间可以觉察到一种只能称之为超然的派头，而且弄不懂这代表什么。\n“你为什么不立刻来看我们，你这个鬼？”伊莎贝儿叫，假装生气。“这五天来，我一直在张望窗子外面，看你来了没有，而且每次门铃响，我的心都要跳到嘴里来，要费很大的劲才能咽得下去。”\n拉里吃吃笑了。\n“毛姆先生告诉我，我的样子太野蛮了，你们的佣人不会放我进门的。我飞往伦敦去买点衣服。”\n“你用不着上伦敦去买，”我笑着说。“你可以在春光百货公司或者美丽园买一套现成的。”\n“我想果真要做衣服的话，那还是做得象样些。我有十年没有买西方服装了。\n我上你的裁缝店去，说我要在三天之内做一套衣服。他说要两个星期，因此折衷下来改为四天。我是一小时前从伦敦回来的。”\n他穿了一套藏青哗叽衣服，和他的瘦长身材非常相称，一件白衬衫，配上软领子，打一条蓝领带，脚上穿一双黄皮鞋。头发已经剪短，脸上胡子都已剃光。他看上去不但整洁，而且头发梳得很光；简直是变了一个人；由于长得很瘦，颧骨显得更加突出，庭穴更凹进去，深陷在眼窝里的那双眼睛比我记得的还要大些；尽管如此，外表还很漂亮；说实在话，那张晒得黑黑的、没有一丝皱纹的脸使他看上去异常年轻。他比格雷小一岁，两人都是三十开外的人，可是，格雷看上去要老十岁，而拉里则要年轻十年。格雷由于身材高大，动作迟缓而且比较滞重，拉里的动作则是轻快随便。拉里的神情象个孩子，又快活又高兴，可是，同时带有一种宁静，使我特别感觉到，并且和我过去认识的这个青年有所不同。谈话一直就没有停，这在老朋友之间是很自然的事，因为许许多多记忆都是共同的；格雷和伊莎贝儿还插进些芝加哥的新闻，都是些零星花絮，从一件事勾起另一件事，引起轻盈的笑声。当他们这样谈笑时，我一直有一个印象，就是拉里虽则笑得很开朗，而且听着伊莎贝儿那样随便拉呱表现出明显的喜悦，但是，有一种很特别的洒脱派头。我不觉得他在做假，他非常自然，决不会做假，而且他的诚恳是一望而知的；我只觉得他内心里有一种东西，不知道叫它知觉，还是感性，还是力量，使他始终说不上来地有点落落寡合。\n两个女孩子被保姆带了进来，和拉里见过，并且有礼貌地行一下屈膝礼。拉里伸出手来，柔和的眼睛带着动人的慈祥神气望着她们；孩子们握着他的手，一本正经地睁眼望着他。伊莎贝儿兴孜孜地告诉拉里，她们的功课都很不错，给了她们每人一片小饼饼，就打发她们走了。\n“你们睡觉时，我来给你们念十分钟故事书。”\n她不愿意在这时候打扰她看见拉里的快乐。女孩子去向父亲道晚安。看见这个大块头搂着孩子吻她们时一张红脸上显露出来的爱，确很动人。谁也看得出他对她们非常钟爱，非常得意；当她们走后，他转向拉里，唇边显出一种甜蜜的微笑说：“两个孩子不错吧？”\n伊莎贝儿亲热地瞟他一眼。\n“我要是听任格雷不管，他就会把她们惯坏了。这个大坏蛋，他会把我饿得个要死，而用鱼子酱和肝酱去喂两个孩子。”\n他微笑望着她说：“你说谎，而且知道你在说谎。我是崇拜得你五体投地的。”\n伊莎贝儿的眼睛里也露出笑意，算是回答。这一点她知道，而且很高兴。真是一对幸福的夫妇。\n她坚决要我们留下吃晚饭。我想他们大约愿意单独和拉里在一起，就推说有事，但是，伊莎贝儿决计不听。\n“我去告诉玛丽在汤里多放一根胡萝卜，就够四个人吃的了。有只小鸡，你和格雷可以吃腿，我和拉里吃翅膀；她的奶蛋酥总可以做得够我们四个人吃的。”\n格雷好象也要我留下；我本来不想走，就服从他们的劝阻。\n在等待晚饭时，伊莎贝儿又把他们的遭遇详细讲了一遍，就是我简单告诉拉里的。虽则她叙述自己的悲惨遭遇时尽量讲得轻松，格雷绷着个脸显得很不好受。她设法使他高兴一点。\n“反正现在全过去了。我们摔了交，但是，我们还有前途。等情形好一点，格雷将会谋得一件好事，发笔大财。”\n鸡尾酒送进来，两杯酒下肚，使这个可怜人儿的兴致好一点起来。我看见拉里虽然拿了一杯酒，但是，简直没有碰；格雷没有注意到，给他再来一杯时，他拒绝了。我们洗了手，坐下来吃晚饭。格雷关照人开一瓶香槟酒，可是管家给拉里倒酒时，他告诉管家他不喝酒。\n“唉，可是你非喝一点不可，”伊莎贝儿叫。“这是艾略特舅舅最好的酒，他只在招待特客时才开呢。”\n“告诉你老实话，我还是欢喜喝水。在东方呆了这么些年，能够喝到干净的水已经是福分了。”\n“这是庆祝。”\n“好吧，我喝一杯。”\n晚饭烧得很好，可是，伊莎贝儿注意到，我也注意到，拉里吃得很少。大约她忽然想起一直是自己在谈话，而拉里除掉洗耳恭听外，简直没有机会说什么，所以，现在开始问拉里自从上次见面以后，这十年来做了些什么。他回答得很诚恳坦率，但是，含糊其辞，等于没有告诉我们什么。\n“噢，我在晃膀子，你知道。我在德国呆了一年，在西班牙和意大利呆了些年。\n在东方胡乱跑了一阵。”\n“你刚从哪里来？”\n“从印度。”。\n“你在印度多久？”\n“五年。”\n“玩得好吗？”格雷问。“打到老虎没有？”\n“没有，”拉里笑了。\n“你于了些什么，要在印度呆上五年呢？”伊莎贝儿说。\n“到处玩，”他答，忍俊不禁的样子。\n“那个绳子戏法[注]是怎么回事？”格雷问。“你看见过没有？”\n“没有，没看见。”\n“你看见什么呢？”\n“很多的事情。”\n我这才向他提出一个问题。\n“据说瑜伽师[注]具有我们认为的神奇能力，是真的吗？”\n“我弄不清楚。我只能告诉你，印度一般都这样认为。但是，最有智慧的人并不把这些能力看得怎样了不起；他们觉得只会妨碍修真。我记得他们里面有一个人告诉我，有个瑜伽师来到河边，没有渡河钱，摆渡的船夫不肯白白带他，于是他就走到河上，踏着水面到达对岸。告诉我这件事的瑜伽师，相当鄙夷地耸耸肩膀说，‘这样的奇迹只抵得上一个渡河钱的价值。’”\n“可是，你认为瑜伽师真的能在水上行走吗？”格雷问。\n“告诉我的那个瑜伽师摆明是相信的。”\n听着拉里讲话，使人觉得很好受，因为他的声音非常之悦耳，清脆，圆润而不深沉，有种特殊的抑扬顿挫。吃完晚饭，大家回客厅喝咖啡。我从来没有到过印度，急于想多知道一点。\n“你跟作家和思想家有过接触吗？”我问。\n“我看你把他们当作两种不同的人，“伊莎贝儿取笑我说。\n“我有心要去接触他们，”拉里回答。\n“你怎样同他们交谈的呢？用英语吗？”\n“他们里面最有意思的人，即使会说英语，也说得不大好，理解就更差了。我学了兴都斯坦语。后来去南方，又学了不少泰米尔语，所以相当混得下去。”\n“拉里，你现在懂得几国语言？”\n“噢，我也不知道。半打左右吧。”\n“我还想多了解一点瑜伽师的情形，”伊莎贝儿说。“你跟他们里面的人可有搞得很熟的？”\n“熟得不能再熟了，”他微笑说。“我在一个瑜伽师的亚西拉马住了两年。”\n“两年？亚西拉马是什么？”\n“啊，我想你不妨称它做隐居的地方。有些圣徒总是单独生活，或是在庙里，或是在林子里，或者在喜马拉雅山的山坡上。另外有些瑜伽师吸引了一些门徒。有些乐善好施的人为了积功德，对某一个瑜伽师的虔诚深怀景仰，就为他造一间房子住；房子有大有小，那些门徒就跟着他住，或者住在阳台上，或者住在厨房，如果有厨房的话，或者住在树底下。我在这处丛林有一间小房子，刚好放得下我的行军床、桌椅和书架。’“这地方在哪儿？”我问。\n“在特拉凡哥尔，那是一处美丽的乡野，青绿的山谷，缓缓的河流。山上有老虎、豹子、象和野牛，可是，那个亚西拉马是在环礁湖上，周围长着椰子树和摈榔树。它离开最邻近的城镇也有三四英里远，但是，人们常常从那边或更远的地方徒步或者坐着牛车来听这位瑜伽师讲道；那是在他高兴讲的时候；他不讲道时，就坐在他的脚下，在晚香玉的氤氲空气中，共同享受从他的道行所散发出来的宁静和安乐气氛。”\n格雷在椅子上不安地扭动着。我猜想谈话的内容使他感到不大好受了。\n“来杯酒吗？”他问我。\n“不要，多谢。”\n“那么，我来一杯。你怎么样，伊莎贝儿？”\n他挪动自己沉重的身体从椅子上起来，走到放威士忌和贝里埃及酒杯的台子前面。\n“那儿有别的白人吗？”\n“没有，我是唯一的一个。”\n“你怎么能呆得了两年之久呢？”伊莎贝儿叫。\n“那就象一转眼似的。我过去的有些日子过得好象比这两年的时间长得多呢。”\n“这两年你干些什么？”\n“读书。散步，散很长的步。坐一条船在环礁湖上游。冥思。冥思非常之吃力；两三个小时之后，你就象赶了五百英里路的马车一样精疲力尽，以后只想休息，什么事都不想干。”\n伊莎贝儿眉头微微皱一下。她弄得迷惑了，敢说她有一点儿害怕。可能她开始感觉到这个几小时前走进屋子里来的拉里，虽则外表上没有变，而且和以前一样开朗和亲热，但是，和她过去认识的那个拉里，那个非常坦率、平易、和蔼，执拗不听她的话但是讨人喜欢的拉里已经不是一个人了。她曾经失掉他，现在重新见面，她认为他还是旧日的拉里，不管经过世情变化，他仍旧是她的；现在呢，她好象在把一道日光抓在手里，而日光却从她握紧的手指间漏掉了；这使她感到有点迷惑不解。那天晚上，我总是在看她，这在我是一件赏心乐事；我看出她的眼光落到拉里那修剪得很整齐的头上，两只小耳朵贴着脑壳时，眼中有股喜悦的神情，而当她注意到他深陷的庭穴和瘦削的双颊时，眼睛的神情又是怎样变化的。她望望他的一双又长又瘦的手，尽管看上去憔悴，仍旧强壮有力。后来她的眼睛又盯着他那富于表情的嘴看，嘴形长得很好，丰满但没有肉感；盯着他开阔的额头和端正的鼻子看。\n他的那一套新衣服穿在身上不象艾略特那样风度翩翩，可是，自如落堂，就好象穿了有一年，而且天天穿，日日穿似的。他好象引起了伊莎贝儿的一种母性本能，而这种本能是我在伊莎贝儿和她的女儿中间不曾见到的。她是个有经验的女人；而他看上去还只是个男孩子；我从她的神情仿佛察觉到一种母性的骄傲，因为自己的成年孩子能够侃侃而谈，而且别人也都在听，觉得他的话有道理。我不相信拉里那些话的涵义能打中她的心坎。\n可是，我的话还没有问完。\n“你的瑜伽师是什么样子？”\n“你指外表，是不是？怎么说呢，他个子不高，人不瘦，也不胖，暗棕色皮肤，胡须剃得光光，白发剪得很整齐。身上除掉一件围腰布外，什么也不穿，然而能够使人看上去和布罗克司兄弟公司广告上的男人一样穿着整齐。”\n“那么，他有什么地方使你特别看中的呢？”\n拉里凝神看着我整整有一分钟方才回答。他陷在深窝里的那双眼睛象在企图钻进我的灵魂深处。\n“圣徒气息。”\n他的回答使我微微感到不安。在这间陈设着精美家具、墙上挂着名画的房间里，这句话就象浴缸漫出的水从天花板上漏下来，卜笃的一声。\n“我们全都读到过圣徒。圣佛兰西斯啊，十字架的圣约翰啊，但是，这都是几百年前的事了。我从来没有想到过会在今天碰见一个活的圣徒。从我第一次看见他，我就毫不怀疑他是个圣徒。这是个了不起的经验。”\n“你得到的又是什么呢？”\n“宁静，”他随口回答，淡淡地一笑。然后突然站了起来说，“我得走了。”\n“唉，等等，拉里，”伊莎贝儿叫。“时间还早呢。”\n“晚安，”他说，一面仍旧笑着，毫不理会她的央求。他吻了一下她的秀颊。”\n我一两天内再来看你们。”\n“你住在哪里？我来看你。”\n“哦，别找这些麻烦了。你知道在巴黎打一个电话多么困难，而且我们的电话常常出毛病。”\n我看见拉里这样不落痕迹地拒绝把住址告诉人，肚子里好笑。这是他的一个怪癖，总是瞒住自己的住址。我建议后天晚上请他们全体在波隆花园吃饭。在这样令人心醉的春天，露天坐在树下面吃饭，确是快意之至，而且格雷可以用他的小轿车开我们去。我同拉里一同离开，本来很愿意跟他走一段路，可是，一走到街上，他就和我拉拉手，大踏步走了。我坐上出租汽车。\n五 # 我们约好在公寓里碰头，先喝杯鸡尾酒，然后出发。我在拉里之前到达。我约他们去的是一家很讲究的餐馆，总以为伊莎贝儿会穿上盛装；有那么多的女人全穿得花枝招展的，肯定她不愿意比不过人家。可是，她只穿了一件素静的羊毛上衣。\n“格雷又发头痛病了，”她说。“他人非常难过。我不能丢下他。我告诉过厨娘，给孩子们吃了晚饭之后，就可以走了，所以我得亲自给格雷烧点吃的，并且劝他吃下去。你还是和拉里单独去吧。”\n“格雷睡在床上吗？”\n“没有，他发头痛时，从来不肯躺在床上。天知道，他最好是睡下来，可是他不肯。他在书房里。”\n这是一间有棕色和金色护壁板的小屋子，护壁是艾略特从一座古堡里弄来的。\n书籍都有镀金格子护着，并且加上锁，以防止人们翻阅；也许这样做倒好，因为这些书大部分是十八世纪的有插图的淫书；不过，用现代摩洛哥皮面装订起来，看上去倒着实漂亮。伊莎贝儿把我带进书房。格雷躬着身子坐在一张大皮椅子里，旁边地板上散着画报。他闭着眼睛，往日的那张红脸现出死灰色，显然人非常痛苦。他打算站起来，但是，我拦住了他。\n“你给他吃阿司匹灵没有？”我问伊莎贝儿。\n“阿司匹灵毫不抵用。我有个美国配方，但是，吃了也不见效。”\n“唉；别管我了，亲爱的，”格雷说。“明天我就会好了。”他勉强一笑。\n“很对不起，做了你们的包袱。”他向我说。“你们全去波隆花园。”\n“谈也不要谈，”伊莎贝儿说。“你想我会玩得开心吗，一面知道你被这个鬼病折磨着？”\n“这个魔鬼，我想他爱上我了，”格雷说，把眼睛闭上。\n接着他的脸突然抽搐起来，你几乎可以觉出他头里面那种痛如刀割的滋味。门轻轻开了，拉里走了进来。伊莎贝儿把情形告诉他。\n“真糟糕，”他说，同情的样子看了格雷一眼。“有什么办法能够使他好过一点呢？”\n“没有，”格雷说，眼睛仍旧闭着。“你们能够做的事情就是别管我，每一个人；离开这儿，自己去寻乐儿。”。\n我心想，这其实是唯一合理的办法，不过，伊莎贝儿恐怕良心上过不去。\n“让我来看看能不能帮助你一下，”拉里说。\n“谁也帮助不了我，”格雷有气无力地说。“这个病简直要我的命，有时候我真盼老天这样做。”\n“我说也许能够帮助你一下，是我说错了。我的意思是也许我能够帮助你帮助一下自己。”\n格雷慢慢睁开眼睛，看着拉里。\n“你怎样帮助呢？”\n拉里从口袋里掏出个象银币似的东西，把来放在格雷手里。\n“用手紧紧勒住，手掌朝下。不要抗拒我。不要用劲，只是把银币勒在手里。\n在我数到二十以前，你的手就会张开，银币就会落在地上。”\n格雷照他说的做了。拉里坐在写字台那儿，开始数起来。伊莎贝儿和我始终站着。一，二，三，四。数到十五时，格雷的手并没有动，后来好象抖了一下，我有个印象，简直说不上是看见，好象那些勒住的手指在松开。大拇指离开拳头。我清清楚楚看见手指在颤动。当拉里数到十九时，银币从格雷的手里掉下来，滚到我的脚边。我拾起来看看。银币很重，而且形状不整齐，一面生动地刻了一个年轻的头像，我认出是亚力山大大帝。格雷茫然望着自已的手。\n“我没有让银币落下去，”格雷说。“是它自己落下去的。”\n他坐在皮椅子里，右臂搁在椅子靠手上。\n“你坐在这椅子上舒服吗？”拉里问。\n“我头痛得不可开交时，只有坐在这里最舒服。”\n“那么，你人完全松下来。不要紧张。不要做什么。不要抗拒。在我数到二十以前，你的右手将要从椅子靠手上抬起来，一直到把手举过头。一，二，三，四。\n他用自己银铃似的抑扬声调数着那些数目；当他数到九时，我们看见格雷的手从搁手的皮面上抬了起来，起先只是勉强看得见，然后高到大约有一英寸光景。有这么一会又停止下来。\n“十，十一，十二。”\n手震动了一下，接着是整个胳臂开始向上移动。胳臂不再搁在椅子上了。伊莎贝儿有点吓，抓着我的手。情形真是古怪。一点不象自愿的动作。我从来没有见过人梦游过，但是，可以想象梦游的人走动起来就象格雷的手臂动作一样古怪。看上去就象本人的意志并不是动力。想来通过自觉的努力把手臂抬得这样慢以及动作这样匀称，是非常困难的。它给人的印象是，有一种心灵不能控制的潜意识力量在抬起这只胳臂；动作就象活塞在汽缸里非常缓慢地上上下下。\n“十五，十六，十七。”\n数目字说得很慢，很慢，很慢，就象洗脸盆的水龙头出毛病滴水一样。格雷的胳臂抬着，抬着，一直到手举过头为止。当拉里说完最后一个数字时，胳臂自动地落回到椅子靠手上。\n“我没有把胳臂举起来，”格雷说。“只是没法阻止它这样抬起来。是它自己抬起来的。”\n拉里淡淡一笑。\n“没有关系。我觉得这样说不定会使你对我产生信心。那块希腊银币呢？”\n我把银币给他。\n“把它抓在你手里。”格雷把银币拿过来。拉里看着表。“现在是八点十三分。\n在六十秒钟之内，你的眼皮将会变得重起来，使你不得不闭上眼睛，然后你就会睡去。你将要睡六分钟。八点二十分时，你会醒来并且不再感到头痛了。”\n伊莎贝儿和我都不说话，眼睛看着拉里。拉里也没有再说什么；眼睛直盯着格雷，但是眼光好象不在看他，而象是透过他，越过他看出去。出现在我们中间的沉寂，给人以一种阴森的感觉，就象夜色降临时园中花丛里那种沉寂一样。突然间，我觉得伊莎贝儿抓着我的手紧起来。我张一下格雷。他的眼睛已经闭上，呼吸通畅均匀；人睡着了。我们站在那里的一段时间就象没完没了似的。我渴想抽支烟，但是不想点。拉里一动不动，眼睛注视着渺茫的远方。除掉眼睛还睁着外，他可以说是处在一种木然块然状态。忽然间，他好象松了下来z眼睛重又是往常的那种神情。\n他看看表。当他看表时，格雷的眼睛睁开了。\n“噢唷，”他说，“我敢说我睡觉了。”接着他一惊。我注意到他脸上的那种惨白完全消失。“我的头不痛了。”\n“很好，”拉里说。“抽一支烟，然后我们一起出去吃晚饭。”\n“这是个奇迹。我觉得人好极了。你怎样做的？”\n“我没有做。你自己做的。”\n伊莎贝儿去换衣服，我和格雷则喝着鸡尾酒。尽管拉里摆明不想再提，格雷却坚决要谈适才发生的一切。他一点弄不明白是怎么一回事。\n“你知道，我根本不相信你会有什么办法，”他说。“我听你摆布只是因为我懒得跟你辩。”\n他接着形容自己发病时的情形，受到的折磨，以及头痛过去后人就象垮掉一样。\n他简直弄不懂怎么刚才醒来时，人会跟平时一样精力充沛。伊莎贝儿回来了；穿的一件衣服是我从前没有见过的；衣服一直拖到地，大约是用一种叫马罗坎的极薄的白平纹绸做的，外镶一圈黑纱边。我不由而然觉得她会为我们争光。\n马德里宫堡[注]那天特别热闹，我们都兴高采烈。拉里杂七条八谈些逗趣的话——我从来没有听见他这样谈过——使我们全都笑了。我感到他这样做的用意，是使我们不要再去想他适才显示了自己的非凡能力。但是，伊莎贝儿是个意志坚强的女子。不碍她的事时，她可以顺着你滚，可是，她满足自己好奇心的打算决不放弃。\n吃完晚饭，大家喝着咖啡和甜酒，伊莎贝儿大约认为一顿好饭和那杯葡萄酒以及亲密的谈话，已经削弱了拉里的防范，就把一双亮晶晶的眼睛盯着他看。\n“现在告诉我们你是怎样治好格雷的。”\n“你自己不是看见了，”他微笑着说。\n“你是在印度学会这套玩意儿的吗？”\n“是的。”\n“他被病魔折腾得很苦。你认为可以使他断根吗？”\n“我不知道。也许能够。”\n“这会使他的整个生活变样子。象他现在这样一来就病倒四十八小时，怎么能担任正正经经的工作。而他除非又有了工作，是决不会开心的。”\n“你知道，我是做不出奇迹的。”\n“可是你做的就是奇迹。我亲眼见来。”\n“不，这不是奇迹。我只是使格雷脑子里有一种想法，余下的都是他自己做的。”\n他转向格雷。“明天你做什么？”\n“打高尔夫。”\n“我六点钟来，我们一起谈谈。”接着，向伊莎贝儿眯眯一笑：“伊莎贝儿，我有十年没有跟你跳舞了。你要不要试一下我行不行。”\n六 # 这事以后，我们就时常和拉里碰面。接下去的一个星期，他每天都到公寓来，和格雷单独关在书房里半个小时。看来他是要劝说格雷——如他自己笑着说的——摆脱掉那种使他振作不起来的忧郁心理，而格雷则是孩子气地对他极端信任。从格雷那些零零星星谈话里，我觉察到拉里同时也在设法使格雷恢复对自己的信心。大约在十天以后，格雷的头痛又发作了，碰巧拉里要到傍晚才来。这次的头痛并不太厉害，可是，格雷现在对拉里的异常能力已经充满信心，认为只要找得到拉里，他就能在几分钟内治好他的头痛。可是，他们不知道他的住址z伊莎贝儿打电话问我，我也不知道。等到拉里终于来了，并且治好格雷的头痛后，格雷就问他住在哪里，以便紧急时立刻可以找到他。拉里笑笑。\n“打电话给美国旅行社，留一个口信。我每天早上打电话给他们。”\n伊莎贝儿后来问我为什么拉里要把住址保密。他从前就是这样，后来发现他住在拉丁区一个三等旅馆里，并没有什么不可告人的地完“我一点不懂得，”我回答说。“我只能提出些想入非非的理由，可能完全是捕风捉影。也许他的某种古怪本能迫使他把自己精神的一些隐秘部分转移到他的栖息之所。”\n“你这是他妈的什么意思？”她相当恼火地问。\n“你可注意到他和我们在一起时，尽管那样平易近人，和和气气，但是，总有种超然物外的味儿，就好象他并不把自己全部公开出来，而是把某些东西保留在自己的灵魂深处。是什么使他脱离我们呢？一种拉力？一个秘密？一种向往？某种知识？我也不知道。”\n“我从小就认识拉里，”伊莎贝儿不耐烦地说。\n“有时候，我觉得他就象个伟大的演员，在一出蹩脚戏里把一个角色演得无懈可击，就象爱琳娜?杜丝[注]在《女店主》[注]那样。”\n伊莎贝儿听了沉吟一下。\n“我想我懂得你的意思。大家玩得很开心，而且觉得他是我们里面的一员，犹如别的人一样，可是，突然间，你觉得他就象你想要抓在手里的烟圈一样逃脱你的掌握。你说是什么使他变得这样古怪呢？”\n“也许很稀淡平常，所以人们简直觉察不到。”\n“比方说？”\n“例如，人好。”\n伊莎贝儿眉头皱起来。\n“我希望你不要这样说。使人听了怪不是滋味的。”\n“还是心灵深处有那一点点苦痛呢？”\n伊莎贝儿盯着我看了好长一会，象在考虑我在想些什么。她从旁边桌上取一支香烟，点起来，靠在椅背上；望着烟袅袅升到空中。\n“你要我走吗？”我问。\n“不。”\n我半晌不开口，尽看着她，欣赏着她俊俏的鼻子和下巴的优柔线条。\n“你是不是非常之爱拉里？”\n“你这个狗蛋，我有生以来从来没有爱过别的人。”\n“那你为什么嫁给格雷呢？”\n“我总得嫁人。格雷疯狂地追我，妈也要我嫁给他。人人都说我和拉里解约很对。我很欢喜格雷；我现在仍旧喜欢他。你不知道他多么的可爱。世界上没有人能够象他这样更温和更体贴的了。他看上去好象脾气很大，是不是？可是，他对我永远那样温柔。他有钱的时候，总要叫我欢喜这个，欢喜那个，这样他就可以给我买来，并且自己觉得好受。有一次，我说，如果我们能有只帆船周游世界多么好，倘若不是因为经济大崩溃，他就会买来。”\n“他听上去太好了，有点叫人信不过似的，”我说。\n“我们曾经生活得非常美满。在这方面，我将永远感激他。他使我过得非常幸福。”\n我看看她，没有开口。\n“我想我并不真正爱他，可是，一个人没有爱满可以过得下去。在我的内心深处，我渴想的是拉里，可是，只要不和他见面，这并不真正打扰我。你可记得你跟我说过，只要隔开三千英里的大洋，爱情的痛苦就变得可以忍受了？我当时觉得这是一句极端带有讽刺意味的话，但是，话当然是对的。”\n“如果你看见拉里感到痛苦，那么，不和他见面，你说是不是更聪明些呢？”\n“可是这种痛苦是天堂啊！再者，你知道他是怎样的人。随便哪一天，他都会象太阳落山后的影子一下子消失掉，而且多年和他见不到面。”\n“你从来没有想到和格雷离婚吗？”\n“我没有理由要和他离婚。”\n“没有理由并不能阻止你们国家的女人要和她们丈夫离婚。”\n她大笑。\n“你认为她们为什么要离婚呢？”\n“你不知道？因为美国女人指望她们的丈夫十全十美，就同英国女人指望她们的男管家一样。”\n伊莎贝儿把头傲然向后一甩，我简直认为她要把头颈骨扭断。\n“你看见格雷不那样能说会道，就以为他一无可取吗？”\n“你弄错了，”我赶快打断她。“我觉得他有种动人的地方。人非常之多情。\n只要看看他望着你时的脸，就知道他对你的情感是多么真挚，多么深。他对自己的孩子比你爱得多。”\n“我想你现在要说我是个坏母亲了。”\n“相反，我觉得你是个很好的母亲。你照顾得她们很周到，很快乐；注意她们的饮食，留心她们大便是否正常；教给她们礼貌，读书给她们听，命她们做祈祷；一有毛病立刻就请医生，而且小心服侍她们。但是，你不象格雷那样，全心全意放在她们身上。”\n“本来没有必要这样做。我是个人，我把她们也当作人看待。一个做母亲的把儿女当作自己唯一的生命，只会对儿女有害处。”\n“我认为你很对。”\n“而且她们照样崇拜我。”\n“这一点我也留意到了。她们把你看作是她们理想中的一切，文雅、美丽、高贵。但是，她们和你在一起不象和格雷在一起时那样适意和随便。她们崇拜你，这是事实；但是，她们爱格雷。”\n“他是可爱。”\n我很喜欢她这样说。她的性格中一个顶可爱之处就是对赤裸裸的事实从不恼火。\n“大崩溃之后，格雷完全垮了。有好多个星期，他在写字间里一直工作到深夜。\n我时常在家里坐得胆战心惊；生怕他会自杀，因为他觉得太丢脸了。你知道，那些人过去对公司，对他父亲，对格雷都非常信赖，对他们的正直和判断的正确非常信赖。倒并不完全是因为我们把自己的钱蚀光了，而是因为所有那些信任他的人把钱全蚀光了，使他交代不过去。他觉得自己早就应当看出一点苗头。我没法子说服他认为事情不能怪他。”\n伊莎贝儿从手提包里取出一支口红，涂涂嘴唇。\n“但是，我要告诉你的并不是这个。我们剩下的唯一一块财产就是农场；我觉得格雷的唯一机会就是离开当地，所以我把两个孩子交给妈，和格雷上农场去住。\n农场他是一直喜欢的，但是，从来没有单独去过；过去总是带上一大堆人，玩得非常痛快。格雷的枪法很好，可是，当时没有心思打猎。他过去时常一个人坐一条船，划到沼泽那边，呆上几点钟头，观察野禽。他时常在小河里划来划去，两边是浅灰色的蒲草，头上只看见蓝天。有些日子，那些小河就象地中海一样蓝。他回来总不大肯说，只说妙极了。可是，我能看出他感受很深。我知道他的心被这种美，这种寥廓，这种幽静打动了。在太阳刚要落山之前，沼地上有这么一会儿光线很是迷人。\n他往往站在那里凭眺，心里感到非常受用。他时常骑马到那些孤寂而神秘的林子里跑得老远；那些树林就象梅特林克[注]一出戏剧里的那种树林一样，灰暗、沉寂，简直有点阴森；而且春天有这么一个时候——顶多只有半个月——山茱萸盛开，橡皮树抽叶，嫩绿色的叶子被灰色的西班牙苔藓一衬，就象一首欢乐的歌曲；地上开遍白色的大百合花和野杜鹃，象铺了地毯一样。格雷形容不出自己的感受，但是感受极深。他被妩媚的春光弄得浑陶陶的。啊，我知道我讲得不好，可是我没法告诉你，看见这样一个大块头被这样纯洁、这样美的感受提到这样高的境界，叫人简直要哭出来。如果天上有个上帝的话，那么格雷是非常接近上帝的。”\n伊莎贝儿告诉我这段话时，人有点儿动心，所以掏出一块小手绢，小心地把眼角两边的晶莹眼泪揩掉。\n“你在制造幻想，是不是？”我微笑说。“我觉得你在把你指望格雷具有的思想和情感说成是真事。”\n“如果他没有，我怎么能看到呢？你知道，我是怎样的人。我除非感觉到人行道上脚底下的水泥，和沿街商店大橱窗里有帽子、皮大衣、钻石手镯和镶金的化妆用品盘可看，就不觉得真正快乐。”\n我笑了；有这么一会，双方都没有开口。后来，她回到我们先前谈的话题上来。\n“我决不会和格雷离婚。我们共同经历的事情太多了。而且他是绝对离开不了我的。这使人相当得意，你知道，也使人产生一种责任感。再者…。\n“再者什么？”\n她斜瞥了我一眼，眼睛里闪出一种调皮的神情。我认为，她拿不准我对她打算讲的话抱什么态度。\n“他在床第之间很不错。我们结婚已经有十年，可是他还是和开头一样对我那么热火。你在你的一个剧本里不是说过，一个男子对一个女子不会爱到五年以上的？\n哼，当时你只是胡说八道。格雷就跟我们刚结婚时一样爱我。在这方面，他使我很快乐。不过单看我的样子，你不会想到我是那样的人。我是个很风骚的女人。”\n“你完全错了，我会这样想的。”\n“那么，这并没有什么要不得的地方，对不对？”\n“恰恰相反。”我仔细看了她一眼。“你可懊悔十年前没有和拉里结婚吗？”\n“不。当时如果和他结婚，那简直是发疯。不过，当然喽，当时如果我象现在这样懂得，我就会溜走和他住上三个月，然后，把他从我的生活中排除出去，一了百了。”\n“你没有做这样的试验，恐怕算你的运气；你说不定会发现自己没法摆脱掉他。”\n“我不相信。这不过是一种肉体的诱惑。你知道，克服肉体欲望的最好办法往往就是让它得到满足。”\n“你可曾想到过你是一个占有欲很强的女人？你告诉过我，格雷的情感有深刻的诗意，你又告诉我，他是个热烈的情人；我深信这两者对你都极其重要；但是，你没有告诉我比这两者加在一起还要重要得多的是什么——那就是把他抓在你那美丽但并不太小的手掌心里的感觉。拉里将永远逃脱你的掌握。你可记得济慈[注]的《希腊古瓮颂》？‘大胆的情人，你永远，永远不能吻到，虽则逐渐接近目标。’”\n“你往往自命你懂得的比你知道的多，”她说，话有点尖刻。“一个女子只有一个法子能抓住男人，你而且知道的。让我再告诉你一点：她要抓住男人不在乎第一次和他睡觉，而是看第二次。如果一个女子抓住了一个男人，那么，就此永远抓住他了。”\n“你这话可以说是探骊得珠。”\n“我到处跑，眼睛和耳朵又没有闲住。”\n我有半晌没有开口；心里在盘算。\n过了一会，我说道，“我不知道拉里过去是不是真正爱你。”\n她坐起来；脸色有点变，眼睛含怒。\n“你讲的什么？他当然爱我。你认为一个女孩子碰到有人爱她都不知道吗？”\n“噢，我敢说他在一定程度上是爱你的。他认识的女孩子里没有一个象你这样接近的。你们从小就在一起玩。他指望自己爱你。他有正常的性欲本能。你们应当结婚是非常自然的事情。你们除掉住在一起，睡在一起外，相互的关系并没有任何特殊不同。”\n伊莎贝儿气平了一点下来，等着我继续说下去；我知道女子总是喜欢人谈论爱情，所以接着说道：“道德家总想说服我们，把性的本能和爱情看作是两码子事。他们总倾向于把性说成是一种附带现象。”\n“附带现象，这放的什么屁？”\n“有些心理学家是这样看的，认为意识是伴随脑的活动出现的，并且由脑活动决定，但是意识对脑的活动并不产生任何影响。意识就象水里的树影，离开树不能存在，但是对树丝毫没有影响。有人说，没有热情也可以有爱，我认为是胡说；他们说热情没有了，爱仍旧可以存在，他们指的是另外一种东西，感情，好心，共同的爱好，兴趣，和习惯。特别是习惯。两个人可以由于习惯继续发生性关系，就象到了吃饭的时候肚子觉得饿一样。当然，人可以有欲望而没有爱。欲望并不是热情。\n欲望是性的本能的天然结果，它比人这个动物的其他功能并不更重要些。所以有些做丈夫的在时间地点适合时偶尔放纵一下，他们的妻子那样大惊小怪，实在愚蠢。”\n“这难道专指男人吗？”\n我笑了。\n“你一定要问的话，我得承认对两者都适用。唯一不同的是，对一个男子来说，这种露水关系毫无情感价值，对一个女子来说就不同了。”\n“那要看是什么样的女人。”\n我不预备让她打断我的话。\n“爱没有情欲，就不是爱，而是别的东西；而且情欲并不是由于满足而是由于阻挠变得强烈的。你想济慈告诉他的希腊古瓮上的情人不要难受是什么意思？‘你将永远爱着，而她将永远美好！’为什么？因为她是得不到手的；不管这情人怎么疯狂地追求，她仍旧逃脱他的掌握。原因是他们被拘禁在我所谓的一件无情艺术品的大理石上面。你对拉里的爱，和拉里对你的爱，就和保罗与法郎赛斯加的爱情[注]，和罗米欧与朱丽叶的爱情，一样单纯和自然。所幸是，你们没有碰上一个悲惨的结局。你和一个有钱的人结了婚，拉里则云游世界，想弄清妖女唱的是什么歌[注]。\n情欲在这里没有起过作用。”\n“你怎么知道的？”\n“情欲是不计代价的。巴斯噶[注]说感情有其为理智所不理解的理由。如果他的意思是我设想的那样，那就是指情欲控制着感情的时候，感情就会发明一些不但言之成理的理由，而且可以充分证明世界在爱的面前可以为了爱完全毁掉。它使你相信牺牲荣誉是值得的而蒙耻受辱是便宜事情。情欲是毁灭性的。它毁掉安东尼和克里娥彼特拉[注]，毁掉特雷斯坦和伊苏尔德[注]，毁掉巴奈尔和吉蒂?奥赛[注]。\n如果它不毁掉人，它就死掉。到了那时候，一个人才会废然若失，发现自己虚掷了一生的大部分时间，熬受因妒忌引起的剧烈痛苦，蒙辱含垢，忍气吞声，把自己的全部柔情蜜意，自己灵魂的全部财富，都浪费在对方身上，而对方不过是只破鞋，一个蠢货，是自己制造许多梦想的一个借口，连一块橡皮糖都抵不上。”\n我发挥掉这段议论之前，已经满看出伊莎贝儿并不凝神听我，而是一个人在出神。可是，她下面的一句话却使我出乎意料。\n“你想拉里是处男吗？”\n“亲爱的，他已经三十二岁了。”\n“我肯定他是的。”\n“你怎么会有这样看法？”\n“对这种事情女人天生有一种本能。”\n“我知道有一个年轻人冒充他从来没有和女人睡过觉，把一个个美丽女子都骗了过去，因此混得很不错。他说这就象巫咒一样灵。”\n“你怎样说我也不管。我是靠直觉知道的。”\n天已经快晚了，格雷和伊莎贝儿有朋友约他们吃晚饭，她要换衣服。我无事可做，因此，沿着拉斯拜尔大街一路行来，享受着春天傍晚的愉快气息。我对女人的直觉从来就不大相信；它和她们的主观愿望太适合了，使人对它的可靠性不得不产生怀疑。当我想到和伊莎贝儿的那一大段谈话的末尾，自己不由得笑了出来。这使我想起苏姗?鲁维埃来，我有好几天没有和她见面了。不知道她目前在干些什么。\n如果没有什么事，说不定愿意跟我一起吃晚饭，并且去看个电影。我叫住一辆在街上彷徨的汽车，告诉车夫鲁维埃的公寓地址。\n七 # 我在本书开头时，曾经提到过苏姗?鲁维埃。我认识她已有十一二年；在我现在讲到她的时候，她已是将近四十岁的人。人长得并不美；实际上，可以说相当丑。\n在法国女人里面，个子算是高的，短身体，长胳臂，长腿；动作笨拙，就好象不知道把长长的四肢怎么对付似的。头发的颜色看她的高兴，多数的时间是红褐色。一张小方脸，高高的颧骨胭脂搽得红红的；大嘴，唇膏涂得很厚。所有这些全谈不上动人，但是，偏偏有人看中她。诚然，她皮肤长得很好，还有雪白有力的牙齿，和大而有神的眼睛。这是她相貌最美的部分，所以她把睫毛和眼皮都染黑了，尽量使得眼睛更好看。人看上去既精明而又和善，而且有种随遇而安的派头；性情非常敦厚，也相当地硬挣。就她所过的那种生活来说，她非得硬挣一点不可。母亲嫁了一个政府的小公务员，丈夫死后，回到昂懦原籍那个村子靠抚恤金过活。苏姗十五岁时，被送到邻镇一个服装店里学生意，离家很近，每星期都能回家；十七岁那年，苏姗有两个星期假期，被来到她村子画风景的一个画家勾引上了。苏姗知道得很清楚，自己一个铜子没有，结婚的机会是谈不上的，所以，在夏天快完时，画家建议带她上巴黎去，她欣然答应了。他带她在蒙马特尔区象兔子窝一样全是画室的地段找到一个住处，快快活活过了一年。\n一年后，他告诉她说，自己一张画都没有卖掉，因此没有能力再养活一个情妇。\n她对此早已料及，所以泰然处之。他问她要不要回家去，当她回答说不想回去时，他就告诉她说，另外有个画家愿意要她，就在同一条街上。他提的这个人曾经勾引过她两三次；虽则她顶了他回去，但是，嘻嘻哈哈的，所以并不使他难堪。她对这个人并不讨厌，所以服服帖帖接受这个建议。搬家很方便，连出租汽车都不用叫，就把箱子搬了过去。她的第二个情人比第一个情人年纪大得多，但是仍旧长得很体面，把她各式各样的姿势都画到了，穿衣服的，裸体的。她和他同居了两年，过得很快活。她感到得意的是，他的第一张真正成功的画就是以她当模特儿的；她拿给我看这张画的一张印刷品，是从介绍这张画的一个画报上剪下来的。这张画后来被一家美国画店购去。一张裸体，和活人一样大小，躺的姿势和马奈的《奥林匹司》差不多。画家很快就看出她的身体比例有一种现代情趣，所以把她的瘦削身材画得更加瘦弱，腿和胳臂画得更长，两个高颧骨更为突出，蓝眼睛画得特别大。从复制品里当然看不出用的什么颜色，但是使人感到构图是漂亮的。这张画给他带来一点小名气，从而使他能够娶一个有钱的寡妇，引得人人欣羡。苏姗完全理解一个男人应以自己前途为重，～点没有吵闹，就和他断绝这种亲切关系。\n原来到了这时，她已经认识到自己的价值。她喜欢艺术家的生活，高兴让画家画她，当模特儿；在一天工作之后，上咖啡店去跟画家们、画家的妻子和情妇坐在一起，听他们谈论艺术，咒骂画商，讲些下流故事，她觉得开心。就在这种场合，她看见有机可乘，自己打定好主意。她挑中了一个没有相好女人的年轻画家，而且在她看还有点才气；当画家单独坐在咖啡店时，她就找一个机会明白讲出自己的处境，也不来什么开场白，就建议两个人同居。\n“我二十岁而且很会理家。我会替你省钱，而且省掉你雇用模特儿的钱。你看看你的衬衫，真不象个样子；你的画室简直是一团糟。你需要有个女人照应你。”\n他知道她是个好样的；对她的建议觉得很好玩；她看出他有意思接受。\n“反正试试没有害处，”她说。“万一不行的话，我们至多和现在一样，谁也没有损失。”\n他是个非表现派的画家，给她画像画的全是些方块和长方块；画她只有一只眼睛，没有嘴；把她画成一幅黑、棕、灰色交织的几何图案；画成一大堆杂乱无章的线条，这里面勉强可以看出一张人脸。她和他同居了一年半，后来自动地离开他。\n“为什么？”我问她。“你不喜欢他吗？”\n“我喜欢他，他是个很好的男孩子。我觉得他没有进步。他在重复自己。”\n她毫无困难地又找到一个继承者。她始终忠于画家们。\n“我总是和绘画打交道，”她说。“我和一个雕塑家呆了六个月，可是，不懂得为什么，我始终不能欣赏。”\n她引以为慰的是她和那些情人分开时从没有发生不快过。她不但是个很好的模特儿，也是很好的主妇。她喜欢在自己暂时栖身的画室里工作，把画室收拾得整整齐齐的，并且引以为荣。她的菜烧得很好，能够花很少一点钱烧出很可口的菜来。\n男人的袜子破了，给他补好；衬衫的钮扣掉了，给他钉上。\n”我永远不明白为什么一个人因为是个画家，就不能穿得整整齐齐的。”\n她只失败过一次。这次是同一个年轻的英国人；人比她以前认识的画家都有钱，还有一辆汽车。\n“可是，没有多久就吹了，”她说。“他时常吃醉酒，吃醉酒之后真够烦人。\n如果他是个不坏的画家，我也就不在乎了，可是，亲爱的，他画得简直不堪人目。\n我告诉他我要离开他之后，他哭了起来，说他爱我。\n“‘我可怜的朋友，’我跟他说。‘你爱我不爱我都无关紧要，重要的是你没有才气。你顶好回到本国去开个杂货店。这是你的本份。’”\n“他听了你这番话之后怎么说的？”我问。\n“他火高三丈，叫我滚出去。可是你知道，我跟他讲的全是忠告；真希望他能够采纳。他人并不坏，就是画得太坏了。”\n世情洞达和心地忠厚对于一个风尘中人说来，常会使她的人生历程比较顺利，但是苏姗选的职业也和别的职业一样有它的成功和失败。例如当初那个斯堪的纳维亚人。苏姗很孟浪，竟然爱上了他。\n她告诉我说，“亲爱的，他是个神。个子非常之高，就象爱菲尔铁塔[注]一样，宽肩膀，阔胸脯，腰只有那一点细，只消两只手几乎就可以围过来，肚子是平的，平得和我的手掌一样，肌肉结实得象个职业运动员；头发是金黄色的鬈发，皮肤象蜂蜜一样细腻。画得也不坏。我喜欢他的笔触，有力而且泼辣，色彩用得浓厚鲜明。”\n她拿定主意要和他生个小孩。他反对，可是，苏姗说由她负责来养。\n“孩子生下来时，他相当喜欢。哦，真是个可爱的娃娃，粉红肤色，淡颜色头发，跟父亲一样长了一双蓝眼睛。是个女孩子。”\n苏姗和他同居了三年。\n“他有点愚蠢，有时候使人厌烦，但是他很可爱，而且长得非常之美，所以我并不真正在乎。”\n后来他接到瑞典的一封电报，说他父亲病危，他必须立刻回家。他答应回到巴黎，可是苏姗有个预感，觉得他永远不会回来。他把钱全留给她；走后，一个月听不到他的消息，后来收到他一封信，说他父亲死了，身后有一大堆事情要料理，他认为自己有责任侍奉母亲，并且经营本材生意。信中附了一张一万法郎的支票。苏姗不是那种容易弄得心灰意懒的女人，她很快就打定主意，认为带一个孩子在身边非常碍事，所以把孩子带到乡下，连同那一万法郎，交给她母亲去抚养。\n“这使我很伤心。我非常爱这孩子，可是在生活上，人一定要讲求实际。”\n“后来怎样了？”我问。\n“哦，还不是过下去。我又找到一个朋友。”\n可是，接着她就害了伤寒。她提起来时总是说“我的伤寒”，就象百万富翁会说“我的棕榈滩”或者“我的松鸡泽”一样。她病得几乎死掉，在医院里住了有三个月。出院之后，人只剩皮包骨头，身体弱得风都吹得倒，人动不动就要哭。当时她这个人可以说一点用处没有，做模特儿，身体吃不消，钱也很少。\n“噢拉拉，”她说，“我那些日子真是够受的。所幸是我还有些好朋友。不过，你知道画家都是哪一种人，他们能够混口饭吃，已经是不容易了。我从来就不怎么漂亮，当然姿色还是有一点，但是已经不再是二十岁的小姑娘了。后来我碰到那个和我同居过的立体派画家；自从我们分手之后，他已经结了婚并且离了婚；他并且放弃了立体派，变成超现实派。他觉得可以利用我，并且说他感到寂寞；他只能供给我住宿和吃饭，老实告诉你，我欣然答应了。”\n苏姗和他同居到认识那个工厂主的时候为止。这位工厂主是一个朋友把他带来的，指望他说不定会买下一张这位前立体派画家的画。苏姗急于拉拢这笔交易，竭尽所能地敷衍这位客人。工厂主当场不能决定买还是不买，但是，说他想要再来看一次。两个星期后，他果然来了。这一次，苏姗有个印象，好象他是来看她，而不是为了看画。离开时，他仍旧没有买，但是，和她拉手拉得有点过分亲热。第二天，那个带工厂主上门的朋友趁她上街买小菜时半路上拦着她，告诉她那位工厂主看上了她，问她在他下一次来巴黎时，愿意不愿意和他一起吃晚饭，因为他想向她提出一项建议。\n“你想，他看中了我什么地方？”苏姗问。\n“他是一个近代绘画的业余爱好者。他看见过你的画像。你使他着了迷。他是外省人，而且是个生意人。你在他眼中代表巴黎，艺术，风流韵事，总之，这一切是他在里尔[注]所得不到的。”\n“他有钱吗？”苏姗老老实实地问。\n“很多。”\n“好的，我愿意和他吃晚饭。不妨听听他有些什么话要说。”\n他带她上的马克昔姆饭店，使她觉得他为人还不算小气。那天她衣服穿得很文静，再把周围的那些女人看看，觉得自己很充得过一个上流已婚女子。他叫了一瓶香槟，这一点她也认为是对她的尊重。到了喝咖啡时，他把建议提了出来。她觉得条件很不错。他告诉她，自己经常每隔两个星期都要上巴黎来开一次董事会；晚上总是一个人吃晚饭，如果想找女人的话，就上妓院去；这种生活很腻味。以他这样的地位，结了婚，而且有了两个孩子，这样的生活安排实在不能令人满意。那个他们共同认识的朋友把苏姗的身世全部告诉了他，他认为她是个很懂得分寸的女人。\n他自己已近中年，不想和那些朝三暮四的女孩子牵牵搭搭。他多少又是一个收藏现代绘画的人，而她在这方面的关系使他感到有种同好。接着他就提出具体安排，他准备给她租下一所公寓，全部装修好，包括家具在内，另外每月给她两千法郎。交换条件是，每两个星期能够有一个晚上和她在一起。苏姗有生以来从来没有过这么多钱供她零花过；她很快就计算出有了这笔钱，不但吃的穿的可以和她现在的地位相称，还可以供应自己的女儿，并且积攒一点下来以备不虞。可是她迟疑了一下，原因是她一直自命“在绘画界”里转，现在要做一个生意人的情妇，敢说感到有点降低身份。\n“cest a prendre ou a laisser，”他说。“你可以接受或者不接受。”\n她并不讨厌他，而且他钮孔里挂的玫瑰形勋章，说明他还是个头面人物。她笑了。\n“je prends，”她说。“我接受。”\n八 # 苏姗虽说一直住在蒙马特尔区，可是，她认为有必要和过去的生活割断，因此，在蒙帕纳司大街附近的一幢大房子里租下一所公寓。公寓只有两间房间，一间小厨房，一间浴室；是在六层楼，但是有电梯。对苏姗说来，有浴室和电梯，尽管电梯只容得了两个人，开得象蜗牛爬，下楼还得步行，这一切不但代表舒适，而且有气派。\n在他们结合的头几个月里，亚希尔?戈万先生——这就是他的名字——每隔两个星期来到巴黎时，总是住在旅馆里；晚上和苏姗做完好事以后，仍旧回到旅馆里一个人睡觉，第二天到时候起来，搭火车回去做他的生意，和享受安静的家庭乐趣。\n后来是苏姗向他指出，这种旅馆钱花得毫无道理；为什么不可以在公寓里住到早上，既省钱，人也舒服得多。戈万先生当然觉得这话很有道理。他对苏姗这样体贴自己的生活感到高兴——老实说，在一个寒冷的冬夜跑到街上，找一辆出租汽车，并不是什么愉快的事——而且很赞成她不愿意看见他为自己浪费钱财。一个女人不但自己省钱，还要为自己的情人省钱，确是个好女人。\n亚希尔先生过得十分满意。他们一般都是上蒙帕纳司大街一家比较考究的饭店吃晚饭，但是，有时候，苏姗也在公寓里给他烧一顿晚饭吃。那些菜烧得滋味很好，吃得亚希尔先生很喜欢。天气暖和的一些傍晚，他往往只穿一件衬衫吃晚饭，对这种放浪不羁的生活方式觉得很有味道。他总欢喜买画，可是，苏姗看不上的画决不让他买；不久，他对她的眼光也服帖了。她决不跟掮客们打交道，总是把他带到画家的画室去买，所以花的钱只抵在外面买画的一半。亚希尔先生知道她在积钱；后来苏姗告诉他，自己逐年在本村里买了一点地时，亚希尔先生心里感到一阵得意。\n他懂得在法国人的血液里，每一个人都想要占有土地，所以苏姗也有田地使他对她就更加器重了。\n就苏姗这方面来说，她也很满意。她既不忠于他，也不不忠于他；那就是说，她很注意不同另一个人发生永久关系，可是，如果她碰上一个她中意的人，也并不拒绝同这个人睡觉。但是，决不让他在公寓里过夜，这一点她始终坚守不渝；认为这是她对那位有钱势地位的亚希尔先生应尽的责任，她眼前的这种安定和受人尊敬的生活还不是全亏的他。\n我是在苏姗和一位画家同居时认识她的。这位画家刚巧是我的一个相识；苏姗在画室里让他画时，我时常坐在旁边看。后来偶尔也碰见她，不过不大经常；真正和她关系密切起来，是在她搬到蒙帕纳司之后。当时好象是亚希尔先生——苏姗在背后和当面都是这样称呼他——读了一两本我的小说的法译本，于是，在某天晚上，请我在一家饭馆里和他们一起吃饭。他身个很小，比苏姗矮半个头，铁灰色头发，修得整齐的灰色上须。人偏胖一点，而且是个大肚皮，但是并不过分，只衬出他的有钱派头；走起路来象个矮胖子那样神气十足，显然对自己甚感得意。一顿晚饭请得很讲究；人也有礼貌。他告诉我，他很高兴苏姗有我这样一个朋友；他一眼就能看出我是comme if faut[注]，而且很高兴我看重苏姗。他的事业，唉，总是把他捆在里尔，使得苏姗往往非常之寂寞；想到她能有机会接近一个有教养的人，他感到安慰。他是个生意人，但是，对艺术家一直钦佩。\nah，mon cher monsieur[注]，艺术和文学一直是法兰西的一对掌上明珠。当然，还有它的军事技术。我作为一个毛织品厂商，毫不迟疑地要说，我是把画家、作家和军事家、政治家放在同等地位的。”\n再没有比他这番话讲得更中听了。\n苏姗决不肯雇一个女佣料理家务，一半是为了省钱，一半是因为（她自己知道得最清楚）她不喜欢有人插进她叫做的个人事务中来。那间小公寓被她收拾得干干净净、整整齐齐，而且是按照当时最时新的式样陈设的；所有的内衣都由自己亲手来缝。可是，虽说如此，由于她现在不再充当模特儿了，日子过得有点百无聊赖，可她是个勤劳的女人，不久，她就想起既然过去让那么多的画家画她，为什么不可以自己也画一点；于是，她买了画布、画笔和油彩等等，就动起手来。有时候，我约她出去吃晚饭，去得早一点时，就会看见她穿着罩衫在忙着作画。正如胎儿在子宫里大体上重演物种进化的过程一样，苏姗也重演了她过去所有情人的风格。她画风景就象那个风景画家，画抽象画就象那个立体派画家，还借助一张风景明信片画了一只停泊的帆船，和那个斯堪的纳维亚人画的一样。她不会素描，可是，色彩感还不错，所以即使画得并不怎样好，自己却画得很开心。\n亚希尔先生鼓励她画。想到自己的情妇是个画家，使他感到某种满足。就是在他的敦促之下，苏姗送了一张画去参加秋季沙龙；画挂出来时，两人都非常得意。\n亚希尔先生给了她一条忠告。\n“不要画得象男人一样，亲爱的，”亚希尔先生说。“象个女人那样画。不要着眼于有笔力；只要讨人喜欢就行。而且要诚实。在生意经上，欺骗有时候会得手，但是在艺术上，诚实不但是最上策，也是唯一的策略。[注]”\n在我写到这里时，他们发生关系已经有了五年；而且双方都感到满意。\n“显然他这个人并不使我感动，”苏姗告诉我。“可是，他人聪明，而且有地位。到了我这样年纪，我有必要考虑一下自己的处境才是。”\n她心肠好，而且明白事理；亚希尔先生很尊重她的意见。他和她谈到自己的生意和家庭之间的事务时，她都有滋有味听着。亚希尔先生的女儿一次考试失败，她和他一样难受；亚希尔先生的儿子和一个有钱的女孩子订婚，她和他一样开心。亚希尔先生自己讨的就是一个同行中人的独养女儿；两个厂家原来是对头，这样一合并，对双方都有好处。现在亚希尔先生的儿子能懂得这个道理，认识到幸福的婚姻必须建筑在共同物质利益的基础上，当然使他满意。亚希尔先生还把自己的心事告诉苏姗，说他有个野心想把女儿嫁给一个贵族。\n“为什么不可以，有她那一大笔钱？”苏姗说。\n亚希尔先生替苏姗打通门路，把她自己的女儿送进一所修道院学校，使她能受到好的教育，并且答应等她的女儿到达适当年龄时，由他出钱去学习打字和速记，以便日后靠此谋生。\n“她长大了会是个美人，”苏姗告诉我，“可是受点教育，而且能够敲敲打字机，摆明并没有害处。当然她现在年纪很小，谈什么都太早，也许她会变得没有气质。”\n苏姗没有明说。她让我靠自己的聪明推想她是什么意思。我推想得没有错。\n九 # 一个多星期后，我完全出乎意料地碰见拉里。有天晚上，苏姗和我一同吃晚饭，又去看了电影，后来坐在蒙帕纳司大街的精美咖啡馆喝啤酒；就在这时候，拉里随随便便走了进来。苏姗吃了一惊，而且使我诧异的是喊住了他。拉里走到我们桌子面前，吻了她，并和我握手。我能看出苏姗简直信不过自己的眼睛。\n“我可以坐下吗？”他说。“我还没有吃晚饭，要叫点东西吃。”\n“唉，可是看见你真高兴，我的宝贝，”苏姗说，眼睛里显出光彩。“你从哪里跳出来的？而且这么些年来怎么连个影子都看不见呢？天哪，你真皮啊。我简直当作你已经死了。”\n“可是，我并没有死，”拉里答，眼睛眨着。“奥代特好吗？”\n奥代特是苏姗女儿的名字。\n“啊，她已经长成一个大女孩子了。而且很美。她还记得你。”\n“你从来没有告诉我你认识拉里，”我对苏姗说。\n“为什么要告诉你？我从来不知道你认识他。我们是老朋友了。”\n拉里给自己叫了火腿蛋。苏姗把自己女儿的事情全部告诉他，后来又告诉他关于自己的情况。她一面拉呱，拉里一面蔼然微笑听着。她告诉他，自己已经有了个家，还在作画。她转向我说：“我有了进步，你说是不是？我并不自命是个天才，可是，我的才能和我认识的许多画家比起来并不差。”\n“你卖掉画吗？”拉里问。\n“我不用卖画，”她轻松地回答。“我有私人收入。”\n“好运气。”\n“不，不是运气，是聪明。你一定要来看看我的画。”\n她在一张纸上写下自己住址，并且逼着他答应来。她由于兴奋，滔滔不绝地谈下去。后来拉里叫侍役开帐。\n“你难道要走吗？”她问。\n“我是要走，”拉里微笑说。\n他付掉钱，向我们挥一下手就走了。我大笑起来。他这种派头一直使我觉得很特别，刚才还和你在一起，一转眼间没有一点解释人已经走了，如此突兀，仿佛在空气中消失掉。\n“他为什么这么快就走？”苏姗生气地间。\n“也许有个女孩子在等他，”我带着玩笑回答。\n“这等于废话。”她从手提包里取出粉镜来在脸上扑粉。“哪一个女人爱上了他，算她倒霉，噢啦啦。”\n“你为什么这样说？”\n她有这么一分钟盯着我望，脸色非常严肃，我很少看见她有这样过。\n“我自己有一度几乎爱上了他。这无异于爱上了水里的一个影子，或者一线阳光。或者天上的一块云。我总算是幸免了。便在现在，我一想起当时的险境，还觉得不寒而栗。”\n管他妈的分寸不分寸。只要是人，总想知道这一切是怎么一回事。碰巧苏姗根本就不懂得什么叫守口如瓶。\n“你怎么竟然会认识他？”我问。\n“噢，那是好多年前的事了。六年前，还是七年前，我也记不清楚。奥代特当时只有五岁。他认识马塞尔，那时候，我正和马塞尔同居。他常上马塞尔的画室，坐在那里看马塞尔画我。有时候，他请我们出去吃晚饭。他几时来，你从来没有数。\n有时候，接连好几个星期不来，接着，又会两三天连着来。马塞尔往往喜欢他到画室来，说有他在旁，就画得满意些。后来我就生了我那场伤寒病。我从医院出来之后，日子过得非常之苦。”她耸耸肩膀。“可是，这些我以前已经跟你说过了。总之，有一天，我正兜那些画室，想找个工作做，但是，没有人要我。整整一天我只吃了一杯牛奶和一只油炸面包，而且连房钱都没有着落，就在这时，我在克利希大街上偶然撞见拉里。他停下来，问我近来怎样；我告诉他生了伤寒症的经过，后来，他就跟我说：‘你看上去好象需要好好喂一顿。’他说话的声音和他眼睛里的神情有种地方使我很感动；我哭了起来。\n“我们隔壁就是玛丽埃特大娘饭店，所以，他挽着我的胳臂拉我找一张桌子坐下。我肚子饿极了，连皮靴都吞得下，可是，摊鸡蛋上来时，我觉得一口也吃不下。\n他逼着我吃了一点，又给我叫了一杯勃艮第酒[注]。这一来，人觉得好些，就吃了一点芦笋。我把全部困难都告诉他，身体是这样弱，怎么能做模特儿；人剩了皮包骨头，样子真难看，不可能指望找到个男人。我问他能不能借我一点钱，让我回到本村子去。至少我还有个小女儿在那边。他问我是不是真的要去，我说当然不是。\n妈并不要我；物价这样高，她靠那点抚恤金都不容易过活，而我寄给奥代特的钱已经全都花光了。可是，如果我到了家门口，她也没法不放我进去，她会看出我病得多么厉害。拉里看了我好半天，我想他大约要告诉我，不能借钱给我。后来他开口了：“‘你可愿意我把你带到乡下我认识的一个小地方去，你和你的孩子一起？我需要度一个时候假期。’“我简直相信不了自己的耳朵。我认识他这么多年，可是他从来没有勾搭过我。\n“‘照我现在这样？，我说，自己忍不住笑了出来。‘我的好朋友’，我说，‘眼下什么男人都不会要我的。’“他望着我笑了。你可曾留意过他笑起来是多么的爱人？简直象蜜一样甜。\n“‘别这样胡扯，’他说。‘我并不是指的那件事。’“听了这话，我不禁痛哭起来，连话都说不出。他给我钱，把孩子接出来，我们一起到了乡下。他带我们去的那个地方风景真可爱啊。”\n苏姗把那个地方形容给我听。它离一个小镇有三英里远；小镇的名字被我忘了。\n他们坐汽车开到一家旅馆，那是河边上一幢东倒西歪的房子，有一片草地一直铺到水边。草地上有悬铃树，他们就在树荫下吃饭。夏天，画家们都来作画，不过，时节还早，所以，旅馆等于被他们包下来。这里的菜烧得很好；星期天中午，别地方的人往往开车子来大啖一顿，但是，在别的日子里，他们的安静生活很少受到干扰。\n由于得到休息，而且饮食又好，苏姗的身体逐渐好了起来，而且有孩子在身边，过得很开心。\n“他很喜欢奥代特，奥代特也非常亲近他。我得拦阻奥代特不要缠着他，可是，拉里不管奥代特怎样闹，都好象不介意。这情况常常引得我大笑，他们在一起就象两个孩子。”\n“你们做些什么事情呢？”我问。\n“噢，事情有的是。我们常常坐条船出去钓鱼；有时候，借了旅馆老板的西铁隆汽车开到镇上去。拉里很喜欢这个小镇。旧式的房子，方场。镇上非常之静，你走在铺了鹅卵石的路上，足声是唯一听得见的声音。有一所路易十四时期的市政厅和一座老教堂；小镇边上是宫堡和勒诺特尔[注]设计的花园。当你坐在方场的咖啡馆里时，你感到就象回到三百年前一样；停在路边上的那部西铁隆汽车好象根本不属于这个世界。”\n我在本书开头叙述的关于那个年轻空军的故事，就是拉里在一次出游时告诉苏姗的。\n“我不懂得他为什么要告诉你，”我说。\n“我也不懂。大战时，镇上有过一所医院；公墓里是一排排的十字架。我们去看了；时间并不长，因为我有点毛骨悚然——那么多可怜的年轻人睡在那里。回家的路上，拉里非常沉默。他向来吃得不多，可是，到了晚饭时，他一口都没有吃。\n我记得非常清楚，那天的夜晚很美，满天的星，我们坐在河边上，白杨树在黑暗中望去就象剪影，景色很美，拉里抽着烟斗。忽然间，a propos de bottes[注]，他告诉我他的这个朋友，和他怎样为了救他而送命的。”苏姗喝了一口啤酒。“他是个怪人。我将永远不理解他。他时常喜欢念书给我听。有时候，在白天，我一面听，一面给小东西缝衣服，有时候，在晚上，在我打发小东西睡觉以后。”\n“他念些什么呢？”\n“啊，各式各样的书。德赛维涅夫人的书信[注]和圣西蒙[注]的一些片段。你可想得到，我以前除掉报纸以外，什么都不读的；偶尔看一本小说，是因为在画室里听见人谈论它，不想使自己被他们当成傻瓜才看的。我从没有想到读书这样有味道过。那些旧作家，他们并不象人们设想的那样乏味。”\n“谁会这样设想的？”我吃吃笑了。\n“后来他就叫我和他一同念。我们读《费德尔》和《贝蕾妮丝》[注]。他念男人的台词，我念女人的台词。你决想不到有那样好玩，”她天真地补充一句。“当我念到那些凄凉的台词哭起来时，他往往很古怪地看着我。当然那只是因为我的身体还没有复原的缘故。你知道，这些书我现在还在手里。便在今天，我读到他向我念的德赛维涅夫人的几封信时，耳朵里仍然好象听见他的可爱声音，仍然看见河水静静流着，看见河对岸的那些白杨树；有时候，我简直读不下去，它使我心里非常难受。现在我认识到这几个星期是我一生中过得最快乐的。他这个人，真是象天使一样可爱。”\n苏姗觉得自己变得感情冲动起来，怕我会笑她（其实我不会）。她耸了耸肩膀，微笑说。\n“你知道，我一直心里有这样的打算，等我活到适当的年纪，再没有男人愿意跟我睡觉的时候，我就跟教会妥协，忏悔自己的罪行。但是，我跟拉里犯的罪，不管谁怎样说，我决不忏悔。决不，决不，决不！”\n“可是，象你适才所形容的，我看不出有什么地方是你应当忏悔的。”\n“后半段我还没有告诉你呢。你知道，我的体质本来不错，现在成天在室外走动，吃得好，睡得好，一点心思没有，这样有三四个星期，人已经和过去一样健康了。而且样子也好看起来；两颊红红的，头发也有了光泽。人变得年轻了。拉里每天早上在河里游泳，我时常在一旁看他。他的身体长得很美，不象我那个斯堪的纳维亚人的运动员身体，而是强壮有力，又非常匀称。\n“我身体很坏时，他非常忍耐，但是，现在我已经完全复原，我觉得没有理由叫他继续等着。我给了他一两次暗示，表明我可以干那活儿了，但是，他好象不懂得。当然，你们盎格鲁撒克逊人是古怪的；你们粗暴，同时又容易动感情；你们不是谈情说爱的好手，这是无法否认的。我跟自己说，‘也许这是他体贴的地方，他待我这么好，他让我把孩子带来，也许他不好意思要求我报答他；其实这是他的权利。’所以，有一天晚上，当我们去睡觉之前，我对他说，‘你要我今晚上你的房间来吗？’”\n我大笑。\n“你相当直截了当，可不是？”\n“是啊，我没法要他到我的房间来，因为奥代特睡在里面，”她坦然回答。\n“他用他那双和善的眼睛看了我一下，然后微笑说，‘你要来吗？’“‘你想呢——你这样漂亮的身体？’“‘好吧，你就来吧。’“我上了楼，脱掉衣服，然后，沿着过道溜进他的房间。他躺在床上看书，抽着烟斗。他放下烟斗和书，移过身子让出地方给我。”\n苏姗有这么一会没有说话，我也不想向她提出问题。可是，过了一会，她又继续说道：“他是一个很特别的情人。亲热，甚至温柔，健壮而不热烈，不知道你懂得我的意思没有，而且一点不下流。他爱得就象个青年学生一样。那情形相当可笑，但又令人感动。我离开他时，觉得应当是我感谢他，而不是他感谢我。当我关上门时，我看见他又拿起书，继续从刚才撂下的地方看下去。”\n我开始笑了。\n“我很高兴使你觉得开心，”她带有恶意说，可是，她自己也有点忍俊不禁，所以吃吃笑了。一我不久就发现，如果我要等他来请，那就说不定要永远等下去，所以，我感到需要时，自己就到他的房间去，爬上床。他始终都很好。总之，他也有人类天性中的那些本能，但是，他就象一个心不在焉的人忘记吃饭一样，你只要给他烧一顿好饭，他也能吃得有滋有味的。一个人爱我不爱我，我是清楚的。如果我认为拉里爱我，那我就是个傻瓜，但是，我想他会跟我过得很习惯。一个人在生活上应当实际一点，所以，我跟自己说，如果我们回到巴黎之后，他带着我和他住在一起，我也非常愿意。我知道他会让我把孩子带在身边，这一点我很喜欢。我的本能告诉我，如果我爱上他，那就很愚蠢，你知道女人是很不幸的；时常，她们一堕入情网，自己就变得不可爱了，所以，我打定主意不上这个当。”\n苏姗抽了一口香烟，把烟从鼻子里喷出来。时间已晚，许多桌子都已经空了，但是，还有一群人围在酒柜台那边。\n“有天早晨，吃过早饭，我正坐在河边上做针线，奥代特玩着拉里给她买的积木，这时，拉里走到我面前来。\n“‘我是来向你告别的’，他说。\n“‘你要到什么地方去吗？’我说，感到诧异。\n“‘是的。’“‘你就此不回来了吗？’我说。\n“‘你现在身体已经很好了。这里的一笔钱够你过完夏天，并且回到巴黎重行开始了。’“我一时间心里非常难过，简直不知道说什么是好。他站在我面前，象平日那样坦然微笑着。\n“‘我有什么地方使你不快吗？’我问他。\n“‘一点没有。千万不要有这种想法。我有工作要做。我们在这儿过得非常开心。奥代特，来跟叔叔说再见。’“奥代特太小了，什么也不懂。拉里把她抱起来，吻了她；然后又吻了我，就走回旅馆去；一分钟后，我听见汽车开走了。我看看手里的银行支票。一万二千法郎。事情来得是这样快，我连反应都来不及。‘zut alors[注]，’我跟自己说。至少我有一件事情得感谢老天，我没有让自己爱上他。可是，我简直弄不懂这是怎么回事。”\n我不禁笑了。\n“你知道，有一个时候，我只是简简单单把事情真相说出来，竟给自己挣得一个很不坏的幽默家头衔。对多数人说来，他们完全想象不到事实就是如此，所以当作我是说笑话。”\n“我看不出这里的关系。”\n“你知道，我觉得拉里在我认识的人当中，是唯一能够完全无所为而为的人。\n这就使他的行动显得古怪。有些人不相信上帝，但是，他们的所作所为却完全是为了上帝之爱；这种人我们是不习惯的。”\n苏姗瞠着眼睛望我。\n“我可怜的朋友，你酒喝得太多了。”\n第五章 # 一 # 我在巴黎拖拖拉拉地写作。春天真是好过，爱丽舍田园大街上那些栗子树开花了，许多街道的光线非常悦目。空气中有一种快乐，一种轻飘飘的短暂快乐，使人心荡神怡而不涉邪想，使人的步履更加轻捷，头脑更加清醒。我和自己五花八门的朋友一起玩得很开心，心里充满往日亲切的回忆，至少精神上恢复了一点青春的活力。这种片刻的欢愉我说不定永远不会再充分享受到；我倘若让写作来干扰我，那我就是傻瓜，我跟自己说。\n伊莎贝儿、格雷、拉里和我常常一同去游览近郊的名胜：尚蒂伊和凡尔赛，圣日尔曼和枫丹白露。我们不管去哪儿，午饭都吃得很好，很多。格雷由于他的大块头身体需要，胃口最大，而且酒喝得往往有点过头。他的健康肯定有了好转，是否由于拉里的治疗，还仅仅是日子久了的缘故，我也说不上。总之，他的头痛病已经不发了。我来巴黎和他初见面时，他眼睛里那种惘然若失的神情，使人看了很难受的，现在也消失了。他谈话不多，只是偶然谈些冗长的故事，但是，伊莎贝儿和我胡说八道时，他会哈哈大笑。他玩得很开心；尽管人并不风趣，但是脾气好而且容易满足，人不由得不喜欢他。这种人，你是不愿意和他度过一个寂寞的夜晚的，而且说不定会高兴地期望和他过六个月。\n他对伊莎贝儿的爱，看了真使人喜欢；他崇拜她的美，而且认为她是世界上最有才华、最动人的女子；他对拉里的忠诚，象狗对主人的一样的忠诚，也使人感动。\n拉里也玩得很开心；他似乎把这段时间看作是一种休假，使他暂时把脑子里的打算——且不问是什么打算——放一放，安心安意地尽情享受。他也不大讲话，但是没有关系，有他在一起，就和谈话差不多；人很随便，而且总是那样兴致勃勃，使你觉得这样已经很够了，不需要再对他有所要求；我而且满知道我们度过的这些日子所以能这样快活，全是由于有他和我们在一起。虽则他从来没有说过一句动人的或者风趣的话，少他一个就会感到无聊。\n有一次，在我们作了这类短程游览的归途中，我目睹了一幕使我相当骇异的情景。我们玩了夏尔特尔[注]之后，正回到巴黎来。格雷开车子，拉里坐在他旁边；伊莎贝儿和我坐在后面。一整天玩下来，全都觉得疲倦。拉里一只胳臂伸出来搭在前座椅背上。这个姿势使他的袖口拉了上去，露出瘦长而有力的手腕和微微长了一层茸毛的棕色皮肤的小臂。阳光把那些茸毛照成黄金色。伊莎贝儿一点声息没有，使我觉察到这里有异，便瞄她一眼。她一动不动，使人简直当作她受了催眠似的。\n她呼吸急促；眼睛直瞪着那长了金黄茸毛的坚韧手腕和那只瘦削、修长而有力的手望，当时她脸上的那种如饥似渴的淫荡，我在任何人脸上都没有见到过。那是一只肉欲的假面具。我决没有想到她的美丽容貌会表现出这样放纵的骚态来。它是兽欲，而不是人性。脸上的美全剥掉了；神情变得丑陋和骇人。它可怕地使人想起一只春情发动的母狗，我感到有点厌恶。她并不感到我在旁边；她感到的只是那只随随便便搭在椅背上、使她欲火中烧的手。后来就象是一阵痉挛掠过她的脸，她打了个寒噤，闭上眼睛往车角上一靠。\n“给我一支烟，”她说，声音是那样嘶哑，我简直听不出是她。\n我掏出烟盒，给她点上一支。她死命抽着。在汽车余下的路程中，她始终望着窗外，一句话也不说。\n格雷开到家时，请拉里把我开国旅馆，然后把车子开进车间。拉里坐上司机的座位，我坐在他身边。穿过人行道时，伊莎贝儿挽着格雷的胳臂，紧贴着他，向格雷做了个脸色；我虽然没有看见脸色，但可以猜出那意味着什么。我想格雷今天晚上将会发现自己妻子特别狂热，但是，他将永远不懂得是什么良心责备促使她这样热烈的。\n六月快完了，我得回里维埃拉去。艾略特的某些去美国的朋友把他们在迪纳尔[注]的乡下别墅借给马图林夫妇住，他预备等孩子学校放假立刻动身。拉里留在巴黎工作，但是，自己买了一辆旧西铁隆，答应在八月里上他们那儿去住几天。在我离开巴黎的前夕，我请他们三个人和我一同吃晚饭。\n就在这天晚上，我们碰见了索菲?麦唐纳。\n二 # 伊莎贝儿有意观光一下那些冶游场所；由于我对这些地方比较熟悉，就要求我做他们的向导。我不大愿意，因为在巴黎的这类地方，那些人对美国来的游客很不喜欢，而且毫不掩饰，所以往往弄得人不开心。但是，伊莎贝儿非去不可。我预先打她招呼，说这会使人很扫兴，请她千万穿得朴素一点。我们很迟才吃晚饭，先去仙女游乐厅[注]看了一小时戏，然后出发。我先带他们到圣母院附近的一处地下室，是歹徒和他们的那些家属常去的地方。由于老板和我相识，他找一张长桌子给我们让出几个空位子；长桌子那儿还坐着几个很不象样的人，可是，我叫了酒请大家喝，并且互祝健康。室内又热又脏又烟雾迷漫。后来我带他们去斯芬克斯舞厅；这里的女人穿着漂亮而俗气的晚服，里面什么都不穿，奶子等等全看得见，面对面坐在两张长凳子上；乐队奏乐时，就一对对没精打采地跳起来，一面眼睛搜索着舞厅周围靠大理石面桌子坐着的男人。我们叫了一瓶没有冰过的香槟酒。有些女人经过我们面前时，把伊莎贝儿狠狠看了一眼，我不知道她可懂得这是什么意思。\n后来我们又去了拉白路。那是一条寒伧狭窄的巷子；你才走进巷子，就给你一种下流淫秽的印象。我们走进一家咖啡馆。弹钢琴的是那种通常的苍白而浪荡的年轻人，另一个刮着小提琴的则是一个又老又疲倦的老头子，还有第三个人吹着不协调的萨克斯管。这地方挤满了人，看上去好象一张空台子都没有，但是老板看出我们是肯花钱的主顾，毫不客气地把一对男女赶到另外一张已经坐了人的桌子去，请我们坐下。那两个被打发掉的客人不甘心，讲了一些涉及我们的很不中听的话。不少的人都在跳舞；帽上系红绒球的水手；男人多数戴着便帽，或者用手帕围着脖子：成年的妇女和年轻的女孩子，眼睛全画起来，光着头，穿着短裙和颜色罩衫。男人和眼睛化了装的矮胖男孩子跳；瘦削，面目凶恶的女子和染了头发的胖女人跳；男人和女人跳。一股烟气杂酒气的臭味和汗酸味。音乐没完没了地奏着，这一群气味难闻的乱七八糟的人不停地在屋子里转，脸上闪耀着汗水，一本正经的劲头里带有一种可怕的样子。有几个大个儿的样子很粗暴，但多数人都矮小而且营养不足。我打量那三个奏乐的人。他们不妨说是机器人，因为演奏完全是机械式的；我心里盘算，有没有可能在过去某一个时候，当他们刚刚开始时，曾经想到自己说不定是人们会跑老远的路来听并向之喝彩的音乐家呢。便是把小提琴拉得很坏，你也得请人教，也得练习啊：难道这个提琴手费了那么大的事，就是为了在这个臭气熏人的狗窝里拉狐步舞曲子，拉到天快亮吗？音乐停止了，钢琴家掏出一块脏手绢揩揩脸。\n跳舞的人或者懒洋洋地，或者歪着身体，或者扭扭捏担地，回到自己座位上。忽然间，我们听到一个美国口音。\n“我的老天啊！”\n一个女人从屋子对面的一张台子站起来。和她在一起的男子打算拦住她，但是，她把他推在一边，自己摇摇晃晃从对面走过来。她已经很醉了，走到我们台子边，站在我们面前，身体带点摇晃，傻里傻气地咧开嘴笑。她好象觉得我们这些人的样子怪有意思的。我望一下我的同伴。伊莎贝儿木然望着她，格雷皱着眉头，一脸愠怒，拉里盯着她看，象是相信不了自己的眼睛。\n“哈罗，”她说。\n“索菲，”伊莎贝儿说。\n“你还他妈的当作是哪一个？”她咯咯笑了。她一把抓着身边走过的侍役，“芬山，拿张椅子来。”\n“你自己拿，”他说，挣开她的手。\n“salaud，[注]”她骂，向他吐了一口唾沫。\n“ten fais pas，sophie[注]．”一个大胖家伙说；他的大脑袋上长了一头油光光的头发，只穿件衬衫，就坐在我们邻座。“这儿有椅子。”\n“想不到这样子碰见你们大伙儿，”她说，仍旧有点晃。“哈罗，拉里。哈罗，格雷。”她在那个男子搬在她身后的椅子上一屁股坐下。“大家来杯酒，patron[注]，”\n她叫。\n我早已注意到老板的眼睛在盯着我们，这时走了过来。\n“你认识这些人吗，索菲？”他问，用熟悉的第二人称单数[注]称呼她。\n“ta gueule[注]，”她醉醺醺地大笑。“他们是我小时候的朋友。我要请他们喝一瓶香槟。你可不要给我们什么urine de cheval[注]吃。拿点人咽得下去不会呕出来的。”\n“你吃醉了，我可怜的索菲，”他说。\n“滚你的。”\n他走了，很高兴能卖掉一瓶香槟酒——我们为了安全起见，只喝白兰地掺苏打水——这时索菲木木然看了我一会儿。\n“你这位朋友贵姓，伊莎贝儿？”\n伊莎贝儿把我的姓名告诉她。\n“哦？我记得的，你有一次到过芝加哥。派头很神气的，是不是？”\n“也许，”我笑说。\n我一点想不起她来；这并不奇怪，因为我已经有十年多没有去过芝加哥，而且当时和以后都接触过不少的人。\n她相当高，站起来时看去更高，因为人很瘦。她穿了一件鲜绿的绸罩衫，但是，弄绉了而且有污迹，下面着一条黑短裙。染成棕红色的头发剪得很短，马马虎虎卷了一下，而且弄得乱七八糟。妖里妖气的打扮；两颊的胭脂搽到眼睛，上眼皮和下眼皮涂成深蓝色；眉毛和睫毛都搭上很浓的黑油；嘴唇用口红染成鲜红；两只手的指甲也都染红，但是手很脏。她的样子比屋子里别的任何女人都更下流。我怀疑她不但吃醉了而且吸了毒。不过，也不能否认她具有一种邪恶的吸引力；她的头以一种傲慢的姿态稍稍向后仰起，脸上的打扮把她眼珠的绿色衬得更加刺目。尽管醉得颠三倒四的，她却有一种厚颜无耻的派头，使我能够想象得出是所有下流男人都喜欢的。她向我们鄙薄地一笑。\n“敢说你们并不怎么高兴看见我，”她说。\n“我听说你在巴黎，”伊莎贝儿懒洋洋地说，脸上带着冷淡的微笑。\n“你何妨打电话给我。电话簿上有我的名字。”\n“我们来了不久。”\n格雷来解围了。\n“你在巴黎玩得开心吗，索菲？”\n“开心。你生意失败了，格雷，是不是？”\n格雷的脸本来就红，这一下涨得更红了。\n“是的。”\n“真倒霉。我想眼下芝加哥的日子大约很不好过。幸亏我及早就离开了。天哪，那个狗娘养的怎么不拿点酒来我们喝？”\n“他就来了，”我说；一个侍役盘子里托了几只杯子和一瓶酒，正穿过台子中间走来。\n我的话使她注意到我。\n“我的可爱的婆家人把我赶出芝加哥。说我败坏了他家——名声。”她咯咯地狞笑起来。“我现在靠国内的汇款生活。”\n香槟来了，斟好了。她一只颤抖的手把杯子举到嘴边。\n“神气十足的小人物见鬼去，”她说。她把酒喝光，看看拉里。“你自已好象没有什么说的，拉里。”\n拉里脸上毫无表情地望着她。自从她来了以后，他的眼睛就一直没有离开她，现在很和气地对她一笑。\n“我讲话本来不多，”他说。\n音乐又奏起来。一个人走到我们面前；他个子相当高，而且长得结实；大鹰钩鼻子，刷亮的黑头发，大嘴和多肉的嘴唇。那样子就象个成了反面角色的萨冯纳罗拉[注]。象这里的多数男人一样，他不戴领子，小腰身的上褂扣得很紧，显出一点腰来。\n“来，索菲。我们去跳舞。”\n“走开。我没有空。你难道没有看见我有朋友吗？”\n“jm en fous de tes amis[注]。滚你妈的朋友。来跳舞。”\n他抓着她的胳臂，但是，她挣脱他。\n“fous mol la piax，espece con[注]，”她突然怒气冲冲叫出来。\n“merde[注]．”\n“mange[注].”\n格雷不懂得他们讲些什么，可是，我看出伊莎贝儿完全理解，因为她具有多数正经女子有的那种对猥亵的奇异知识，所以她脸板下来，皱着眉头表示氏恶。那人举起胳臂，张开手———一只长满老茧的工人的手——正预备打她耳光，这时格雷从椅子上半抬起身子。\n“allaiz vons ong[注]，”他用自己的恶劣声调喊。\n那人停下来，恶狠狠看了格雷一眼。\n“当心，可可，”索菲说，狞笑一下。“他会把你打个半死。”\n那人把格雷的高大身材、体重和力气打量一下，悻悻地耸耸肩膀，向我们骂了一句脏话，溜走了。索菲醉意十足地吃吃笑了。在座其余的人都不作声。我重新给她把杯子斟满。\n“你住在巴黎吗，拉里？”索菲把酒喝光之后问他。\n“暂时。”\n跟一个喝醉酒的人谈话总是很吃力的，而且不用说，清醒的人都处在不利地位。\n我们继续谈了几分钟话，谈得既乏味，又尴尬。后来索菲把椅子往后一推。\n“我再不回到我的男朋友那儿去，他就要气疯了。他是个生闷气的浑蛋，可是老天啊，是个好样的。”她摇摇晃晃站起来。“再会，朋友们。来玩嘛。我每天晚上都在这儿。”\n她挤到那些跳舞的人中间，在人群中消失了。我看见伊莎贝儿的高贵容貌上那种冷冰冰的鄙夷表情，几乎要笑出来。我们谁也不讲话。\n“这是个下流地方，”伊莎贝儿突然说。“我们走吧。”\n我付掉我们叫的酒和索菲的香槟酒帐，大家一同离开。大部分人都在舞池里，我们看也不看就出去了。时间已过两点，我觉得应当睡觉了，但是，格雷说他肚子饿，所以，我建议上蒙马特尔的格拉夫饭店去吃点东西。车子开出去时我们全都不说话。我坐在格雷旁边指挥他开到那个装璜得很低气的餐馆。阳台上还坐了一些人。\n我们走到里面，叫了火腿蛋和啤酒。伊莎贝儿至少表面上重又镇定了下来；她恭维我认识巴黎的这些比较下流的场所，也许带有一点调侃味儿。\n“是你要去的，”我说。\n“我玩得十分开心。今天晚上痛快极了。”\n“见鬼，”格雷说。“叫人要呕出来。还有索菲。”\n伊莎贝儿无动于衷地耸一下肩膀。\n“你还记得她吗？”她问我。“你第一次到我们家来吃晚饭时，她就坐在你旁边。当时她的头发还不是红得这样不象话。它原来的颜色是暗赭包。”\n我把往事回忆一下；想起了一个年纪很轻的女孩子，蓝得几乎象绿色的眼睛，头微微斜向一边，很逗人；不能算美，但是活泼坦率，杂有腼腆和俏皮，使我觉得很有趣。\n“当然我记得。我喜欢她的名字。我有个姑母就叫索菲。”\n“她嫁了一个叫鲍勃?麦唐纳的男孩子。”\n“人不错，”格雷说。\n“他是我碰见的最漂亮的男孩子之一。我永远不懂得他看中索菲的什么地方。\n她是紧接着我之后结婚的。她的父母离婚了；母亲改嫁了一个在中国的美孚石油公司的人。她跟着父亲住在麻汾，那时我们时常看见她，但是，她结婚之后就和我们这群人有点疏远下来。鲍勃?麦唐纳是个律师，但是挣的钱不多，住在城北一所没有电梯的公寓里。但是，这不是原因。他们不愿意看见任何人。我从来没有看见有两个人相爱得这样狂热的。便在他们结婚已经有两三年而且生了一个孩子之后，两个人上电影院时，还是象情人一样；他搂着她的腰，她的头靠在他的肩膀上。他们在芝加哥被人当作笑话说。”\n拉里听着伊莎贝儿讲，不赞一辞。脸上有一种莫测高深的神情。\n“后来怎样呢？”我问。\n“有天晚上，他们开着自己的小敞篷汽车口芝加哥，把孩子带在身边。他们总是把孩子带着，因为家里没有帮手，索菲什么事都亲自动手，而且他们对孩子异常钟爱。一伙醉鬼开着一部大轮车以每小时八十英里的速度和他们迎头撞上。鲍勃和孩子当场撞死，可是，索菲只受到脑震荡，另外断了一两根肋骨。他们尽量瞒着，不让她知道鲍勃和孩子已经死了，但是，最后只好告诉她。他们说那情形真使人受不了，她就象疯了一样；叫得房子都要塌下来。他们得日夜看守着她，有一次，几乎被她从窗子里跳出去。当然我们凡是能够做的都做了，可是，她好象恨我们。她从医院出来之后，他们把她送进疗养院，在那边住了好几个月。”\n“可怜的人儿。”\n“当他们放她出来之后，她开始喝酒z喝醉之后，谁找上她，她就跟谁睡觉。她的夫家人吃她不消。他们都是些善良的安分的人，对这种丑事非常愤恨。开头我们全都想帮助她，但是没办法；如果你请她吃晚饭，她来的时候就已经喝醉了，而且很可能客人还没有散，她就醉得不省人事了。后来她和一班坏蛋混起来，我们只好不睬她。有一次，她因喝醉酒开汽车被捕。和她在一起的是她在地下酒店结识的一个达果[注]，一查原来是个官方要缉拿的人。”\n“可是，她有钱吗？”我问。\n“有鲍勃的人寿保险；那辆把他们撞倒的汽车的主人是保了险的，她从他们那里也拿到一点钱。不过，这点钱维持不了多久。她花钱就象喝醉酒的水手，两年之内就赤脚了。她的祖母不肯让她回麻汾。后来，她的夫家人说，如果她肯出国，并且住在外国不回来，就给她生活津贴。我想，她现在就是靠的这笔钱过活。”\n“事情又还原了，”我说。“从前有一个时候，败家子是从英国送到美洲去的；现在的败家子显然是从美国送到欧洲来了。”\n“我真替索菲可惜，”格雷说。\n“是吗？”伊莎贝儿冷静地说。“我不。当然这是一个打击，当时我比任何人都更加同情她。我们一直彼此都很熟悉。但是，一个正常的人碰到这种事情总要恢复过来的。她所以垮掉是因为她本来就有劣根性；天生就是个不健全的人；连她对鲍勃的爱情都嫌过分。她如果性情坚强的话，总应该有办法过下去。”\n“如果坛坛罐罐全都……你是不是太狠心了，伊莎贝儿？”我咕噜说。\n“我不认为如此。这是常识，我认为不须要对索菲感情用事。天晓得，谁也不比我更爱格雷和两个孩子的了；如果他们在一次车祸中送了命，我会变得神志失常，但是，迟早将会振作起来。格雷，你是不是赞成我这样做，还是赞成我每晚喝得酩酊大醉，并且和巴黎的随便一个流氓睡觉？”\n格雷的回答很妙，也可以说是我听见格雷的讲话最有风趣的一次。\n“当然我赞成你穿一件库林诺时装店新制的衣服跳进我的火葬堆里，不过，既然现在不行殉葬，我想最好的代替办法是打桥牌。你而且要紧记住，除非你有把握一出手就拿三叠半到四叠牌，不要上来就叫无王牌。”\n我不想向伊莎贝儿指出，她对自己丈夫和孩子们的爱虽则出于真心，但一点谈不上热烈；这不是时候。可能她已经看出我脑子里在想的什么，所以带有挑战的味道问我道：“你怎么说？”\n“我和格雷一样，很替这女孩子惋惜。”\n“她不是女孩子，她已经三十岁了。”\n“我想她的丈夫和孩子丧命时，世界对她说来已经完结了。生命待她太残酷了，所以她也不管自己变得怎样，一头钻进酗酒和淫乱的堕落泥坑，作为对生命的报复。\n她本来住在天堂，现在天堂失去了，她住不惯平凡人的平凡世界，因此，绝望之余，一头钻进地狱。我可以想象得出，既然她不再能喝到天神的琼浆玉液，那还不如饮小便的好。”\n“这是你们在小说里写的一套。它是胡扯，你也知道是胡扯。索菲滚进泥潭里是因为她喜欢。别的女人也有死掉丈夫和孩子的。她变坏并不是这个原因。坏不是由好变过来的。坏本来就已经有了。等到那次车祸冲破她的防线，她就露出本来面目来。别把你的怜惜浪费在她的身上；她现在变成这样，说明她一直就是这样。”\n拉里自始至终没有开口。他象在沉思，我们讲些什么恐怕他听都没有听见。伊莎贝儿讲完话后，暂时有一段沉寂。后来他开始讲话了，但是，声音很古怪、很单调，不象朝着我们，而象自言自语；眼睛象在望着模糊的已往岁月。\n“我记得她十四岁时，把长头发从前额梳到后面，在后面打一个黑蝴蝶结，一张长了雀斑的严肃的脸。是一个谦虚的、高尚的、充满理想的孩子；碰到什么书都看，我们时常在一起谈书。”\n“在什么时候？”伊莎贝儿问，眉头微微有点皱。\n“哦，在你和你母亲出去交际的时候。我常上她祖父家里去，我们会坐在他们家那棵大榆树下面，相互读书。她喜欢诗歌，自己也写了不少诗歌。”\n“很多女孩子在这样年纪都写诗。相当蹩脚的东西。”\n“当然那是好多年以前的事了，而且敢说我自己就不懂得什么好坏。”\n“你自己顶多也不过十六岁。”\n“当然是模仿的。有不少地方学的罗勃特?弗罗斯特[注]。不过我的感觉是，年纪这样轻的女孩子能写成这样，是了不起的。她的耳朵很灵敏，而且有节奏感；对乡野间的声音和气味有感情，诸如空气中早春的温柔气息和干旱土地上雨后发出的清香。”\n“我从来不知道她写诗，”伊莎贝儿说。\n“她保守秘密，怕你们大家笑她。她很害臊。”\n“她现在可不害臊。”\n“战后我回来时，她几乎已经是成人了：读了许多关于工人阶级情况的书，而且是在芝加哥亲自看到了那些情况。她迷上了卡尔?桑德堡[注]，拼命写自由诗，描写穷人的困苦生活和工人阶级的受剥削情况。我要说那些诗写得平淡，但是诚实，而且带有同情和高尚感情。当时，她想要做一个社会工作者。她的牺牲精神很使人感动。我觉得，她的能力很强。她并不傻，也不感情冲动，但是，给人一种幽闭贞静和灵魂高洁的印象。那年夏天，我们时常碰面。”\n我能够看出，伊莎贝儿听得越来越毛躁。拉里一点不觉得自己在拿一柄匕首戳进她的心里，而且每一个单词都象匕首在她心里搅。可是，伊莎贝儿开口时，嘴边却露出淡淡的微笑。\n“她怎么选上你做她的知心人的？”\n拉里一双诚实的眼睛望着她。\n“我不知道。你们这些人都很有钱，她在你们中间是一个穷女孩子，而我则不属你们之列。我来到麻汾，只是因为纳尔逊叔叔在麻汾行医。想来她觉得这使我和她有共同的地方。”\n拉里一个亲戚也没有。我们多数人至少有些堂兄弟、堂姐妹或者表兄弟、表姐妹；这些人我们可能简直不认识，但至少使我们感到自己是这个家族的一部分。拉里的父亲是独生子，母亲是独生女；他的祖父是教友派教徒，年纪很轻时就在海上遇难，他的外祖父没有兄弟，也没有姐妹。世界上没有一个人象拉里这样孤零的。\n“你曾想到过索菲爱你吗？”伊莎贝儿问。\n“从来没有，”他笑了。\n“她是爱你的。”\n格雷冒冒失失的样子说，“拉里打完仗作为一个受伤军人回来时，半个芝加哥的女孩子都在追他。”\n“这不仅仅是追。她崇拜你，我可怜的拉里。难道你是说你不知道吗？”\n“我当然不知道，而且我不相信。”\n“想来你认为她太高尚了。”\n“对我说来，她现在仍旧如在目前；一个瘦瘦的小女孩子，头发打了个蝴蝶结，脸色庄重，读起济慈的颂歌来，声音有点抖，含着眼泪，因为诗太美了。不知道她如今在哪里。”\n伊莎贝儿微微吃了一惊，带着迷惑不解的神情把拉里看了一眼。\n“晚得不象话了，我人疲倦得不知道怎么办。我们走吧。”\n三 # 第二天傍晚我坐蓝钢车去里维埃拉，两三天后，就上昂第布去看艾略特，告诉他巴黎的新闻。他看上去气色很不好。蒙特卡地尼的疗养并没有取得预期的疗效，而事后去各处旅行又弄得他精疲力竭。他在威尼斯找到一只洗礼盆，然后又上佛罗伦萨去买下那张他和人家讨价还价的三联画。为了急于把这些东西安装好，他亲自上庞廷尼沼地去了一趟，住在一家很蹩脚的小旅馆里，热得使人简直吃不消。他买的那些名贵艺术品要好多天才能运到，但是，他下定决心非要达到目的决不离开，因此继续住下去。当一切总算照他所要求的那样安装就绪以后，他感到非常满意，并且得意扬扬地把自己拍的那些照片拿给我看。教堂虽然小，但是有气派；内部装修华丽而不俗气，证明艾略特确有眼光。\n“我在罗马看见一日早期基督教时代的石棺，非常中意，考虑了好久，想把它买下来，但是，最后打消了。”\n“你怎么想到要买一口早期基督教的石棺，艾略特？”\n“给我自己睡，老兄。制作非常之精，我觉得和门那边的圣水盘正好扯平[注]，不过，那些早期基督徒都是些矮矮胖胖的人，我睡不进去。我总不能躺在那儿等那张最后的王牌[注]跑来使我的膝盖顶着下巴，就象胎儿那样。怪不舒服的。”\n我大笑，艾略特却是一本正经。\n“我想了一个更好的办法。我跟教堂方面商量好——是碰到些困难的，不过也是意料中事——把我葬在祭坛前面，就在圣坛东面台阶底下；这样的话，当庞廷尼沼地那些可怜的农民前来领圣餐时，他们那些沉重皮靴就会踏在我的骨头上面。相当帅，你说是不是？只是光秃秃一块石板上面刻了我的名字和两行生率年月。simonumentum quoeris，circumspiece[注]。如果你要找他的碑，你四下看看，就知道了。”\n“我拉丁文还算懂得，一句陈词滥调还用不着译给我听，艾略特。”我有点刻薄地说。\n“对不起，老兄。我一向习惯于上流人士的愚昧无知，一时间忘记我是在和一位作家谈话。”\n口头上还是被他占了便宜。\n他又继续说道，“不过，我要告诉你的是：我已经在遗嘱上把葬礼应当注意的事情全写上了，但是，我要你当监视人。我决不和里维埃拉那批退休军官和中产阶级的法国人葬在一起。”\n“我当然愿意照办，艾略特，不过，我觉得多年后的事情用不着现在就考虑得这样周到。”\n“我年纪不小了，你知道，而且说实在话，离开人世我并不难过。兰道尔[注]那几句诗是怎么说的？我烘我的双手……”\n我对诗文的记性虽则很差，但是，这首诗很短，所以我能背得出来。\n我从不与人争，没有人值得我与之争；我爱自然，其次爱的是艺术；我向生命之火伸双手取暖；火快烧残了，我也准备离去。\n“对了，”他说。\n我私心认为艾略特硬要拿这首诗来形容自己，实在非常牵强。\n可是，他说，“它完全表达了我的心情。我唯一要增人的地方是，我一直和欧洲最上流的人士交往。”\n“在一首四行诗里，添上这一点恐怕不容易。”\n“交际界完结了。有一个时候，我曾经希望美国会取代欧洲建立一个为‘大众’[注]所尊重的贵族阶层，可是，不景气把这种可能性完全摧毁了。我可怜的祖国越来越变得不可救药地庸俗。你决不会相信的，我亲爱的朋友，上次在美国时，一个开出租汽车的司机竟然称呼我“老兄’。”\n里维埃拉受到一九二九年市场大崩溃的打击仍未恢复；虽然它远不是过去那样，艾略特照旧举行宴会，并参加人家的宴会。他从不和犹太人过从，只有罗思柴尔德家族除外，但是，现在有些最盛大的宴会却是这些上帝的选民[注]举行的，而只要是宴会，艾略特都舍不得不去参加。他在这些聚会里东跑跑西站站，风度翩翩地和这个人握手，或者对那个人行吻手礼，但是，带有一种无可奈何的超然派头，就象一个被放逐的皇族看见自己和这批人混在一起感到有点不自在似的。可是，那些被放逐的皇族却玩得非常快活；对他们说来，认识一个电影明星好象是他们一生中最大的愿望。时下的这种风气，把戏剧界人士看作是交际对象，艾略特也看不人眼；但是，有一个退休的女演员就在他的邻近造了一所豪华的住宅，还经常招待宾客。\n部长、公爵、名门闺秀之流在她家里一住就是几个星期。艾略特也成了经常的客人。\n“当然，人色很不整齐，”他告诉我说，“不过，你不喜欢的人用不着理睬。\n她是美国人，我觉得应当帮她撑撑场面。她招待下榻的那些客人发现有人和他们有共同语言，一定会解除不少疑虑。”\n有时候，他显然身体非常不好，使我不得不劝他参加社交活动何必这样积极。\n“老兄，在我这样的年纪，我是经不起掉队的。我在上流社会混了快五十年了，难道我不懂得这里的道理：只要你不经常在重要场合出现，你就会被人家忘记掉。”\n我弄不懂他是否意识到自己当时作了一次多么可悲的自白。我不忍心再嘲笑艾略特了；他在我眼中成了一个极其可怜的人物。他活着就是为了社会交际；宴会和他是息息相关的；哪一家请客没有他，等于给他一次侮辱；一个人溜单是羞耻的；而现在人已经老了，他对受冷落尤其怕得要死。\n夏天就这样过掉。艾略特从里维埃拉的这一头到里维埃拉的那一头忙得团团转，在戛纳吃午饭，在蒙特卡洛吃晚饭，拿出全副本领来适应这一家的茶会或者那一家的鸡尾酒会；而且不管自己多么疲劳，总竭力做得和蔼可亲，谈笑风生。他的内幕新闻来得个多，敢说最近的一些丑事秽闻的细节，除掉直接有关系的人外，谁也不比他知道得更早。假如你说他这种人生无益于时，他会瞠眼望着你毫不掩饰他的骇异。他会觉得你简直愚昧无知。\n四 # 秋天到了。艾略特决定上巴黎住些时候，一半是看看伊莎贝儿、格雷和两个孩子过得怎样，一半是如他说的为了在首都acte de presence[注]。这以后，他预备上伦敦定制些新衣服，顺带看望看望几个老友。我自己计划直接去伦敦，但是，他邀我和他一同坐汽车上巴黎。这样上路很舒服，所以我答应下来，同时觉得自己不妨在巴黎至少也呆上几天。一路上走得很从容，只要哪儿饭菜做得好，就停下来休息。艾略特的腰子有毛病，只饮维希矿泉水，但是，我喝的半瓶葡萄酒，他总坚持要替我挑选；他心地忠厚，尽管自己现在享受不了品酒的乐趣，看见我夸奖酒好，从心里感到快活。他非常慷慨，我要花费许多唇舌才能说服他让我付掉我那一部分的房饭钱。他谈论过去认识的那些大人物，听得人有些生厌，但是这趟旅行还是开心的。我们经过的大部分是乡间，初秋的景色很喜人。在枫丹白露吃了午饭之后，一直到下午才到达巴黎。艾略特把我送到我那家中等的老式旅馆，便绕过街角去里茨饭店。\n我们预先通知伊莎贝儿说我们要来，所以，看见她在旅馆里留交给我的便条，并不感到突然，可是，便条的内容却使我吃了一惊。\n你一到就来。出了大事情了。别把艾略特舅舅带来。看在上帝的份上，请你立刻就来。\n我和别人一样急于想知道究竟，但是，我得洗个脸，换上一件干净衬衫；然后，叫了一辆汽车，开到圣纪尧姆街的公寓。佣人把我领进客厅。伊莎贝儿立刻站了起来。\n“你这半天上哪儿去了？我等了你好几个钟点。”\n时间是五点钟，我还没有来得及回答，管家已经把吃茶的东西送进来。伊莎贝儿双手紧勒，看着管家摆茶具简直不耐烦。我想象不出究竟是怎么回事。\n“我刚到。我们在枫丹白露吃午饭，把时间拖得太长了。”\n“老天啊，他摆得多慢。人都要急疯了！”伊莎贝儿说。\n管家把托盘连同茶壶放在桌上，把糖缸和茶杯放在桌上，然后以一种的确恼人的安详在桌子四周摆上一盆盆的面包、牛油、蛋糕、甜饼。他出去时，随手把门带上。\n“拉里要跟索菲?麦唐纳结婚。”\n“她是谁？”\n“别这样蠢，”伊莎贝儿叫出来，眼睛里闪出怒火。“就是在你带我们去的那家下流咖啡馆里我们碰到的那个喝醉酒的婊子。天知道你为什么把我们带到那种地方去。格雷倒尽了口味。”\n“哦，你是指你们的那个芝加哥朋友吗？”我说，不理会她的不公正责备。\n“你怎么知道的？”\n“我为什么要知道？昨天下午他亲自来告诉我的。从那时候起，我一直恼火到现在。”\n“你何妨坐下来，给我倒杯茶，一五一十地告诉我。”\n“你自己倒。”\n她坐在吃茶桌子对面，一股不耐烦的样子看着我给自己倒茶。我在靠近壁炉的一张小小的长沙发上舒舒服服坐下。\n“我们和他最近不大见面，我是说，自从我们从迪纳尔回来之后；他去迪纳尔待了几天，但是，不肯跟我们住在一起，住在一家旅馆里。他常到海边来，跟两个孩子玩。孩子们喜欢得他要命。我们去圣布里亚克打高尔夫。格雷有一天问他后来见到过索菲没有。\n“‘见到，见过好几次，’他说。\n“‘为什么，’我问。\n“‘她是老朋友嘛’，他说。\n“‘我要是你的话，决不在她身上浪费时间’，我说。\n“他听了微笑一下。你懂得他笑的那种派头，好象认为你的话很好笑，然而，事实上，一点也不好笑。\n“‘可是，你不是我’，他说。\n“我耸耸肩膀，谈到别的上面去了。这件事我从来没有再盘算过。当他上这儿来，告诉我他们要结婚时，你可以想象得出我的震动多大。\n“‘你不可以，拉里，’我说。‘你不可以。’“‘我预备跟她结婚’，他若无其事地说，就好象他要再来点马铃薯似的。\n‘我而且要你好好接待她，伊莎贝儿。’“‘这个要求太过分了，’我说。称疯了。她是坏人，坏人，坏人。’”\n“你怎么会这样想的？”我打断她。\n伊莎贝儿望着我，眼睛里直冒火。\n“她从早到晚吃得烂醉。不管什么流氓要跟她睡觉，她就跟人家睡觉。”\n“这并不意味着她就是坏人。不少有身份的人酗酒，而且喜欢干下流事情。这些是坏习惯，就象咬指甲一样，说它坏，也只能坏到这个地步。我认为，那些说谎、欺骗、残酷的人才是真正的坏人。”\n“你假如偏袒她，我就要你的命。”\n“拉里怎样又碰见她的？”\n“他在电话簿上找到她的住址。他去看了她。她正在生病，这也不奇怪，过的是那种生活。他替她请了医生，并且找个人服侍她。关系就是这样开始的。拉里说她戒了酒；这个蠢货认为她的病已经治好了。”\n“你记得拉里治格雷的头痛吗？他不是把他治好了？”\n“那不同。格雷要自己的病好。她不要。”\n“你怎么知道？”\n“因为我理解女人。一个女人堕落到象她那样，就完结了；是永远不会回头的。\n索菲所以堕落到现在这样，是因为她一向就是这样一种人。你认为她会永远跟拉里吗？当然不会。迟早还是要跟他崩掉。她天生有一种劣根性。她喜欢的是流氓，这种人能给她刺激，她要找的是这种人。她会把拉里的生活搞得一塌糊涂。”\n“看来很有可能，不过，我看不出你能想出什么办法。他又不是糊里糊涂这样做的。”\n“我是没有办法，但是，你有。”\n“我？”\n“拉里喜欢你，他会听你的话。你是唯一能对他施加影响的人。你见多识广。\n你去找他，叫他不要做这种傻事。告诉他这会毁掉他的。”\n“他会干干脆脆告诉我这不关我的事，而且他这样讲完全对的。”\n“可是，你喜欢他，至少你对他是感觉兴趣的，你总不能抄着手站在旁边，看着他把生活搞得一团糟。”\n“格雷是他最要好的朋友，而且认识最早。我并不是说这会有什么帮助，不过。\n我觉得跟拉里谈，格雷最适合。”\n“格雷，哼，”她说，不耐烦的样子。\n“你知道，事情未见得如你设想的那样糟。我有两三个朋友，一个在西班牙，两个在东方，他们都娶的妓女做老婆，结果家庭处得很好。她们都感谢自己丈夫，我是指给了她们生活上保障，而她们对怎样讨男人的欢心，当然都是知道的。”\n“你真罗嗦。你认为我牺牲自己，就是为了让一个疯狂的淫荡女人把拉里抓在手里吗？”\n“你怎样牺牲自己的？”\n“我放弃拉里的唯一一条理由，是我不想影响他的前途。”\n“去你的，伊莎贝儿。你放弃拉里是为了方形钻石和貂皮大衣。”\n话才出口，一盘黄油面包就向着我的头飞来。总算运气，盘子被我接住，可是，黄油面包都落在地板上。我站起身，把盘子放回在桌子上。\n“你把艾略特舅舅的王冠德比盘[注]打破一只，他可不会感谢你。这些当初是替第三代多塞特公爵烧制的，几乎是无价之宝。”\n“把黄油面包拾起来，”她气嘘嘘地说。\n“你自己拾起来，”我说，又在沙发上靠起。\n她站起身，一面生气，一面把散在地上的黄油面包拾起来。\n“你还自称是一位英国上流人士呢，”她恶狠狠地说。\n“不行，这件事情我一生从来没有做过。”\n“滚出去。我再不要看见你了。你的样子叫我厌恶。”\n“很抱歉，因为你的样子一直使我欢喜。可有人告诉过你，你的鼻子跟那不勒斯博物馆里普赛克[注]石像的鼻子一模一样。这座石像是存世的代表少女美的最优秀作品。你的腿很美，又长又有线条，我看见时总是感到诧异，因为你做女孩子时，你的腿很粗而且不匀称。我没法想象你是怎样做到的。”\n“靠坚强的意志和上帝的恩泽，”她怒冲冲地说。\n“可是，你的手当然是你最勾引人的特色。这样纤细瘦削。”\n“我有个印象，好象你觉得我的手太大了。”\n“就你这样的身材来说，不能算大。你使用两只手起来姿势异常美妙，我十分叹服。不管是出自天工，或者人为，总之，你的手的每一动作总给人以美感。它们有时候象花朵，有时候象飞鸟。它们比任何语言更富于表现力。它们就象艾尔?格列柯[注]的画像里的那些手；说实在话，我看着你的手时，想到艾略特原来胡扯你家祖上有一个是西班牙贵族，说不定有道理。”\n她头抬了起来，悻悻然的样子。\n“你讲的什么？我还是第一次听到。”\n我把德?劳里亚娶玛丽王后贵嫔的事告诉她，这是艾略特从母系方面追溯上去的。伊莎贝儿一面听，一面心安理得地端详着自己的长手指和修剪涂染过的指甲。\n“人总是什么人的后代，”她说，接着轻盈一声笑，顽皮的样子把我看看，一点怨气没有了。“你这个鬼儿子，”她又说。\n一个女人，你只要告诉她真情实话[注]，就很容易使她讲理。\n“有时候，我并不怎样真正恨你，”伊莎贝儿说。\n她走来靠着我，在长沙发上坐下，把胳臂和我的胳臂套起，探出身子来要吻我。\n我把面颊避开。\n“我可不要脸上沾上口红，”我说。“你假如要吻我，就吻我的嘴，这是慈悲的上苍指定的地方。”\n她吃吃笑了，用手把我的头转了对着她，嘴唇在我的嘴唇上印上一条细红颜色。\n那滋味很好受。\n“现在你既然这样表示了，也许可以告诉我你是什么打算。”\n“要你出个主意。”\n“我很愿意给你出，不过，敢说你一时接受不了。你只能做一件事，就是勉为其难。”\n她又火起来，抽开胳臂，站起身，一屁股坐在壁炉那一边的一张沙发上。\n“我不愿意眼看着拉里把自己毁掉不管。我要不惜一切阻止拉里娶那个贱货。”\n“你不会成功的。要知道，他是被一种最强烈的最动人心弦的情感迷惑住了。”\n“你难道认为他真正爱上了她？”\n“不是。爱和这种情感比起来，是微不足道的。”\n“什么？”\n“你读过《新约全书》没有？”\n“总算读过吧。”\n“你记得基督是怎样被圣灵引到旷野，禁食四十天的？当时，他感到饥饿，魔鬼就来找他，对他说：你若是上帝的儿子，可以命令这些石头变成面包。但是，基督拒绝了他的引诱。后来魔鬼就教基督站在殿顶上，对基督说：你若是上帝的儿子，就跳下去。因为天使受命照应你，会将你托着。但是，基督又拒绝了。后来魔鬼又把他带上一座高山，指给他看世上的万国，说你若俯伏拜我，我就把这一切都赐给你。但是基督说：滚开吧，撒但。根据心地善良单纯的马太的记载，故事的结尾就是这样。但是，故事并没有完。魔鬼很狡猾，他又来找基督，对他说：如果你愿意接受耻辱，鞭挞，戴上荆棘编的冠，让人家把你钉死在十字架上，你将使人类得救，因为为了朋友牺牲自己的生命，是人所能表现的最伟大的爱。基督中计了。魔鬼笑得肚子都痛了，因为他知道环人会借了为人类赎罪的名义来干坏事。”\n伊莎贝儿忿然瞧着我。\n“你从哪儿听来的这段话。”\n“哪儿也没有。是我临时诌出来的。”\n“我觉得这段故事很愚蠢，而且亵读神圣。”\n“我只想向你指出，自我牺牲是压倒一切的情感，连淫欲和饥饿跟它比较起来都微不足道了。它使人对自己人格作出最高评价，驱使人走向毁灭。对象是什么人，毫无关系；值得也可以，不值得也可以。没有一种酒这样令人陶醉，没有一种爱这样摧毁人，没有一种罪恶使人这样抵御不了。当他牺牲自己时，人一瞬间变得比上帝更伟大了，因为上帝是无限和万能的，他怎么能牺牲自己？他顶多只能牺牲自己唯一的儿子。”\n“老天啊，你真唠叨，”伊莎贝儿说。\n我不理会她。\n“当拉里被这种情感牢牢掌握着时，你想跟他讲通常的道理，或者劝他小心从事，会对他有影响吗？你不知道他这多年来在追求什么。我也不知道，我只是猜想。\n但是，这许多年的辛勤收获，所有这些年积累的经验，现在都敌不过他的欲望——啊，岂止是欲望，是一种急切的、如饥似渴的压迫：去救一个他过去认识的清白女孩子而现在已成为荡妇的人的灵魂。我认为你是对的，我认为他是在做一件没有指望的事；以他那样敏感，他将要象受天罚的人一样吃足苦头；他的毕生事业，不管那是什么，将永远完成不了。卑鄙的帕里斯一箭射中阿喀琉斯的脚后跟，使他送了命。[注]拉里恰恰缺少这点狠毒，而这点狠毒便是圣徒为了取得正果，也是少不了的。”\n“我爱他，”伊莎贝儿说。“上帝知道，我一点不要求他什么。我一点不指望他什么。谁也不会象我爱他那样毫无自私之心。这底下的日子他可着实不好过呢。”\n她开始哭起来。我觉得哭哭对她有好处，所以不加劝阻。我无意间脑子里出现一个想法，借此消磨时间。一个人在想着玩。我敢大胆断言，魔鬼目睹基督教挑起的那些残酷战争，教徒对教徒进行的那些迫害和刑罚，以及残忍、虚伪、褊狭，一定对这本帐感到心满意足。而且当他想起基督教给人类背上了一个原始罪恶的痛苦包袱，使美丽的满天星斗昏暗下来，给世上那些供人们享受的赏心乐事投下一道邪恶的阴影，他准会咯咯笑起来，一面咕哝着：活该受这报应，这个鬼。\n不一会，伊莎贝儿从手提包里取出一块手帕和一面镜子，看看自己，小心地指指眼角。\n“你他妈的很同情，是不是？”她忿然说。\n我若有所思地望着她，但不答话。她在脸上扑扑粉，涂上口红。\n“你刚才说你猜想他这多年来在追求什么东西。你这是什么意思？”\n“告诉你，我只能猜测，而且有可能完全错了。我觉得他是在寻求一种哲学，也可能是一种宗教，一种可以使他身心都获得安宁的人生准则。”\n伊莎贝儿把我的话盘算了一下，叹口气。\n“你认不认为奇怪，一个伊利诺斯州麻汾镇的乡下孩子会有这样的想法？”\n“路得?伯班克出生在马萨诸塞州的农场，会种出一种无核的橘子，亨利?福特出生在密执安州的一个农场，会发明一种小汽车，拉里并不比他们更奇怪。”\n“可是，那些都是实用的东西。是在美国传统之内的。”\n我笑了。\n“世界上还有什么比学会生活得最好更实用的吗？”\n伊莎贝儿作了一个没精打采的姿势。\n“你要我怎么办？”\n“你不想完全失掉拉里，是吗？”\n她点头。[注]“你知道拉里是非常忠实的：你假如不睬他的老婆，他也不会睬你。你如果懂道理的话，就得跟索菲交朋友。你得忘掉过去，在有可能时，尽量对她好。她要结婚了，我想她要买些衣服。为什么你不提出陪她去买。我想她准会喜出望外。”\n伊莎贝儿眼睛眯起听我说。她好象很注意听我的话。有这么一会儿，她在盘算，可是，我猜不出她脑子里在想些什么。后来她使我吃了一惊。\n“你请她吃午饭好吗？在我昨天给拉里那顿发作之后，我请是相当尴尬的。”\n“我如果请的话，你肯循规蹈矩吗？”\n“象个光明天使，”她带着最魅人的微笑回答。\n“我立刻就敲定。”\n屋内有电话。我很快查到索菲的电话号码；经过一段通常的耽搁——凡是使用法国电话的人，都得耐心耐性——我接上了她。自己报了名字。\n“我刚到巴黎，”我说，“就听说你跟拉里要结婚了。我向你道喜。希望你们过得非常幸福。”伊莎贝儿站在我身边，把我胳臂上的肉狠狠拧一下，我几乎叫了出来。“我在巴黎只呆很短一段时间，不知道你跟拉里后天能不能到里茨饭店和我一起吃午饭。我还要请格雷、伊莎贝儿和艾略特?谈波登。”\n“我来问问拉里。他就在这儿。”停了一下。“好的，我们很高兴来。”\n我讲定了时间，说了一句客气话，放下耳机。这时，我瞥见了伊莎贝儿眼睛里有种表情，使我不放心起来。\n“你在想什么？”我问她。“我不大喜欢你脸上的神情。”\n“对不起；我还以为你真正喜欢我的就在这种地方。”\n“你会不会肚子里面藏了什么坏主意，伊莎贝儿？”\n她眼睛睁得多大的。\n“我向你保证没有。事实上，我急切想看见拉里使索菲改邪归正之后，看上去是什么样子。我只希望她上里茨饭店来的时候，不要搽得一脸的胭脂花粉。”\n五 # 我的小宴会开得还不环。格雷和伊莎贝儿先到；拉里和索菲?麦唐纳五分钟之后到。伊莎贝儿和索菲亲热地互吻，伊莎贝儿和格雷又祝贺她订婚。我瞥见伊莎贝儿的眼睛迅速地把索菲的外表打量了一下。索菲的样子使我吃惊。以前我在拉白路那家下等咖啡馆看到她时，她搽得一脸脂粉，头发染成棕红色，穿一件鲜明的绿衣服，尽管神情放荡而且吃醉了，但是，带有一种挑衅的味儿，甚至有股骚劲儿；可是，现在，看上去则很寒伧，虽则比伊莎贝儿肯定要小一二岁，但是，样子比她老多了。头仍旧象上次那样傲然翘着，但不知道什么缘故，却是一副可怜相。她已经让头发恢复原来的颜色，染过的头发和新长出来的头发看上去邋里邋遢的。除掉嘴唇涂了红色以外，脸上什么脂粉都不施。皮肤粗糙，而且带有不健康的苍白色。我记得她的眼珠是鲜明的绿色，可是，现在变得暗淡无光了。身上穿一件红衣服，显然是新买的，还配了一色的帽子、鞋子和手提包；我并不自命懂得女人应当怎样穿衣服，但总觉得有点刺眼，而且在今天这样场合稍嫌过分讲究一点。胸口戴了一件很触眼的人造宝石的首饰，就是人们在雷奥里路买到的那路货色。伊莎贝儿穿一件黑绸子衣服，挂一串人工培养的珠项链，戴一顶很漂亮的帽子；和她一比，索菲显得很低气，更谈不上派头。\n我叫了鸡尾酒，不过拉里和索菲都拒绝喝。后来艾略特来了。可是，他穿过那间辽阔的厅堂走来时，却被一个接一个的熟人拦住，跟这个拉手，吻那个的手。他的举止就好象里茨是开在他家里的，而他正在向自己客人的惠然光临表示衷心感谢。\n我们把一切都瞒着他，只告诉他索菲的丈夫和孩子在一次车祸中丧命，现在要和拉里结婚。当他终于走到我们面前时，他使出自己最拿手的一套，风度翩翩地向这对未婚夫妇祝贺。大家一同走进餐厅；由于我们是四男二女，所以我叫伊莎贝儿和索菲就一张圆桌面对面坐下，索菲的两旁边坐着格雷和我。桌子很小，谈话大家都听得见。午餐我已经预先订好，管酒的侍役这时把酒单拿来。\n艾略特说，“老兄，你酒一点不在行。阿尔勃特，把酒单给我。”他翻着酒单，一面说。“我自己只喝矿泉水，但是，我不能容忍别人喝次等酒。”\n他跟管酒的侍役阿尔勃特是老朋友。经过热烈的讨论后，两人决定我应当叫什么酒请客人喝。然后他转向索菲。\n“你们预备上哪儿去度蜜月，亲爱的？”\n他瞧了她衣服一眼，眉毛几乎令人觉察不到地抬了一下，使我看出他对这件衣服看不上眼。\n“我们预备去希腊。”\n“我想去希腊总有十年了，”拉里说，“可是，不知道什么缘故，总是去不成。”\n“这个季节应当是风光最好的时候，”伊莎贝儿说，表示很起劲。\n她记得，我也记得，当初拉里要跟她结婚时，提议带她去的就是希腊。对拉里说来，去希腊度蜜月好象已经成为固定的了。\n谈话进行得并不怎样容易，如果不是亏了伊莎贝儿，我这个主人就会觉得事情很难办。她表现得非常之好。只要讲话有中断的危险，而我在开动脑筋想找个新话题来谈时，她就插进些轻松的话。这使我很感激。索菲简直不大开口，只在有人跟她谈话时，方才勉强讲几句。她神气索然。你会说这个人已经是个半死人了；我肚子里在盘算拉里是不是约束她过头了，使她简直受不了。我猜想她不但酗酒，而且吸毒；这倘然属实，一下子把这些戒掉准会使她的人垮掉。有时候，我瞥见他们相互对看一眼。拉里的神情含有温存和鼓励，索菲的神气带有恳求，使人感到恻然。\n格雷天性忠厚，可能本能地觉察到我猜测的情况，所以跟索菲谈起拉里怎样治好那个使他成为废人的头痛病，接着又告诉她他是怎样离不开拉里，感激拉里。\n“现在我一点病都没有了，”他继续说。“只要有一天找到事，我就会重新工作起来。现在我有几件事都在接头，希望不久能够敲敲定。嘘，回国去真是开心。”\n格雷完全出于好意，可是，他讲的那些话也许不大策略；因为照我的想法，拉里用来治愈索菲酗酒的痼疾的，可能用的是治愈格雷的同一的暗示术（在我看，就是这个法子）。\n“你现在一点不发头痛了吗，格雷？”艾略特问。\n“三个月来从没有发过；如果我感到它要发作了，我就立刻抓着我的护身符，我就好了。”他说着从口袋里摸出拉里给他的那块古钱。“这是我的无价之宝。”\n午饭已毕，上咖啡了。管酒的侍役过来问要不要来点甜酒[注]。我们全拒绝了，只有格雷说他要一杯白兰地。瓶子拿来时，艾略特坚持要看看是什么牌子。\n“行，我认为可以喝。对你没有害处。”\n“您来一小杯吗？”侍役问。\n“唉，我现在是禁酒了。”\n艾略特详详细细告诉侍役，自己的腰子有毛病，医生不允许他喝酒。\n“喝一点苏布罗伏加对您不碍事。这酒有名的治腰痛。我们刚从波兰运来一批。”\n“真的吗？这种酒近来很难得。把瓶子拿来我看看。”\n管酒的侍役是个身材魁梧、神气十足的家伙，脖子绕了一根长长的银项链，跑去拿酒瓶。艾略特向我们解释说这是波兰酿制的一种伏特加酒，但在种种方面比伏特加高级得多。\n“我住在拉德齐威尔斯家里参加打猎时，常饮这种酒。你们应当瞧见那些波兰亲王喝起这种酒来的派头；成大杯地喝，一点不动声色，我这话丝毫没有夸张。当然都是些金枝玉叶；一举一动完全是贵族味儿。索菲，你非得尝一下这个酒不可；伊莎贝儿，你也要尝。这个机会不能轻易放过。”\n管酒的侍役把酒瓶拿来。拉里、索菲和我都拒绝了，但是，伊莎贝儿说她愿意试试。我感到诧异，因为她一向酒喝得很少，而今天她已经喝了两杯鸡尾酒和两三杯葡萄酒了。侍役倒了一小杯淡绿色的甜酒，伊莎贝儿擎起来闻闻。\n“哦，多香啊！”\n“是不是？”艾略特说。“香味是因为里面泡了有一种药草；酒的味道好也是这个缘故。我也陪你喝一点点。偶尔一次对我不会有什么害处。”\n“酒味真美，”伊莎贝儿说。“象甘露一样。我从来没有喝过这样美的酒。”\n艾略特把杯子举到唇边。\n“唉，这酒使人想起已往的日子。你们从没有在拉德齐威尔斯家住过的人，就不懂得什么叫生活。那个场面真大啊。封建的场面，懂吗？你简直觉得自己象置身在中世纪。上车站来接你的是一辆六匹马驾驶的车，还有驭者骑在马上。吃饭时，每个人后面都站着一个穿制服的男佣人。”\n他继续形容那家府邸的阔绰华贵，以及那些筵席的豪华；我忽然起了一阵疑心——当然是无足轻重的——好象这件事整个儿是艾略特和那个管酒侍役商量好的，让艾略特借这机会大谈特谈一下这个三族的豪华排场，以及他在他们的宫堡作客时结识的那一大堆波兰贵族。要阻止他不谈是不可能的。\n“再来一杯，伊莎贝儿？”\n“哦，我不敢来了。不过酒实在太美了。我很高兴知道有这种酒；格雷，我们得想法买几瓶。”\n“我叫他们送几瓶到公寓去。”\n“呀，艾略特舅舅，你肯吗？”伊莎贝儿兴孜孜地说。“你待我们太好了。格雷，你非尝一下不可；它问上去就象新割的稻草和春天的花草，象百里香和薰香草，尝上去一点不辣，非常适意，就象在月光下面听音乐。”\n这样呱啦呱啦地前言不搭后语，不象伊莎贝儿的为人，我疑心她是不是有点醉了。筵席散了，我同索菲握手道别。\n“你们几时结婚？”我问她。\n“再下个星期。我希望你能来参加婚礼。”\n“恐怕我那时候不在巴黎。我明天就去伦敦。”\n当我和其他客人握别时，伊莎贝儿把索菲拉到一旁，跟她谈了几句话，就转身向格雷说：“哦，格雷。我要等一等回去。摩林诺时装店有一个时装展览，我要带索菲去看。她应当看看最新的衣服式样。”\n“我很愿意。”索菲说。\n我们分手了。当晚我带苏姗?鲁维埃去吃晚饭，第二天早上就动身去英国。\n六 # 两个星期后，艾略特抵达克拉里奇饭店；之后不久，我就便道去看他。他已经给自己定制了几套衣服，并且有点不厌其烦地详细告诉我他挑选的什么料子，而且为了什么理由。当我终于能插话时，我就问他拉里的婚礼是怎样举行的。\n“没有举行，”他冷冷地说。\n“你这话是什么意思？”\n“婚礼要举行的前三天，索菲失踪了。拉里到处寻她。”\n“真是怪事！他们吵嘴了吗？”\n“没有。根本谈不上。什么都准备好了。我还担任把新娘交给新郎的角色。他们预备婚礼举行后立刻去搭东方快车。你现在问我，我觉得拉里做得完全不对头。”\n我猜想伊莎贝儿已经把什么都告诉他了。\n“究竟是怎样一回事情？”我问。\n“好吧，你记得那天你请我们在里茨吃午饭之后，伊莎贝儿带索菲上摩林诺去。\n你记得她穿的那件衣服吗？不象样子。你可注意到两个肩膀？一件衣服剪裁得好不好，你只要看肩膀合身不合身就行了。当然，可怜的孩子，摩林诺的价钱是她付不起的，可是，伊莎贝儿，你知道她是非常慷慨的，伊莎贝儿打算送她一件衣服，使她至少在结婚那一天有件象样的衣服穿。总之，长话短说，有一天，伊莎贝儿约索菲三点钟上她公寓来，一同去服装店最后试样。索菲来了，但是不幸的是伊莎贝儿要带两个孩子上牙科医生那里去一趟，四点钟后方才到家，那时候，索菲已经走了。\n伊莎贝儿以为她等得不耐烦，自己去摩林诺了。她立刻赶到摩林诺去，但是，索菲没有来过。最后，她只好放弃，自己又赶回家。他们晚上要在一起吃饭；拉里晚饭时来了，伊莎贝儿问他的第一件事就是索菲哪里去了。\n“他不懂得什么原因，就打电话到她公寓，但是，没有人接，因此拉里说他要亲自去找她。他们把晚饭尽量延迟，但是，两个人都没有来，他们只好自己吃了。\n当然你知道你们在拉白路碰见索菲之前，她过的是什么样的生活；你把他们带到那种地方去是一件非常不幸的事件。总之，拉里整整一夜把她去的那些地方跑遍了，但是，哪儿也找不到她。他一次又一次回到她的公寓去，但是，看门的人说她没有回来过。他花了三天工夫找她的下落。她就这样失踪了。第四天，他又上她的公寓去。看门人告诉他索菲回来过了，打了一只提包，叫一辆出租汽车走了。”\n“拉里是不是很难过？”\n“我没有见到他。伊莎贝儿告诉我他相当不好受。”\n“她没有写信来或者留下什么字条吗？”\n“什么都没有。”\n我考虑了一下。\n“你对这件事情什么看法？”我说。\n“老兄，跟你的看法完全一样。她熬不下去了；所以又开了酒戒。”\n这摆明是这样，但尽管如此，还是很古怪。我不懂得为什么她偏偏选在这个时候溜掉。\n“伊莎贝儿怎样看的？”\n“当然她很难受，不过，她是个懂事的女子，所以，她告诉我，她认为拉里娶这种女人是不会有好结果的。”\n“拉里呢？”\n“伊莎贝儿对他很体贴。她说难办的是他不肯跟她谈这件事。他会恢复的，你懂得；伊莎贝儿说，他从来就没有爱上索菲，他娶她只是出于一种不正常的怜惜心理。”\n我能够想象伊莎贝儿对事态转变得这样如她的心愿，是会表现得非常坚强的。\n我敢肯定，下次我见到她时，她准会向我指出她早就知道会是什么结局了。\n可是，我几乎在一年以后才重又见到伊莎贝儿；那时候，我可以把索菲的情形说给伊莎贝儿听，让她仔细想一想，但是，鉴于当时的处境，我不”想跟她谈。我在伦敦一直住到圣诞节，然后直接回到里维埃拉自己家里，在巴黎没有停留。我着手写一部小说，这以后几个月都闭门谢客。艾略特有时候见见面。他的健康显然很环，但是尽管如此，他还坚持参加社交活动，真使人看了替他难受。他对我很不开心，因为我不肯从三十英里外开车子来参加他继续举行的定期宴会，认为我喜欢坐在家里工作太自命不凡。\n“老兄，这个季节比往年特别热闹，”他告诉我。“象你这样把自己关在屋子里，外面什么活动都不参加，简直是犯罪。而且你为什么选择里维埃拉那段完全过了时的地区居住，我就是活上一百年也弄不懂。”\n可怜的、可爱的、可笑的艾略特；很显然，他是活不到这么大年纪的。\n到了六月，我的小说初稿已经完成，觉得自己应当休息一下，所以打了一只包，乘上那只夏天常把我们开到福斯湾洗海水浴的单桅帆船，并且沿着海岸向马赛驶去。\n由于风时起时歇，所以大部分时间我们都把附装的马达一路上轧轧开着。我们在戛纳港过了一夜，在圣马克昔姆又过了一夜，在萨纳里过了第三夜。后来就到达土伦。\n这个海港我对它一直有好感。法国的舰队赋予它一种既浪漫而又亲近的气息，而且在那些老式街道上闲逛，从不使人厌倦。我能够在码头上留连几个钟点不走，看那些上岸休假的水兵一对一对地或者带着女友闲逛，平民来回溜达着，就好象除掉享受欢乐的阳光外，世界上没有其它的事可做似的。由于所有这些船舶和渡船都是把扰攘的人群带往这个大海港的各个据点去，所以，土伦给你的印象是大千世界各种活动的一个终点站。当你坐在一家咖啡馆里，眼睛被天光和海水照耀得有点眼花缭乱时，你的幻想就会将你带往金光灿烂的海角天涯。你坐一条狭长的船在太平洋上一座珊瑚岛上登陆，周围长着椰子树；你走下舷梯，到了仰光的码头上，坐上一部黄包车；你的船向太子港疾驶着，你从上甲板察看那些嘈杂的、做着手势的一群黑人。\n帆船在上午较晚时到达。我于下午三点左右上岸，沿着码头走去，看看店铺，看看身边经过的行人，看看坐在咖啡店天篷下面的客人。忽然间，我看见索菲；在同一时候，她也看见了我。她笑着向我招呼。我停下来和她拉手。她一个人靠一张小台子坐着，面前放一只空玻璃杯。\n“坐下来喝杯酒，”她说。\n“你跟我一同喝一杯，”我说，同时在一张椅子上坐下。\n她穿了一件法国水手穿的蓝白条子紧身衣，一条大红裤子，脚上穿的凉鞋，露出涂了趾甲的大足趾。她没有戴帽子，头发剪得短短的而且烫过，淡金色简直近于白银。和我们在拉白路碰见她时一样浓装艳抹。从桌上的盘子可以看出她已经饮过一两杯，不过人还清醒。她对我的态度还算亲热。\n“巴黎的那些人好吗？”她问。\n“想来都还好。自从那天我们一起在里茨饭店吃午饭之后，我还没有碰见过谁。”\n她从鼻孔里喷出一大股烟，大笑起来。\n“我总算没有跟拉里结婚。”\n“我知道。为什么？”\n“亲爱的，事到临头一想，我觉得我不能让拉里做耶稣基督，我来做抹大拉的马利亚[注]。不行。先生。”\n“你为什么到最后关头改变了主意？”\n她嬉皮笑脸地望着我。头傲然抬起一点，小奶子，狭窄的腰身，加上这身打扮，她看上去简直象个顽童。可是和我上次看见的她一比，穿着那件红衣服，那种又漂亮又多气的使人看了不起劲的派头，不能不说她现在要吸引人得多。脸和脖子都被太阳晒黑了，虽则皮肤的棕色把两颊搽的胭脂，眉毛涂的黑色衬得更加刺眼，但是，这种俗气所产生的效果也有其妩媚的地方。\n“要不要我告诉你？”\n我点点头。侍役把我叫的啤酒和她叫的白兰地苏打送过来。她用手里刚吸完的粗丝卷烟燃起另外一支。\n“我那时有三个月没有喝过一杯酒。没有抽过一次烟。”她看见我微微吃惊的神情，不禁大笑。“我不是说香烟。是鸦片。我觉得难受之极。你知道，有时候，我一个人时，我简直要把房子叫塌了；我常说，‘我支持不下去了，我支持不下去了。’我跟拉里在一起时，还不怎样难受，可是他一不在，那简直是地狱。”\n我正在看着她；当她提到鸦片时，我就更加仔细地打量她起来，看出她的瞳孔缩成针眼一样大，这证明她现在还在抽。她的眼珠绿得骇人。\n“我的结婚礼服是伊莎贝儿送的。这衣服不知道现在怎样了。真美。我们讲好我来找她，然后一同去摩林诺。这一点我是服帖伊莎贝儿的，她对衣服实在内行。\n我到了她的公寓，那个佣人告诉我，他的女主人急急忙忙把琼带去看牙医生了，留下了话，说她即刻就回来。我走进客厅。桌上还放着咖啡壶和杯子，我问那人能不能给我来一杯咖啡。那时我靠着打气的只有咖啡了。他说替我烧点来，同时把吃剩的咖啡壶和杯子拿走，在盘子里留下一瓶酒。我看了一下，原来就是你们大家在里茨饭店谈论的那个波兰玩意儿。”\n“苏布罗伏加，我记得艾略特说他要送几瓶给伊莎贝儿的。”\n“你们全盛夸酒非常之香，引起了我的好奇心。我打开塞子，闻上一闻。你们讲的一点不错；酒闻上去的确他妈的非常之香。我点起一支香烟。过了几分钟，那人把咖啡送进来。咖啡也很好。人们都大夸特夺法国咖啡好，让他们去夺吧；我还是喜欢喝美国咖啡。这是我在法国唯一想念的东西。可是，伊莎贝儿的咖啡烧得不坏，我正感觉无聊，吃了一杯咖啡，人觉得好些。我望望桌上放的那瓶酒。真是馋人呀，可是，我说，滚他妈的蛋，我决不想它，于是又点起一支烟。我想伊莎贝儿就会来了，可是，她并不来；我变得神经非常不宁起来；我最恨等人，而且屋子里没有什么可以翻阅的东西。我在屋子里开始走动起来，看看墙上的画，但是，眼睛始终离不开那个混蛋的酒瓶。后来我想，我只倒一杯出来，看看它。它的颜色确实好看。”\n“淡绿色。”\n“对了。怪吧，它的颜色就跟它的味道一样。那种绿色就象你有时候在一朵白玫瑰心子里看见的那样。我非得看看它的味道是不是也是这样不可，我想尝一下对我不会有什么影响；我只打算呷一口，接着，我听见一声响，我当伊莎贝儿来了，就一口把酒喝掉，因为我不愿意被她撞见。但是，伊莎贝儿并没有来。天哪，我自从戒酒以后从来没有觉得这样好受过。我的确开始觉得人又活络起来。那时候，如果伊莎贝儿进来，我想我现在和拉里已经结过婚了。我不懂得那将会是怎样的结果。”\n“她没有进来吗？”\n“没有，她没有来。我很生她的气。她是什么了不起的人，叫我这样等她。接着，我看见杯子里酒又满了；我想我一定是无意中把酒斟上，不过，信不信由你，我并不记得我曾经倒过。可是，再把酒倒回去太没有意思了，所以我就把酒喝掉。\n没有话说，酒实在太美了。我觉得自己变了个人；觉得自己在大笑，三个月来，我从来没有这样感觉过。你可记得那个老屈死说，他在波兰看见有人用大杯子灌这种酒，但是神色不动吗？哼，我想，一个波兰狗崽子喝得了，我也喝得了，管他妈的索性喝它个痛快，所以我把剩下的咖啡倒在壁炉里，把杯子斟得满满的。什么母亲的奶是天下最美的，完全胡扯。这底下我就记不清楚是怎么一回事，不过，敢说等到我喝得尽兴之后，瓶子里已经所剩无几了。接着，我想到我要在伊莎贝儿进来之前溜掉。她几几乎撞上我。我才走出前门，就听见琼妮[注]的声音。我奔上公寓的楼梯，等她们全都进了自已公寓关上门之后，再奔下来，上了一辆出租汽车。我叫车夫死命地开，他问我上哪儿去，我向他哈哈大笑。人就象成佛成仙一样。”\n“你回自己的公寓没有？”我问，明知道她没有回去。\n“你把我当作什么样的大傻瓜？我知道拉里会来找我。那些我常去的地方一处也不敢去，所以我去了哈基姆那里。我知道拉里决不会在那里找到我。再者，我还要过一下烟瘾。”\n“哈基姆是什么地方？”\n“哈基姆。哈基姆是个阿尔及利亚人，而且只要你付得起钱，总能够替你弄到鸦片。他同我是很要好的朋友。你要什么他都能给你弄到，不管是男孩子，是男人，是女人，或者黑人。他手边总有半打阿尔及利亚人随叫随到。我在那里住了三天。\n我不知道搞了多少男人。”她开始吃吃笑起来。“各式各样的，和各种肤色的。总算把损失掉的时间捞回来。可是，你知道，我害怕起来了。我觉得在巴黎住下去不安全。我怕拉里会找到我，而且我的钱已经花光，那些狗娘养的，你得付钱，才跟你睡觉，所以，我就出来了，回到公寓里，给看公寓的女人一百法郎，告诉她如果有人来找我，就说我已经离开了。我把行李打好，当晚就坐火车来到土伦。一直到抵达这里之后，我的心才算放了下来。”\n“你从此就没有离开吗？”\n“一点不错，而且我要一直待下去。这儿的鸦片烟要多少有多少。那些水手从东方带来的，上等货色，不是他们在巴黎卖给你的那种烂狗屎。我在旅馆里有一间房间。你知道，商业与航海旅馆。晚上你走进旅馆，过道里全是鸦片烟味。”她放荡地唤一下鼻子。“又香又刺鼻子，你知道客人们就在自己房间里抽，使你有一种亲切之感。他们而且不管你带什么人进来睡觉。早上五点钟时，他们来敲敲你的门，喊那些水手上船去，所以，你只管放心大胆睡觉。”接着，并不改换话题，就说：“我在沿码头的一家铺子里看见一本你的书；早知道要碰见你，我就会买下来，叫你签个名。”\n刚才经过书店时，我曾经停下来看看橱窗，注意到在别的新书里面有一本我的小说的法译本，是新近出版的。\n“我想，你看了不会觉得好玩的，”我说。\n“为什么不？你知道，我是能够看书的。”\n“而且你还能够写，我相信。”\n她迅速地看我一眼，大笑起来。\n“哎，我小时候常常写诗。想来一定不象样子，但是，我觉得很好。我想是拉里告诉你的。”她迟疑了一下。“人生反正是他妈的，可是，如果能找些乐儿，而你不去享受，那你就是天大的傻瓜。”她把头挑战性地向后一甩。“我如果买下那本书，你肯在上面写几个字吗？”\n“我明天就离开。你真要的话，我买一本送你，留在你旅馆里。”\n“那太好了。”\n就在这时候，一条海军汽艇开到码头上，汽艇里跑出一群水手来。索菲狠狠看了那些水手一眼。\n“那是我的男朋友。”她向其中一个挥一下胳臂。“你可以请他喝一杯酒，然后最好溜掉。他是个科西嘉人，而且和我们的老朋友耶和华[注]一样妒忌。”\n一个年轻人向我们走来，看见我时迟疑了一下，但是，索菲作了一个打招呼的姿势，就走到我们桌子面前。他很高，黑黑的，胡子刮得很干净，很漂亮的深色眼睛，鹰钧鼻子，乌黑的鬈发。样子看上去不到二十岁。索菲介绍我是她童年时代的一个美国朋友。\n“不会讲话可是漂亮，”她向我说。\n“你喜欢他们粗暴，是不是？”\n“越粗暴越好。”\n“总有一天会割你的脖子。”\n“完全意想得到，”她咧开嘴笑。“早死早好。”\n“人要讲法文，是不是？”水手厉声说。\n索菲转身向他一笑，笑里带有一点调侃味道。她说得一口流利的俚俗法语，美国音很重，但是，这样一来，却使她平日使用的下流猥亵语言带有一种滑稽腔调，使人忍俊不禁。\n“我告诉他你很漂亮，但是怕你不好意思，我用英语讲了。”[注]她对我说。\n“他很棒。肌肉就象个拳击手。你摸摸看。”\n这些恭维话使水手的愠怒消失了，带着满意的微笑弯起胳臂，把二头肌鼓出来。\n“你摸摸看，”他说。“来吗，你摸摸看。”\n我摸了一下，表示相当钦佩。我们拉呱了几分钟。我付了酒帐，站起身来。\n“我得走了。”\n“见到你很高兴。别忘记那本书。”\n“不会的。”\n我和两个人都拉了手，漫步走开。途中经过书店时，买下那本小说，写上索菲和我的名字。接着，脑子里忽然来了一个念头，但是，想不出什么别的好写，我把龙沙[注]那首精美小诗的第一句写在上面（这首诗是所有选集里都有的）：美人儿，我们去看看那玫瑰花……我把书留在索菲的旅馆里。旅馆就靠近码头，我常住在那里，因为天一亮，人就被呼唤值勤人上班的喇叭吵醒；那时太阳朦胧照在港里平静的水上，犹如给那些幽灵似的舰只蒙上一层尸衣，十分娇美。第二天，我们开往卡锡，我要在这儿买点葡萄酒，然后开到马赛；在马赛换了一只我们预订的新船。一星期后，我回到家里。\n七 # 我看到艾略特的佣人约瑟夫的一封信，告诉我艾略特卧病在床，很想见见我，所以，第二天，我就开车子上昂第布去。约瑟夫在领我上楼见他主人之前，告诉我艾略特生了一场尿毒症，他的医生认为情形很严重。他现在已经熬过了，正在复原中，但是，腰子有病，要完全康复是不可能的。约瑟夫跟随艾略特四十年，对他很忠心，可是，尽管表面显得难过，人们不难看出，和他这个阶层的许多成员一样，当主人家遭到灾难时，他暗地里却在庆幸。\n“可怜的先生，”他叹口气。“他当然有他的怪癣，不过，基本上为人还是好的。人迟早总是要死的。”\n他的口气就好象艾略特快要断气了。\n“我敢说你的赡养费他早已安排好了，约瑟夫，”我不客气地说。\n“人不能不指望这个，”他哀叹地说。\n当他把我领进艾略特的卧房时，我没有想到艾略特竟然很活跃。脸色苍白，样子看上去很老，但是，兴致很好。胡子刮过，头发梳得很整齐。身上穿的是淡青色绸睡衣，睡衣口袋上绣着他姓名的缩写字母，字母上面是他的伯爵冠饰。在翻过来的被单上，也绣有这些字母和冠饰，并且大得多。\n我问他觉得怎么样。\n“非常之好，”他兴孜孜地说。“不过是暂时欠安。再过几天，我就会起来了。\n我约了第米特里大公星期六和我共进午餐，而且告诉我的医生，无论怎样，到那时候，要把我治好。”\n我陪他坐了半小时，出来时告诉约瑟夫，如果他的病复发，就来告诉我。一个星期后，我去赴一个邻居家里的午宴，没想到艾略特也在座。他穿着赴宴的衣服，脸色象个死人。\n“你不应当出来，艾略特，”我跟他说。\n“噢，这是什么意思，老弟。佛里达请了玛法尔达公主。我认识意大利王室已有多年，从可怜的路易莎在罗马任上的时候起，而且我总不能拆佛里达的台吧。”\n我不知道究竟应当佩服他的不屈不挠精神，还是可怜他在偌大的年纪而且得了不治之症之后，还对社交生活这样热衷。你决不会想到他是一个病号。就象一个快死的演员，脸上一涂了油彩，踏上舞台，登时忘掉身上的病痛一样，艾略特也以他一贯的自如担当他的潇洒请客的角色。人极端和蔼可亲；对于适当的人能照应得使人洋洋得意；讲话刁钻刻薄，非常逗人，这是他的拿手好戏。我好象从来没有看见他使出这样浑身解数过。当那位殿下走后（而且艾略特鞠躬的那种翩翩风度，既表现了对公主的崇高身份的尊敬，又表现了一个老人对一个年轻美丽女子的景慕，真值得一看），无怪乎耳朵里听见我们的女主人跟他说，他是这次宴会的生命和灵魂。\n几天后，他又躺在床上了。他的医生禁止他走出房门。艾略特简直冒火。\n“偏偏在这个时候，真是糟糕透了。今年这个季节特别热闹。”\n他滔滔不绝地谈出一大串知名人士今年夏天都要到里维埃拉来。\n我每隔三四天都去探望他一次。他有时候躺在床上，有时候穿一件华丽的晨衣坐在一辆两轮推车上。这种晨衣他好象备有无限若干件，因为我从来没有看见他穿过同样的。有一次去探望他——时间已是八月初——发现他异乎寻常地沉默。约瑟夫领我进屋子时告诉我，他人好象好了一点；看见他这样没精打采，我有点诧异。\n我把海边听来的一些花絮告诉他，想使他高兴一点，但是，他显然不感兴趣。他双眉微蹙，脸上有种愠怒的表情，这在他是少见的。\n“你去参加爱德娜?诺维马里的宴会吗？”他突然问我。\n“不，当然不。”\n“她请了你没有？”\n“里维埃拉的每个人她都请。”\n诺维马里亲王夫人是一个美国巨富，嫁了一个罗马亲王，不过，不是意大利那种一钱不值的普通亲王，而是一个伟大家族的族长，一个雇佣兵队长的后代；这位雇佣兵队长在十六世纪就为自己割了一大片采邑。诺维马里亲王夫人已经六十岁，是个寡妇。由于法西斯政权索取她的美国进款太多了，她很不乐意，所以离开意大利，自己在戛纳山背面一块漂亮的地产上盖了一所佛罗伦萨式的别墅。她从意大利运来大理石作为她那些大客厅墙壁的镶边，从外国请来画家给她画天花板。她的藏画，她的铜像都异常精美；连艾略特向来不喜欢意大利家具的人，也不得不承认她的家具十分华贵。那些花园都很秀丽，一座游泳池的造价抵得上一个中产人家的财产。人非常好客，每顿饭总不少于二十个人。她安排好在八月里月圆时举行一次化装舞会。虽则还有三个星期的时间，里维埃拉已经到处都在谈论这次舞会了。晚上要放焰火，她还要从巴黎带一个黑人乐队下来。那些流亡的王公贵族相互谈论时又是羡慕，又是妒忌，认为她这一晚的花费足够他们一年的用度。\n“真是豪华，”有人说。\n“简直发疯，”有人说。\n“庸俗之至，”有人说。\n“你预备穿什么衣服？”艾略特问我。\n“可是，我告诉过你了，艾略特，我不预备去。你认为在我这样的年纪还会穿得花花绿绿吗？”\n“她没有请我，”他叹声叹气说，瞪着一双倦眼望着我。\n“哦，她会请的，”我淡然说。“敢说请帖还没有发全。”\n“她不预备请我。”他讲话的声音都变了。“这是故意给我难堪。”\n“哦，艾略特，这个我不能相信。肯定只是一时疏忽。”\n“我不是个会被忽略的人。”\n“你健康环到这样，反正是去不了的。”\n“当然我应当去。这个季节最好的一次宴会！我就是躺在床上要死了，也会爬起来去。我有我祖先德?劳里亚伯爵的衣服可以穿。”\n我不知道说什么是好，所以没有作声。\n“你来之前不久，保罗?巴顿刚来看过我，”艾略特忽然说。\n读者想必忘记这个人是谁了，因为我自己写到这里还得翻翻前面我给这个人起了个什么名字。保罗?巴顿就是那个艾略特引进伦敦社交界，后来觉得派不了艾略特用场就不理会他的美国青年，因此艾略特非常恨他。这个人近来相当引人注目，先是因为他加入了英国国籍，后来又因为他娶了一个报界巨头的女儿，而这位巨头已经晋升为贵族了。有了这样的后台，再加上人那样灵活，显然前途是不可限量的。\n艾略特恨透了。\n“只要我夜里醒来，听见有只老鼠在护壁板里面扒，我就说，‘这是保罗?巴顿在朝上爬。’我敢说，老弟，最后他总要进上议院的。感谢上帝，那一天我是看不见了。”\n“他的来意是什么呢，”我问，因为我和艾略特一样清楚，这个年轻家伙决不会无缘无故跑来。\n“我告诉你他的来意，”艾略特气哼哼地说。“他想要借我的德?劳里亚伯爵的服装。”\n“真不要脸！”\n“你懂得他的用意吗？这表明他知道爱德娜没有请我，而且不打算请我。她唆使他来的。这只老狐狸。没有我，她决不会混到现在这样。我为她开宴会。她认识的人都是我介绍的。她跟自己的汽车司机睡觉；这个你当然知道的。叫人恶心！巴顿坐在那儿告诉我，她预备把花园整个扎上灯彩，还要放焰火。我就爱焰火。他告诉我，许多人缠着爱德娜要请帖，可是，她全拒绝了，因为她要把宴会开得十分出色。他谈话的口气好象我被请是没有问题的。”\n“你把服装借给他吗？”\n“借给他？先叫他死了进地狱。我自己下葬时就要穿它。”艾略特在床上坐起来，象个发疯的女人，身子摇摇晃晃。“唉，真是忍心，”他说。“我恨他们，我恨他们所有的人。我能够招待他们时，他们都高高兴兴地捧我的场，但是，现在我又老又病，我对他们就派不了用场了。自从我病倒以后，来探望我的病的不到十个人，而且整整这个星期只有一只寒伧的花束送来。我什么事情都替他们做。他们吃我的饭，喝我的酒。我给他们当差。替他们安排宴会。我竭尽心力帮他们的忙。而我得到的是什么呢？屁也没有。他们里面没有一个关心我的死活。唉，太狠心了。”\n他开始哭起来。大滴大滴的眼泪从他消瘦的面颊上滚下来。“我真懊悔离开美国。”\n看见这个一只脚已经跨进棺材的老头儿，因为一家宴会没有请他，哭得象小孩子一样，实在遗憾；这使人觉得骇异，同时凄凉得有点令人吃不消。\n“没有关系，艾略特，”我说，“宴会那天，可能下雨。那就会搞垮它。”\n他就象传闻的快要淹死的人捞到一根稻草一样，赶快抓着我这句话，眼泪还没有干就吃吃笑了起来。\n“我从来没有想到这上面。我要比平时祷告更加虔诚地向上帝祷告下雨。你讲的很对，那就会搞垮它。”\n我总算把他的无聊念头引导到别的方面去，离开他时，他即使不是高高兴兴，至少已经安静下来。可是，我不愿意事情就这样了结；回到家里，我就打电话给爱德娜?诺维马里，说我明天得上戛纳山来，问她我能不能和她一起吃午饭。她叫佣人回话，说她很欢迎，不过，明天她没有举行宴会。虽说如此，我到达时一看，除了她以外，还有十位客人。她这人并不坏，慷慨而且好客；她的唯一严重毛病是一张嘴不好。连和她最亲密的朋友，她也没法不讲人家讲话，不过她这样做是因为她是个愚蠢女人，除了讲人家讲话之外，没法引起人们对她的注意。由于她讲的那些坏话又被人传了出去，所以她和那些被她中伤的人往往不叫应，但是，她的宴会总很热闹，多数人经过一段时间之后，觉得还是不和她计较的好。我觉得求她邀请艾略特参加她的盛会未免丢艾略特的脸，不想这样做，所以先看看风色。她对举行这次宴会很兴奋，午饭时全是谈的这个。\n“艾略特有一个机会穿他的菲力普二世服装，一定很高兴呢，”我尽量说得很随便。\n“我没有请他，”她说。\n“为什么不？”我装作诧异地问。\n“我为什么要请他？他在社交界已经数不上了。他是个老厌物，是个势利鬼，是个传播流言蜚语的人。”\n这些攻击对她同样适用，所以，我觉得，她太过分了。她是个蠢货。\n“再者，”她又说，“我要保罗穿艾略特的服装。他穿上那套服装样子一定神气。”\n我不再言语，但是，决心要替艾略特把他念念不忘的请帖弄到手，不管用什么手段。午饭后，爱德娜把她的朋友带到花园里去。这给我以可乘之机。我曾经有一次在这里作过几天客，所以知道一点她家的情况。我猜想总还有些请帖剩下来，这些当会留在秘书的房间里。我急匆匆向秘书的房间走去，打算悄悄塞一张请帖在口袋里，写上艾略特的名字寄掉；明知道他病得很厉害，赴不了宴会，但是，收到请帖一定使他非常高兴。可是打开门时，我愣住了，因为爱德娜的秘书就坐在写字台那边，而我原来指望她还在吃午饭呢。秘书是个中年的苏格兰女子，名叫吉斯小姐，赭黄色头发，脸上许多雀斑，夹鼻眼镜，从头到脚一副老处女派头。我装出随便的样子。\n“亲王夫人带大伙儿去逛花园了，所以，我想进来和你一同抽支烟。”\n“欢迎。”\n吉斯小姐讲话时带有一种苏格兰的粗嗄音。她讲话冷隽，但只对自己喜欢的人讲，而当她这样谈时，粗嗄的喉咙就变得更粗嗄了，使她的那些话听上去极端令人发笑。但是，当你笑不可抑时，她却会诧然不悦地看着你，仿佛认为你觉得她讲的话好笑，简直是发神经。\n“我想这个宴会给你增加了不少的麻烦事儿，吉斯小姐，”我说。\n“简直弄得我团团转。”\n我对她完全信赖得过，所以就单刀直入。\n“为什么老东西不请谈波登先生？”\n吉斯小姐刻板的脸上显出微笑。\n“你知道她是怎样的人。她跟他有仇。是她亲自在名单上把他的名字划去的。”\n“你知道，他快死了。他不会再起床的。他对没有请到他很感到难受。”\n“他要是想跟她拉拢，当初就该明白一点，不应当到处告诉人，她跟自己的汽车司机睡觉。而且这个人有老婆，还有三个孩子。”\n“那么她睡了没有呢？”\n吉斯小姐从夹鼻眼镜上面看看我。\n“我亲爱的先生，我当了二十一年的秘书，我一贯的准则是相信我所有的雇主都和积雪一样皎洁。我承认，当我的女主人之一发现自己有了三个月的身孕，而爵爷则去非洲猎狮子已有六个月时，我的信仰是有点支持不住的，可是，她去巴黎旅行了一趟，而且是一次很花钱的短期旅行，那就万事大吉了。亲王夫人和我同时都松了一口气。”\n“吉斯小姐，我来并不是为了同你一起抽支烟的，我来是想偷一张请帖亲自寄给谈波登先生。”\n“这样做很不妥当。”\n“就算如此吧。吉斯小姐，请你做做好事。给我一张请帖。他不会来的，这会使老头儿快活。你对他没有什么不痛快吧？”\n“没有，他一直对我很有礼貌。他是个正派人，这一点我对他是肯定的，而且比多数跑到这里来骗亲王夫人一顿吃喝，把大肚子装得饱饱的人都正派。”\n所有重要的人物身边都有些得宠的下属。对这些倚仗人势的人，你最怠慢不得。\n当他们得不到自认为应受到的尊重时，他们就会产生敌意，并且反复在主子面前针对这些人放冷箭，进行挑拨离间。你必须和这种人搞好关系。艾略特比任何人都更懂得这一点，所以对那些穷亲戚，老年女佣人或者倚为亲信的秘书，他总要和他们亲亲热热讲句话，或者有礼貌地微笑一下。我肯定他时常和吉斯小姐相互打趣，而且每逢圣诞节总记着送她一盒巧克力或者小手提包。\n“求求你，吉斯小姐，发个善心吧。”\n吉斯小姐把夹鼻眼镜在自己大鼻子上夹得更牢。\n“毛姆先生，我肯定你没有意思要我做不忠于我的雇主的事；再者，如果那个老母牛发现我违背了她，她就会辞退我。请帖在写字台上，都装在信封里。我要向窗外看看，这一半是因为我在一个位置上坐得太久了，腿有点僵，想活动一下，一半是想看看美丽的景色。在我背后发生的事，不论上帝或者凡人都不能要我负责。”\n当吉斯小姐重新坐下来时，请帖已经到了我的口袋里。\n“今天很幸会，吉斯小姐，”我说，把手伸出来。“化装舞会上你预备穿什么服装？”\n“我亲爱的先生，我是个牧师的女儿，”她回答说。“这种愚蠢的事，我留给上层阶级去做。当我看见《先驱报》和《邮报》的那些代表吃了一顿好宵夜并且喝了一瓶我们的第二等最好的香槟酒之后，我的责任就结束了。我将回到我的卧室关起门来看一本侦探小说。”\n八 # 两天之后，我去看艾略特时，发现他笑逐颜开。\n“你看，”他说，“我收到请帖了。今天早上来的。”\n他从枕头下面把请帖拿出来给我看。\n“我不是告诉过你吗，”我说。“你看你的姓是从t开始的。那位秘书显然到现在才写到你。”\n“我还没有回信呢。等明天回。”\n听见这话，我一时害怕起来。\n“你要不要让我替你写回信？我走时就可以替你寄掉。”\n“不，为什么你要替我回？我完全能够亲自回答人家的请帖。”\n我想，幸亏信封会由吉斯小姐拆，而她当会懂得把它扣下来。艾略特按按铃子。\n“我要把服装拿给你看。”\n“难道你真想去吗，艾略特？”\n“当然要去。自从博蒙家那次舞会之后，我还没有穿过它呢。”\n约瑟夫听见铃声进来，艾略特告诉他把服装拿来。服装放在一只大的扁盒子里，用薄绢包着。这里有白绸长袜，衬里的织金布短裤，白麻布镶边，配上紧身上衣，一件大氅，一条围在脖子上的绉领，一顶平顶丝绒便帽，一条长金链子，链子的一头挂着那个金羊毛勋章。我看出这是模仿提香画的菲力普二世穿的那件豪华服装，这张画就在普拉多[注]。当艾略特告诉我西班牙国王和英国女王结婚时，德?劳里亚伯爵穿的恰恰就是这样的装束，我认为他完全是想入非非。\n第二天早晨，我还在吃早饭时，就有人打电话来。是约瑟夫；他告诉我，夜间艾略特又发病了，医生匆匆赶来之后，认为可能今天都熬不过去。我命人把汽车开来，赶到昂第布。艾略特正处于昏迷状态。艾略特坚决不肯用护土，可是我却看见有个护士在场，是医生从那个介于尼斯与博卢之间的英国医院找来的，这使我看了很高兴。我出去打了个电报给伊莎贝儿。她和格雷正带着孩子在拉保尔的海滨度夏，因为那边费用比较便宜。这条路很长，恐怕他们赶不到昂第布送终。她是艾略特唯一在世的亲人，除了她以外，就是她的两个哥哥，他们同艾略特已经多年不见了。\n可是他的生活意志很强，不然就是医生用的药物生效，在这一天里，他慢慢恢复过来。尽管病得不成样子，他仍旧强作精神，和护士打趣，问一些关于她的性生活的狠亵问题。我在下午大部分时间里都和他在一起；第二天再去看他时，发现他虽则人很疲惫，兴致已经相当好了起来。护士只允许我和他果很短一段时间。我对发出的电报没有得到回音感到焦急；由于不知道伊莎贝儿在拉保尔的地址，电报是打到巴黎去的，生怕管家转电报时耽搁了时间。两天之后，我才收到回电，说立刻动身。也是活该倒霉，格雷和伊莎贝儿正坐汽车在布列达尼半岛作短途旅行，所以刚刚收到电报。我查了火车表，看出他们至少要等过三十六小时才能到达。\n第二天清早，约瑟夫又打电话给我，说艾略特夜里睡得很不好，而且要找我。\n我赶快去了。当我到达时，约瑟夫把我拉到一旁。\n“先生，恕我冒昧跟您谈一件不大好说的事，”他跟我说。“我当然是不信教的，认为所有的宗教都只是神父企图控制人民的阴谋，但是，先生要知道，女人不这样看。我老婆和女佣都坚持老先生应当受到最后的祝福，而且时间越来越短了。”\n他相当不好意思地望望我。“实际的情形是，谁也说不了，也许一个人如果要死的话，还是把自己跟教会的关系搞搞好为上。”\n我完全懂得他的意思。多数的法国人，不管他们平时怎样随便闻弄宗教，到了临终时，都还是愿意和他们几乎骨肉相连的信仰妥协的。\n“你是要我向他提出吗？”\n“先生如果肯行好的话。”\n这个差使我并不怎样喜欢，但是，艾略特毕竟多少年来都是个虔诚的天主教徒，所以，履行一个天主教徒的职责也是对头的。我上楼进了他的房间。他仰卧着，人又瘦又憔悴，但是，神志完全清楚。我请护士出去。\n“艾略特，你的病恐怕很重了，”我说。“不知道，不知道你愿意不愿意找个神父来？”\n他看看我，有半晌没有说话。\n“你的意思是说我就要死了？”\n“哦，但愿不是如此。不过还是把稳的好。”\n“我懂了。”\n他不作声。这的确是个难受的时刻，当你不得不向一个人说出我刚才向艾略特讲的话时。我没法望着他；自己牙关紧咬，生怕要哭出来。这时我人坐在床边，面向着他，伸出一只胳臂撑着身体。\n他拍拍我的手。\n“不要难过，我亲爱的朋友。义不容辞的事，你懂。”\n我傻里傻气地笑了。\n“你这个怪家伙，艾略特。”\n“这就对了。现在打电话给主教，说我要忏悔并且受涂油礼[注]。如果肯派夏尔神父来，我将感激不尽。他是我的朋友。”\n夏尔神父是主教的代理人，我以前也提到过。我下楼打了电话；在电话里，和主教亲自讲了。\n“急吗？”他问。\n“很急。”\n“我立刻就办。”\n医生来时，我告诉他适才的事情。他和护士一同上楼去看艾略特，我在楼下饭厅里等着。从尼斯到昂第布开汽车只消二十分钟，所以过了半小时多一点，一辆大黑轿车就开到门口。约瑟夫跑来告诉我。\n“cest monseigneur en personne，monsieur[注]，是主教本人。”他慌慌张张地说。\n我出去迎接他。主教并不如往常一样带着他的副手，而是——不知道什么原因——带着一个年轻神父；神父携着一只盒子，想来里面装的是进行涂油礼的用具。\n汽车司机携了一只破烂相的黑皮包跟在后面。主教同我握手并介绍了他的同伴。\n“我们可怜的朋友怎么样了？”\n“恐怕病得很厉害呢，主教大人。”\n“请您把我们带到一间屋子里，好穿上法衣。”\n“餐厅在这儿，主教大人，客厅在楼上。”\n“餐厅就行。”\n我招待他进了餐厅，我和约瑟夫在外面等着。不一会，门开了，主教走了出来，后面跟着神父，双手捧着一只圣餐杯，杯子上面是一个小圆盘子，里面放一块祭祀用过的圣饼。这些都拿一块麻纱食巾盖着，麻纱非常之细，等于透明。我除掉在晚宴或者午宴席上和主教见面外，从来没有和他会见过；他而且是个食量很大的人，能欣赏一顿好饭和一杯佳酿，讲些滑稽甚至下流的故事起来津津有味。那时候，他给我的印象是一个身体结实强壮的人，只有中等身材。今天穿上白法衣，披上圣带，看上去不但很高，而且高贵。一张红红的脸，一般都是笑容可掬的，现在则很严肃。\n从外表上看，过去的那个骑兵军官在他身上找不到一丝痕迹；他的样子就象是教会里的一个大人物，而且实际也是如此。我看见约瑟夫在胸口画了十字，一点不觉得诧异。主教头向前倾，微微怄一下身体。\n“带我上病人那里去，”他说。\n我让他先上楼，可是，他请我在前领路。我们在庄严沉默中上楼。我走进艾略特的房间。\n“主教亲自来了，艾略特。”\n艾略特挣扎着坐了起来。\n“主教大人，我感到不胜荣幸之至，”他说。\n“你别动，我的朋友。”主教转身向着护士和我。“请你们离开。”然后又对神父说：“我到时候会叫你。”\n神父向四下看看，我猜想他是想找个地方放圣餐杯。我把梳妆台上的玳瑁壳镶背的发刷推推开。护士下楼去了，我把神父领进艾略特作为书房的那一间。窗子开着，窗外是蓝天，神父走过去，站在一扇窗子口。我坐下来。海湾里一些两头尖的单桅帆船正在竞赛，它们的三角帆被蓝天一衬，白得闪烁耀眼。一条大黑壳纵帆船，红帆张开，正迎着风向港口驶来。我认出这是捕捞龙虾的船，是从撒了捕获了一批鱼虾给赌场里的那些寻欢作乐者晚饭时食用的。从关闭的门里，我能隐隐听见讲话声。艾略特正在作忏悔。我渴想抽支烟，可是，怕神父瞧见不以为然。他站着不动，向外面望出去，一个身材瘦削的年轻人，浓密的黑鬈发，清秀的深色眼睛，黄里带青的皮肤，表明他是意大利种。他的脸上带有南方的那种生命的活力，这使我心里盘算着是什么强烈的信仰，什么火热的心愿，促使他放弃日常生活的欢乐、年轻人的享受和感官的满足，献身为上帝服务。\n隔壁房间的声音忽然停止，我看看门。门开了，主教出来。\n“来，”他向神父说。\n剩我一个人。我重又听见主教的声音，知道他正在祈祷；这是教会命令要为将死的人说的。接着又是一阵沉寂，知道艾略特正在吃圣餐。恐怕这是远祖的影响，我虽则不是一个天主教徒，但是每次做弥撒时，听见侍从摇着小铃通知我圣饼举起时[注]，总不免感到一阵战栗；现在我同样感到一阵战栗，就好象冷风透过肌肤一样，感到又害怕又奇怪。门重又打开。\n“你可以进来了，”主教说。\n我走进去。神父正在把杯子和放圣饼的镀金小盘子用纱布盖上。艾略特的眼睛显出喜悦。\n“送主教大人上车，”他说。\n我们走下楼。约瑟夫和女佣们在厅堂里等着。女佣们在哭。她们一共三个人，都挨次地走上前来，跪下吻主教的戒指。主教伸出两个指头放在她们头上，为她们祝福。约瑟夫的老婆用肘部捣他一下，他上前一步，也跪下来，吻了戒指。主教微笑。\n“你不是不信教的吗，孩子？”\n我看出约瑟夫挣扎了一下。\n“是的，主教大人。”\n“别放在心上。你对主人很忠心耿耿。主将会饶恕你在理性上的错误。”\n我陪主教到了马路上，给他开了汽车门。他向我鞠个躬，上车子时，欣然徽笑说：“我们可怜的朋友病很重了。他的缺点只是些浮面的；他心地非常宽厚，而且对同类是仁慈的。”\n九 # 我想艾略特经过了适才的临终忏悔仪式之后，可能不想见人，所以，上楼进了客厅，看起书来，可是，才坐下来，护士就进来通知我，说艾略特要见我。我爬上那串楼梯到了他的房间。是不是由于医生给他打了一针，帮助他能熬过即将临头的忏悔仪式，还是由于举行仪式给他的兴奋，他的兴致比较好，眼睛也有神。\n“莫大的荣幸，我亲爱的朋友，”他说。“我将带着教会的一位大人物的介绍信进入天国。我想所有人家都会欢迎我。”\n“恐怕你会发现人色一点不齐整，”我微笑说。\n“你别相信它，我亲爱的朋友。我们从《圣经》上知道，天上和地上一样有阶级区别。有六翼天使和二级天使，有天使长和天使。我一直在欧洲的上流社会中走动，毫无疑问，我也将在天上的上流社会中走动。主曾经说过：在我父的家里有许多住处[注]。把大众安置在他们完全不习惯的环境里是极端不适合的。”\n我猜艾略特把天国想象为德?罗思柴尔德男爵的宫堡一样，墙上镶有十八世纪的护壁板，比尔的桌子，嵌术细工的小房间和路易十五风格的成套家具，蒙着原来的精工刺绣。\n“我不骗你，亲爱的朋友，”他停了一下，又说，“天上决没有那种混蛋的平等。”\n他忽然睡着了。我坐下来，拿本书看。他一直睡下去。一点钟时，护士进来告诉我，约瑟夫替我把午饭烧好了。约瑟夫变驯服了。\n“真想不到主教大人竟然亲自来。对我们可怜的先生是很大的光荣。您看见我吻他的戒指吗？”\n“我看见了。”\n“我自己不会吻它，是为了满足我可怜的老婆才做的。”\n我在艾略特的房间内呆了一下午。中间伊莎贝儿来了个电报，说她同格雷坐蓝钢车第二天早晨到达。我认为他们肯定赶不及送终。医生来了，摇摇头。太阳下山时，艾略特醒来，能够进一点饮食。这好象使他暂时有点力气。他向我招招手，我走到他的床前。他的声音很弱。\n“我还没有回爱德娜的请帖呢。”\n“噢，现在别管它了，艾略特。”\n“为什么不管。我一直是个台面上的人；不能因为我就要离开，就忘掉礼貌。\n请帖在哪里？”\n请帖放在壁炉板上，我交在他手里，但是，敢说他看不清楚。\n“你在我的书房里可以找到一本信纸。你把它找来，我就可以口述回信。”\n我走进书房，把信纸拿来，在他的床边坐下。\n“你预备好了吗？”\n“是的。”\n他的眼睛闭着，可是，嘴边露出调皮的微笑。我盘算不知他会说些什么。\n“艾略特?谈波登先生甚感遗憾，由于和赐福的主事先有个约会，不能接受诺维马里亲王夫人的盛意邀请。”\n他发出一声轻微的幽灵似的冷笑。他脸色白得很古怪，看上去阴森森的，而且呼出的气息有他这种毛病所特有的令人作呕的恶臭。可怜的艾略特，过去一直就喜欢洒夏内尔和摩林诺的香水的。他手里仍旧抓着那张我偷来的请帖。我觉得拿着不方便，想从他手里取出来，可是，他勒得更紧。他忽然开口讲话，声音相当大，这使我吃了一惊。\n“老淫妇，”他说。\n这是他最后讲的一句话，接着人就昏迷过去。护士前一天晚上陪了他一夜，脸色非常疲乏，所以，我叫她去睡觉，答应在必要时叫她，由我来守夜。事实上，无事可做，我开了一只有罩子的灯，看书看得眼睛发酸，于是把灯熄掉，在黑暗中坐着。夜晚很热，窗户都洞开。灯塔的闪光每隔一定时间扫射一下屋子。月亮下去了；等月圆时，它就会俯视着爱德娜?诺维马里的化装舞会那片空洞而嘈杂的欢乐景象。\n天的颜色是一种极深极深的蓝，无数的星星照得骇人地亮。我大约打了一下瞌睡，但是，感觉仍旧清醒；忽然间，一声仓促的愤怒的声音，是人们所能听到最怕人的声音，死的呼啸，把我惊醒，人的神志变得极端清楚起来。我走到床边，凭着灯塔的闪光接接艾略特的脉搏。他已经死了。我开了他床头的灯，望望他。他下巴张开，眼睛睁着。我将他眼睛闭上之前，先对眼睛看了一会，自己感动了，觉得有几滴眼泪沿双颊流下来。一个老朋友，忠厚的朋友。想到他的一生过得那样愚蠢、无益和无聊，使我感觉难受。他参加过那么多的宴会，曾经和所有那些亲王、公爵、伯爵厮混过，现在都毫无道理了。他们已经忘记他了。\n我觉得没有道理要叫醒那个筋疲力尽的护士，因此，回到我原来靠窗子的座位上。护士在早晨七点钟进来时，我已经睡着。我留下她做她认为应当做的事，自己吃了早饭，就上车站去接格雷和伊莎贝儿。我告诉他们，艾略特已经去世。由于艾略特的房子里没有客房，我邀他们上我家去住，可是他们愿意住旅馆。我回到自己家里洗了个澡，刮了胡子，换了衣服。\n上午格雷打电话给我，说约瑟夫给他们一封信写的我的名字，是艾略特付托给他的。由于这封信里面讲的话可能只是对我一人讲的，所以，我说立刻就到，因此，一小时不到，我又一次进了那所房子。那封信的信壳是这样写的：在我死后，立刻变去；信里面是关于丧葬礼的指示。我知道，他一心一意要葬在他造的那座教堂那边，而且已经告诉过伊莎贝儿。他要涂上防腐香膏，并且提到可以进行这种手术的店铺名字。“我打听过，”他继续说，“人家告诉我，他们做得很道地。我信任你不会让他马虎了事。我要穿上我的祖先德?劳里亚伯爵的服装，佩上他的长刀，把他的金羊毛勋章挂在胸前。挑选棺材的事交给你办。不要很触目，但要符合我的身份。为了避免给人增加不必要的麻烦，我要求由托马斯?库克父子公司[注]承办一切转运遗体事宜，他们应当派一个人护送棺木到它最后安放的地点。”\n我记得艾略特曾经说过，他要穿他那件古服装安葬，但是认为这只是闹着玩的一句话，没有想到他当真要这样做。约瑟夫坚持要执行他的遗志，我们好象没有理由不照办。他的遗体及时涂了香膏，然后，由我和约瑟夫给穿上那荒唐的装束。这件事使人倒尽了口味。我们先把他的两只长腿套上白长统丝袜，再在上面拉上那金色布的紧身裤。好不容易才把两只胳臂塞进紧身上衣的袖管。给他戴上那浆洗好的宽大轮状绉领，再把缎斗篷给他披在肩上。最后把那只平顶丝绒帽戴在他头上，把金羊毛的领圈围着他的脖子。涂香膏的人已经给他的两颊搽上胭脂，嘴唇染红。艾略特的身体现在瘦得只剩一点点，这套衣服穿在他身上就仿佛是威尔第[注]早期歌剧里的一个歌手。一个乏善可陈的悲惨的唐吉诃德。当装殓的人把他抬进棺材时，我把那柄作为道具的长刀沿着他的身体放在两腿之间，两手按着刀柄的回头，就象我看见一个十字军骑士墓上雕塑放的那个样子。\n格雷和伊莎贝儿去意大利参加葬礼。\n第六章 # 一 # 我觉得应该先打读者一个招呼，他完全可以跳过这一章，而仍旧能抓着我要讲的故事线索，因为这一章大部分只是记述我和拉里的一次谈话。可是话又要说回来，如果不是由于这次谈话，我也许认为不值得写这部书。\n二 # 那年秋天，在艾略特逝世后两个月，我去英国，中途在巴黎逗留了一个星期。\n伊莎贝儿和格雷，作了那次艰苦的意大利旅行之后，又回布列塔尼半岛，可是，现在重又在圣纪尧姆街的公寓里住下来了。伊莎贝儿把艾略特遗嘱的详细内容告诉我。\n他留下一笔钱给他造的那座教堂为他的灵魂做弥撒，另外还捐给教堂一笔维持费。\n他留给尼斯主教一笔可观的数目作为慈善费用。他留给我他收藏的那批真伪难说的十八世纪淫书，和弗拉戈纳尔[注]的一张美丽的绘画，画的一个山羊神和一个女仙子那背着人干的事。这张画太下流了，没法挂出来，而我又不是那种私下里贪看猥亵图画的人。他留给几个佣人的钱都相当多。他的两个外甥每人各得一万元，其余的财产全归伊莎贝儿。这笔财产究竟值多少，她没有说，我也没问；从她那心满意足的外表看来，该是很大的一笔钱。\n好久以来，格雷自从恢复健康之后，就急于想回美国重新工作。尽管伊莎贝儿在巴黎住得相当舒服，格雷定不下心来也影响到她。格雷曾经和自己的那些朋友通过一个时期的信，但是，最好的一个机会是由他拿出相当大的一笔资本。这笔钱他拿不出。可是，艾略特死后，伊莎贝儿却拥有比格雷需要的数目多得多的钱，所以，在取得伊莎贝儿的同意之后，格雷又开始和人家接洽起来；如果情形真如对方所说，他预备离开巴黎，亲自去看看。但是在成行之前，有不少事情要做。他们必须和法国财政局在遗产税问题上取得一项合理的协议。他们要把昂第布的房子和圣纪尧姆街的公寓处理掉。他们得在德鲁奥旅馆筹备一次拍卖，处理掉艾略特的那些家具、藏画和素描。这些都很名贵，看来最好等到春天那些大收藏家可能在巴黎时拍卖最合算。伊莎贝儿认为在巴黎再过一个冬天井不坏；两个孩子现在法文已经讲得和英文一样流利，所以，伊莎贝儿很愿意让她们在法国学校里再呆几个月。三年来，她们全长高了，长长的腿，瘦瘦的身体，成了生动活泼的小姑娘，目前还没有长得象她们母亲那样美，但是，全懂礼貌，而且有一个永不满足的好奇心。\n就这么多。\n三 # 我和拉里是无意中碰到的。我曾经向伊莎贝儿问到他；她告诉我，从拉保尔回来之后，他们很少见到他过。她和格雷这时自己认识了一些朋友，都属于他们这一代的人，所以常有约会，比我们四个人时常在一起时的那些快乐的日子忙得多。有一天晚上，我去法兰西剧院看《贝蕾尼丝》。这个剧本我当然读过，但从没有看见它上演；由于难得演，所以很不愿意错过这个机会。这不是拉辛最好的戏，因为题材太单薄了，顶不了五幕，但是戏写得很感动人，有几段够得上说是脍炙人口。故事是根据塔西佗[注]的短短的一段文字写的：铁图热烈爱上巴勒斯坦的女王贝青尼丝，甚至如人们所设想的，答应和她结婚，但是，为了国家大事在他登基的开始，却违反自己的愿望，也违反贝蕾尼丝的愿望，使她离开罗马。原因是元老院和罗马的人民都反对自己的皇帝和一个外国女王结合。剧本写的是铁图在爱情与义务之间的心理斗争；在他摇摆不定时，最后是贝蕾尼丝拿准了他爱她，赞成他的出发点，永远离开了他。\n恐怕只有一个法国人能够充分欣赏拉辛诗句的文采和音调美，但是，即便是一个外国人，一旦习惯于诗句的那种矫揉造作风格之后，也没法不被他的柔情蜜意和高尚情感打动。很少人能象拉辛那样懂得人的语音里面含有那么多的戏剧成分。不管怎样，对我来说，那些流畅的亚历山大体[注]诗句的作用足可以代替情节，而且我发现那些长篇大论，以卓绝的手腕逐渐达到预期的高潮，和电影里任何惊险的镜头一样使人惊心动魄。\n第三幕演完时有一场休息。我出去门厅里抽支烟；门上首竖着乌东[注]的伏尔泰雕像，咧着一张没有牙齿的嘴在讽刺地微笑。有人拍拍我的肩膀。我转过身去，可能有点着恼，因为我想要独自享受一下那些铿锵诗句在我心中引起的兴奋；我看见是拉里。和平时一样，我见到他总很高兴。我和他已经有一年没有见面，因此，建议看完戏，一同去喝杯酒。拉里说他肚子饿了，因为没有吃晚饭，提议上蒙马特尔去。到时候，我们碰上头，一同走出剧院。法兰西剧院有一种特殊的霉味。这种气味又和一代代的那些女招待员身上的气味掺合在一起；她们从不洗澡，板着一副脸，把你带领到座位上，硬邦邦等你付小帐。这使人走到外面来时深深透一口气；由于晚上天气很好，所以我们一路走了过去。歌剧院大街的弧光灯傲然炫耀着；天上的星星好象不屑跟它们较量，都把自己的光华隐藏在无完无尽的黑暗里。我们一边走，一边谈论着刚才看的戏。拉里感到失望。他原来指望演得自然一点，把诗句读得象说话一样，姿势也不要那样太戏剧化。我觉得他的看法错了。这出戏以辞藻胜，而且使用华丽的辞藻，所以，我认为台词读起来应当带有做作气。我喜欢碰到韵脚时那样顿一下；而且那些优美的姿势和身段，由一个悠久传统保留到今天的，好象和这种偏重形式的艺术格调很适合。敢说拉辛当年就愿意他的戏照这样子演呢。\n过去我对那些演员在重重限制下竭力演得真实、热烈和有人情味，总很佩服。艺术能够利用传统格式达到自己的目的，就是艺术的胜利。\n我们到了克利希大街，走进布拉西里?格拉夫饭店。时间是夜晚十二点过去不久，馆子里挤满了人，但是，我们找到了一张桌子，叫了火腿蛋。我告诉拉里，我见到伊莎贝儿。\n“格雷应该高兴能回美国，”他说。“他在这里就象鱼儿失水一样。他非要重新有了工作，是不会快乐的。敢说他会赚到很多钱。”\n“他如果赚到很多钱，那都是亏的你。你不但治好他的病，而且治好他的心病。\n你使他恢复了自信心。”\n“我做得很有限。我仅仅指给他看怎样医好自己。”\n“这点‘有限，你是怎样学会的？”\n“碰巧。那是我在印度的时候。我当时患失眠症，刚好向一个我认识的老瑜伽教徒谈起；他说即刻给我治一下。他对我做的就是你看见我给格雷做的那一套；那天晚上，我睡得很好，几个月来都没有睡得这样好过。后来，时间当在一年以后，我和我的一个印度朋友爬喜马拉雅山；他把脚踝跌伤了。当地找不到医生，而他的脚痛得不可开交。我想到照老瑜伽教徒那样试一下，竟然奏效。不管你相信不相信，总之他完全不痛了。”拉里笑起来。“我可以向你保证，我比任何人都更加诧异。\n这里面实在一点神秘也没有；它只是把这种想法灌输到病人的头脑里。”\n“说来容易，做起来可不容易。”\n“如果你的胳臂不由自主地从桌子上抬起来，你会诧异吗？”\n“当然非常诧异。”\n“它会的。当我们回到文明世界以后，我的印度朋友告诉人们，说我会这项本领，并且带领别的人来看我。我非常之不愿意做，因为我还不完全懂得这是怎么回事，可是，他们坚决要我做。不知道什么道理，我总把他们治好了。我发现不但能止痛，而且能驱除恐惧。奇怪的是，许多人都患恐惧病。我说的恐惧并不是指怕被关闭起来或者怕站在高地方，而是怕死亡，或者更糟糕的，怕生命。他们往往看上去好象非常之健康，生活富裕，一点心事也没有，然而却被恐惧折磨着。我有时觉得，这是人性中的最扰人意的一种心理倾向；有一个时候，甚至盘算这是不是植根于某种动物本能，是人类从那个第一次感到生命颤栗的原始物质继承下来的。”\n我一面倾听着拉里，一面怀着期望，因为他很少讲话有这样长的。我而且觉察到这一次他总算愿意谈心了。也许我们刚才看的那出戏减轻了某种内心的压抑，那种明快的抑扬顿挫的节奏，正如音乐会引起的反应一样，克服了他的天生拘谨。忽然间，我感到自己的手有点不对头。我对拉里刚才说的那个半开玩笑的问题一点没有在意。现在我觉得自己的手不再搁在台子上，而是不由自主地离开台面有一英寸光景。我吃了一惊，看看手时，发现它微微有点抖。我感到自己胳臂的神经有一种古怪的颤动，它震动了一下，手和小臂就自动地抬了起来，我老老实实，既不参与也不抵抗，直到它们离开桌子有好几英寸；接着，感到整个胳臂举过肩头。\n“这很古怪，”我说。\n拉里笑了。我稍微运用一点意志，手就落回到桌子上。\n“这不希罕，”他说。“别当它什么了不起。”\n“是不是你刚从印度回来跟我们谈到的那个瑜伽教徒教给你的？”\n“不是的，他对这类事情很不耐烦。我不知道他是否相信自己具有某些瑜伽教徒自命具有的能力，但是，他认为运用这些能力是幼稚无聊的。”\n我们要的火腿蛋来了。两人吃得津津有味，喝喝啤酒，谁都没有说话。我不知道他在想些什么，我则在想着他。吃完之后，我燃起一支纸烟，拉里点上他的烟斗。\n“你去印度首先是为了什么？”我蓦然问他。\n“碰巧。至少当时是认为如此。现在我比较倾向于认为这是我在欧洲呆了多年的必然结果。差不多所有对我影响最大的人都好象是偶然的遇合，然而，回想起来却象是非碰上他们不可似的。那就象是他们全在那里等待我在需要时找上他们。我去印度是想休息一下，因为工作得太累了，还想把思想清理清理。我找到一个水手的工作，就在那种周游世界的旅游船上。船正开往东方，并且要通过巴拿马运河到纽约。我已经有五年不回美国，很想家。人情绪低落。你知道我们好多年前在芝加哥初次见面时，我是多么的无知。我在欧洲读了许许多多的书，见识了不少事情，但是，比我开始着手寻找我要追求的东西时好不了多少。”\n我想问他追求的什么，但是，感到他会笑笑，耸耸肩膀，说这事不值得一谈。\n“可是，你为什么要去当一名水手呢？你又不是没有钱，”我换了个题目问他。\n“我要体验一下。只要我精神上到了饱和点，只要我把暂时能吸收的全都吸收了，我发现做做水手之类的事情有好处。那年冬天，我和伊莎贝儿解除婚约之后，我就在朗斯附近的煤矿做了六个月的工。”\n就在这时，他叙述了我在前面讲的他那些遭遇。\n“伊莎贝儿把你扔掉时，你难过吗？”\n在回答我以前，他有这么半晌眼睛盯着我看，一双深得很特别的眼睛这时好象不向外看，而是在向内看。\n“是的。我那时年纪轻，已经打定主意要结婚，并且安排好我们的生活打算。\n我指望可以生活得很美满。”他淡淡一笑。“但是，结婚要有两个人才行，正如吵架要有两个人才吵得起来一样。我从没有想到，我给伊莎贝儿安排的那种生活使她大失所望。我如果懂得一点人情世故的话，决不会向她提出来。她太年轻，太热爱生活了。我不怪她。但是我没法妥协。”\n读者现在可能想起，自从他和农场主的寡媳发生了那次荒唐的关系并且逃出农场之后，他是去波恩的。我急于想听他继续讲下去，但是，知道我必须当心，不要问些不必要的问题。\n“我从来没有到过波恩，”我说。“小时候在海德尔堡上过一个时候的学。那是我一生最快乐的时期，我觉得。”\n“我喜欢波恩；在那边呆了一年。我在波恩大学一位教授的家里租了一间房间；教授已经亡故，他的遗孀收容了两个房客；两个女儿都已经达到中年，做饭和家事都由她们担当。她们的另一个房客是法国人，开头我有点失望，因为我只想说德国话，别国话都不想讲；可是他是阿尔萨斯人，德国话[注]即使讲得不比他的法国话更流利，至少吐音比他的法语准确。他穿得象个牧师；几天之后，我才知道他是个黑衣教士，这使我有点意想不到。他是经修道院批准到大学图书馆来做研究工作的，是一个饱学之士，但是，外表看上去和我心目中的僧侣并没有两样。身材又高又大，赭黄色头发，碧碧蓝的一双眼睛，红红的圆脸。人很怯生拘谨，看上去不大想跟我多搭讪，可是，礼貌相当周到，在餐桌上谈话时始终客客气气；我只在吃饭时见到他；午饭一吃完，他就回图书馆工作；吃完晚饭，我留在客厅里和那个不洗餐具的女儿谈话，练习德语，他总是回自己的屋子。\n“有一天下午，那至少已经在我迁来一个月之后，他问我愿不愿意和他散一回步。这有点出乎我的意料之外。他说他能够指给我看邻近的一些地方，而这些地方敢说单靠我一个人是不会发见的。我相当能够走路，可是，他随时都能击败我。这第一次散步，我们一定足足走了有十五英里远。他问我来波恩干什么，我说来学德文，井且想熟悉一下德国文学。他很有谈吐，说他愿意尽量帮助我。这次以后，我们每星期总要出去散步两三次。我发现他教哲学已有好些年。在巴黎时，我读过一些哲学，斯宾诺莎啊，柏拉图啊，笛卡尔啊，但是，德国的那些大哲学家都没有读过，听他谈论这些哲学家正是求之不得。有一天，我们作了一次短途旅行，越过莱茵河，坐在一家卖啤酒的园子里喝啤酒，他问我是不是新教徒。\n“‘想来是的，’我说。\n“他迅速扫了我一眼，我觉得他的眼睛里闪出一丝笑意。他开始谈论埃斯库罗斯[注]起来；你知道，我学过希腊文；他对这些伟大的悲剧家之熟悉，我简直无法望其项背。听他谈很给人启发。我不懂得他为什么忽然问我这个问题。我的保护人纳尔逊叔叔是一个不可知论者，但是，他经常去做礼拜，因为他的病家指望他这样；他送我上主日学校，也是为了同样理由。我们的帮佣玛莎是一个顽固的浸礼会教徒；我做小孩时，她时常告诉我地狱里的烈火，有罪的人将要永远在地狱里受苦，以此来吓唬我。村子里某些人，她为了这种或那种原因，要给他们惩罚，就形容给我听，他们在地狱里将要受的各种苦难，自己觉得十分开心。\n“到了冬天，我和恩夏姆神父已经混得很熟了。我觉得，他是个相当了不起的人。我从来没有看见他着恼过。人平和忠厚，比我可能指望的还要胸襟开阔，而且极其宽容。他学识渊博，而且肯定知道我什么都不懂，但谈起话来，往往把我当作好象和他一样有学问。对待我非常耐心，仿佛除掉帮助我之外，别无所求。有一天，我不知道什么缘故，患了腰痛，我的房东太太葛拉保夫人给了我热水袋，坚决要我睡上床。恩夏姆神父听说我病倒了，晚饭后，来到我的房间。我除掉腰痛得很厉害以外，人还是好好的。你懂得书呆子的为人，他们对书总要弄个明白；我把手里看的书放下时，他就拿了起来看看书名。那是一本讲梅斯特?艾克哈特的书，我在城里一家书铺里买到的。他问我为什么看这种书，我告诉他，我曾经涉猎过相当一部分有关神秘主义的书，并且和他谈到考斯第以及他怎样引起我对神秘主义的兴趣的。\n他用那双碧碧蓝的眼睛打量着我，眼睛里有一种神情只能形容为爱惜。我感到他觉得我相当可笑，但是，同时对我的钟爱并不因此而有所减弱。反正我从来就不在乎人家认为我有点象傻瓜。\n“你在这种书里面想寻些什么？’他问我。\n“‘我要是知道的话，’我答，‘至少就会去寻它了’。\n“‘你可记得我曾经问过你是不是新教徒？你说想来是的。这话是什么意思？’“‘我就是这样长大的，’我说。\n“‘你相信上帝吗？’他问。\n“我不喜欢人问我这些个人问题，所以首先想到的是告诉他，说这不关他的事。\n可是，他的脸色非常和善，使我感到没法顶撞他。我不知道说些什么；我不想回答相信，也不想回答不相信。也许是我的腰痛要说话，也许是他对我的某种影响。反正我和他谈了自己的经历。”\n拉里迟疑了一下。当他继续说下去时，我知道他讲话的并不是对着我，而是对着那个黑衣教士。他已经把我忘却。我不懂得是什么时间因素抑是地点因素使他违反自己的沉默性格，不经我敦促，就把他长期讳莫如深的事情讲了出来。\n“鲍勃?纳尔逊叔叔很民主，他送我进的是麻汾中学。只是因为路易莎?布雷德利伯母跟他唠叨个不停，到了我十四岁时，他才让我进圣保罗中学。我不论功课或者体育都不怎么行，只是还对付得过去。我认为我是个完全正常的男孩子。我对飞行特别迷。那时候，飞行还处在早期，鲍勃叔叔对飞行和我一样兴奋。他认识几个飞行员；当我说想要学飞行时，他就说愿意给我想办法。我年纪虽小，个子却长得高，十六岁就完全可以充十八岁。鲍勃叔叔叮嘱我务必保守秘密，因为他晓得人家知道他让我飞行全都会骂得他臭要死。可是，事实上，就是他帮助我溜到加拿大，并且给我一封介绍信去见他的一位熟人的。结果是，到了十七岁时，我已经在法国当飞行员了。\n“当时我们飞的全是非常蹩脚的飞机；你每次上天等于拿性命打赌。飞行的高度，按照今天的标准，是荒唐透顶的，但是，我们全不懂得，反而认为了不起。我真爱飞行啊。我没法形容飞行时心里的感受，只觉得自己又得意又快乐。在天上，飞得高高的，觉得自己成了某种伟大而美丽的东西的一部分。我不知道这是什么，只知道到了两千英尺以上，我不再是先前那样孤零零的一个人，而是有所属了。这话听上去可能很愚蠢，但是，我实在说不清楚。当我飞到云层以上，看见那些云就象大群绵羊似的在我脚下，我的感受就象和无限合为一体了。”\n拉里停了一下，从他那深不可测的眼窝里盯着我，可是，我说不出他是否看见我。\n“我知道有成千上万的人死去，但是，我没有亲眼看见他们死去，所以对我没有什么影响。后来我亲眼看见了一个死人。这使我感到惭愧。”\n“惭愧？”我不由自主地叫出来。\n“惭愧，因为那个孩子只比我大三四岁，是那样的精力充沛和勇敢，在不久前还是充满生命力，还是那样善良，而现在只剩下一堆烂肉，那样子就象从来没有活过似的。”\n我没有说什么。我读医科时曾经见过死人，在战争时看见的还要多。使我倒胃口的是他们看上去非常渺小，一点尊严没有。只是些弃置不用的木偶。\n“那天晚上，我没有睡觉。我哭了。我并不是为自己担心；我感到忿恨不平；使我控制不了自己的是死的丑恶。战争结束了，我回到家里。过去我一直喜欢机械。\n如果航空没有什么干头的话，我就进一家汽车工厂。我曾经受过伤，只能暂时无所事事一下。后来他们要我就业。我没法做他们要我做的那种事情。这好象很无聊。\n我曾经有过很多时间在思索。我不断问自己，人生是为了什么。归根到底，我能够活着只是靠运气；我要一生有所作为，但是，不知道应当做什么。我从来没有对上帝开动过什么脑筋。现在却想起他来了。我不懂得为什么世界上要有恶。我知道自己很肤浅；我不认识什么可以请教的人，但是，我要学，所以我就胡乱地读起书来。\n”当我告诉恩夏姆神父所有这些话时，他就问我：‘那么，你已经读了四年书了，是不是？你找到答案没有呢？’“‘一点没有，’我说。\n“他望着我，一脸的慈祥神气，把我都搞糊涂了。我不知道自己说了些什么使他这样感动。他在桌上轻轻敲着指头，就象脑子里在盘算一件事情一样。\n“‘我们大明大智的老教会’，他当时说，‘曾经发现，如果你假装信教那样行事，你就会真正信教；如果你带着疑虑祈祷，但是出于真心，你的疑虑将会消除。\n我们圣餐仪式对精神的力量是为多少世纪以来的人类经验所证明了的；如果你肯使自己接受一下圣餐仪式的美，也许上天会赐给你宁静。我不久就要回修道院。何不跟我们一同去住几个星期呢？你可以和我们的杂役僧人一起在地里做活；晚上在图书馆里看书。这个经验不见得不及在煤矿或者在德国农场上做工。’“‘你为什么要建议我这样做呢？，我问。\n“‘我从旁观察你已有三个月了’，他说。‘也许我理解你比你理解自己还要多些。你和信仰之间只隔开一层薄纸。’“我对他这话没有说什么。那就象有人扣着我的心弦，并且拨了一下，给人一种古怪的感觉。终于我跟他说，让我考虑考虑。他就不再言语。在恩夏姆神父逗留在波恩的余下期间，我们从不再提有关宗教的事，可是，在他离开时，他开了修道院的地址给我，说如果我决定去，只要写个便条给他，他就会替我安排住所。他走后，我比预计的还要想念他。日子过得很快，又是仲夏天气。在波恩过夏天相当不错。我读了歌德、席勒、海涅z读了荷尔德林[注]和里尔克[注]；但是，仍然没有找到答案。我时常盘算恩夏姆神父讲的那些话，终于决定接受他的邀请。\n“他上车站来接我。修道院在阿尔萨斯，乡间很美。恩夏姆神父介绍我见了院长，然后，领我到指定给我的小房间。房内有一张狭窄铁床，墙上挂了一只耶稣殉难的十字架，陈设简陋，只是些生活必需的东西。午饭铃响时，我向食堂走去。那是一间有穹顶的大厅。院长带领两个僧侣站在门口，一个僧侣端一盆水，另一个手里拿条毛巾，院长在客人两只手上洒几滴水洗洗，然后用僧侣递给他的毛巾将两手擦干。除了我之外，还有三个客人，另有两个过路牧师留下吃午饭的；还有一个年长的满腹牢骚的法国人，到这里来归隐的。\n“院长和两个助手，一正一副，在餐厅的上首就座，各自坐一张桌子；神父们在沿墙的两边坐，修道士和勤杂人员以及客人们则坐在餐厅正中。做了感恩祷告之后，大家就吃起来。一个见习修士站在餐厅进口处，以一种单调的声音读一本道书。\n吃完饭，大家又做感恩祷告。院长、恩夏姆、客人和招待客人的修士走进一间小点的屋子喝咖啡，谈些杂七杂八的话。然后我就回自己的小房间。\n“我呆了三个月，人很快乐。那种生活对我完全适合。图书馆很好，我看了不少的书。神父们没有一个企图用任何方法影响我，但是，很高兴和我交谈。他们的学问，他们的虔诚，和他们的那种不随流俗的派头，都深深打动了我。你不要以为他们过的是一种无所事事的生活。他们一直都不得闲。自己种地，自己打粮食，也高兴我帮助他们做。我喜欢做祈祷的华丽场面，但是，最最喜欢的是晨祷。那是在清晨四点钟。你坐在教堂里，四周围全是黑夜，觉得特别动心；这时候，修士们都神秘地穿上他们的服装，头巾拉上来遮着头，用他们有力的男声唱着礼拜仪式的平易歌曲。这类日以为常的活动给人以一种安全感；而且尽管花了偌大的精力，尽管思想从没有停止过活动，你仍然感到一种持久的宁静。”\n拉里带有憾意地微笑一下。\n“我就象罗拉[注]一样，生得太晚了，没有碰上自己的时代。我应当生在中世纪，那时候，信教是天经地义的事。那样的话，我就会看清自己的前途，在教会里谋一个职位。现在我没法相信。我想要相信，但是，我相信不了一个比一般上流人士好不了多少的上帝。神父们告诉我上帝创造世界是为了颂扬自己。这在我看来并不是怎么高尚的事儿。贝多芬写他的那些交响乐难道是为了颂扬自己？我不相信是如此。我相信他写那些创作是因为他的灵魂里有一种音乐要表现出来，而他要做的就是尽自己的能力把这些音乐表达得尽善尽美。\n“我常听神父们反复念餐前祈祷，心里盘算他们怎么会一直祈祷而不怀疑到他们的天父给他们每日粮食呢。儿童会恳求他们尘世的父亲给他们食物吗？他们指望他这样做，对他这样做既不感谢，也不需要感谢；对于一个生了孩子而养不活或者不愿养活孩子的父亲，我们对他只有责备。我觉得一个万能的造物主如果不准备给他创造的众生以生存的必要物质和精神食粮，他还是不创造的好。”\n“亲爱的拉里，”我说，“你还是不生在中世纪的好。否则，你准被判处人刑。”\n他笑了。\n“你获得不少成就，”他继续说。“你可愿意人当面恭维你吗？”\n“这只会弄得我很尴尬。”\n“我替你想，也会是这样。我也没法相信上帝要人恭维。在空军里面，一个家伙靠巴结指挥官弄到美差，我们都看不起他。一个人想要靠穷巴结，而从上帝那里得到拯救，我相信上帝也会看不起他。我总认为，上帝最喜欢的崇拜者是那种按照你的知识程度尽力而为的人。”\n“可是，使我想不通的首先还不是这个。我没法理解那种原始罪恶的想法，而以我所知，那些神父的头脑里多多少少都带有这种成见。我参加空军时认识许多人。\n当然他们只要有机会就喝醉酒，就找女孩子睡觉，而且嘴里不干不净的；我们里面有一两个坏蛋：一个家伙因开空头支票被逮捕，并且判了六个月徒刑；这不完全是他的过错；他从来没有过钱，当他拿到比自己想望更多的钱时，他就忘乎所以了。\n我在巴黎碰到过环人：回到芝加哥时，碰到过更多的坏人，但是，他们做坏事大都由于遗传，而这是他们无法可想的，或者由于环境，这也是不由他们自己选择的：对于这些罪恶，敢说社会应当比他们负有更大的责任。我如果是上帝的话，我就设法惩罚他们里面的一个，甚至里面最坏的一个，堕入地狱，水受沉沦之苦。恩夏姆神父思想比较开通；他认为地狱就是失去上帝护持，但是，如果这样就是一种使人忍受不了的惩罚，够得上是地狱，你能想象仁慈的上帝会执行这种惩罚吗？归根到底，是他创造了人类；如果他创造的人类使他们能够犯罪，那就是他要他们犯罪。\n如果我训练一只狗去咬闯进我后院来的生人的咽喉，它咬了生人的咽喉之后，我再去打它，那是不公平的。\n“如果一个至善和万能的上帝创造了世界，为什么他又创造恶呢？神父们说，这是为了使人克服自己恶的本性，抵拒诱惑，把痛苦和忧患作为上帝用以洗刷自己的考验来接受，使自己终于配得上享受上帝的恩典。这就象派个人送封信到某地去，然后在他必经之路上造一个迷阵，使他不容易通过，又挖一条壕沟，使他要游过去，最后又造一道城墙使他攀缘过去。我不相信全能的上帝会没有常识。我不懂得为什么你们不能设想一个并没有创造世界的上帝，而是尽力而为的上帝，比人类好得多，聪明得多，伟大得多，在和一个不是由他创造的恶斗争，而且说不定最后会战胜恶。\n但是话又说回来了，我也说不出为什么你们应当信仰这样一个上帝。\n“那些神父对使我困惑的这些问题，不论在理智上或者在情感上，都没法替我解决。我和他们不在一个道儿上。当我去向恩夏姆神父告别时，他没有问我有没有从他认为满有把握的经验中得到益处。他无限仁慈地把我看看。\n“‘恐怕我辜负了你的美意，神父，’我说。\n“‘不，’他回答。‘你是一个有极深宗教观念的不信上帝的人。上帝将会挑选上你。你会回来。是回到这里或者别处，只有上帝说得了。’”\n四 # “那年冬天余下的时间，我都住在巴黎。我对科学一点不懂；觉得现在该是我对科学至少有点人门知识的时候了。我读了不少的书。我不知道自己学到多少，只知道自己极端无知。不过这一点我过去已经晓得了。春天来时，我就去乡间住在小河边一个旅馆里，靠近一个美丽的旧式小镇；这类小镇法国很多，生活在这里好象二百年来就没有变动过。”\n我猜想这就是拉里和苏姗?鲁维埃一起度夏的地方，可是，我没有打断他。\n“后来，我去西班牙。我要看看贝拉斯克斯[注]和艾尔?格列柯；盘算艺术能不能给我指出宗教所不能指出的一条出路。我游荡了一个时期，然后到了塞维利亚。\n这地方使我很喜欢，心想我要在这儿过冬。”\n塞维利亚我二十三岁时也到过，那地方我也喜欢。我喜欢那些白色的弯弯曲曲的街道，那些教堂，和瓜达尔基维尔河一带广阔的平原；可是我也爱那些安达卢西亚女郎的风韵和欢快，深色的眸子，和佩在她们黑头发上的麝香石竹，把头发衬得更黑，而石竹花也被头发衬得更鲜艳；我喜欢她们浓郁的肤色，她们嘴唇的诱惑性肉感。那时候，确实是，只要年纪轻就等于置身天堂。拉里去塞维利亚时不过比那时候的我稍微大一点，所以，我不由而然盘算他面对这些迷人精的引诱，是否仍旧无动于衷。他回答了我没有说出的问题。\n“我碰到一个在巴黎认识的画家，一个叫奥古斯特?科泰的家伙；他一度和苏姗?鲁维埃住在一起过。他来到塞维利亚写生，在那边找到一个女子就同居起来。\n有天晚上他请我去埃里丹尼亚剧院听一个弗拉门科[注]歌唱家唱歌，并且带了那女子的一个朋友来。你从来没有见过那样娇小玲珑的女子；年纪只有十八岁。她跟一个男孩子闯了祸；因为有了身孕，只好离开自己村子。男孩子正在服兵役。她生下孩子之后，把孩子交给乳娘带，自己在烟草工厂里找了一个工作。我把她带回家。\n她人非常快活可爱；几天之后，我就问她愿不愿意和我同居。她说愿意，所以我们就在有余屋分租的人家租了两间房，一间卧室，一间起坐间。我跟她说她可以不去做工，可是她不肯，这对我也合适，因为这样白天我就可以自己支配。厨房是公用的，所以，她总是在上工之前给我把早饭烧好，中午时候回来烧午饭，晚上我们上馆子，饭后看电影或者找个地方跳舞。她把我看作是疯子，因为我洗过一次蒸汽浴，而且每天早上非要用海绵蘸冷水淋身不可。她把孩子托在一个村子里，离塞维利亚有几英里，我们常在星期天去看他。她并不瞒我，她跟我同居是为了多赚两个钱，等她的男朋友服兵役期满之后，好和他在大杂院里找个住的地方。她是个很惹疼的小东西，肯定说她会成为她的帕科的好妻子。人兴致好，性情温和，热忱。她把人们讳言的性交看作是身体的自然功能之一，和别的身体功能一样。她从中找到快乐，也高兴给人快乐。她当然象一只小动物，但她是一只很好的，吸引人的，驯化了的动物。\n“后来有一天晚上，她告诉我，她收到帕科从西属摩洛哥（他服兵役的地方）寄来一封信，说他就要复员，两天内将抵达加的斯。第二天早上，她把自己东西打了包，把钱塞在长袜子里，让我送她上车站。当我把她送上车厢时，她热烈地吻了我，可是，她大兴奋了，一脑门子只想到和自己的情人重逢，谈不上和我惜别。我有十足的把握，在火车还没有完全开出车站之前，她已经把我忘记得一干二净了。\n“我在塞维利亚继续住下去倒秋天就动身去东方，也就是那一次使我到达印度的。”\n五 # 时间已经很晚了。客人逐渐少下来，只有几张桌子还坐了些人。那些因为无所事事而坐在那里的人都回家了。那些看完了戏或者电影来这里喝杯酒或者吃点东西的人，也已经离开。偶尔会有些晚到的客人，闲闲散散走进来。我看见一个高个子，显然是个英国人，带了一个年轻流氓进来。他有一张英国知识分子长长的疲惫的脸，稀疏的鬈发；他有着和许多人一样的幻觉，总以为只要人到了国外，你在国内认识的人就没法认出是你来。年轻流氓狼吞虎咽地吃一大盘三明治，他的同伴则带着喜悦和仁慈的眼光在一边看着他。真好的胃口！我看见一个脸熟的人，因为我们在尼斯时同在一家理发店理过发。这人个子高大，年纪不小了，花白头发，一张红红的虚胖的脸，眼睛下面两个大大的眼包。他是美国中西部的一个银行家，经济大崩溃之后，宁可离开自己根生土长的城市，而不愿意对簿公堂。我不知道他究竟犯了罪没有；如果他犯了罪，他在法国当局的眼中恐怕也是个提不上嘴的人物，犯不着引渡他。他派头很大，而且象蹩脚政客那样假装兴高采烈，但是，他眼睛里显出害怕和忧郁。他从来没有完全醉过，也从来没有完全清醒过。他总是带着一个妓女，而这个妓女显然在尽可能地榨取他。而现在他正带着两个满脸脂粉的中年妇女坐在那里；两个妇女显然在嘲笑他，而且并不打算加以掩饰；他呢，只勉强懂得她们讲话的意思，还在吃吃地傻笑。繁华的生活啊！依我看来，他还是呆在家里吃下那帖苦药的好。有一天，女人会把他榨干，那时候，他就只有投河或者服安眠药自杀的一条路了。\n在两点和三点之间，生意好一点起来，大约是因为夜总会关门了。一伙美国青年踱了进来，喝得烂醉而且闹得厉害，不过，不久就走了。离我们不远，两个脸色阴沉的胖女人穿着男人似的紧身装束，并排坐着，一声不响在忧郁地饮着威士忌苏打。来了一群穿晚礼服的人，是法文里叫作gens du monde[注]的人，显然是到各处逛逛，现在要找个地方吃宵夜，作为结束。他们来了又走了。一个小个子男人，穿着朴素，坐在那里有一个多钟点，面前放了一杯啤酒，在看报。这人引起我的好奇心。他留了一撮整齐的黑胡子，戴夹鼻眼镜。终于进来了一个女人和他坐在一起。\n他向女人点一下头，毫不亲热。我猜想，他大约因为女人使他久等，生气了。女人年纪轻，穿得很不象样，但是涂得满脸脂粉，而且看上去很疲倦。过不久，我看见女人从手皮包里拿个东西交给他。钱！他看看，脸色沉下来。他跟女人讲的话我听不见，但是，从女人的样子看来，这些话大约是骂她的，而且她好象在给自己开脱。\n突然间，他探身过去，给了女人一记响亮的耳光。她叫了一声，呜呜咽咽哭起来。\n经理听见闹声赶来，看是怎么回事。他好象在告诉他们，如果不守规矩，就滚出去。\n女子转身向着经理，并且为了使别人听见，尖着嗓子用下流话告诉他不要多管闲事。\n“他打我耳光是我自找的，”她大声说。\n这些女人！过去我一直认为一个人要靠女人卖淫吃饭，一定得身体精壮、面目姣好而且具有性感，随时会动刀子或者拔出手枪；没想到这样一个矮小委琐的家伙，从外表看来，可能只是律师事务所的一个小职员，竟而能够在这人满为患的职业里有插足之地。\n六 # 那个伺候我们这张桌子的侍役要下班了；为了拿到小帐，把帐单送过来。我们付了钱，并叫了咖啡。\n“怎么样？”我说。\n我觉得拉里有心思讲下去，我也知道自己有心思所下去。\n“我不使你厌烦吗？”\n“不。”\n“好吧。我到了孟买。船在孟买要停三天，让那些旅游者借此游览一下，并作短途旅行。第三天，我下午不值班，就上岸去走走。我走了一转，看看来往人群：真是五方杂处！中国人，穆斯林教徒，印度教徒，和你的帽子一样黑的泰米尔人；还有那些拖大车的、长着两只长角的驼背公牛！后来我去石像山逛了那座山洞[注]。\n一个印度人在亚历山大城搭了我们的船去孟买，那些旅游者都不大看得起他。这人矮而胖，一张棕黄色的圆脸，穿一套黑绿两色格子的厚花呢衣服，围一条牧师的领子。有天晚上，我正在甲板透透空气，他跑上来和我攀谈。刚巧那时候我不想跟任何人谈话，我要单独一个人；他问了我许多问题，恐怕我对他有点不大客气。反正我告诉他我是一个学生，为了回美国省点路费而在船上干活的。\n“‘你应当在印度逗留一下，’他说。‘东方能够教给西方的东西，比西方所想象的要多。’“‘是吗？’我说。\n“‘反正，’他继续说，‘你一定得去看看石像山的山洞。你决不会后悔。’”\n拉里打断自己问了我一个问题。“你到过印度没有？”\n“从没有到过。”\n“是这样，我正在瞧着那个庞大的三头神像，这是石像山的巨观，而且弄不懂这是什么意思时，听见身后有人说道：‘原来你接受我的劝告了。’我转过身去，一眼就看出是谁在跟我说话。就是那个穿厚花呢衣服，戴牧师领子的矮子，可是，现在，他穿上一件番红色长袍；事后我才知道，这种长袍是罗摩克里希那教会长老[注]着的。他已经不再是以前的那个滑稽相的吱吱呱呱小矮子，而是很有派头，很神气了。我们同时都盯着那个庞大的胸像看。\n“‘大梵天，司创造，’他说。‘毗湿奴，司护持；湿婆，司破坏。绝对精神的三个表现。’“‘我不大懂得你的意思，’我说。\n“‘这并不奇怪，’他回答，唇边露出微笑，眼睛眨了一下，仿佛在嘲笑我。\n‘一个能够被人了解的上帝就算不上上帝。无限岂能形诸语言？”\n“他合掌微微躬身，就漫步走去。留下我望着那三个神秘的头像。也许我正处在一种虚心接受状态，自己感到异常激动。你知道，有时候，人在回忆一个名字的情形；那名字就在嘴边，可你就是叫不出来：当时我的感受就是这样。我从山洞里出来之后，坐在石阶上很久很久，望着大海。我关于婆罗门教的全部知识只是爱默生[注]的那些诗，现在想把那些诗背出来，但是背不出。这使我很恼火。回孟买时，我走进一家书店，看能不能找到什么书收进这些诗的。原来在《牛津英诗选》里。\n你记得吗？\n他们刷掉我是他们失算，他们逃避我，我就是羽翼：我是怀疑者，我也是怀疑，我是婆罗门歌唱的圣诗。\n“我在一个本地饭馆吃了晚饭，然后到练兵场上走走，眺望大海，因为我可以玩到十点钟上船。我觉得从来没有看见天上有这么多的星星过。一天酷热之后，晚凉便人很受用。我找到一处公园，在长凳上坐下。公园里很黑，沉默的白色人影在我身旁来来去去。这个神奇的一天，朗照的日光，五颜六色的闹吵吵的人群，辛辣而芳香的东方气味，使我心醉了；而那三尊‘大梵天’、毗湿奴和湿婆的庞大头像，就象画家用来使他的构图具有完整性的一个物体或者一片颜色似的，赋予这一切以一种神秘的意义。我的心开始疯狂地跳起来，因为我突然间深深体会到印度能给我某种我非有不可的东西。那就象有个机会摆在我面前，我要么立刻拿到手里，要么就永远失之交臂。我很快打定主意，决定不回船。船上我没有留下什么，只有一只旅行袋，装了几样东西。我慢慢走回本地居民区，看有没有旅馆；不久就找到一家，要了一个房间。我有的是身上穿的衣服，一点零钱，护照和取款证明信：我觉得非常自由，大声笑了。\n“开船在十一点钟；为了保险起见，我等到十一点才走出房间。我走到码头上，看船开出去，然后去罗摩克里希那教会，访出那位在石像山和我谈话的长老。我不知道他的名字，但我讲明要见那位刚从亚历山大城来的长老。我告诉他，我决定在印度呆下来，并且问他应当看些什么。我们谈了好半天，最后，他说，他当晚要去贝那勒斯，问我可愿意和他一同去。我高兴得跳起来。两个人坐的三等车厢。车厢里满是人，吃东西，喝酒，谈话，而且热得简直吃不消。我一夜没有闭眼；第二天早上，人相当疲倦，可是，那位长老就象一朵雏菊那样精神奕奕。我问他怎么会的，他说：‘靠参究混沌；我在绝对中找到休息。’我不懂得该怎么想法，可是，我能够亲眼看出他就象在一张舒适的床上睡了一夜好觉那样神清气爽。\n“贝那勒斯总算到了。一个和我年纪相仿的年轻人来迎接我的伙伴；长老命他给我找一间房子住。他的名字叫马亨德拉，是大学里的一个教师。人忠厚聪敏，很喜欢我；我也很喜欢他。那天傍晚，他带我坐一条船去游恒河；这对我可说是开眼界，全城的人都拥到水边来，望去很美，简直惊心动魄；但是，第二天早上，他还有更好的指给我看。天没有亮，他就到旅馆来叫我起身，重又把我带到河边。我看见的事情使我简直不相信自己眼睛：成千上万的人来到水边洗去邪浴和祷告。我看见一个又长又瘦的高个子家伙，蓬发虬髯，只穿一条兜带这着下体，立在那里伸出两只长胳臂，仰起头，高声向着初升的太阳做祈祷。我没法形容给你我所获得的印象。我在贝那勒斯呆了六个月，破晓时，屡次到恒河边去看这种稀有的景象。我永远忘记不了这种奇观。那些人一点不是将信将疑，一点不带有保留，或者疑虑参半。\n“人人都对我很好。他们一旦发现我来并不是为了打老虎，或者做买卖，而是求学，就想尽方法帮助我。他们很高兴我想学习兴都斯坦语，并且替我找先生。他们借书给我；回答我的问题从来不感到累。你对印度教可懂得吗？”\n“很有限，”我答。\n“我以前还当作你会感觉兴趣呢。印度教认为宇宙没有开头，没有结尾，而是永远从成长到平衡，从平衡到衰落，从衰落到解体，从解体到成长，如是以至无穷；可有什么见解比这个更了不起的？”\n“印度教徒认为这种无完无尽的周而复始，其目的是什么？”\n“我觉得他们会说这就是绝对的本性。你晓得，他们相信生死是一个阶段，其目的是对灵魂的前世行为给予惩罚或者奖励。”\n“这就是主张轮回说。”\n“三分之二的人类都相信这个学说。”\n“有许许多多人相信并不能保证它就是真理。”\n“不能，但至少值得认真对待。基督教吸收了不少的新柏拉图主义，它当初说不定很便当地也吸收了轮回说；事实上，有一个早期基督教派就相信轮回说，但是被宣称为异端。如果不是因为这个缘故，基督教徒就会对轮回和对耶稣复活一样深信不疑。”\n“轮回是不是指灵魂从一个身体转到另一个身体，并且根据前生的功过没完没了地经历下去？”\n“想来是这样。”\n“可是，你知道，我不但是我的灵魂，也是我的身体。谁说得了我之所以为我，有多少是我的身体碰巧造成的。拜伦不是因为碰巧生了一只畸形的脚会是拜伦吗？\n陀思妥耶夫斯基不是因为碰巧有羊痫风会是陀思妥耶夫斯基吗？”\n“印度人不愿意说碰巧。他们会说是你前生的所作所为，才使你的灵魂投进一个残缺的身体。”拉里用手指轻轻敲着桌子，眼睛空无所瞩地在出神。后来，嘴边露出微笑，眼睛里显出深思的神气，继续说道：“你可曾想到过，轮回既是世间有恶的解释，也是恶的存在理由？如果我们受的恶报是我们前生造孽的结果，我们就会服服帖帖地忍受，并在今生努力行善，使来生少受些苦。但是，自己忍受恶报比较容易，只要硬挣一点就行；使人不能忍受的是看见别人受苦，而这些苦难看起来往往不是应得的。如果你能够说服自己，认为这是前世作的孽，你可以怜悯人家，可以尽力减轻其痛苦，而且应当如此，但是，你没有理由抱怨或者不平。”\n“可是，为什么上帝不在一开始就创造一个没有痛苦和不幸的世界，使人决定自己的行动时没有功过可言呢？”\n“印度教徒会说开始是没有的。个人灵魂是与天地同存的，从古如斯，它的善恶则由以前的生存决定。”\n“那么相信轮回说对人的生活会有实际影响吗？说来说去，考验就在这上面。”\n“我认为有影响。我可以告诉你我的一个相识，轮回说对他的生活肯定产生了很实际的影响。我到印度的最初两三年中，大都住在当地的旅馆里，但是，有时候，也有人请我到他家里去住，而且有一两次在一位生活很阔气的土邦主的家里作客。\n通过我在贝那勒斯一个朋友的关系，我被邀请到北方的一个小土邦去住住。首府很爱人；‘一座桃红色的城市，有时间一半老’。朋友介绍我认识的是一位财政部长；他受过欧洲教育，在牛津读过书。跟他谈话时，你得到的印象是一个有学识的进步开明人士，而且以一个极端能干的部长和精明的政治家知名于时。他穿西装，外表很整洁；相貌相当漂亮，和一般印度人达到中年时一样，身体稍微有点发胖，留了一撮修剪得很整齐的上须。他时常请我到他家里去。家里有座大花园，我们常坐在大树的荫影里聊天。他有一个妻子，两个成年的孩子。你会把他看作只是一般的，相当平常的，英国化的印度人，所以，有一天，我发现他一年之后他五十岁时，就要辞去自己进项很好的职位，把财产交给妻子和孩子，去做托钵僧到处去飘流，不由得大吃一惊。但是，更使人诧异的是，他的朋友们，以及土邦主，都认为事情已成定局，并且把这看作是很自然的事，而不是什么出奇出格的行为。\n“有一天，我跟他说：‘你这人头脑是很开通的，而且见过世面，读过万卷书，科学，哲学，文学——难道你真心真意相信灵魂转世吗？’“他的整个表情变了，完全是一副先知的脸。\n“‘我亲爱的朋友，’他说，‘如果我不相信灵魂转世，生命对我将会毫无意义。’”\n“那么你相信吗，拉里？”我问。\n“这个问题很难回答。我认为，我们西方人不可能象东方人那样从心眼里相信。\n这和他们是血肉相连的；而对我们说来，只能是种见解。我既不相信，又不不相信。”\n他停了一下，手托着脸看着桌子；然后向后靠起。\n“我想告诉你，我有过一次非常奇怪的经验。那时，我在阿什拉玛；一天晚上，在自己的小房间里按照我的印度朋友教给我的方式参掸。我点了一支蜡烛，把注意力集中看着火焰；过了一段时间，我从火焰里很清晰地见到一长串的人物。为首的是一个年事已长的妇女，头上一顶花边帽，戴一对灰色耳环，穿一件黑紧身上衣和一条黑绸撑裙大约是上世纪七十年代穿的那一种；她站在那里，正面向着我，态度姻雅谦虚，两臂沿身体下垂，手掌心向着我。一张有皱纹的脸，脸上神情给人以和蔼可亲的感觉。紧接在她后面是一个瘦长个子的犹太人，偏着身子使我只能看见他的旁相；他长了一只鹰钩鼻子，和两瓣厚嘴唇，穿一件黄色粗布衣服，一顶黄便帽这着浓密的深色头发。他的神态象个好学深思的学者，表情严肃，同时又富于情感。\n在他身后是一个年轻人，但是脸朝着我，就象我们中间不隔着任何人似的，他面色红润愉快，一眼就看出是一个十六世纪的英国人。他直挺挺地站着，两腿稍稍分开，神情强悍骄横；全身装束都是红色，就象朝服一样华丽；脚上穿的宽头黑丝绒鞋，头戴黑丝绒扁帽。在这三个人后面，还有一长串数不尽的人，就象电影院外面排的长队，但是，模模糊糊，看不清他们的面貌。我只感觉到他们的模糊形状和夏风吹过麦田时的那种起伏动作。没有一会儿工夫，不知道是一分钟，还是五分钟，还是十分钟，他们便慢慢消失在夜晚的黑暗里，只剩下蜡烛的稳定火焰。”\n拉里微笑一下。\n“当然可能是我睡糊了或者做梦。可能是我把注意力集中在那微弱的火焰上，使我进入一种催眠状态，而我看见的三个象你一样清晰的人只是保留在潜意识里的过去见到的图画。但也可能是前世的我；可能不多年以前我是新英格兰的一位老太太，而在这以前是勒旺岛一带的一个犹太人，而再在这以前的若干年，在塞瓦斯蒂安?卡博特[注]从布里斯托尔启航不久以后，是亨利王太子宫廷的一个风流人物。”\n“你那个桃红色城市的朋友结局怎么样？”\n“两年后我去南方的一个叫马都拉的地方；一天晚上，在庙里有人碰碰我的胳臂；我转身看时，瞧见一个留了胡须和长头发的人，只在腰间围了一块布，拿一根手杖和圣徒化缘的钵子。直到他开口，我才认出是谁，原来就是我那位朋友。我惊得不知说什么是好。他问我这两年做些什么，我告诉了他。他问我去哪里，我说去特拉凡哥尔；他叫我去见见西里?甘乃夏。‘他会传授给你你寻求的东西的。’我请他谈谈这个人，他只是笑笑，说一切见面自知。那时候，我对这些事已经司空见惯了，就问他在马都拉干什么。他说，他正徒步到印度各地朝圣。我问他食宿怎样解决的。他告诉我，有人家肯借宿，他就睡在凉台上，没处借宿就睡在树下，或者在庙里安身；至于吃的，有人施舍就吃，没有就饿肚子。我看看他，说‘你瘦了’。\n他大笑，说他觉得瘦了更好受。接着他就向我告别，听这个腰间只围一块布的人向我说英语‘well so long，old chap’[注]，真是滑稽——后来，他就走进了庙中的内室，那是我进不去的。\n“我在马都拉呆了一个时期。这庙恐怕是印度唯一的可以让白人随意走动的庙宇，只有庙中最圣洁的部分不能进去。天黑以后，庙里挤满了人，男男女女，大大小小。男人赤膊穿件围腰布，额上，往往连着胸口和胳臂，都涂上牛粪烧剩的白灰。\n你看见他们在这个或那个神龛面前膜拜，有时候，整个人匍匐在地上，脸朝下，行五体投地礼。他们祈祷并且朗诵连祷经文；他们相互叫唤，招呼，斗嘴，热烈争辩。\n一片邪恶的吵闹声，然而，莫明其所以然，上帝好象近在咫尺而且活灵活现。\n“你穿过许多长厅堂，厅堂的屋顶都有雕塑的柱子撑住，靠近柱子下面都有一个托钵僧人坐着：每人面前放一只化缘的碗，或者一小块席子，让虔诚的人不时丢一个铜板。他们有些穿着衣服，有些几乎是赤身裸体。有些在你经过时瞠目望着你；有些念着经，或者读出声来，或者默诵，对川流不息的人群仿佛毫不觉察。我想在他们中间寻找我那位朋友，但是，就此见不到他了。想来他已经开始自己预定的行程了。”\n“那是什么呢？”\n“不再堕入轮回。根据吠陀经义，真我，即他们称作阿特曼而我们称作灵魂的，与身体及其感觉，与心灵及其智力，都不相同；它不是绝对的一部分，因为绝对由于是无限的，就不能有部分而只能是它本身。灵魂不是创造出来的；它亘古以来就有了，而当它终于解脱掉愚昧的七重蒙蔽之后，就会回到它原来的无限去。它就象海里蒸发起来的一滴水，在一场雨后坠进水潭，然后流人溪涧，进入江河，通过险峻的峡谷和广袤的平原，迂回曲折，络石萦林，终于抵达它所由升起的无垠大海。”\n“但是，这一小滴可怜的水，当它重又和大海合为一体时，肯定是失去个性了。”\n拉里咧开嘴笑。\n“你要尝尝糖的味道，你并不要变做糖。个性除掉表现我们的自我中心主义外，还会是什么？除非灵魂摆脱掉自我中心的最后痕迹，它就不能和绝对合为一体。”\n“你谈起绝对来，好象很熟悉，拉里，而且这个名词非常冠冕堂皇。它对你究竟意味着什么？”\n“现实。你没法说它是什么，你也没法说它不是什么。它是无法表达的。印度称它为大梵天。它是无在而无所不在。万物都蕴涵它，仰藉它。它不是人，不是物，不是因。它没有属性。它凌驾在久与变之上，整体与部分之上，有限与无限之上。\n它是永恒的，因为它的完善与时间无关。它是真理和自由。”\n“我的老天！”我肚子里寻思，但是对拉里说道：“不过，一个纯理智的观念怎么能成为受苦人类的慰藉呢？人总是要求一个人化的上帝，俾能在苦难时祈求安慰和鼓励。”\n“也许在遥远的将来，通过更大的洞察力，人类有一天将会看出只有在自己的灵魂里面寻找安慰和鼓励。我自己以为崇拜个人化的上帝只是古代祈求残忍神抵的蛮性遗留。我相信上帝只在我心里，此外哪儿都没有。如果是这样，我应当崇拜谁呢？崇拜我自己？人的精神发展是分不同阶段的，因此在印度人的想象中，绝对就表现为大梵天、毗湿奴、湿婆和上百种其他名称。绝对在‘自由’（即宇宙大神）里，它是世界的创造者和统治者，也在那些卑微的神物[注]里，那些在太阳烤得滚烫的田里的农民放一朵花供奉的卑微的神物。印度的那些名目繁多的神只是些用以达到使自我与至高的我合为一体的手段。”\n我望着拉里，一面沉思。\n“我不懂得是什么使你向往这种严峻的信仰，”我说。\n“我想我可以告诉你。我一直觉得那些宗教的创始人有种使人觉得可悲的地方，因为他们要你信仰他作为得救的条件。看上去好象他们要倚靠你们的信心才能对自己有信心。这使你联想起古代那些异教的神抵，如果没有信徒的祭祀，就会变得日益憔悴。吠坛多的不二论哲学并不要求你凭信仰去接受什么；它只要求你具有认识现实的热烈欲望；它断言你能够象感到快乐或痛苦一样有把握地感觉到上帝。而且今天印度有许多人——以我所知总有成百上千的人——自认已经做到这一点。我对于人可以通过知识达到最高现实这种想法感到非常满意。在后期，印度的圣徒有鉴于人类的软弱性，承认通过爱和通过工作也可以得到解脱，但是，他们从来不否认最高但是最艰难的途径是通过知识，因为知识的工具是人类最宝贵的能力，即他的理智。”\n七 # 这里我得先行交代一下，我并不想在本书里阐述所谓《奥义书》[注]的哲学体系。我懂得太少了，但是，即使懂得很多，这也不是阐述《奥义书》教义的地方。\n我们的谈话很长；拉里告诉我的比这里写的要多得多，但是，这本书说到头毕竟是部小说，不适宜把拉里讲的话全都记录下来。我想到的只是拉里。下面不久我就要讲到拉里所要采取的行动；我觉得至少要提一下他的那些哲学思考，和可能由此而引起的稀罕经验，否则就会使人觉得他的那些行径不合乎人情；除掉这个原因，我根本不会涉及这样一个复杂绕人的宗教问题。他的声音非常悦耳，连最最随便的一句话都带有说服力；他的脸部表情经常随着他的思想在变化，从严肃到轻快，从沉吟到嬉戏，就象钢琴在许多小提琴猛然奏起一个协奏曲的几个主题时发出的涟漪一样；而使我感到恼火的是，所有这些我休想用语言形容得了。尽管在谈正经事情，他谈时却很自然，口气就象平时谈话一样，也许有点踟躇，但是丝毫不勉强，犹如在谈天气或者庄稼。如果读者有一个印象好象他在说教，那完全是我的过失。他的谦虚，和他的诚恳，都是一望而知的。\n咖啡馆里已经稀稀落落，剩下没有几个人了。那些闹酒的早已离开。两个靠爱情做生意的可怜虫也已经回到他们肮脏的寓所。不时走进来一个满脸倦容的人要一杯啤酒和一块三明治，或者一个好象还没有完全睡醒的人要一杯咖啡。都是些脑力工作者。一个是值完夜班回家睡觉；另一个是被闹钟惊醒，一肚子不愿意去参加冗长的一天劳动。拉里似乎对时间和对周围情况都毫不觉察。我这一生中碰到的离奇事情可多着。我曾经不止一次差一点儿送命；曾经不止一次几乎做下风流勾当而且自己心里明白；曾经骑一匹小马沿着马可波罗当年通往传说中的中国那条路穿过中亚细亚；曾经在彼得堡一间整洁的会客室里一面喝俄国茶，一面听一个穿黑上衣条纹裤子的、和声和气的矮子谈他怎样暗杀一个大公；曾经坐在议会大厦一间客厅里倾听着海顿[注]的恬静温柔的钢琴三重奏，而飞机的投弹则在外面爆炸着；但是，这些遭遇我觉得都不及眼前这样离奇：在一家花花绿绿的咖啡馆里，坐着红丝绒椅子，听拉里一个钟点接一个钟点谈下去，谈上帝和永恒，谈绝对和厌倦的没完没了的轮回。\n八 # 拉里有几分钟没有说话。我不想催他，所以等着。接着，他向我友善地一笑，仿佛突然又觉察到我。\n“当我到达特拉凡哥尔时，我发现根本不用打听西里?甘乃夏的下落。人人都知道他。有好多年他都住在深山的一个山洞里，但是，最后被人劝说迁移到平原上来，由一位施主舍出一块土地，给他造了一间土砖墙的房子。这里离首府特里几得琅有很长一段路，我花了整整一天，先是坐火车，然后坐牛车，才到达道观。在院子的进口处，我碰见一个年轻人，问他能不能见到师长[注]。我带了一筐水果，这是通常的觐见礼。几分钟后，年轻人回来，领我到一处长轩，四周围全是窗子。在长轩的一角，西里?甘乃夏坐在一张蒙着虎皮的平台上参禅。‘我在等你呢，’他说。这使我感到诧异，但是，猜想大约是我在马都拉的那个朋友跟他谈到我的。可是，当我提起这个朋友的名字时，他摇摇头。我把水果呈上，他叫年轻人把水果拿走。这时只剩下我们两个人，他看看我，没有说话。我不记得这样的沉默有多久；可能有半小时。我已经告诉过你他的仪表；但没有告诉你他身上焕发出的那种宁静，那种善良、平和、无我的气息。我一天旅行下来，人又热又疲倦，但是，逐渐感到完全安静下来。在他没有再开口之前，我已经知道他就是我要访求的人了。”\n“他说英语吗？”我打断他。\n“不。可是，你知道，我学语言相当快。我已经学了不少泰米尔语，使我能在南部和人应对。他终于开口了。\n“‘你来作什么的？’他问。\n“我开始告诉他，我是怎样来印度和怎样度过这三年的；怎样根据人家传说某某人多么智慧、多么圣洁，我一个个找上门，但发现他们谁也没能给我满意的答复。\n他拦着我。\n“‘这我全知道。用不着告诉我。你来这儿做什么？’“‘希望你做我的师傅，’我回答。\n“‘只有大梵才是师傅，’他说。\n“他以一种古怪的神情死命盯着我瞧，后来，突然身体变得挺硬，眼睛象是转为内视，看得出他的人进入印度人叫做的人定状态，在这种状态下，物我之分开始消失，人成为绝对知识。我盘膝坐在地上，面向着他，心怦怦跳。经过了不知多久时间，他叹口气，我知道他已经恢复正常知觉。他以慈爱的神情看了我一眼。\n“‘住下吧，’他说。‘他们会告诉你住宿的地方。’“他们拨给我的住处就是西里?甘乃夏初次来到平原时住的那间土砖墙房子。\n他现在日夜住的长轩是在他的门徒聚集得越来越多，和有更多的人慕名而来之后兴建的。为了不至引人注目，我改穿了舒适的印度服装，而且皮肤晒得黝黑，除非你特别注意到我，否则，很可能把我当作是本地人。我读了许多书：一个人思索；在西里?甘乃夏高兴讲话时，听他讲。他不大讲话，但是，你有问题问他时，他都愿意回答。听他讲话，真使人振奋；听上去就象音乐一样。他自己虽则在年轻时持戒律极严，但并不要求自己的门徒照做，只是劝导他们摆脱私心、情欲、声色的奴役，告诉他们通过静穆、克制、谦虚、退让，通过专心致志，通过对自由的孜孜向往，他们就可以得到解脱。人们常从三四英里外的一个镇市赶来求他；那儿有一座著名的庙宇，每年都有大群的人来赶庙会；人们从特里凡得琅来，从辽远的地方来，把自己的苦难告诉他，向他请教，听他的教导；离开时，全都胸怀舒畅，心定神安。\n他的教导很简单。他教导说，人都比他自视的为高，而智慧是解脱之道。他教导说，要脱离苦海并不一定要出家，只要去掉一个我字。他教导说，行事不怀私心使心地纯洁，责任为个我并人大我提供机会。但是感人最深的并不是他的那些教导而是他的为人，他的慈祥，他的气度，他的圣洁。只要能见到他的面，就是福气。同他在一起，我觉得很幸福。我感到终于达到了自己追求的目的。一个星期接一个星期，一个月接一个月，日子过得想象不到地快。我打算住到他死为止，因为他告诉我们，他不打算在这躯壳里呆多久了，不然就是等我有一朝大彻大悟，那就是终于冲破愚昧的藩篱并且深信不疑自己与绝对合而为一了。”\n“那么这下面呢？”\n“这下面，如果他们讲的话局实，就没有可说的了。灵魂的尘世旅程就此结束，永不再来。”\n“西里?甘乃夏死了吗？”我问。\n“以我所知，还没有死。”\n他说时看出我问这话的用意，轻微地笑了一声。经过片刻迟疑之后，方才又说下去，可是，说话的派头使我起先以为他想避免回答我在口边上的第二个问题，那当然是指他有没有达到大彻大悟。\n“我并没有一直住在道观里。我有幸认识当地一个森林管理员，他的住处就在山脚下一个村子边上。这人最笃信西里?甘乃夏，在公务之暇，总要来跟我们盘桓两三天。人非常之好，和我们一谈半天。他喜欢找我练习英语。和我认识了一段时间之后，他告诉我森林管理所在山上有间小屋子，哪一天我想一个人上山去住住，他就把钥匙交给我。我有时候去那里。路上要走两天；先坐长途汽车到森林管理员的村子，下面只好步行，可是，到达之后，那种庄严，那种幽静，真是壮丽。我把所能携带的东西装在一只背袋里，雇了个脚夫替我扛食物，一直呆到粮食吃完为止。\n那只是一所用树桩钉成的小屋，后面有一间烧饭的地方；家具除掉一只可以放一张席子的支起架床，和一张桌子、两把椅子外，别无长物。山上很风凉，有时候，晚上升个火，倒也受用。想到二十英里之内渺无人烟，不禁感到惊心。晚上常常听见虎啸或者象群穿过丛莽的嘈杂声。我常在森林中走得很远。有一个地方是我最喜欢坐的，因为坐在那里全山景色都映人眼帘，还可以俯眺下面的湖水。在黄昏时刻，许多野兽，如鹿、豕、水牛、象、豹都来饮水。\n“我呆在阿什拉玛刚满两年之后，就到我山上那个隐居的地方去住；我去的理由，你听了也许会好笑，我要在那边过我的生日。我在生日的前一天到达那里。第二天早上，天没亮就醒来，想去我刚才告诉你的那个地方看日出。那地方我闭着眼睛也摸得到。我坐在一棵树下等着。当时还是黑夜，但是，星儿淡了，说明白天就要到来。我怀着一种古怪的期望心情。光线开始一点一点地，几乎使人觉察不到，缓缓透过黑暗，就象一个神秘的身形蹑足穿过树丛。我感到心跳，就象碰到危险似的。太阳升了起来。”\n拉里停了一下，嘴边露出苦笑。\n“我不会形容，那些写景的字眼我全不会使用，我讲不来，不能使你亲眼看见破晓时展现在我面前的那片壮丽景色。那些满布茂密林莽的群山，晓雾仍旧笼罩在树顶上，和远在我脚下的那座深不可测的大湖。太阳从山峦的一条裂缝中透进来，照耀得湖水象灿银一样。世界的美使我陶醉了。我从来没有感到过这样的快意，这样超然物外的欢乐。我有一种古怪的感觉，一种震颤从脚下起一直升到头顶，人好象突然摆脱掉身体，象纯精灵一样分享着一种我从来没有意想到的快感。我感到一种超越人性的知识掌握着我，使得一切过去认为混乱的变得澄清了，一切使我迷惑不解的都有了解释。我快乐得痛苦起来；我挣扎着想摆脱这种状态，因为我觉得再这样继续下去，人就会立刻死掉；然而，我是那样陶醉，又宁可死去而不愿放弃这种欢乐。我有什么法子告诉你我那时的感觉呢？没有言语能够形容我当时的幸福心情。等我恢复到原来的我时，人变得精疲力竭，而且在发抖。我睡着了。\n“我醒来时，已经是中午。走回我的小屋时，人是那样的轻松愉快，好象脚不沾地一样。我给自己弄点吃的，我真的饿了，并且点上烟斗。”\n拉里这时也点上烟斗。\n“我不敢认为这是我，伊利诺斯州麻汾镇的拉里?达雷尔所得到的启示，而别人穷年累月苦行苦修到今天还没有到手的。”\n“你为什么不认为这只是一种催眠状态，是你当时的心情，加上你的孤寂，破晓时的神秘气氛和你脚下那片灿银的湖水，造成的呢？”\n“那是由于它的极端真实感。说实在话，它就是千百年来世界各地的神秘主义者所获得的那类经验。印度的婆罗门，波斯的苏非[注]，西班牙的天主教徒，新英格兰的新教徒；只要他们想要形容那无法形容的境界，使用的语言都差不多。这种境界的存在是无从否认的；唯一的困难在于解释。是不是我一时间和绝对合为一体，还是潜意识里的一种亲力（我们全都有这种潜在亲力）流进普遍精神所致，我也说不了。”\n拉里停了一下，向我嘲弄地看了一眼。\n“还有，你能用拇指碰到你小指头吗？”他问。\n“当然能，”我笑着说，并且当场做给他看。\n“你可知道这只有人和灵长目动物能够做到？由于拇指能够和别的指头相对，手才成为现在这样可爱的工具。这种能够和别的指头碰到的拇指，当它还在雏型时，会不会只在个别的人类祖先和大猩猩中才有；它之成为人类的共同特征只是经过无数世代发展的结果，会不会呢？而这类和绝对合为一体的经验，过去为许多不同的人所具有的，会不会指向人类意识的一个第六感觉的发展方向，即在遥远遥远的将来，它将成为人类共同的感觉。人类将如现在感到感官事物一样，直接感到绝对呢？\n这至少是可能的。”\n“如果那样，你指望会对人类有什么影响呢？”我问。\n“我无法告诉你，就如同那第一个能将拇指碰到小指的人，无法告诉你这点细微动作将蕴涵多少重大后果一样。我只能告诉你，那片刻陶醉时抓住我的浓郁的宁静、欢乐和安泰感仍旧留在我心里，那种第一次使我眼花缭乱的宇宙美丽境界，现在仍旧同样鲜明生动。”\n“可是，拉里，你关于绝对的见解肯定会逼使你认为世界和世界的美只是幻觉——是玛雅[注]一手造成的。”\n“认为印度人把世界看作是幻觉，这是错的；印度人并不如此；他们只说世界的真实和绝对的真实不能同日而语。玛雅只是那些热衷的思想家编出来的，借此解释无穷怎样创造有穷。沙姆卡拉，他们里面最聪明的一个，断言这是一个解决不了的谜团。你知道，困难在于解释为什么婆罗门要创造世界。婆罗门是存在、福泽和智慧；它是不可改变的；它一直在这里，而且永远保持静止，它什么都不缺，它什么都不需要，因此既不知道变易，也不知道争夺，它是十全十美的；既然如此，它为什么要创造世界呢？你假如问这个问题，你得到的一般解答是，绝对创造世界是闹着玩的，并不带有什么目的。可是，当你想到洪水和饥谨，地震和飓风，想到折磨人体的一切疾病，你的正义感就会爆发出来，认为这么多骇人听闻的东西当初怎么会这样随随便便就创造出来。西里?甘乃夏心地太忠厚了，所以不相信这种学说；他把世界看作是绝对的表现，而且是它的完善的泛滥。他教导说，神没法子不创造，而世界则是神性的表现。我问他，既然世界是一个十全十美的主宰的本性表现，为什么它是这样的可恨，使众生的唯一合理出路就是摆脱它的束缚。西里?甘乃夏回答说，尘世的满足都是暂时的，只有无限能提供持久的快乐和幸福。但是，时间的没完没了并不能使善更加善些，也不能使自更加白些。如果中午的蔷薇失去它在清晨时的娇美，它在清晨时的娇美仍然是真实的。世间万事万物都有个完，我们除非是傻子才要求事物永久不变，但是，如果我们不抓着手里的东西及时享受它，肯定说我们就更傻了。如果交易是事物的本性，我们会认为把这一条作为人生哲学的前提，是最合情合理了。我们谁也不能两次濯足于同一的河流，然而，河水流去，继之流来的水仍旧一样清凉沁人。\n“往昔雅利安人初次来到印度时，把我们知道的世界看作只是不可知世界的表象；但是，他们欢迎这样一个世界，觉得它窈窕多姿。只是经过了若干世纪之后，当征伐的劳累和困人的气候消磨掉他们的活力，使得他们成为异族大举入侵的俎上肉时，他们方才仅仅看见人生的丑恶一面，并且渴望从轮回中解脱出来。但是，为什么我们西方人，特别是我们美国人，慑于腐朽、死亡、饥渴、疾病、衰老、愁恨和虚幻呢？我们的生命力是旺盛的。当时，我坐在自己的小木房子里抽着烟斗时，觉得自己比从前任何时候都更加精神。我觉得体内有种力量急于要扩展出来。要我离开世界，住进一个修道院，我决计不干；相反，我要生活在世界上，爱这世界上的一切，老实说不是为它们本身，而是为了它们里面的无限。如果在那几次的片刻陶醉中，我的确和绝对合为一体，那就如他们告诉我的，什么都不能伤害我，而当我清算了今生的前因后果之后，我就不会再回到世界上来。一想到这里，我不禁充满惶惑。我要投生，投生再投生。我愿意接受形形式式的生活，不管它是怎样忧伤痛苦；我觉得只有生生不息，一个生命接一个生命，才能满足我的企求，我的活力，我的好奇心。\n“第二天早上，我动身下山，于次日到达道观。西里?甘乃夏看见我穿上西服感到诧异。那些衣服是我上山时在森林管理员那所小屋子里换上的，因为山上比较冷；下山时也没有想起要换掉。\n“‘师傅，我是来告别的，’我说。‘我打算回家乡了。’“他没有开口。和平时一样，他盘膝坐在铺着虎皮的禅床上，前面火钵里点了一支香，空气里微微闻得见一点香味。跟我第一天看见他时一样，他只是一个人。\n他凝神盯着我看，好象一直看到我的内心深处。我知道他已经完全懂得了。\n“‘这样好，’他说。‘你离家太久了。’“我朝他跪下，他为我祈福。当我站起来时，我的眼睛湿了。他是一个高尚圣洁的人。我将永远以认识他为荣。我和院中那些修士一一告别；他们有些已经修道多年，有些是在我之后来的。我把自己的一点衣物和书籍留下，觉得说不定对他们有用，于是把背包扛在肩上，穿着我到达时的旧长裤和褐色上褂，戴一顶破帽子，步行回到镇上。一星期后，在孟买搭上一条船，在马赛上了岸。”\n我们两人都沉默下来，各自在思索；可是尽管我已经十分疲倦，有一件事我还是急切地要问个明白，所以最后还是我开口。\n“拉里，老弟，”我说，“你这次长时期的探索是从恶的问题开始的。是世界上有恶的存在使你孜孜以求的。可是，谈了这半天，你对这个问题连一个初步答案也没有提到。”\n“也许就没有什么答案，也许我不够聪明，因而找不到答案。罗摩克里希那把世界看作是神的一种游戏。他说，‘世界就是游戏，在这种游戏里，有乐有忧，有道德亦有堕落，有知识亦有愚昧，有善亦有恶。如果罪恶和痛苦在创世时就被完全排除掉，游戏还能继续玩下去吗？’我将以全力否定这种说法。我能提出的最好设想是，当绝对在这世界上表现为善时，恶也自然而然联带着出现。没有地壳灾变的那种无法想象的恐惧，你就决不会见到喜马拉雅山的壮丽景色。中国烧瓷的匠人能够把花瓶烧得象蛋壳一样薄，烧得造形那样优美，点缀上美丽的花饰，着上迷人的色彩，涂上粲然的光泽，但是，由于它的本质是瓷，他就没法改变它的脆弱性。如果失手落在地上，它就会变成许多碎片。根据同样的道理，我们在这世界上所珍视的一切美好的，有价值的事物，只能和丑恶的东西共同存在，你说是不是呢？”\n“拉里，这是一个很别致的想法。我觉得并不怎样令人满意。”\n“我也不满意，”他微笑说。“顶多只能说，既然得出某些事情是不可避免的结论，一个人就只能尽力而为。”\n“你现在有什么打算？”\n“我有一件工作要在这里做掉，然后回美国去。”\n“回去干什么？”\n“生活。”\n“怎样生活？”\n他的回答很冷静，但是，眼睛里闪出一种好笑的神气，因为他料准我会完全意想不到。\n“不急躁，对人随和，慈悲为怀，丢掉一个我字，不近女色。”\n“高标准！”我说。“那么，为什么要不近女色？你还年轻；女色和吃饭一样是人这个动物最强的本能，你这样抑制它是否明智呢？”\n“所幸的是对我说来，接近女色只是寻欢作乐，而不是出于生理需要。根据我个人的经验，印度的那些哲人主张不近女色可以大大增强精神的力量，这话说得再确当没有了。”\n“我还以为最明智的生活方式是在肉体需要和精神需要之间保持一种平衡呢。”\n“印度人认为这恰恰是我们西方人所没有做到的；认为我们有了许许多多的发明，许许多多的工厂和机器以及生产出来的商品，总想把幸福建筑在物质上，但是，幸福的取得并不靠这些，而是靠精神。他们而且认为我们选择的道路是毁灭的道路。”\n“你以为美国那种地方对实现你的理想适合吗？”\n“我看不出为什么不适合。你们欧洲人一点不理解美国。因为我们积聚了大笔财富，你们以为我们只是要钱。我们一点不要钱；我们一有钱就拿来花掉，有时候花得好，有时候花得不好，但我们总是花掉。钱对我们说是不在话下的，它只是成功的象征。我们是世界上最大的理想主义者；我只是认为我们把理想放错了地方，我认为一个人能够追求的最高理想是自我的完善。”\n“这是一个崇高的理想，拉里。”\n“这种理想值不值得人努力去实现呢？”\n“但是，你有没有想到，以你这样一个人，对美国这样一个贸贸匆匆、忙忙碌碌、目无法纪、极端个人主义的民族会有什么影响呢？这无异想要赤手空拳阻止密西西比河的河水不流。”\n“我可以试试。是一个人发明轮子的；是一个人发现引力的定律的。没有一件事情不会产生影响。你把一粒石子投入池中，宇宙就不完全是它先前那样子。把印度的那些圣者看作生无益于时，是错误的。他们是黑暗中的明灯。他们代表一种理想，这对他们的同类是一帖清凉剂；普通的人可能永远做不到，但是，他们尊重这种理想，而且生活上始终受到它的影响。一个人变得纯洁完善之后，他的性格就会产生广泛的影响，使得那些追求真理的人很自然地去接近他。如果我过着给自己安排的那种生活，它也可能影响到别人。这种影响也许并不比石子投入池中引起的涟筋影响更大，但是，一道涟漪引起第二道涟漪，而第二道又弓愧第三道涟漪；很可能有少数几个人会看出我的生活方式带来幸福和安适，而他们也会转而把自己所学到的传给别人。”\n“我不知道你可知道自己在和什么人作对，拉里。要知道那些不学无术的人过去用拉肢架和火刑架镇压他们害怕的意见，现在早已放弃不用了；他们现在发明了一种更恶毒的毁灭武器——说俏皮话。”\n“我这个人相当顽强，”拉里微笑说。\n“好吧，我只能说你有点个人收益总算有你的狗运。”\n“这对我是很大的帮助。如果不是靠这点钱，我就没法象过去那样天南地北地跑。可是，我的学徒阶段结束了。从现在起，它将成为我的包袱。我要扔掉它了。”\n“这将是非常不明智的事。你打算过的那种生活之所以可能，唯一靠的就是经济上不仰求别人。”\n“相反，经济上不仰求别人，将使我计划的那种生活成为没有意义。”\n我实在按捺不住了，摆出一副不耐烦的样子来。\n“这对印度那些云游四方的托钵僧也许很合适；他可以在树下过夜，而那些虔诚的人，为了结缘，都很愿意把他的讨饭钵子装满吃的。可是，美国的气候对露宿是很不相宜的，而且我虽然不敢自命对美国十分了解，至少有一件事是美国人全都同意的，就是要吃饭就得工作。可怜的拉里，恐怕你还没有起步，就会被人当作流浪汉抓到教养院去了。”\n他大笑。\n“我懂。人得适应自己所处的环境，我当然要工作。我到达美国之后，将要设法在汽车修配厂找一个工作。我是个相当好的机械工，想来这不大困难。”\n“这一来，你不是把本来可以派用场的精力浪费掉？”\n“我喜欢体力劳动。不论什么时候，只要看书看不下去了，我就从事一个时候体力劳动。我觉得这样能使人精神振作起来。记得有一次，我读斯宾诺莎传，读到这位哲学家为了糊口不得不打磨镜片，作者非常愚蠢地认为这对斯宾诺莎是很大的折磨。我敢说这对他的理智活动只会有好处。别的不谈，单单使他暂时不去苦思苦想那些哲学问题，也就够了。当我冲洗车子或者修理汽化器时，我的脑子是不去想什么的，而当我把手里的活做完之后，我会有一种乐滋滋的味儿，觉得自己完成了一件事情。当然，我不会在一个汽车修配厂永远呆下去。我离开美国已经有好多年了，我得重新熟悉它。我将设法找一个卡车司机的工作。那样的话，日子长了，我就会把美国全都跑到。”\n“你大约忘记钱有一个最大的用处，就是节省时间。生命太短促了，而我们要做的事情是那样多，所以一分钟也不能浪费。比如说，你从一个地方徒步走到另外一个地方，而不坐公共汽车，又如搭公共汽车而不坐出租汽车，你将浪费多少时间？”\n拉里笑了。\n“讲得很对，这一点是我没有想到的，但是，我可以拥有自己的出租汽车来解决这个困难。”\n“你这话是什么意思？”\n“最后我将在纽约定居下来，别的理由不说，还因为纽约拥有最大的图书馆。\n我只需要很少一点生活费；我对住宿的地方毫不在乎；一天只要吃一顿饭就够了；等我把美国要返的地方全逛到了，我将会省下一笔钱来买一部出租汽车，自己当司机。”\n“你应当关起来，拉里，你疯了。”\n“一点不疯。我很懂事，也很实际。当一个出租自己的汽车的司机，我每天开车子的时间只要够我的食宿和车于的折旧就行了。其余的时间可以用来从事别的工作。如果有什么急事要上哪儿去，就可以开自己的出租汽车去。”\n“可是，拉里，一部出租汽车和政府公债一样也是财产，”我故意说这话逗他。\n“而占有一部出租汽车，你就是一个资本家。”\n他大笑。\n“不然。我的出租汽车只是我的劳动工具，无异于托钵僧的手杖和食钵。”\n这样打趣一番之后，我们的谈话中止了。我久已看出，咖啡馆里的客人愈来愈多了。一个穿晚礼服的人离我们不远坐下，叫了一份很丰盛的早餐；他那疲倦而带有满足的面容，说明他过了一夜风流，现在口想起来还有余味。几位老者，由于年纪大睡觉少，都起身很早；他们一面一本正经地喝牛奶咖啡，一面从深度眼镜里读着晨报。年纪轻一点的人，有的衣冠楚楚，有的穿得破烂，匆匆走进来，三口两口吞下一只面包，喝掉一杯咖啡，就赶往写字间或者店铺去。一个干瘪老太婆挟了一捆早报进来到处兜售，但是，看上去好象一份也没卖掉。我从大玻璃窗户望出去，看见天色已经大亮。一两分钟后，电灯全都熄掉，只有这家大咖啡馆的后面一半还开着。我看看表，已经七点过了。\n“来点早饭怎样？”我说。\n我们吃了油炸面包和牛奶咖啡；油炸面包是新出锅的，又热又脆。我人很疲倦，没精打采的，样子一定很难看，但是，拉里却象平时一样精神，眼睛奕奕有神；光滑的脸上一条皱纹也没有，看上去顶多只有二十五岁。咖啡使我振作了一点。\n“容许我给你一点忠告，拉里。我是不大给人忠告的。”\n“我也不大接受人家的忠告，”拉里回答，咧开嘴一笑。\n“在你处理掉你那一点点财产之前，希望你慎重考虑一下。因为一旦脱手之后，就永远不会回来。说不定有一天你为了自己或者为了别人迫切需要钱用，那时你就会后悔莫及，觉得自己做了一件蠢事。”\n他回答时，眼睛里带有嘲笑的神气，但是，丝毫不含恶意。\n“你比我把钱更加看得重。”\n“我很重视，”我直率地回答他。“要知道，你一直有钱，而我并不如此。钱能够给我带来人世上最最宝贵的东西——不求人。一想到现在只要我愿意，我就能够骂任何人滚他妈的蛋，真是开心之至，你懂吗？”\n“可是，我并不要骂任何人滚他妈的蛋；而如果我要骂的话，也不会因为银行里没有存款就不骂。你懂吗，钱对你说来意味着自由，对我则是束缚。”\n“你是个讲不通的家伙，拉里。”\n“我知道。这没有法子。反正时间还早着，我要改变主意，尽来得及。我要等到明年春天才回美国。我的画家朋友奥古斯特?科泰把萨纳里的一所村舍借给我，我打算在那边过冬。”\n萨纳里是沿里维埃拉的一个不大出色的海滨休养地，介于班多尔和土伦之间。\n艺术家和作家不喜欢圣特罗佩那些花花绿绿的宗教仪式的，常到这里来。\n“那地方就象一潭死水那样了无生气，你如果不在乎这一点就会喜欢它。”\n“我有事情要做。我搜集了一大堆资料，预备写一本书。”\n“写的什么呢？”\n“写出来后你就会知道，”他微笑说。\n“书写成之后，你假如愿意寄给我，也许我可以设法替你出版。”\n“你不用费心。我有几个美国朋友在巴黎办了个小小的出版社。我跟他们谈好替我印出来。”\n“可是，这样出版一本书很难指望有销路的，而且不会有人给它写书评。”\n“我不在乎有人给它写书评，也不指望出售。书的印数很少，只预备寄给我的印度朋友和在法国的少数可能对它感觉兴趣的人。它并没有什么了不起，我写它出来只是为了把搜集到的资料处理掉，而出版它是因为我觉得只有印出来才能弄清楚它是什么货色。”\n“这两条理由我都懂得。”\n这时我们的早饭已经吃完，我叫侍役开帐。帐单来时，我把它递给拉里。\n“你既然打算把你的钱全部送光，老实不客气，这顿早饭要你请了。”\n他大笑，把钱付掉。坐了这样久，我人都僵了；走出咖啡馆时，觉得两胁在痛。\n秋天早晨的空气非常新鲜，人很好受。天是蓝的，德?克利希大街在夜里是那样一条肮脏的通道，现在却显出一点活泼气象，就象一脸脂粉的消瘦妇人走着女孩子的轻快脚步，看去并不讨厌。我向一部过路的出租汽车打一个手势。\n“带你一段路怎样？”我问拉里。\n“不用。我预备步行到塞纳河边，找一处洗澡的地方游泳一下，以后还得上图书馆去，我有些东西要查。”\n我们拉了手。我望着他的两条长腿大踏步走过马路。我这块料可没有他硬挣，所以坐上出租汽车回到旅馆。走进起坐间时一看，已经八点过了。\n“一个年纪大的人在这个时候才回家，”我向玻璃罩里的裸体女子不以为然地说；一八一三年以来她一直就横陈在时钟上面，身体的位置在我看来极端不舒服。\n她继续望着自己在镀金铜镜里的镀金铜脸，而那座钟的回答只是：滴答、滴答。\n我放了一盆热洗澡水；一直泡到水不太热时，方才把身体擦干，吞下一片安眠药，把瓦勒里[注]的《海葬》带到床上去看（书刚巧放在床头柜上），一直看到睡去。\n第七章 # 一 # 六个月后，在四月里的一个早晨，我正在弗拉特角自己房顶书室里忙着写稿子，一个佣人进来说，圣让（我的邻村）的警察在楼下要见我。我对受到打搅很恼火，而且想不出警察找我有什么事情。我没有亏心事，定期的慈善捐款也已经交纳。他们还发给我一张身份证，被我藏在汽车里，预备开车超出规定速度或者在马路上停错地方被人捉着时，可以在出示行车执照时，让警察无意中瞧见，免得警告没有个完。当时我想很可能是我的那些佣人里面，有一个被人家写了匿名信（这是法国人生活中一个可爱之处），因为她的身份证还没有办妥；不过，我和当地的警察关系处得不坏，在打发他们走之前，总要请他们喝杯酒，所以想来不会有什么大了不起的事。可是，他们（总是两个人一同来）这次来却负有完全不同使命。\n我们握了手并且相互问好之后，年长的一个——他的称呼是班长，蓄了一部我从没有见过的又浓又密的上须——从口袋里掏出个本子，用肮脏的拇指翻着。\n“索菲?麦唐纳这个名字你听说过吗？”他问。\n“我认识的人有叫这个名字的，”我小心地回答。\n“我们刚和土伦的警察局通电话，那边的警长要你立刻就去，[vous prie de vous y rendre][注]。”\n“为什么？”我问。“我和麦唐纳夫人并不熟。”\n我立刻想到索菲一定出事了，很可能和鸦片有关系，但是，弄不懂为什么会把我牵连进来。\n“这个我不管。毫无疑问，你和这个女人有过交往的。好象是她有五天没有回她的住所，后来，有人在海港捞到一具女尸，警察认为可能就是她。局里要你去认一下。”\n我打了一个寒噤。不过，这事并不怎样出乎我的意料。她过的那种生活很可能使她在抑郁无聊之际突然结束自己的生命。\n“可是，从她穿的衣服和随身的证件也可以认出是她来。”\n“她被捞到时是赤条条的，而且脖子割了。”\n“老天啊！”我一面感到毛骨悚然，一面自己在动脑筋。很可能警察会强逼着我走，所以我还是遵命为上，落得个漂亮。“好的。我搭第一班火车就去。”\n我看了火车时刻表，查到五点到六点之间，有一班火车可以搭到土伦。班长说他会打电话报告土伦的警长，并且叫我一到达就直接上警察局去。我把必要的衣物装了一只手提箱，吃完午饭，就坐汽车上火车站。\n二 # 我上土伦警察局报到时，立刻被引进警察长的房间。警察长坐在桌子后面，长得又粗又黑，脸色阴沉沉的，看上去象是科西嘉岛的人。也许习惯使然，他怀疑地看了我一眼；可是当他注意到我（为了防而不备）佩在领孔上的勋章[注]时，就假意地一笑，请我坐下，满口打招呼，说是惊动我这样一个有身份的人，实在出于不得已。我也同样客客气气回答，说是只要能够替他效劳，我是不胜荣幸之至。接着我们就谈起正经事情来。他又恢复到先前粗鲁而且相当傲慢的神情，看看放在面前的文件，对我说：“这是一件不光彩的事情。看来这个麦唐纳女人的名声很坏，酗酒，吸毒，一个烂污货。她不但经常和船上下来的水手睡觉，还和当地的流氓睡觉。你这样年纪和身份的人，怎么会和这种人混起来？”\n我本来想告诉他这不关他的事，可是，根据我钻研几百本侦探小说的经验，对待警察还是客气的好。\n“我和她并不熟；是在芝加哥碰见她的，那时，她还是个女孩子。后来她在芝加哥和一个有身份的人结了婚。一年多以前，通过她和我共同认识的一些朋友，才重又和她见面。”\n在这以前，我一直弄不懂他怎么会把我和索菲联系在一起，可是，现在，他把一本书推到我面前。\n“这本书是在她房间里找到的。请你看看上面写的话，你当会懂得你们的关系决不是如你自称那样的泛泛之交。”\n就是那本索菲在书店橱窗里看见的我的小说法文译本，她要我在上面写几个字的。我在自己的名字下面写了“mignonne，allons voir si la rose，”[注]因为是提笔就想起的。这当然看上去太亲热一点。\n“你假如认为我是她的情人，那你就错了。”\n“这不关我的事情，”他答，接着眼睛霎了一下：“而且我丝毫没有触犯足下的意思，根据我打听到的这个女人的癖好，敢说你也不是她会看中的人。但是，你对一个完全陌生的人显然不会称呼为美人儿。”\n“这句诗，局长先生，是龙沙一首脸炙人口的诗的头一行，他的作品以你这样有文化教育的人肯定是熟悉的。我录了这句诗因为我有把握她知道这首诗并且会联带想起下面的诗句，这一来，说不定使她感到自己过的那种生活，别的不说，至少是不检点的。”\n“我在学校里显然读过龙沙，可是，我的事情非常繁忙，你提起的那些诗句早已被我忘了。”\n我把那首诗的第一节背了出来，满知道他在我提到这位诗人之前，从来就没有听到这个名字过，所以一点不怕他会想到这首诗的最后一节丝毫不带有劝人学好的味儿。\n“她摆明是读过一点书的。我们在她的房间里找到若干侦探小说和两三本诗集。\n有一本波德莱尔[注]，一本兰波[注]，还有一本英文诗，一个叫艾略特[注]写的。\n他出名吗？”\n“名气很大。”\n“我没有时间读诗。反正我不懂英语。可惜的是他如果是个好诗人，为什么不用法文写诗、使得受教育的人都能读他。”\n想到这位局长在读艾略特的《荒原》，我真乐了。突然间，他把一张照片送到我面前。\n“你可看得出这是何等样人？”\n我一眼看出是拉里。他穿着游泳裤，照片是新近拍的，据我猜想，大约就是前年夏天他和伊莎贝儿和格雷在迪纳尔避暑时照的。我脱口而出的一句话是想说我不认识，因为我从心里不愿意这件可恨的事情牵连到拉里，可是再一想，倘若警察局查出是拉里的话，我的否认就会使他们疑心到我认为这里面有什么不可告人之处。\n“他是个美国公民，叫劳伦斯?达雷尔。”\n“这是我们在这女人的东西里面找到的唯一一张照片。他们之间什么关系？”\n“他们都是在芝加哥附近同一个村子里长大的，从小就认识。”\n“可是，这张照片拍了没有多久，想来是在法国北部或者西部一个海滨休养地。\n查出究竟在什么地方并不难。他是怎样的一个人？”\n“是一个作家，”我大胆说。警察局长的两撇浓眉毛稍稍抬一点起来，我想他认为干我这一行的人，行为都是不大检点的。“而且生活不靠稿费收入，”我又补上一句，企图抬高他的身份。\n“他现在在哪里？”\n我又禁不住想说我不知道，但是，仍旧认为这一来只会把事情弄别扭。法国警察也许有许多毛病，但是，他们的组织体系却能使他们很快就查出一个人来。\n“他住在萨纳里。”\n警察局长头抬了起来，显然感觉兴趣。\n“地址呢？”\n我记得拉里告诉过我奥古斯特?科泰把自己乡下的小房子借给他住；我圣诞节回来时，曾经写信给他，邀他到我家来住一个时候，但是，不出我所料，他谢绝了。\n我把他的地址告诉了警察局长。\n“我就打电话到萨纳里，叫人把他带到这儿来。可能从他嘴里问出点名堂。”\n我不由而然觉得警察局长大约认为这可能是个嫌疑犯，真想笑出声来。我断定，拉里会很容易证明他和这件事情无关。我急于想知道的是关于索菲的悲惨结局的详情，但是，局长告诉我的只比我知道的多出一些细节。两个渔夫把尸体捞到。当地的警察告诉我尸体一丝不挂，其实是耸人听闻。凶手把三角裤和奶罩都留下了。如果索菲的衣着和我看见她时一样，那么，凶手只要剥去她的长裤和紧身衫就行了。\n由于查不出她的姓名，警察就在当地报纸上加上一段描写。有个女人在一条小街上出租房间的（法国人叫它做临时房间，客人可以随意把女人或者男人带去睡觉），见报后就上警察局来。她原是警察局的耳目，警察常要她报告谁上她的客栈来，和来了干什么。我上次碰见索菲时，她刚被码头附近的那家旅馆赶了出来，因为她的行为实在太不象话，连一向马虎的旅馆主人都忍耐不下去了。这以后她就找到上述的那个女人，在她的房子里租下一个卧房，另外加一间小起坐间。一间房间一夜租出去两三次，赚的钱比较多，可是，索菲出的价钱很大，所以那女人就答应租给她，按月计算。这个女人现在到警察局来，说她的房客有好几天没有回来住宿了；她原也不放在心上，以为她暂时去了马赛或者维尔弗朗什，因为英国军舰最近开来了，这件事对沿海岸一带的老少女子都具有吸引力；但是，她读到报上关于死者的那段描写，觉得可能是她的房客。警察带她去看了尸体，她稍微迟疑一下，就声称这是索菲?麦唐纳。\n“可是，如果尸体已经被认出是谁，你们找我来做什么？”\n“贝莱太太是个很诚实的女人，而且品行不错，”局长说，”可是，她认出这个女尸的理由可能是我们不知道的；反正我觉得应当找一个和死者关系比较密切的人来证实一下。”[注]“你认为有可能捉到凶手吗？”\n局长耸耸自己宽阔的肩膀。\n“我们当然在查访。我们到她常去的酒吧间问了一些人。她可能是被一个水手出于妒忌杀害的，而水手的船已经离开港口了，也可能是当地一个流氓抢她身上的钱而杀死她。看上去她身边总带有不少的钱使那些歹徒会看上她。也许有些人认为某某人有很大的嫌疑，但是，在和她交往的人中间，除非为了自身的利益，谁也不会说出来。象她那样跟这批环蛋朝夕相处，得到这样的下场是完全意想得到的。”\n我对他这话也没有可说的。局长请我明天早上九点钟之后来，那时候，他当会和“照片中的这位男子”见过面，底下就由一个警察领我们去停尸所看尸首。\n“她的打葬事情呢？”\n“如果验明正身，你们承认是死者的朋友并且愿意负担丧葬费的话，你们将会得到批准。”\n“我敢说达雷尔先生和我都愿意很快得到批准。”\n“我完全理解。这可怜的女人遭遇太惨了，能够越早安息越好。你的话使我想起我这里有一张丧葬承办人的名片，他收费公道，而且办事利落。我将在上面写几个字，叫他办得更周到些。”\n我有把握他在丧葬费用上会得到回扣，可是，我满口感谢他。在他竭力表现得必恭必敬，送我出门之后，我立刻就找到名片上的地址。丧葬承办人既活跃又一本正经。我挑了一口棺材，既不是最便宜的，也不是最贵的。他主动提出替我向他熟识的一家花店订购两三只花圈——“免得先生履行一项不愉快的义务，并且出于对死者的尊敬，”他说——约好枢车于次日两点钟到达停尸所。他告诉我，对坟地用不着操心，一切他都会安排好的，又说“想来太太是新教徒吧”，所以如果我同意的话，他将找一位牧师等在公墓那边，于下葬时为死者祈祷。所有这一大套使我不由得佩服他的办事能力。但是，由于我和他素不相识，而且是个外国人，如果请我肯惠然给他预先开一张支票，敢说我是不会介意的。他说出的数目比我指望的要大一点，显然是准备我还价；可是，我一声不嘀咕，掏出支票本来，开了一张支票给他；当时看得出他脸上显出诧异的样子，甚至于有点失望[注]。\n我在旅馆开了一个房间，第二天早上，又到警察局去。先在候见室等了一段时间，然后由人请我到警察局长的房间去。我看见拉里，神情严肃而且不自如，就坐在我昨天坐的椅子上。局长兴高采烈地和我招呼，仿佛我是个多年失散的弟兄似的。\n“很好，我亲爱的先生，你的朋友极其坦率地回答了我有责任问他的问题。我没有理由不相信他已经有一年零六个月没有见到过这个可怜的女人。他叙述了自己在上星期的行踪，以及那个女人房间里他那张照片的由来，讲得都非常令人满意。\n照片是在迪纳尔拍的，有一天，他和那女人吃午饭时，刚好放在他口袋里。我从萨纳里收到的关于这位年轻人的情况报告非常之好，我而且，并不是我想卖弄，本来就善于识人；深信他不可能干下这种勾当。我而且不揣冒昧向他表示同情，一个童年的朋友，而且在一个健康和有种种教养的家庭长大的，竟会堕落到这种地步。可是，这就是人生。现在，亲爱的先生们，我的一个下属将陪二位上停尸所去，在你们证实死者之后，就没有你们的事了。去吃一顿好午饭吧。我这里有一张土伦最好餐馆的卡片，只消我在上面写几字，餐馆老板就会尽力招待。经过这番折腾之后，来一瓶好酒对你们两位都有益处。”\n他这时的的确确充满善意了。我们跟随一个警察走到停尸所。这地方的生意并不兴隆。只有一张板上停了一具尸体。我们向着尸首走去，看守人把头部的遮布揭开。那形象很不好看。海水已经把烫弯曲的银灰色染发泡直，而且湿儒慌地粘在颅骨上。脸肿得厉害，看上去使人毛骨悚然，但是，毫无疑问，是索菲。看守人把遮布又拉下一点，给我们看了那道一直割到两边耳朵下面的骇人刀痕；对我们两个来说，还是不看见的好。\n我们回到局里。局长没有空见客，我们只好把应当说的话告诉一个助理。他丢下我们，不久就拿了证件出来哦们带了证件去交给丧葬承办人。\n“现在去喝杯酒吧，”我说。\n拉里从我们离开警察局上停尸所，除掉从停尸所回来时声称他认出尸身是索菲?麦唐纳外，一句话也不说。我领他上码头那边，和他坐在从前和索菲坐的那家咖啡馆里。外面正吹着一股强烈的北风，平时波平如镜的海港到处点缀着白浪花。渔船轻轻摇曳着。阳光朗照；和每次刮北风时一样，眼中望去的任何物体都异常清晰耀眼，就好象从望远镜中特别对准了物体眺望，给人以一种震撼心弦和生命在颤栗的印象。我喝了一杯白兰地苏打，但拉里始终没有碰我给他叫的一杯。他郁然坐着，一声不响，我也不打搅他。\n过了一会，我看看表。\n“我们还是去吃点东西吧，”我说。“我们两点钟要到停尸所。”\n“我饿了，我没有吃早饭。”\n我根据警察局长的外貌断定他是懂得吃好菜的，所以把拉里带到局长告诉我的那家饭店。我知道拉里很少吃肉，所以叫了摊鸡蛋和煎龙虾，然后把酒单要来，仍旧遵照局长的话，挑了一瓶葡萄酒。酒送来时，我给拉里倒了一杯。\n“你还是喝下这劳什子，”我说。“它可能给你提示一个话题。”\n他乖乖地遵照我的话喝了。\n“西里?甘乃夏常说沉默也是谈话，”他咕哝着说。\n“这使人想起剑桥大学那些冬烘先生一次欢快的聚会。”\n“恐怕你得单独负担这笔丧葬费呢，”他说。“我没有钱了。”\n“我完全愿意，”我回答。接着，他这句话的含义触起我。“你难道真的做了不成？”\n他有半晌没有作声。我注意到他眼睛里那种诡诈神情。\n“你没有把你的钱送掉吧？”\n“除掉等我的船开到之前必要的用度外，全送掉了。”\n“什么船？”\n“我在萨纳里住的房子的邻舍负责一家货轮在马赛的办事处，货轮的航线往返于近东和纽约之间。他们从亚历山大城打电报给他，说一条开往马赛的船有两个水手生病，在亚历山大城上了岸，叫他找两个替工。他是我的好朋友，答应把我弄上船。我把自己的旧雪铁龙送给他做纪念。上船之后，我除掉身上的衣服和一个手提包的东西外，便别无长物了。”\n“嗯，反正是你自己的钱。现在你自由了，白种人而且满二十一岁[注]。”\n“自由这个字眼用得很对。我一生从来没有比现在更感到快活和更无牵无挂了。\n我到达纽约时，他们会付给我工资，这钱将能够维持到我找到一个工作。”\n“你写的书怎样了？”\n“噢，已经写完而且印好了。我开了一张赠书的名单，你在一两天内当会收到。”\n“多谢。”\n这下面没有什么可说的。我们在友好的沉默中吃完午餐。我叫了咖啡。拉里点起烟斗；我点起一支雪茄，若有所思地望着他。他感到我的眼光朝着他，将我看了一眼；他自己的眼睛闪出顽皮的神气。\n“你要是想骂我是个大傻瓜蛋，你就只管骂吧。我一点不介意。”\n“不，我并不怎样想骂你。我只是盘算，如果你象别人一样结婚生子，生活方式会不会变得更正常些。”\n他笑了。过去我提到他的笑很美，肯定总有二十次了；他笑得是那样适意，真挚和迷人，恰恰反映出他那优良品质的坦率和诚实的一面，可是我还要再提一次，因为现在他的笑除掉上述的种种以外，还含有一种凄惨和温柔的味道。\n“现在太迟了。我碰到的有可能和她结婚的女子只有可怜的索菲。”\n我诧然望着他。\n“经过这一切之后，你还能这样说吗？”\n“她有个可爱的灵魂，热情，超脱，慷慨。她的理想是高尚的。甚至到最后她寻找自我毁灭的方式，也具有崇高的悲剧味道。”\n我没有作声；我不懂得对这些古怪的评述该怎样看待。\n“当时你为什么不和她结婚呢？”我问。\n“她那时还是个孩子。告诉你实在话，我从来没有想到当初我常到她祖父家，和她一同在榆树下读诗时，这个瘦骨嶙峋的小鬼蕴藏着灵魂美的种子。”\n我不由得感到诧异的是，在这个当口，他竟然不提伊莎贝儿。他不可能忘记曾经和她订过婚。人们只能设想他把订婚的事看作是两个没有成熟的年轻人糊里糊涂干出来的蠢事，毫无道理。他决没有想到伊莎贝儿一直在苦恋着他，这件事我深信在他脑子里连个影子都没有。\n现在是动身的时候了。我们走到拉里停车的广场，汽车已经很破旧了。我们开到停尸所。丧葬承办人没有虚报。什么事情都办得井井有条；在那片光华耀眼的天光下，狂风把墓地的柏树都吹弯了，给殡葬添上最后一点恐怖气氛。各事完毕以后，承办人恭敬如仪地和我们拉手。\n“两位先生，希望你们满意。办得很不错吧？”\n“很不错，”我说。\n“请先生记着，如果有什么差遣，随时吩咐好了。路远毫无关系。”\n我谢过他。当我们走到公墓门口时，拉里问我还有什么事情要他做的。\n“没有了。”\n“我想尽快赶回萨纳里。”\n“把我开到我的旅馆，好吗？”\n开着车子时，我们一句话都没有说。我到旅馆时下车，两个人拉拉手，他就开走了。我付了旅馆帐，拿了手提箱，雇一部出租汽车上火车站。我也要赶快离开。\n三 # 几天之后，我就动身去英国。我原来的打算是沿路不停，但是，出了索菲这件事情之后，我特别想看看伊莎贝儿，所以决定在巴黎停留二十四小时。我打了个电报给她，问她我能不能在下午晚一点时候去，并在她家吃晚饭。到达我的旅馆时，我收到她留下一张便条，说她和格雷晚上有饭局，可是，欢迎我五点半以前来，因为五点半以后她要去试衣服。\n天冷，雨下下停停，但下得很大；我猜想格雷不会上毛特芳丹去打高尔夫。这对我不大合适，因为我想单独会见伊莎贝儿。但是，当我到达公寓时，她告诉我的第一句话就是，格雷上旅行者俱乐部打桥牌去了。\n“我告诉他不要回来太晚，如果要见你的话，不过，我们要到九点钟才吃晚饭，这就是说，我们用不着在九点半以前到达，所以我们满有时间痛痛快快谈一下。我有一大堆事情要告诉你。”\n他们已经把公寓转租出去。艾略特的藏画将在两星期内拍卖。拍卖时他们要到场，所以正准备搬到里茨饭店去住。然后上船回国。伊莎贝儿除掉艾略特在昂第布房子里挂的那些近代绘画之外，什么都卖掉。这些近代绘画她虽则不大喜欢，但是，认为这些挂在他们未来的家里将会抬高他们的身价；她想得完全对头。\n“遗憾的是，可怜的艾略特舅舅并不太合时宜。毕加索，马蒂斯，鲁奥[注]，你知道。我想他的藏画好还是好的，不过恐怕过时了一点。”\n“我倘若是你的话，就不去管它。几年之后，别的画家将会出头，毕加索，马蒂斯比起你那些印象派画家来也未见得更时新了。”\n格雷和人家的谈判快结束了。他有了伊莎贝儿给他提供的资本，将以副经理的身份参加一家生意兴隆的企业。这家企业和石油有关系，所以他们打算住在达拉斯。\n“我们的首要事情是找一幢合式的房子。我要有一个很好的园子，这样格雷工作回来可以有地方闲逛逛，而我非要有一间真正的大起坐间不可，这样才可以招待客人。”\n“我不懂得你为什么不把艾略特的家具带走。”\n“我认为不大合适。我要打全套的摩登家具，也许在有些地方来点墨西哥式样，使它带有一种情调。我一到纽约就去打听现在哪一个屋内装饰家最吃香。”\n安托万，那个男佣人，捧了一只盘进来，上面放了许多酒瓶。伊莎贝儿总是那样机灵，知道十个男人有九个都自命搀鸡尾酒比女人搀得好（而且这个看法是对的），所以叫我搀两杯。我把杜松子酒和努瓦里普拉[注]倒出来，搀上少量的苦艾酒；就靠这点苦艾酒把原来是不甜的马地尼[注]从一种说不出名堂的酒变成仙露，连奥林匹斯山上的诸神肯定都会放弃自己的家酿来喝它。我私下里一直觉得这是一种可口可乐的饮料。当我把酒杯递给伊莎贝儿时，我注意到桌上有一本书。\n“嗨，”我说。“这就是拉里写的书啊。”\n“是的，今天上午寄来的，可是，我非常之忙，午饭之前，有说不尽的事情要做；午饭是在外面吃的；下午又去了摩林诺时装店。不知道什么时候才能稍微翻一下。”\n一个作家成年累月地写一本书，也许呕心沥血才写成它，但是，被人随便放在那里，一直到无事可做时才会看它；想到这里，我感到抑然。\n“想来你知道拉里整个冬天都在萨纳里过的。你碰见过他没有？”\n“碰见过。前几天还一起在土伦的。”\n“是吗？你们去土伦干什么？”\n“打葬索菲。”\n“她难不成死了？”伊莎贝儿叫出来。\n“她如果不是死了，我们会有什么借口去打葬她？”\n“这并不好笑，”她停了一下。“我不想假装难受。恐怕是酗酒和吸毒双重原因。”\n“不是的，是被人割了脖子，赤身裸体抛到海里的。”\n和圣让的警察班长一样，我觉得有必要强调一下她的脱光情况。\n“太可怕了！可怜的人儿。当然象她那样子生活，结局一定是悲惨的。”\n“这也是土伦的警察局长说的话。”\n“他们知道凶手是谁吗？”\n“不知道，但是我知道。我认为是你杀了她。”\n她诧异地盯着我望。\n“你讲的什么？”接着，似笑非笑的一声：“再猜猜：我有铁证，不在犯罪的现场。”\n“去年夏天，我在土伦碰见她，和她有一次长谈。”\n“她没有喝醉酒吗？”\n“相当清醒。她告诉我，在她将要和拉里结婚的前几天，她是怎样会无缘无故失踪的。”\n我看见伊莎贝儿的脸色板了下来。接着，我把索菲告诉我的话一五一十地告诉她。伊莎贝儿竖着耳朵在听。\n“从那次之后，我把她告诉我的话盘算了很久，越想越发现这里面肯定有鬼。\n我在你这里吃午饭总有过二十次，你在午饭时，从来不备甜酒。那天你一个人吃午饭。为什么放咖啡杯子的盘子里有一瓶苏布罗伏加酒呢？”\n“艾略特舅舅刚派人把酒送来。我想尝尝看，是不是和我在里茨尝到时一样合口味。”\n“对，我记得你当时盛夸这酒。我觉得诧异，因为你从来就不饮甜酒；你非常注意自己的身材，决不会想喝甜酒。那时候我有个印象，你是想撩索菲；我觉得你简直不怀好心。”\n“谢谢你。”\n“你一般和人约会都很守时间。你约索菲去试结婚礼服，这件事对她说很重要，对你说也好玩，为什么你要跑出去？”\n“这是她亲口告诉你的。我对琼的牙齿不大放心。我们的牙医生很忙，只能在他指定的时间去。”\n“看牙医生总是在上一次走前约好的。”\n“我知道。可是，他早上打电话给我，说有事不能看病，但是，可以改在当天下午三点钟；我当然不放过这个时间。”\n“难道不能叫保姆带琼去吗？”\n“琼吓得要命，可怜的孩子，我觉得亲自带她去，她会好受一点。”\n“你回来的时候，看见那瓶苏布罗伏加四分之三光了，索菲也不见了，你难道不诧异吗？”\n“我以为她等得不耐烦，自己去摩林诺了。我到摩林诺一问，她并没有去，弄得我莫名其妙。”\n“还有那瓶苏布罗伏加呢？”\n“哦，我的确看出酒喝掉许多，还以为是安托万偷喝的，几几乎要说他，可是，他的工资是艾略特舅舅付的，他又是约瑟夫的朋友，所以我想想还是不理会的好。\n他是一个很好的佣人，即使偶尔偷点嘴，犯不着我来责备他。”\n“你真是个说谎精，伊莎贝儿。”\n“你不相信我吗？”\n“一点不相信。”\n伊莎贝儿站起来，走到壁炉架那边。壁炉里烧着木柴，在这阴寒天使人很适意。\n她把肘部撑在壁炉板上，姿态很文雅；这是她可喜的禀赋之一，能够不显得一点做作。多数的法国上流女子白天穿黑，她也如此，这对她瑰丽的肤色特别相宜；今天她穿了一件很贵重但是式样简单的衣服，很能衬出她的苗条身材。她有一分钟抽着香烟。\n“我跟你还有什么不可以说的。那天我要出去一趟确是很不幸，而且安托万实在不应当把甜酒和咖啡杯盘留在房间里，应当在我出去时就拿走。我回来时，看见瓶里酒差不多光了，当然知道是怎么回事，后来听说她失踪，我猜想，她大概是喝醉酒胡闹去了。这事我没有声张出去，因为说了只会使拉里更尴尬，单单这样子已经够他烦心的了。”\n“你肯定那瓶酒不是你故意叫人放在那里的？”\n“肯定不是。”\n“我不相信。”\n“那就不相信吧。”她恶狠狠地把香烟扔到炉火里；眼露凶光。“好吧，你要了解真相的话，那就老实告诉你，并且滚你妈的蛋。是我做的，而我现在还会做。\n告诉你，我要不惜一切阻止她和拉里结婚。你是不会阻止的，你或者格雷，你们只会耸耸肩膀，说这事做得太荒唐。你们一点不关心。我关心。”\n“你如果不插手的话，她现在还会活着。”\n“跟拉里结婚，弄得拉里痛苦不堪。他觉得能使她变一个新人。男人真是傻瓜！\n我早就知道迟早她会把持不住。这是摆明的。我们大家在里茨吃午饭时，你自己亲眼看见她多么坐立不安。我注意到她喝咖啡时，你在看她；她的手抖得厉害，一只手不敢拿，只好两只手捧到嘴边。我看出侍者给我们倒酒时，她的眼睛盯着酒望；一双没精打采的眼睛跟着瓶子转，就象一条蛇盯着一只羽毛方满的小鸡拍翅似的。\n我知道她会拼死弄一杯喝的。”\n伊莎贝儿现在面向着我，眼睛里充满激情，声音严厉，刻不急待地讲了下去。\n“当艾略特舅舅把那混蛋的波兰甜酒捧上天的时候，我觉得糟透了，但是，硬说我从来没有尝到过这样美的酒。我有把握说，她一有机会，绝对没有勇气抵制得了。所以我就带她去看时装展览。所以我要送她一套结婚礼服。那一天最后试样时，我告诉安托万，午饭我要喝杯苏布罗伏加，后来，又告诉他，我约好一位女太太，她来时请她等一下，喝杯咖啡，并且把甜酒留下来，说不定她会高兴喝上一杯。我的确把琼带到牙医生那里，但是，由于没有预先约好，医生不能看病，我就带琼去看了一场新闻片[注]。我打定主意，如果索菲不碰那活儿，我就勉为其难，尽量和她要好。我发誓，这是实话。可是，我回家时，一看酒瓶，知道自己算对了。她走了，我而且可以拿头来打赌，她将永远不会回来。”\n伊莎贝儿说完时，人老老实实都有点喘了。\n“这和我想象的多少有点象，”我说。“你看，我猜对了；你无异亲手拿刀子割了她的脖子。”\n“她是坏人，坏人，坏人！我很高兴她死了。”她猛然倒在一张沙发上。“给我一杯鸡尾酒，你这浑蛋。”\n我走过去，又搀了一杯。\n“你是个卑鄙的坏蛋，”她接过我手里的鸡尾酒时说。后来勉强一笑；她的笑就和小孩的笑一样，知道自己笑得很顽皮，但是，认为仗着那一点天真的派头，可以哄得你不会生气。“你不会告诉拉里吧？”\n“你怎么想得到的。”\n“你能对天发誓吗？男人是顶顶靠不住的。”\n“我答应你不告诉他。可是就算我想告诉他，我也没有机会，因为我今生今世恐怕不会和他再见面了。”\n她身子坐直。\n“你说的什么？”\n“这时候，他已经搭上一艘货轮，当水手或者司炉，开往纽约了。”\n“你这话是真的吗？他真是个怪人！几个星期前，他还到巴黎来，为他那本书上公共图书馆查资料的，可是，绝口不提他要去美国。我很高兴；这就是说，我们又要和他见面了。”\n“我不敢说。他的美国离开你的美国就和戈壁沙漠一样远。”\n接着，我就告诉伊莎贝儿，拉里怎样处理掉自己的财产，以及他今后的打算。\n她张口结舌地听我讲；脸上显出骇异的神情；有时候，打断我的话，喊“他疯了，疯了”。我说完之后，她垂着头，两行眼泪沿颊上流下来。\n“现在我真正失去他了。”\n她转过身去，脸抵着沙发椅背哭起来。悲伤破环她的美丽容颜，她也不在乎。\n我束手无策；不懂得在她的心灵深处是什么愚蠢而矛盾的希望被我传来的消息最后砸得粉碎。我有个模糊看法，好象能够偶尔见到拉里，至少知道拉里是她的世界的一部分，就把她和拉里牵在一起，而拉里的行动最后把这根微弱的牵线也割断了，因此她觉得自己永远丧失了他。我弄不懂使她痛苦的，使她枉自悔恨的是什么；想想还是让她哭一阵的好。我拿起拉里的书，看看目录。我的一本在我离开里维埃拉时还没有寄来，现在在几天之内没法看到。书写得完全出乎我的意料，是一本论文集，篇幅和利顿?斯特雷奇[注]的《维多利亚名人传》相仿佛，论述了若干有名人物。他挑选的人使我迷惑不解。有一篇论述罗马独裁者苏拉[注]，在独揽大权之后，退位归隐，一篇论建立帝国的蒙古征服者阿克巴尔[注]；一篇论吕本[注]，一篇论歌德，还有一篇论切斯特菲尔德勋爵，那个搞文学的[注]。显然每篇文章都需要读许多书，无怪拉里要花这么长的时间才能写成，可是，我不懂得为什么他认为值得在这上面花这么多时间，也不懂得他为什么选择这些人来研究。接着我想起来，这些人都各有一套方式在自己一生中取得卓越的成就，而使拉里感觉兴趣的想来就在于此。他有心估量一下究竟是怎样的成就。\n我随便读了一页，看看他的文笔怎样。是那种学术性的文章，但是写得流畅，一点没有初学写作的人往往有的卖弄或者陈腐气。看得出他就和艾略特?谈波登经常亲近达官贵人一样，他也是经常浸润在名著中的。我的思绪被伊莎贝儿的一声叹息打断了。她坐起来，皱着脸把变得微温的鸡尾酒一饮而尽。\n“我再哭下去，眼睛要肿得不象样子了；今天晚上，我们还要出去吃晚饭呢。”\n她从皮包里取出一面镜子，不放心地照照自己。“对了，用冰袋在眼睛上放半小时，这就是我要做的。”她在脸上扑了粉，涂了口红。后来若有所思地望着我，“你听了我这样作为，会瞧不起我吗？”\n“你在乎吗？”\n“你也许会奇怪，我在乎。我要你觉得我人不错。”\n我笑了。\n“亲爱的，我是一个很不道德的人，”我答。“当我真正欢喜一个人的时候，尽管我不赞成他做的那些坏事，但是照样喜欢他。按说你不是个坏女人，而且风度翩翩。我知道你的美貌是两种因素的巧合，高超的审美眼光和不顾一切的决心，但并不因此而影响我对你的欣赏。你只是缺少一样使人完全对你着迷的东西。”\n她微笑着等待。\n“温柔。”\n她唇边的笑意消失了，恶狠狠地看了我一眼，可是还没有来得及定下神来回答我，格雷已经瞒珊地走进来。在巴黎住了这三年，格雷已经胖得厉害，脸色变得更红，头发秃得很快，可是健康好到极顶，而且兴致勃勃的。看见我时，高兴得一点不做作。他讲话充满了口头禅。不管怎样过时的字眼，他说起来总深信自己是第一个想到这样说的。上床是打稻草，睡觉总睡得象没有亏心事的人一样；下雨总是敲锣击鼓，巴黎必定是繁华的巴黎。可是他为人非常善良，非常不自私，非常正直，非常可靠，非常不搭架子，使人没法子不喜欢他。我对他倒有真实感情。他现在对于即将动身回国很兴奋。\n“天哪，又要上笼头了，真开心，”他说。“我已经闻到饲草香了。”\n“是不是都谈妥了？”\n“我还没有在虚线上签字呢，但是有十成十了。我打算合伙的是我大学里一个同房间同学，一个好样的，我敢保他不会叫我上当。可是，我们一到达纽约，我就会飞往得克萨斯把整个设备检查一下，在我把伊莎贝儿的钱吐出之前，敢保任何可疑的情况都不会逃过我的眼睛的。”\n“你知道，格雷是一个很精明的生意人，”她说。\n“我又不是在牛棚里长大的，”格雷微笑说。\n他继续告诉我他预备加入那项生意的情况，时间拖得相当长，可是我对这类事情简直不懂，只掌握到一件具体事实，就是他很有希望赚一大笔。他对自己讲的事情越来越感兴趣，所以，不久就转身向伊莎贝儿说：“我说，我们何不把今晚这顿讨厌的饭回掉，就我们三个人上银堡痛痛快快吃一顿晚饭呢？”\n“哎，亲爱的，这不能做。他们是为我们请的客。”\n“反正我也来不了，”我插嘴说。“在我听到你们晚上有饭局之后，我打电话给苏姗?鲁维埃，约好带她出来吃饭了。”\n“苏姗?鲁维埃是谁？”伊莎贝儿问。\n“拉里认识的一个女子，”我说，故意捉弄她。\n“我总疑心拉里有个小娘儿藏在哪儿不给我们知道，”格雷说，咯咯笑了出来。\n“胡扯，”伊莎贝儿愤然说。“拉里的性生活我全知道。他没有人。”\n“好吧，让我们分手之前再喝一杯鸡尾酒，”格雷说。\n我们喝了鸡尾酒，然后，我和他们道别。他们陪我到了穿堂里。当我穿上大衣时，伊莎贝儿把胳臂和格雷的胳臂套起，挨近他身子，盯着他的眼睛看，脸上带着我指责她所缺乏的那种温柔表情。\n“你说说。格雷——坦白地说——你觉得我狠心吗？”\n“不，亲爱的，远不是如此。怎么，难道有人说你狠心吗？”\n“没有人。”\n她把头掉过去，使格雷看不见她，向我把舌头吐了出来，那个派头艾略特肯定会说不象个上流女子。\n“那是两回事情，”我一面咕哝着，一面走到门外，随手把门带上。\n四 # 我再经过巴黎时，马图林一家已经走了；艾略特的公寓已经住进别人。我很怀念伊莎贝儿。她长得好看，而且谈话不大拘束，领会很快，对人没有恶意。我后来从没有见过她。我不会写信而且拖拉，伊莎贝儿则从不和人通信。她如果不和你通电话或者打电报，你就休想得到她的消息。那一年圣诞节，我收到她一张贺片，上面有张漂亮照片，照的是一幢有殖民地时期门廊的房子，四周围长着茂密的株树，想来就是农场那边的房子；当初他们需要钱时卖不掉，现在大约愿意留下来了。邮戳表明信是从达拉斯寄出的，可以肯定，合营的交易已经谈妥，他们已在达拉斯定居了。\n我从来没有到过达拉斯，但可以想象它和我见到的美国其他城市一样，有一个住宅区，坐汽车去商业中心和郊外俱乐部都不需要多少时间；住宅区阔人家的房子都很漂亮，有大花园，从客厅窗子里可望见幽美的山陵或者溪谷。伊莎贝儿肯定住在这样一个地方和这样一幢房子里，房子从地窖到阁楼都是由纽约最时髦的屋内装饰家按照最时新的式样布置的。我只希望她挂的那些画，勒努瓦，马奈的花卉，莫奈的风景和高更看上去不太过时。餐厅无疑不大不小，正适合伊莎贝儿经常招待午宴，酒肯定好，菜肴当然是第一流。伊莎贝儿在巴黎学到不少东西。她一眼就可以看出客厅够大不够大，客厅不大的房子她是不会住的；因为她要等两个女儿长大了一点，在客厅里开未成年人的舞会，这是做母亲的一项愉快的责任。今天琼和普丽西拉该已到结婚的年龄了。肯定她们都有很好的教养。她们进的是最好的学校，伊莎贝儿准会把她们培养得面面俱到，使她们在合格的青年人眼中成为可以追求的对象。格雷现在想来脸色更红润了，兴致更好了，头更秃了，体重更增加了，但是，伊莎贝儿我不相信会变到哪里去。她仍旧会比两个女儿长得美。马图林这一家肯定是杜会上少不了的，我而且有十足把握他们在当地的人缘很好，这也是应该的。伊莎贝儿人风趣、文雅、殷勤、机智；至于格雷，不用说，是标准美国人中的精华。\n五 # 我不时仍去看望苏姗?鲁维埃。后来，她的境遇发生了意想不到的变化，使她离开巴黎，也在我的生命中消失了。那是一天下午，大致在我叙述的事件两年之后，我先在奥台翁剧院的走廊上测览书籍，很惬意地消磨了一个钟点，后来一时无所事事，就想起去看望一下苏姗。我有六个月没有见到她了。她开门时，拇指搭着调色板，嘴里咬一支画笔，穿一件罩衫，上面满是油彩。\n“ah， cest vons， cher ami．entrez，je vons en prie．[注]她这样客气使我有点诧异，因为一般我们只是你我相称。我走进那间客厅兼画室的房间。画架上放了一张油画。\n“我很忙，不知道怎么办是好。我一分钟也不能浪费。说来你不会相信，我要在梅耶海姆画店开个人画展，得准备三十幅画呢。”\n“在梅耶海姆？这真了不起。你是怎样做到的？”\n因为梅耶海姆并不是塞纳路上的那些靠不住的画商；那些人开一爿小店，由于付不出房租，随时都有关门的可能。梅耶海姆在塞纳河繁华的这一边有一爿漂亮画店，而且享有国际声誉。一个画家被他看中了就会发财。\n“亚希尔先生带他来看我的作品，他认为我很有才气。”\n“a dautres， ma vieille，”我答，这句法文我想最好的译法是“鬼相信你，小女人”。\n她看了我一眼，吃吃笑起来。\n“我要结婚了。”\n“跟梅耶海姆？”\n“别装傻了。”她把画笔和调色板放下来。“我工作了一整天，现在该休息一下了。让我们喝杯红葡萄酒，我再告诉你经过。”\n法国生活的一个不大愉快的方面是，你往往逼得要在不适当的时候喝一杯酸溜溜的红葡萄酒。你只好听命。苏姗取出一瓶酒和两只杯子，把杯子斟满，坐下来如释重负地叹了一口气。\n“我站了有好几个钟点，我的静脉曲张血管都痛了。是这样的。亚希尔先生的妻子今年年初去世了。她是个好女人，也是个好天主教徒，但是，亚希尔和她结婚并不是出于自愿；他娶她是为了生意经，因此虽则他器重她，尊敬她，要说她的亡故使亚希尔先生怎样伤心，那就过甚其辞了。他儿子的婚姻很不坏，在公司里也做得很出色；现在他女儿的婚事也谈妥了，对方是一位伯爵，虽说是比利时人，倒是货真价实的贵族，在那慕尔附近有一座很美丽的宫堡。亚希尔先生认为，他可怜的妻子不会为了自己的缘故耽误两个年轻人的幸福，所以尽管还在居丧期间，一等到财产过户手续[注]完成后，立刻就举行婚礼。显然亚希尔先生住在里尔的那幢大房子里会感到寂寞的；他需要有个女人照应他的生活起居，还要管理好那所关系到他身份的住宅。长话短说，他要我代替他妻子的位置；他讲得入情入理：‘我第一次结婚是为了消除两家对立的竞争，我而且并不懊悔，但是第二次结婚那就要听我喜欢了’。”\n“恭喜恭喜，”我说。\n“当然我将失去自由，而我是喜欢无拘无束的。可是，一个人应当考虑到自己的前途。不瞒你说，我已经是四十开外的人了，这事只有你我知道。亚希尔先生正处在危险的年龄；万一他忽然想入非非追求一个二十岁的女孩子起来，我怎么办呢？\n我还要替我的女儿着想，她现在十六岁，看上去会出落得和她父亲一样漂亮。我使她受到很好的教育。但是，事实摆在你面前，不容你否认z她既没有才干当一个演员，也没有她可怜母亲的气质去当妓女，那么我问你，她能指望什么呢？当个女秘书，或者在邮局里当个职员。亚希尔先生很慷慨地同意她和我们住在一起，并且答应给她一笔厚厚的奁资，使她能嫁个好人家。说实在话，我亲爱的朋友，别人怎样说不去管它，结婚仍旧是女人的最最满意的职业。很明显，当我想到女儿的幸福时，我毫不迟疑就接受了亚希尔先生的建议，即使牺牲某种满足也在所不惜；反正一年年过去，这种满足愈来愈不容易获得了。而且我一定要告诉你，我结婚之后，预备绝对格守妇道（dune vertu farouche），因为根据我多年的经验，深信幸福的婚姻唯一倚靠的就是双方绝对的忠实。”\n“这是很高尚的情感，我的美人儿，”我说。“亚希尔先生还预备每两个星期来巴黎谈生意吗？”\n“噢啦啦，你把我当作什么样人，我的小宝贝？亚希尔先生向我求婚时，我跟他讲的第一件事就是：‘你听我说，亲爱的，你到巴黎来开董事会时，我也跟着来，这算讲定了。你一个人在这里我是不放心的。’‘你不能设想我这样年纪还会做出蠢事来，’他答。‘亚希尔先生，’我跟他说，‘你正当壮年，我而且比谁都清楚你是个多情人，而且风度翩翩，神气十足。种种地方都会被女人看中。总之，我觉得最好你不要受到引诱。’最后，他答应把董事的位置让给儿子，由他代替父亲来巴黎开会。亚希尔先生假装不快，认为我不讲理，事实上他心里觉得很好受。”苏姗满意地叹了一口气。“对我们可怜的女人来说，如果不是因为男人的这种想象不到的虚荣心，生活就更加难办了。”\n“这一切都很好，但是，这和你在梅耶海姆开个人画展有什么相干？”\n“我可怜的朋友，你今天有点儿笨头笨脑的。多少年来我不是告诉过你，亚希尔先生是一个极端聪明的人吗？他要考虑到自己的地位，而且里尔的人是很挑剔的。\n亚希尔先生要我在社会上有地位；作为他这样重要人物的妻子，我有权利享受这种地位。你知道那些外省人是怎样的，他们最欢喜管别人的闲事；他们要做的第一件事情就是问：苏姗?鲁维埃是什么人？好吧，这就是他们的回答。她是一位名画家，最近在梅耶海姆画店开的画展获得很了不起和当之无愧的成功，‘苏姗?鲁维埃是殖民步兵团一位军官的遗孀，好些年来都靠自己的艺术才能维持生活，并抚养一个早年丧失父爱的娇女，表现了典型的法国妇女的刚毅性格。现在我们欣悉她的作品不久将在目光犀利的梅耶海姆先生的画室展出；广大公众将有机会观赏她的细致笔触和过得硬的技巧。’”\n“你胡说些什么？”我说，耳朵竖了起来。\n“亲爱的，这就是亚希尔先生计划做的抬高我的宣传。法国重要一点的报纸都将登载这条新闻。他真是了不起。梅耶海姆先生的条件很苛刻，亚希尔先生毫不在乎全接受了。预展时要开香槟酒庆祝；美术部长（他本来欠亚希尔先生的人情）将要在开幕式上来一篇夸夸其谈的演讲；他将着重提到我的品德和绘画才能，最后他将宣布国家的责任和职权是论功行赏，所以已经买下我的一张画由国家收藏。巴黎各界人士都将到场，梅耶海姆先生将亲自招呼那些评论家，保证他们的报道不但要讲好话，还要占相当篇幅。那些可怜的家伙，他们挣的钱实在太少了。给他们一个机会额外挣点钱也算是做好事。”\n“这一切是你本来应当得到的，”我说。“你一直是个好心肠的人。”\n“et ta soeur，[注]”她答，这句话无法翻译。“可是这还不算数。亚希尔先生又用我的名义在圣拉斐尔海边买了一所别墅，所以我将不仅以一个艺术家，而且还要以一个有产业的妇女在里尔的社交界露面。再过两三年他就要退休了，那时，我们将象上流人士那样[comme des gens bien]在里维埃拉住下去。他可以在海上划船，捞虾子，我则画我的画。现在我把画拿给你看。”\n苏姗作画已有好几年，而且学会了她那些情人的作画方式，终于画出了她自己的风格。素描仍旧不会，但是色彩感很不错。她给我看的画有和她母亲住在昂儒省时画的风景，有凡尔赛宫花园和枫丹白露森林的小景，有在巴黎近郊被她看中的街道风光。她的画象浮光掠影，不踏实，但是具有一种花枝招展的美，甚至某种不经意的情趣。有一张画我很中意，告诉她我要买，因为我认为这样会使她高兴。这张画我记不起是叫《林中荫道》，还是叫《白围巾》，而且事后检阅，到今天还说不出来。我问了价钱，要价也很合理，所以说我要买下它。\n“你是个宝，”她叫。“我的第一笔交易。当然你在展览会开过后才能拿到，可是，我要叫他们在报上登出来，说你买了它。反正一点点宣传对你是没有妨碍的。\n我很高兴你挑了这一张，我认为这是我的一张得意之作。”她拿起一面镜子，从镜子里端详这张画。“很有情调，”她说，眼睛眯了起来。“没有人能否认这一点。\n这些绿颜色——多么浓郁，然而又多么娇嫩！还有中间这点白颜色，确是神来之笔；它把整个画面统一起来了，它有特色。这是才气的表现，毫无疑问，真正的才气。”\n我看出她在通往职业画家的路上已经迈出老远了。\n“现在，我的小宝贝，我们谈得够长了，我得重新工作起来。”\n“我也得走了，”我说。\n“顺带问一句，那个可怜的拉里还住在印第安人中间吗？”\n她提到上帝自己国家[注]的居民时，一向习惯于用这种鄙薄口气。\n“据我知道，还在那里。”\n“以他那样温和可爱的人，日子一定很不好过。如果那些电影使人信得过的话，有那许许多多的匪帮、牛仔和墨西哥人，那边的生活肯定是使人受不了的。并不是说那些牛仔没有一种吸引力，使你想起什么来。噢啦啦。可是看上去一个人在纽约街上行走，口袋里如果不带一支手枪的话，那将是极端危险的。”\n她送我到门口，并且吻了我的两颗。\n“我们曾经在一起玩得很开心。日后多想想我。”\n六 # 这就是我的故事的结束。我从没有听到拉里的消息，也不指望听到。由于他一般都按照自己的打算行事，我想他回到美国以后，可能就在汽车修配行里找一个工作，然后当卡车司机，直到他获得关于他阔别多年的这个国家的知识为止。在达到这项目的以后，他很可能把开出租汽车的怪想法付诸实施：诚然，这在当时不过是我们在咖啡馆里对面坐时随便说的一句玩笑话，但是，如果他当真这样做起来，我也丝毫不感到奇怪；我而且后来每次在纽约雇出租汽车时总要把司机看一眼，指望说不定会和拉里的那双深陷的庄重而微笑的眼睛碰上。我从来没有碰到过。大战爆发了。他年纪不小，飞行当然谈不上，但可能重新去开卡车，在国内或在国外；也可能在一家工厂做工。想来他会在空余的时间写一本书，试图阐述他的人生体会和对自己同类的教导；可是，如果在写的话，也要等很长的时间才会完成。他有的是时间；岁月在他身上没有留下痕迹；不管从哪一方面说，他还是个青年。\n他没有野心，不要名；他最厌恶成为知名人士；所以很可能安心安意地过着自己挑选的生活，我行我素，别无所求。他为人太谦虚了，决不肯使自己成为别人的表率；但是，他也许会想到，一些说不上来的人会象飞蛾扑灯一样被吸引到他身边来，并且逐渐和他的热烈信仰取得一致，认为人生最大的满足只能通过精神生活来体现，而他本人始终抱着无我和无求的态度，走着一条通往自我完善的道路，将会作出自己的贡献，就如同著书立说或者向广大群众发表演讲一样。\n但是这都是揣测之辞。我是个俗人，是尘世中人；我只能对这类人中麟凤的光辉形象表示景慕，没法步他的后尘。有时候一些比较接近通常类型的人，我自命能了解他们的内心深处；对拉里，我不能。拉里已经如他自愿的那样，藏身在那片喧嚣激荡的人海中了；而这片人海又是被那么多的矛盾利益困扰着，那样迷失在世界的混乱里，那样渴望好的，那样外表上笃定，内心里彷徨，那样慈善，那样残忍，那样诚实，又那样狡猾，那样卑鄙，又那样慷慨；而这就是美国人民。我讲拉里只能到此为止，我知道这很不够，但是，没有办法。可是，当我写完这本书，感到准会使读者摸不到边际而有点不自在时，我就把这冗长的故事在脑子里重温了一遍，看看有没有办法设计一个令人满意一点的结局。使我非常吃惊的是，我忽然恍悟，尽管丝毫没有意思要这样做，我不多不少恰恰写了一部以“成功”为题材的小说。\n因为书中和我有关的人物无不如愿以偿：艾略特成为社交界名流；伊莎贝儿在一个活跃而有文化的社会里取得巩固地位，并且有一笔财产做靠山；格雷找到一个稳定而赚钱的职业可以每天从早上九点到下午六点上班；苏姗?鲁维埃得到生活保障；索菲获得死；拉里找到了安身立命之道。所以，不管那些自命风雅的人多么挑剔，一般公众从心眼里还是喜欢一部如愿以偿的小说的；所以，也许我的故事结局毕竟并不是怎样不如人意呢。\n结尾 # ——完——\n"},{"id":6,"href":"/docs/Journal/","title":"日志","section":"Docs","content":" 本站相关日志 # "}]